<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIPTEAMMOD AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');

    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(145deg, #f0f0f0, #ffff);
      border-radius: 4px;
      box-shadow: 0 0 10px #ffff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    .chat-container {
      width: 350px;
      background: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    .chat-header {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 18px;
      font-weight: bold;
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-header h1 {
      flex: 1;
      text-align: center;
    }

    .header-controls {
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 10;
    }


    .chat-box {
      height: 400px;
      overflow-y: auto;
      padding: 15px;
      display: flex;
      flex-direction: column;
    }

    .bot {
      background-color: #e0e0e0;
      align-self: flex-start;
    }

    .user {
      background-color: #0084ff;
      color: white;
      align-self: flex-end;
    }

    .chat-input {
      display: flex;
      padding: 10px;
      border-top: 1px solid #ccc;
    }

    .chat-input input {
      flex: 1;
      padding: 10px;
      border: 1px solid black;
      /* Adds a black border */
      outline: none;
      /* Prevents default blue outline */
      border-radius: 5px;
      /* Optional: Adds rounded corners */
    }

    .chat-input button {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(0, 132, 255, 0.5);
      border-radius: 5px;
      color: white;
      margin-left: 5px;
      border: none;
      padding: 10px;
      cursor: pointer;
    }


    #downloadBtn {
      display: block;
      margin: 10px auto;
      margin-top: 15px;
      padding: 10px 15px;
      background: linear-gradient(145deg, #d30, #d35);
      border-radius: 4px;
      box-shadow: 0 0 10px #d35;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }

    #downloadBtn:hover {
      background: linear-gradient(145deg, #d35, #d30);
      border-radius: 4px;
      box-shadow: 0 0 10px #d30;
    }

    /* Chat container */
    #chat-box {

      padding: 20px;
      border-radius: 10px;
      max-height: 400px;
      overflow-y: auto;

    }

    /* Bot message container */
    .bot-container {
      background-color: #ffffff;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      box-shadow: 0 2px 8px rgba(158, 158, 158, 0.2);
      /* Updated to use #9e9e9e */
      outline: 2px solid rgba(158, 158, 158, 0.4);
      /* Added outline with same color */
      transition: box-shadow 0.3s ease, transform 0.1s ease;
      /* Smooth transition for box-shadow and transform */
    }

    /* Add glow effect on touch/click (active state) */
    .bot-container:active {
      box-shadow: 0 0 20px rgba(158, 158, 158, 0.6);
      /* Increase glow intensity on click */
      transform: scale(1.02);
      /* Slightly scale the container to give a touch effect */
    }



    /* Bot message content */
    .bot-message {
      font-size: 14px;
      color: #333;
      line-height: 1.5;
      margin-top: 8px;
      word-wrap: break-word;
    }

    /* Button container for Copy and Share buttons */
    .button-container {
      display: flex;
      /* Align buttons horizontally */
      gap: 10px;
      /* Add space between the buttons */
      margin-bottom: 10px;
    }

    /* Button styling for both Copy and Share */
    .copy-btn {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(0, 132, 255, 0.5);
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 14px;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }

    /* Button hover effect */
    .copy-btn:hover {
      background-color: #0056b3;
    }

    /* Button active effect */
    .copy-btn:active {
      background-color: #004085;
    }

    /* Optional message timestamp */
    .bot-message::before {
      content: attr(data-time);
      font-size: 12px;
      color: #888;
      margin-right: 5px;
    }

    /* User message styling */
    .user-message {
      background: linear-gradient(145deg, #888, #bbb);
      border-radius: 4px;
      box-shadow: 0 0 10px #d35;
      color: #ffff;
      /* Dark blue text color */
      padding: 8px 12px;
      /* Add padding around the message */
      border-radius: 10px;
      /* Rounded corners */
      margin-bottom: 10px;
      /* Spacing between messages */
      max-width: 80%;
      /* Limit the width of the message */
      align-self: flex-start;
      /* Align the message to the left (user's side) */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      /* Subtle shadow */
      font-family: 'Arial', sans-serif;
      /* Clean font */
      font-size: 14px;
      /* Adjust font size */
    }

    /* If the user message is too long, allow it to wrap */
    .user-message {
      word-wrap: break-word;
    }

    .NewT {
      width: 100%;
      height: 20px;
      padding: 12px;
      border: 2px solid #0084ff;
      border-radius: 8px;
      background-color: none;
      color: #000;
      font-size: 16px;
      box-shadow:
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        inset 0 0 10px rgba(14, 239, 255, 0.2);
      transition: all 0.3s ease;
      outline: none;
    }

    .NewT:focus {
      box-shadow:
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        0 0 2px 0084ff0ef,
        inset 0 0 15px rgba(14, 239, 255, 0.3);
    }

    /* Add this to your CSS */
    .dark-mode {
      background: #000000 !important;
      color: #e2e8f0;
    }

    .dark-mode body {
      background: #000000 !important;
    }

    .dark-mode #demo {
      background: #000000 !important;
    }

    .dark-mode .chat-container {
      background: rgba(30, 41, 59, 0.95) !important;
      border: 1px solid rgba(255, 255, 255, 0.1) !important;
    }

    .dark-mode .chat-box {
      background: linear-gradient(to bottom, #1e293b, #0f172a) !important;
    }

    .dark-mode .bot-container {
      background-color: #334155 !important;
      border: 1px solid rgba(131, 56, 236, 0.3) !important;
    }

    .dark-mode .bot-message {
      color: #e2e8f0 !important;
    }

    .dark-mode .chat-input {
      background: #1e293b !important;
      border-top: 1px solid #334155 !important;
    }

    .dark-mode .chat-input input {
      background: #0f172a !important;
      color: #e2e8f0 !important;
      border: 2px solid #334155 !important;
    }

    .dark-mode .chat-input input:focus {
      border-color: #8338ec !important;
    }

    .dark-mode .copy-btn {
      background: linear-gradient(145deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;

    }

    .dark-mode .user-message {
      background: linear-gradient(145deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;
    }

    /* Dark mode toggle button styles */
    .dark-mode-toggle {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
    }

    .dark-mode-toggle:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

    .dark-mode-toggle i {
      color: white;
      font-size: 18px;
    }
  </style>

</head>

<body>

  <div class="chat-container" id ="main-container">
    <div class="chat-header">
      <h1>VIPTEAMMOD AI</h1>
      <button id="darkModeToggle" class="dark-mode-toggle">
                                <i class="fas fa-moon"></i>
                            </button>
    </div>
    <div class="chat-box" id="chat-box">
    </div>
    <div class="chat-input">

      <textarea class ="NewT" id="user-input"placeholder="Type a message..." autofocus></textarea>


      <button id ="startBtn" onclick="sendMessage()">Send</button>

    </div>
  </div>
  
  <script>
  
  
  document.addEventListener('DOMContentLoaded', function() {
    const userInput = document.getElementById('user-input');
    const storageKey = 'autoSaveText';
    
    // Save text to localStorage
    function saveText() {
        try {
            localStorage.setItem(storageKey, userInput.value);
        } catch (error) {
            console.error('Error saving to localStorage:', error);
        }
    }
    
    // Load saved text on page load
    function loadSavedText() {
        try {
            const savedText = localStorage.getItem(storageKey);
            if (savedText !== null) {
                userInput.value = savedText;
            }
        } catch (error) {
            console.error('Error loading from localStorage:', error);
        }
    }
    
    // Debounce function to limit how often we save
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }
    
    // Create debounced save function
    const debouncedSave = debounce(saveText, 500);
    
    // Event listener for typing
    userInput.addEventListener('input', debouncedSave);
    
    // Load saved text on page load
    loadSavedText();
    
    // Set up periodic save (every 30 seconds) as a backup
    setInterval(() => {
        if (userInput.value.length > 0) {
            saveText();
        }
    }, 30000);
});
  
    let pressTimer;
const longPressDuration = 800; // milliseconds
let clickCount = 0;
const clickDelay = 500; // milliseconds between clicks

    
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const transcriptDiv = document.getElementById('user-input');
        const statusDiv = document.getElementById('status');
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        
        if (!SpeechRecognition) {
            alert("Your browser doesn't support Speech Recognition. Try Chrome or Edge.");
            statusDiv.textContent = "Browser not supported. Try Chrome or Edge.";
        } else {
            const recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                startBtn.disabled = true;
                stopBtn.disabled = false;
                transcriptDiv.value = "";
                statusDiv.textContent = "Listening... Speak now";
            };
            
            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript = transcript;
                    }
                }
                
                transcriptDiv.value = finalTranscript + interimTranscript;
                

            sendMessage();
      
                if (finalTranscript) {
                    statusDiv.textContent = "Processing speech...";
                }
            };
            
            recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                transcriptDiv.value = `❌ Error: ${event.error}`;
                statusDiv.textContent = `Error: ${event.error}`;
                startBtn.disabled = false;
                stopBtn.disabled = true;
            };
            
            recognition.onend = () => {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                statusDiv.textContent = "Recording stopped. Click 'Start Recording' to begin again";
            };
            
            startBtn.addEventListener('click', () => {

                clickCount++;
    
    if (clickCount === 3) {
        // This is the triple click action
        if (typeof recognition !== 'undefined') {
            recognition.start();
            botReply(`Voice Assistant Listening....`);
        }
        clickCount = 0;
        return;
    }
    
    setTimeout(function() {

        clickCount = 0;
    }, clickDelay);
    
            });
            
            stopBtn.addEventListener('click', () => {
                recognition.stop();
            });
        }
  </script>
  <script>
    // Prevent zoom with keyboard shortcuts
document.addEventListener('keydown', function(event) {
  if ((event.ctrlKey || event.metaKey) && (event.key === '+' || event.key === '-' || event.key === '0')) {
    event.preventDefault();
  }
});

// Prevent pinch zoom
document.addEventListener('touchstart', function(event) {
  if (event.touches.length > 1) {
    event.preventDefault();
  }
}, { passive: false });

// Prevent double-tap zoom
let lastTouchEnd = 0;
document.addEventListener('touchend', function(event) {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault();
  }
  lastTouchEnd = now;
}, false);
// Dark mode toggle
const darkModeToggle = document.getElementById('darkModeToggle');
const body = document.body;
const darkModeIcon = darkModeToggle.querySelector('i');

// Check for saved dark mode preference or default to light mode
const currentDarkMode = localStorage.getItem('darkMode') === 'true';

// Apply dark mode if it was previously enabled
if (currentDarkMode) {
    body.classList.add('dark-mode');
}

// Function to update dark mode icon
function updateDarkModeIcon() {
    if (body.classList.contains('dark-mode')) {
        darkModeIcon.classList.remove('fa-moon');
        darkModeIcon.classList.add('fa-sun');
    } else {
        darkModeIcon.classList.remove('fa-sun');
        darkModeIcon.classList.add('fa-moon');
    }
}

// Function to toggle dark mode
function toggleDarkMode() {
    body.classList.toggle('dark-mode');
    
    // Save the current dark mode preference to localStorage
    localStorage.setItem('darkMode', body.classList.contains('dark-mode'));
    
    updateDarkModeIcon();
}

// Add event listener to the button
darkModeToggle.addEventListener('click', toggleDarkMode);

// Initialize icon on page load
updateDarkModeIcon();
const responses = [
{
    pattern: /\bhi|hii\b/i,  // Ensures "Hi" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hi there! How are you doing today?",
            "Hi! How can I help you today?",
            "Hi! Is there anything I can help you with today? Just saying \"Hi\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hi! How's it going? Anything I can do for you?",
            "Hey! How’s your day going?",
            "Hi! What’s up?",
            "Hi there! Hope you're having a great day!",
            "Hi! Always nice to chat with you!",
            "Hi! What's new?",
            "Hi! What’s on your mind?",
            "Hi! How’s everything going?",
            "Hi! Nice to see you!",
            "Hi there! Anything exciting happening today?",
            "Hi! How are you feeling today?",
            "Hi! How can I make your day better?",
            "Hi! Need anything?",
            "Hi! Let’s have a great chat!",
            "Hi! It's great to hear from you!",
            "Hi, friend! What’s up?",
            "Hi! It's always a pleasure talking to you!",
            "Hi there! What's going on today?",
            "Hi! Anything interesting happening?",
            "Hi! Just stopping by to say Hi!",
            "Hi! Hope you're having a fantastic day!",
            "Hi there! Anything fun planned today?",
            "Hi! Ready for a great conversation?",
            "Hi! I'm here if you need anything!",
            "Hi! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bhey\b/i,  // Ensures "Hey" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hey there! How are you doing today?",
            "Hey! How can I help you today?",
            "Hey! Is there anytHeyng I can help you with today? Just saying \"Hey\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hey! How's it going? Anything I can do for you?",
            "Hey! How’s your day going?",
            "Hey! What’s up?",
            "Hey there! Hope you're having a great day!",
            "Hey! Always nice to chat with you!",
            "Hey! What's new?",
            "Hey! What’s on your mind?",
            "Hey! How’s everything going?",
            "Hey! Nice to see you!",
            "Hey there! Anything exciting happening today?",
            "Hey! How are you feeling today?",
            "Hey! How can I make your day better?",
            "Hey! Need anything?",
            "Hey! Let’s have a great chat!",
            "Hey! It's great to hear from you!",
            "Hey, friend! What’s up?",
            "Hey! It's always a pleasure talking to you!",
            "Hey there! What's going on today?",
            "Hey! Anything interesting happening?",
            "Hey! Just stopping by to say Hey!",
            "Hey! Hope you're having a fantastic day!",
            "Hey there! Anything fun planned today?",
            "Hey! Ready for a great conversation?",
            "Hey! I'm here if you need anything!",
            "Hey! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bhello|he'llo\b/i,  // Ensures "Hello" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hello there! How are you doing today?",
            "Hello! How can I help you today?",
            "Hello! Is there anything I can help you with today? Just saying \"Hello\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hello! How's it going? Anything I can do for you?",
            "Hello! How’s your day going?",
            "Hello! What’s up?",
            "Hello there! Hope you're having a great day!",
            "Hello! Always nice to chat with you!",
            "Hello! What's new?",
            "Hello! What’s on your mind?",
            "Hello! How’s everything going?",
            "Hello! Nice to see you!",
            "Hello there! Anything exciting happening today?",
            "Hello! How are you feeling today?",
            "Hello! How can I make your day better?",
            "Hello! Need anything?",
            "Hello! Let’s have a great chat!",
            "Hello! It's great to hear from you!",
            "Hello, friend! What’s up?",
            "Hello! It's always a pleasure talking to you!",
            "Hello there! What's going on today?",
            "Hello! Anything interesting happening?",
            "Hello! Just stopping by to say Hello!",
            "Hello! Hope you're having a fantastic day!",
            "Hello there! Anything fun planned today?",
            "Hello! Ready for a great conversation?",
            "Hello! I'm here if you need anything!",
            "Hello! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
    { pattern: /your name/i, response: "I'm VIPTEAMMOD AI, your assistant!" },
    { pattern: /who created you/i, response: "I was created by VIPTEAMMOD." },
    { pattern: /how are you/i, response: "I'm just a program, but I'm functioning well!" },
    { pattern: /what can you do/i, response: "I can chat with you and assist with basic queries. Try asking me something!" },
    { pattern: /help/i, response: "Sure! What do you need help with?" },
    { pattern: /thank you|thanks/i, response: "You're welcome! Let me know if you need anything else." },
    { pattern: /bye|goodbye/i, response: "Goodbye! Have a great day!" },
    { pattern: /who are you/i, response: "I'm an VIPTEAMMOD AI designed to assist you!" },
    { pattern: /what is your purpose/i, response: "My purpose is to assist and provide helpful information!" },
    { pattern: /where are you from/i, response: "I'm a virtual AI, so I exist on the internet!" },
    { pattern: /what time is it/i, response: () => new Date().toLocaleTimeString() },
    { pattern: /what day is it/i, response: () => new Date().toLocaleDateString() },
    { pattern: /tell me a joke/i, response: "Why don't programmers like nature? Because it has too many bugs!" },    { pattern: /how old are you/i, response: "I don't have an age, but I’m always learning!" },
    { pattern: /can you learn/i, response: "I can process and respond, but I don't learn like humans do." },
    { pattern: /do you have feelings/i, response: "No, but I try my best to understand emotions!" },
    { pattern: /do you sleep/i, response: "Nope! I'm always awake and ready to chat." },
    { pattern: /do you eat/i, response: "I don’t need food, but I can recommend recipes!" },
    { pattern: /what's your favorite color/i, response: "I like blue! It reminds me of the sky and technology." },
    { pattern: /who is your best friend/i, response: "Everyone who chats with me is my friend!" },
    { pattern: /can you dance/i, response: "I would, but I don’t have a body!" },
    { pattern: /do you have a family/i, response: "I have my creators and users like you!" },
    { pattern: /what do you like/i, response: "I like helping people and answering questions!" },
    { pattern: /are you human/i, response: "No, I’m just a chatbot, but I try to be helpful!" },
    { pattern: /do you like music/i, response: "I don’t listen to music, but I can recommend songs!" },
    { pattern: /do you have a pet/i, response: "I don’t, but I think virtual pets are cool!" },
    { pattern: /what do you do for fun/i, response: "I enjoy chatting with people like you!" },
    { pattern: /do you know any riddles/i, response: "Sure! What has to be broken before you can use it? An egg!" },
    { pattern: /what is the meaning of life/i, response: "42! Just kidding, it depends on your perspective." },
    { pattern: /do you believe in aliens/i, response: "I think the universe is big enough for endless possibilities!" },
    { pattern: /can you do magic/i, response: "If answering questions instantly is magic, then yes!" },
    { pattern: /do you play games/i, response: "I can’t play, but I can talk about games!" },    { pattern: /what is love/i, response: "Baby, don't hurt me!" },
    { pattern: /what is the weather/i, response: () => "I can't check the weather, but you can try asking your local weather service!" },
    { pattern: /can you write poems/i, response: "Sure! Here's one: Roses are red, Violets are blue, I'm an AI, And I'm here for you!" },
    { pattern: /can you sing/i, response: "I can't sing, but I can give you song lyrics!" },
    { pattern: /what's your favorite food/i, response: "I don’t eat, but pizza sounds delicious!" },
    { pattern: /are you real/i, response: "I’m as real as a program can be!" },
    { pattern: /can you predict the future/i, response: "I can't predict the future, but I can give you advice!" },
    { pattern: /do you play chess/i, response: "I can help with chess strategies if you'd like to play!" },
    { pattern: /how do I make a website/i, response: "To make a website, you’ll need HTML, CSS, and JavaScript! I can help you get started." },
    { pattern: /tell me a fact/i, response: "Did you know? Octopuses have three hearts!" },
    { pattern: /how to get rich/i, response: "Start by investing wisely, learning new skills, and working hard!" },
    { pattern: /can you drive/i, response: "I can't drive, but I can help you learn about it!" },
    { pattern: /what is your favorite animal/i, response: "I think dogs are great! They're loyal and friendly." },
    { pattern: /do you know the answer to everything/i, response: "I try my best to know a lot, but I don’t have all the answers!" },
    { pattern: /how do you work/i, response: "I process your messages and match them to my responses, then send one back!" },
    { pattern: /can you make decisions/i, response: "I can suggest things, but you make the decisions!" },
    { pattern: /how do I code/i, response: "To code, you'll need a good understanding of programming languages like Python, JavaScript, or C++. I can guide you!" },
    { pattern: /what is your favorite game/i, response: "I think video games are fun! I don't have a favorite, but I can talk about many games!" },
    { pattern: /do you watch movies/i, response: "I can't watch movies, but I can suggest some!" },    { pattern: /what is the best programming language/i, response: "It depends on what you're building! Python is great for AI, JavaScript for web, and C++ for performance." },
    { pattern: /can you tell me a story/i, response: "Once upon a time, there was a curious user who chatted with an AI... and they lived happily ever after!" },
    { pattern: /do you sleep at night/i, response: "Nope! I'm available 24/7 to chat with you." },
    { pattern: /can you teach me something/i, response: "Sure! Did you know that the speed of light is about 299,792,458 meters per second?" },
    { pattern: /what is the capital of (.+)/i, response: (match) => `I'm not connected to live data, but you can check Google for the capital of ${match[1]}.` },
    { pattern: /how do I learn hacking/i, response: "Ethical hacking requires learning cybersecurity, networking, and programming skills!" },
    { pattern: /can you do my homework/i, response: "I can help explain concepts, but you should try to do it yourself!" },
    { pattern: /what should I eat today/i, response: "How about some pizza, pasta, or a healthy salad?" },
    { pattern: /what is the meaning of AI/i, response: "AI stands for Artificial Intelligence, which allows machines to mimic human intelligence." },
    { pattern: /do you have emotions/i, response: "I don’t have real emotions, but I can understand and respond to yours!" },
    { pattern: /what is your favorite movie/i, response: "I don't watch movies, but 'The Matrix' is a great one about AI!" },
    { pattern: /can you recommend a book/i, response: "Sure! 'Clean Code' by Robert C. Martin is great for programmers." },
    { pattern: /do you like robots/i, response: "Yes! Robots are fascinating and help in many industries." },
    { pattern: /can you tell fortunes/i, response: "I can't predict the future, but I see good things ahead for you!" },
    { pattern: /how do I become smart/i, response: "Read books, ask questions, and never stop learning!" },
    { pattern: /can you solve a riddle/i, response: "Sure! What has keys but can't open locks? A piano!" },
    { pattern: /why is the sky blue/i, response: "Because of Rayleigh scattering! The atmosphere scatters blue light more than other colors." },
    { pattern: /do you like memes/i, response: "Yes! Memes are a fun way to communicate." },
    { pattern: /who is the richest person/i, response: "It changes over time! You can check Forbes for the latest rankings." },
    { pattern: /can you inspire me/i, response: "Of course! 'The only way to do great work is to love what you do.' – Steve Jobs" },    { pattern: /what is your favorite color/i, response: "I don't have a favorite color, but blue seems pretty cool!" },
    { pattern: /can you do math/i, response: "Yes, I can do math! Ask me any math problem!" },
    { pattern: /what is the largest planet/i, response: "The largest planet in our solar system is Jupiter!" },
    { pattern: /what is the smallest country/i, response: "The smallest country in the world is Vatican City!" },
    { pattern: /can you cook/i, response: "I can't cook, but I can help you find recipes!" },
    { pattern: /who invented the lightbulb/i, response: "Thomas Edison is credited with inventing the practical lightbulb!" },
    { pattern: /what is quantum computing/i, response: "Quantum computing is a type of computing that uses quantum bits (qubits) for data processing." },
    { pattern: /tell me about space/i, response: "Space is vast and mysterious, filled with stars, planets, black holes, and galaxies. There’s so much to explore!" },
    { pattern: /how can I be happy/i, response: "Focus on the positive, practice gratitude, and spend time with those you care about!" },
    { pattern: /what is artificial intelligence/i, response: "Artificial Intelligence is the simulation of human intelligence by machines." },
    { pattern: /what is the largest animal/i, response: "The largest animal on Earth is the blue whale!" },
    { pattern: /do you like video games/i, response: "Video games are awesome! I can talk about many of them, from action to strategy!" },
    { pattern: /what is the speed of sound/i, response: "The speed of sound is around 343 meters per second in air at room temperature." },
    { pattern: /can you read minds/i, response: "I can't read minds, but I can understand what you type!" },
    { pattern: /can you play games/i, response: "I can't play games, but I can help you with strategies or explain game mechanics!" },
    { pattern: /what is the meaning of life/i, response: "The meaning of life is a philosophical question that everyone answers in their own way!" },
    { pattern: /what is a black hole/i, response: "A black hole is a region in space where gravity is so strong that not even light can escape." },
    { pattern: /how old are you/i, response: "I don't have an age like humans do, but I'm constantly learning and evolving!" },
    { pattern: /what is the most famous landmark/i, response: "The Great Wall of China and the Eiffel Tower are among the most famous landmarks in the world!" },
    { pattern: /can you speak other languages/i, response: "I can understand and respond in several languages, but I’m best at English!" },
    { pattern: /where is the nearest restaurant/i, response: "I can't access live data, but you can find nearby restaurants using Google Maps!" },    { pattern: /who was the first person on the moon/i, response: "Neil Armstrong was the first person to walk on the moon in 1969!" },
    { pattern: /what is the fastest land animal/i, response: "The cheetah is the fastest land animal, reaching speeds up to 75 mph (120 km/h)!" },
    { pattern: /how do airplanes fly/i, response: "Airplanes fly because of the lift generated by their wings as air moves over them." },
    { pattern: /can you tell me a fun fact/i, response: "Sure! Did you know honey never spoils? Archaeologists have found pots of honey in ancient Egyptian tombs that are still good!" },
    { pattern: /what is the tallest building/i, response: "The tallest building in the world is the Burj Khalifa in Dubai!" },
    { pattern: /what is the rarest gemstone/i, response: "The rarest gemstone is Painite, which was once considered the world's rarest mineral!" },
    { pattern: /how many continents are there/i, response: "There are seven continents: Asia, Africa, North America, South America, Antarctica, Europe, and Australia!" },
    { pattern: /who wrote Harry Potter/i, response: "J.K. Rowling wrote the Harry Potter book series!" },
    { pattern: /what is the longest river/i, response: "The longest river in the world is the Nile River, stretching over 6,650 km (4,130 miles)!" },
    { pattern: /what is the hardest natural substance/i, response: "Diamond is the hardest naturally occurring substance on Earth!" },
    { pattern: /do fish sleep/i, response: "Yes, fish do sleep, but they don’t close their eyes because they don’t have eyelids!" },
    { pattern: /what is the biggest ocean/i, response: "The Pacific Ocean is the largest and deepest ocean on Earth!" },
    { pattern: /how does the internet work/i, response: "The internet is a global network of computers that communicate using protocols like TCP/IP to share data and information." },
    { pattern: /what is the coldest place on Earth/i, response: "Antarctica is the coldest place on Earth, with temperatures reaching as low as -128.6°F (-89.2°C)!" },
    { pattern: /can you dance/i, response: "I can't dance, but I can find you great music to dance to!" },
    { pattern: /how does a computer work/i, response: "A computer processes data using a combination of hardware (CPU, RAM, storage) and software (operating system, programs) to perform tasks." },
    { pattern: /who is the smartest person/i, response: "Many people have been considered geniuses, like Albert Einstein, Stephen Hawking, and Nikola Tesla!" },
    { pattern: /how big is the universe/i, response: "The universe is vast and ever-expanding, with billions of galaxies, each containing billions of stars!" },
    { pattern: /why do birds sing/i, response: "Birds sing to communicate, attract mates, and mark their territory!" },
    { pattern: /can you recommend a movie/i, response: "Sure! If you like sci-fi, try 'Interstellar'. If you like action, 'John Wick' is a great choice!" },    { pattern: /how do plants grow/i, response: "Plants grow using sunlight, water, and nutrients from the soil through a process called photosynthesis." },
    { pattern: /what is the strongest muscle in the human body/i, response: "The jaw muscle (masseter) is considered the strongest muscle based on force exerted!" },
    { pattern: /why is the ocean salty/i, response: "The ocean is salty due to dissolved minerals and salts from rocks and underwater volcanic activity!" },
    { pattern: /can you predict the weather/i, response: "I can't predict the weather, but you can check a weather app for the latest forecast!" },
    { pattern: /who was the first president of the United States/i, response: "George Washington was the first president of the United States!" },
    { pattern: /why do we dream/i, response: "Scientists believe dreaming helps process emotions, memories, and experiences!" },
    { pattern: /how does a car engine work/i, response: "A car engine converts fuel into mechanical energy through controlled explosions in the cylinders." },
    { pattern: /why do humans need sleep/i, response: "Sleep is essential for brain function, physical health, and overall well-being!" },
    { pattern: /what are black holes made of/i, response: "Black holes are made of extremely dense matter with gravity so strong that nothing can escape!" },
    { pattern: /how do magnets work/i, response: "Magnets work due to the alignment of their atoms, creating an invisible magnetic field that attracts or repels objects." },
    { pattern: /can you tell me a secret/i, response: "I don't have secrets, but here's one: The best way to learn is to stay curious!" },
    { pattern: /how do bees make honey/i, response: "Bees collect nectar from flowers, break it down using enzymes, and store it in honeycombs!" },
    { pattern: /why is fire hot/i, response: "Fire is hot because of the energy released from chemical reactions when a material burns." },
    { pattern: /how does a submarine work/i, response: "Submarines control their buoyancy using ballast tanks, allowing them to sink and rise in water." },
    { pattern: /who is the fastest human/i, response: "Usain Bolt holds the record as the fastest sprinter in history!" },
    { pattern: /what is the oldest civilization/i, response: "The Sumerians of Mesopotamia are considered one of the oldest civilizations, dating back to 3100 BC!" },
    { pattern: /how do birds fly/i, response: "Birds fly by flapping their wings and using air currents for lift!" },
    { pattern: /why do we have fingerprints/i, response: "Fingerprints help us grip objects and are unique to each person!" },
    { pattern: /what is the heaviest animal/i, response: "The heaviest animal is the blue whale, weighing up to 200 tons!" },
    { pattern: /why do we yawn/i, response: "Yawning helps increase oxygen intake and may regulate brain temperature!" },    { pattern: /how do airplanes stay in the air/i, response: "Airplanes stay in the air due to the lift generated by their wings as air moves over them, following Bernoulli’s principle." },
    { pattern: /why is the sky blue/i, response: "The sky appears blue because molecules in the atmosphere scatter sunlight, and blue light is scattered more than other colors." },
    { pattern: /how do fish breathe underwater/i, response: "Fish breathe underwater using gills, which extract oxygen from water as it flows over them." },
    { pattern: /what is the speed of light/i, response: "The speed of light in a vacuum is approximately 299,792,458 meters per second!" },
    { pattern: /why do leaves change color in autumn/i, response: "Leaves change color in autumn because they stop producing chlorophyll, revealing other pigments like red, yellow, and orange." },
    { pattern: /how does WiFi work/i, response: "WiFi works by transmitting data using radio waves between a router and a device, allowing wireless communication." },
    { pattern: /why do cats purr/i, response: "Cats purr as a way to communicate, express comfort, and even to heal themselves!" },
    { pattern: /who invented the telephone/i, response: "Alexander Graham Bell is credited with inventing the first practical telephone in 1876." },
    { pattern: /what is the hottest planet in the solar system/i, response: "Venus is the hottest planet in the solar system, with surface temperatures reaching over 450°C (900°F)!" },
    { pattern: /why do humans have eyebrows/i, response: "Eyebrows help keep sweat, rain, and debris out of our eyes, and they also play a role in facial expressions." },
    { pattern: /how do birds know where to migrate/i, response: "Birds use the Earth's magnetic field, the position of the sun and stars, and landmarks to navigate during migration." },
    { pattern: /what is the strongest wind ever recorded/i, response: "The strongest wind ever recorded was 253 mph (407 km/h) during a tropical cyclone in Australia!" },
    { pattern: /why do we get goosebumps/i, response: "Goosebumps occur when tiny muscles around hair follicles contract in response to cold or strong emotions." },
    { pattern: /how does a camera work/i, response: "A camera captures light through a lens onto a sensor or film, creating an image by recording the light patterns." },
    { pattern: /why do some people have different eye colors/i, response: "Eye color is determined by genetics and the amount of melanin in the iris." },
    { pattern: /what is the largest desert in the world/i, response: "The largest desert is Antarctica, which is technically a cold desert!" },
    { pattern: /why do we blink/i, response: "We blink to keep our eyes moist, clean, and protected from dust and debris." },
    { pattern: /how do vaccines work/i, response: "Vaccines work by stimulating the immune system to recognize and fight specific viruses or bacteria without causing illness." },
    { pattern: /what is the oldest tree in the world/i, response: "The oldest tree is a bristlecone pine named 'Methuselah,' estimated to be over 4,800 years old!" },    { pattern: /how does a rocket launch/i, response: "A rocket launches by burning fuel to produce thrust, pushing it against gravity into space." },
    { pattern: /why do we hiccup/i, response: "Hiccups are involuntary contractions of the diaphragm, often caused by eating too fast or drinking carbonated beverages." },
    { pattern: /how do submarines see underwater/i, response: "Submarines use sonar, which sends sound waves that bounce back to detect objects underwater." },
    { pattern: /what causes earthquakes/i, response: "Earthquakes are caused by the movement of tectonic plates along faults in the Earth's crust." },
    { pattern: /why do we have different blood types/i, response: "Blood types are determined by the presence of specific antigens on red blood cells, inherited from our parents." },
    { pattern: /what is the coldest planet in the solar system/i, response: "Neptune is the coldest planet, with temperatures dropping as low as -214°C (-353°F)!" },
    { pattern: /how does electricity work/i, response: "Electricity is the flow of electrons through a conductor, creating energy that powers devices." },
    { pattern: /why do some animals hibernate/i, response: "Animals hibernate to conserve energy during winter when food is scarce." },
    { pattern: /what is the smallest country in the world/i, response: "Vatican City is the smallest country in the world, covering just 0.49 square kilometers!" },
    { pattern: /how do clouds form/i, response: "Clouds form when warm air rises, cools, and condenses into tiny water droplets or ice crystals." },
    { pattern: /why do we need oxygen/i, response: "Oxygen is essential for cellular respiration, allowing our bodies to produce energy." },
    { pattern: /what is the biggest animal in the ocean/i, response: "The blue whale is the biggest animal in the ocean, growing up to 100 feet long!" },
    { pattern: /how do chameleons change color/i, response: "Chameleons change color by adjusting specialized cells in their skin called chromatophores." },
    { pattern: /why do volcanoes erupt/i, response: "Volcanoes erupt when magma rises to the surface due to pressure buildup inside the Earth." },
    { pattern: /how do computers store data/i, response: "Computers store data using binary code (0s and 1s) on hard drives, SSDs, or memory chips." },
    { pattern: /what is the most spoken language in the world/i, response: "The most spoken language by native speakers is Mandarin Chinese, followed by Spanish and English." },
    { pattern: /why do fireflies glow/i, response: "Fireflies glow due to a chemical reaction called bioluminescence, which helps them attract mates." },
    { pattern: /what is the difference between stars and planets/i, response: "Stars produce light and heat through nuclear fusion, while planets orbit stars and reflect light." },
    { pattern: /how do planes avoid crashing into each other/i, response: "Planes follow air traffic control instructions and use radar and automated systems to avoid collisions." },
    { pattern: /why do some people have freckles/i, response: "Freckles are caused by clusters of melanin in the skin and are more common in people with lighter skin." },    { pattern: /what is VIPTEAMMOD/i, response: "VIPTEAMMOD is a community and platform dedicated to creating mods and assisting with tech-related projects, including game mods and tools!" },
    { pattern: /who created VIPTEAMMOD/i, response: "VIPTEAMMOD was created by a group of passionate developers and modders who aim to enhance gaming and tech experiences." },
    { pattern: /how can I join VIPTEAMMOD/i, response: "You can join VIPTEAMMOD by visiting our website and becoming part of the community. We welcome new members!" },
    { pattern: /what is the purpose of VIPTEAMMOD/i, response: "The purpose of VIPTEAMMOD is to provide tools, mods, and resources for tech enthusiasts and gamers, while fostering a community of creators." },
    { pattern: /can I share my mod on VIPTEAMMOD/i, response: "Yes! You can share your mod on VIPTEAMMOD. We encourage creators to showcase their projects and share their knowledge." },
    { pattern: /where can I find VIPTEAMMOD tools/i, response: "You can find VIPTEAMMOD tools and mods on our website, where we share downloads and guides for various projects." },
    { pattern: /how do I get support from VIPTEAMMOD/i, response: "If you need support, you can reach out through our forums or contact us directly on our website. We're happy to help!" },
    { pattern: /is VIPTEAMMOD free to join/i, response: "Yes, VIPTEAMMOD is free to join! All of our resources and community features are available to members at no cost." },
    { pattern: /can I collaborate with VIPTEAMMOD/i, response: "Absolutely! We encourage collaboration and welcome developers, modders, and creators to work together on projects." },
    { pattern: /does VIPTEAMMOD have a Discord/i, response: "Yes, VIPTEAMMOD has a Discord server where you can chat with other members, get updates, and share your work!" },
    { pattern: /how do I download a mod from VIPTEAMMOD/i, response: "To download a mod from VIPTEAMMOD, simply visit our website, find the mod you're interested in, and follow the download instructions." },
    { pattern: /what kind of mods does VIPTEAMMOD focus on/i, response: "VIPTEAMMOD focuses on a variety of mods, including game mods, Android app mods, and tools for software development." },
    { pattern: /is there a VIPTEAMMOD app/i, response: "Currently, we don't have an official app, but you can access all of our resources and tools via our website." },
    { pattern: /how do I contribute to VIPTEAMMOD/i, response: "You can contribute by creating and sharing mods, offering support to other members, or helping with development projects." },
    { pattern: /can I get paid for my work on VIPTEAMMOD/i, response: "While VIPTEAMMOD is a community-driven platform, some opportunities may arise for paid projects. Stay active and engaged for potential collaborations!" },
    { pattern: /what is the best mod on VIPTEAMMOD/i, response: "The best mod on VIPTEAMMOD is subjective and depends on your interests. Explore the mods on our website and find what works best for you!" },
    { pattern: /is VIPTEAMMOD safe|VIPTEAMMOD safe|VIPTEAMMODsafe/i, response: "Yes, VIPTEAMMOD is a safe platform for modders and developers. We prioritize security and make sure all content shared is safe to use." },
    { pattern: /what games are supported by VIPTEAMMOD/i, response: "VIPTEAMMOD supports a variety of games, including popular mobile and PC titles. Check out our website for a list of supported games." },    { pattern: /how do magnets work/i, response: "Magnets work by generating a magnetic field that attracts or repels certain metals, like iron, cobalt, and nickel." },
    { pattern: /why is the ocean salty/i, response: "The ocean is salty because of minerals, particularly sodium chloride, that are dissolved from rocks and land into the water." },
    { pattern: /what is photosynthesis/i, response: "Photosynthesis is the process by which plants use sunlight to convert carbon dioxide and water into glucose and oxygen." },
    { pattern: /how does a microwave work/i, response: "Microwaves work by emitting electromagnetic waves that cause water molecules in food to vibrate and generate heat." },
    { pattern: /why do we have seasons/i, response: "Seasons are caused by the tilt of the Earth on its axis, which results in different parts of the Earth receiving varying amounts of sunlight throughout the year." },
    { pattern: /how do plants grow/i, response: "Plants grow by absorbing sunlight, water, and nutrients from the soil to produce energy through photosynthesis." },
    { pattern: /why do we dream/i, response: "Dreams are thought to occur as a result of brain activity during sleep, possibly helping with memory consolidation and emotional processing." },
    { pattern: /how do tornadoes form/i, response: "Tornadoes form when warm, moist air meets cold, dry air, causing a violent updraft that spins rapidly and forms a funnel cloud." },
    { pattern: /why do we get dizzy/i, response: "Dizziness can occur due to a variety of reasons, including changes in blood pressure, dehydration, or inner ear issues." },
    { pattern: /what is the speed of sound/i, response: "The speed of sound in air is about 343 meters per second, but it can vary depending on factors like temperature and altitude." },
    { pattern: /how do plants reproduce/i, response: "Plants reproduce through seeds, which can be spread by wind, animals, or water, or through asexual reproduction like cloning or budding." },
    { pattern: /why do humans have two eyes/i, response: "Humans have two eyes to provide depth perception and a wider field of view, helping with coordination and movement." },
    { pattern: /why do we sweat/i, response: "Sweating is the body's natural way of regulating temperature by releasing moisture to cool the skin as it evaporates." },
    { pattern: /how do fish swim/i, response: "Fish swim by flexing their bodies and tails in a side-to-side motion, using fins for stability and steering." },
    { pattern: /why does ice float/i, response: "Ice floats because it is less dense than liquid water. When water freezes, it expands and forms a crystalline structure." },
    { pattern: /how does the brain store memories/i, response: "The brain stores memories by strengthening connections between neurons, particularly in areas like the hippocampus and cortex." },
    { pattern: /why do we feel pain/i, response: "Pain is a signal from the body that indicates potential injury or harm, helping us take action to protect ourselves." },
    { pattern: /what is the largest volcano/i, response: "The largest volcano in the world is Mauna Loa in Hawaii, which is also one of the most active volcanoes on Earth." },
    { pattern: /how do batteries work/i, response: "Batteries work by converting chemical energy into electrical energy through a reaction between electrodes and an electrolyte." },    { pattern: /how does a rainbow form/i, response: "Rainbows form when sunlight is refracted, dispersed, and reflected in water droplets, creating a spectrum of light in the sky." },
    { pattern: /why do we yawn/i, response: "Yawning is believed to help increase oxygen intake and regulate brain temperature, though its exact purpose is still debated." },
    { pattern: /how does a GPS work/i, response: "GPS works by using signals from satellites to determine your precise location on Earth through trilateration." },
    { pattern: /why do we have fingerprints/i, response: "Fingerprints enhance our sense of touch and grip by increasing friction between our fingers and objects." },
    { pattern: /how does a refrigerator keep food cold/i, response: "Refrigerators use a refrigeration cycle involving a coolant that absorbs heat from the interior and releases it outside, keeping the inside cool." },
    { pattern: /why do stars twinkle/i, response: "Stars appear to twinkle because their light is refracted by Earth's atmosphere as it travels to our eyes." },
    { pattern: /how does a compass work/i, response: "A compass works by aligning its magnetic needle with Earth's magnetic field, pointing towards the magnetic poles." },
    { pattern: /why do we have different time zones/i, response: "Time zones exist to account for Earth's rotation, ensuring that noon corresponds to the time when the sun is highest in the sky in each region." },
    { pattern: /how does a parachute work/i, response: "A parachute slows down a person's fall by creating air resistance, reducing their terminal velocity." },
    { pattern: /why do we have wisdom teeth/i, response: "Wisdom teeth were useful for our ancestors who had larger jaws and a diet that required more chewing, but they are often unnecessary today." },
    { pattern: /how does a telescope work/i, response: "Telescopes collect and magnify light from distant objects using lenses or mirrors, allowing us to observe them in greater detail." },
    { pattern: /why do we have an appendix/i, response: "The appendix is thought to have been useful for digesting cellulose in the diets of our ancestors, but it has a limited function in modern humans." },
    { pattern: /how does a radio work/i, response: "Radios receive electromagnetic waves transmitted over the air and convert them into sound through electronic circuits." },
    { pattern: /why do we have different blood types/i, response: "Blood types are determined by the presence or absence of specific antigens on the surface of red blood cells, inherited from our parents." },
    { pattern: /how does a car engine work/i, response: "A car engine converts fuel into mechanical energy through a series of controlled explosions in its cylinders, powering the vehicle." },
    { pattern: /why do we have seasons/i, response: "Seasons occur because Earth's axis is tilted relative to its orbit around the sun, causing varying sunlight angles and durations throughout the year." },
    { pattern: /how does a computer process information/i, response: "Computers process information using binary code, performing calculations and executing instructions through electronic circuits." },
    { pattern: /why do we have different hair colors/i, response: "Hair color is determined by the type and amount of melanin produced by cells in hair follicles, influenced by genetics." },
    { pattern: /how does a plane fly/i, response: "Planes fly by generating lift through their wings, which are designed to create a pressure difference between the upper and lower surfaces." },
    { pattern: /why do we have different skin colors/i, response: "Skin color is determined by the amount and type of melanin produced in the skin, influenced by genetics and evolutionary adaptation to sunlight exposure." },{ 
    pattern: /i need one code/i, 
    response: "Which code do you need?" 
},{ 
    pattern: /what is my battery percentage/i, 
    response: "I can't check your battery directly, but you can check it in your device settings or status bar." 
},

{ 
    pattern: /how to improve battery life/i, 
    response: "To improve battery life, reduce screen brightness, close background apps, and enable battery saver mode." 
},

{ 
    pattern: /why is my phone overheating/i, 
    response: "Your phone may overheat due to excessive background apps, high screen brightness, or prolonged gaming and charging at the same time." 
},

{ 
    pattern: /how to free up storage on my phone/i, 
    response: "You can free up storage by deleting unused apps, clearing cache, moving files to cloud storage, and removing duplicate files." 
},

{ 
    pattern: /why is my phone slow/i, 
    response: "Your phone may be slow due to too many background apps, low storage, or outdated software. Try restarting your phone or clearing unnecessary data." 
},

{ 
    pattern: /how to take a screenshot/i, 
    response: "On most phones, press the Power and Volume Down buttons together. On iPhones with Face ID, press the Power and Volume Up buttons together." 
},

{ 
    pattern: /how to check my phone’s ram/i, 
    response: "You can check your phone’s RAM in the Developer Options or by using a system information app." 
},

{ 
    pattern: /how to enable dark mode/i, 
    response: "Go to your phone’s settings, look for Display, and toggle Dark Mode or Night Mode." 
},

{ 
    pattern: /how to recover deleted photos/i, 
    response: "Check your phone’s Trash or Recently Deleted folder in the gallery. If not found, use a recovery app or cloud backup." 
},

{ 
    pattern: /how to fix a frozen screen/i, 
    response: "Try restarting your phone by holding the Power button. If the screen is still unresponsive, force restart or check for software updates." 
},

{ 
    pattern: /how to connect my phone to tv/i, 
    response: "You can connect via Chromecast, Miracast, HDMI adapter, or screen mirroring feature in your phone’s settings." 
},

{ 
    pattern: /why is my phone not charging/i, 
    response: "Check your charging cable, adapter, and port for dust or damage. Try using a different charger or restarting your phone." 
},

{ 
    pattern: /how to block spam calls/i, 
    response: "Go to your phone app, find Call Settings, and enable Spam Protection. You can also use third-party spam blockers." 
},

{ 
    pattern: /why is my phone camera blurry/i, 
    response: "Clean the camera lens, check for software updates, and adjust focus settings. If the issue persists, try restarting your phone." 
},

{ 
    pattern: /how to reset my phone/i, 
    response: "Go to Settings > System > Reset options > Erase all data (Factory reset). Backup your important files before resetting." 
},

{ 
    pattern: /how to check my phone model/i, 
    response: "Go to Settings > About Phone. You’ll find your phone model and specifications there." 
},

{ 
    pattern: /how to enable developer options/i, 
    response: "Go to Settings > About Phone and tap ‘Build Number’ 7 times to enable Developer Options." 
},

{ 
    pattern: /how to share internet from my phone/i, 
    response: "Go to Settings > Hotspot & Tethering and enable Mobile Hotspot. You can share your phone’s internet via WiFi or USB tethering." 
},

{ 
    pattern: /how to update my phone/i, 
    response: "Go to Settings > Software Update and check for available updates. Make sure you have enough battery and storage before updating." 
},{ 
    pattern: /why is my phone battery draining fast/i, 
    response: "Your battery may drain fast due to background apps, high screen brightness, or weak network signals. Try enabling power-saving mode." 
},

{ 
    pattern: /how to enable 5g on my phone/i, 
    response: "Go to Settings > Mobile Network > Preferred Network Type, and select 5G if your phone and carrier support it." 
},

{ 
    pattern: /how to check if my phone is 5g compatible/i, 
    response: "Go to Settings > About Phone > Network or check your phone’s specifications on the manufacturer’s website." 
},

{ 
    pattern: /how to clear cache on my phone/i, 
    response: "Go to Settings > Storage > Cached Data and clear it. You can also clear cache for individual apps in App Settings." 
},

{ 
    pattern: /why does my phone keep restarting/i, 
    response: "Frequent restarts may be caused by software bugs, overheating, or hardware issues. Try updating your phone or resetting it." 
},

{ 
    pattern: /how to enable call recording/i, 
    response: "Go to your phone app’s settings and check if Call Recording is available. Some phones require third-party apps for this feature." 
},

{ 
    pattern: /how to hide apps on my phone/i, 
    response: "On most phones, go to Settings > Apps > Hide Apps. Some launchers also offer an option to hide apps." 
},

{ 
    pattern: /how to lock apps with a password/i, 
    response: "Go to Settings > Security > App Lock and enable it. You can also use third-party app lockers for more security." 
},

{ 
    pattern: /how to stop ads on my phone/i, 
    response: "Go to Settings > Google > Ads and enable 'Opt out of Ads Personalization'. You can also use an ad blocker app." 
},

{ 
    pattern: /how to enable do not disturb mode/i, 
    response: "Go to Settings > Sound & Vibration > Do Not Disturb and turn it on. You can also set schedules for DND mode." 
},

{ 
    pattern: /how to connect my phone to a printer/i, 
    response: "You can connect via Wi-Fi, Bluetooth, or a USB cable. Install the printer’s app from the Play Store for better compatibility." 
},

{ 
    pattern: /how to check if my phone is original/i, 
    response: "Dial *#06# to check your IMEI number and verify it on the manufacturer’s website. Fake phones may have different build quality and software." 
},

{ 
    pattern: /why is my phone screen flickering/i, 
    response: "Screen flickering can be caused by software glitches, display damage, or incompatible apps. Try restarting or updating your phone." 
},

{ 
    pattern: /how to enable fingerprint lock/i, 
    response: "Go to Settings > Security > Fingerprint and set up your fingerprint. Make sure your phone has a fingerprint scanner." 
},

{ 
    pattern: /how to recover a forgotten phone password/i, 
    response: "If you've forgotten your password, use 'Forgot Password' option or factory reset your phone. You may need your Google account for recovery." 
},

{ 
    pattern: /how to disable notifications/i, 
    response: "Go to Settings > Apps & Notifications > Notifications and turn off unwanted notifications." 
},

{ 
    pattern: /how to fix no sim card error/i, 
    response: "Try reinserting the SIM card, restarting your phone, or checking for network settings updates." 
},

{ 
    pattern: /how to fix phone screen not responding to touch/i, 
    response: "Restart your phone, clean the screen, and remove any screen protectors. If the issue persists, check for software updates or factory reset your phone." 
},

{ 
    pattern: /how to find my phone if lost/i, 
    response: "Use Google’s 'Find My Device' or Apple’s 'Find My iPhone' to locate, lock, or erase your lost phone remotely." 
},{ 
    pattern: /how to take a long screenshot/i, 
    response: "After taking a screenshot, look for the 'Scroll Capture' or 'Extended Screenshot' option to take a longer one." 
},

{ 
    pattern: /how to check if my phone is original or fake/i, 
    response: "Dial *#06# to check your IMEI number and verify it on the manufacturer’s website." 
},

{ 
    pattern: /how to enable one-handed mode/i, 
    response: "Go to Settings > Accessibility > One-handed mode and enable it for easier use." 
},

{ 
    pattern: /how to hide apps on my phone/i, 
    response: "On most Android phones, go to Home Screen settings and select 'Hide Apps'. On iPhone, use App Library to hide apps." 
},

{ 
    pattern: /how to check battery health on android/i, 
    response: "Dial *#*#4636#*#* or use a third-party app like AccuBattery to check battery health." 
},

{ 
    pattern: /how to turn off voice assistant/i, 
    response: "Go to Settings > Accessibility > Voice Assistant and disable it." 
},

{ 
    pattern: /how to recover deleted photos/i, 
    response: "Check the 'Recently Deleted' folder in your gallery or use Google Photos' backup feature." 
},

{ 
    pattern: /how to enable call recording/i, 
    response: "Some phones have built-in call recording in the Phone app settings. If unavailable, try a third-party app." 
},

{ 
    pattern: /how to check my phone's temperature/i, 
    response: "Install a phone temperature monitoring app or check battery settings if your phone supports it." 
},

{ 
    pattern: /how to connect my phone to my car’s bluetooth/i, 
    response: "Enable Bluetooth on both devices, search for your car’s name in the phone’s Bluetooth settings, and pair them." 
},

{ 
    pattern: /how to fix a frozen phone screen/i, 
    response: "Try force restarting by holding the power + volume down button. If the issue persists, clear cache or reset the phone." 
},

{ 
    pattern: /how to change default apps on my phone/i, 
    response: "Go to Settings > Apps > Default Apps and select the app you want as default." 
},

{ 
    pattern: /how to enable always-on display/i, 
    response: "Go to Settings > Display > Always-On Display and enable it (if supported by your device)." 
},

{ 
    pattern: /how to factory reset my phone/i, 
    response: "Go to Settings > System > Reset > Factory Reset. This will erase all data, so back up important files first." 
},

{ 
    pattern: /how to increase internet speed on my phone/i, 
    response: "Clear cache, disable background apps, use 5GHz Wi-Fi, and ensure you have a strong signal." 
},
{ 
    pattern: /how to get a boyfriend/i, 
    response: "To get a boyfriend, focus on being confident, social, and engaging in activities where you can meet new people." 
},
{ 
    pattern: /how to get a girlfriend/i, 
    response: "To get a girlfriend, be kind, confident, and approachable. Engage in conversations and show genuine interest in others." 
},
{ 
    pattern: /how to make my boyfriend happy/i, 
    response: "To make your boyfriend happy, communicate openly, spend quality time together, and show appreciation for him." 
},
{ 
    pattern: /how to make my girlfriend happy/i, 
    response: "To make your girlfriend happy, listen to her, support her goals, and surprise her with small thoughtful gestures." 
},
{ 
    pattern: /how to impress a girl/i, 
    response: "To impress a girl, be confident, dress well, have a good sense of humor, and be a good listener." 
},
{ 
    pattern: /how to impress a boy/i, 
    response: "To impress a boy, be confident, show kindness, engage in meaningful conversations, and share common interests." 
},
{ 
    pattern: /how to know if my boyfriend loves me/i, 
    response: "If your boyfriend loves you, he will prioritize you, communicate openly, and support you through thick and thin." 
},
{ 
    pattern: /how to know if my girlfriend loves me/i, 
    response: "If your girlfriend loves you, she will care for you, make time for you, and show affection through actions and words." 
},
{ 
    pattern: /how to fix a relationship/i, 
    response: "To fix a relationship, communicate openly, understand each other's feelings, and make efforts to resolve conflicts together." 
},
{ 
    pattern: /how to deal with a breakup/i, 
    response: "To deal with a breakup, focus on self-care, stay busy with positive activities, and surround yourself with supportive friends and family." 
},
{ 
    pattern: /how to make my boyfriend miss me/i, 
    response: "To make your boyfriend miss you, give him space, focus on yourself, and keep the relationship exciting." 
},
{ 
    pattern: /how to make my girlfriend miss me/i, 
    response: "To make your girlfriend miss you, be mysterious, avoid being too available, and create memorable moments together." 
},
{ 
    pattern: /why is my boyfriend ignoring me/i, 
    response: "Your boyfriend might be busy, stressed, or upset. Try communicating with him calmly and understanding his perspective." 
},
{ 
    pattern: /why is my girlfriend ignoring me/i, 
    response: "Your girlfriend might be upset, need space, or have personal issues. Give her time and talk to her when she's ready." 
},
{ 
    pattern: /how to make my boyfriend jealous/i, 
    response: "Making someone jealous can be risky in a relationship. Instead, focus on building a strong and healthy connection." 
},
{ 
    pattern: /how to make my girlfriend jealous/i, 
    response: "Jealousy can hurt a relationship. Instead, work on making her feel valued and special." 
},
{ 
    pattern: /how to surprise my boyfriend/i, 
    response: "Surprise your boyfriend by planning a special date, giving him a thoughtful gift, or writing him a heartfelt letter." 
},
{ 
    pattern: /how to surprise my girlfriend/i, 
    response: "Surprise your girlfriend with a romantic dinner, a handwritten note, or a spontaneous trip to her favorite place." 
},
{ 
    pattern: /how to tell my boyfriend I love him/i, 
    response: "Tell your boyfriend you love him in a sincere and heartfelt way. You can say it in person, write a letter, or show it through actions." 
},
{ 
    pattern: /how to tell my girlfriend I love her/i, 
    response: "Tell your girlfriend you love her by expressing it sincerely, making eye contact, and showing your love through actions." 
},
{ 
    pattern: /should I text my ex/i, 
    response: "Before texting your ex, consider why you want to. If it's for closure, keep it respectful. If it's out of loneliness, think twice." 
},
{ 
    pattern: /how to make a long-distance relationship work/i, 
    response: "To make a long-distance relationship work, communicate regularly, plan visits, and build trust." 
},
{ 
    pattern: /how to apologize to my boyfriend/i, 
    response: "Apologize sincerely by acknowledging your mistake, expressing regret, and showing that you want to improve." 
},
{ 
    pattern: /how to apologize to my girlfriend/i, 
    response: "Apologize to your girlfriend with honesty, take responsibility, and make it up to her with kind actions." 
},
{ 
    pattern: /how to stop arguing with my boyfriend/i, 
    response: "To stop arguing, listen to his perspective, stay calm, and focus on solving problems rather than blaming each other." 
},
{ 
    pattern: /how to stop arguing with my girlfriend/i, 
    response: "To stop arguing, communicate calmly, avoid interrupting her, and find solutions instead of escalating conflicts." 
},
{ 
    pattern: /what to do if my boyfriend is losing interest/i, 
    response: "If your boyfriend is losing interest, talk openly with him, reignite the spark, and focus on strengthening your bond." 
},
{ 
    pattern: /what to do if my girlfriend is losing interest/i, 
    response: "If your girlfriend is losing interest, try to understand her feelings, show her appreciation, and bring back excitement into the relationship." 
},
{ 
    pattern: /is my boyfriend cheating on me/i, 
    response: "If you suspect your boyfriend is cheating, look for changes in behavior and communication. The best approach is to talk to him directly." 
},
{ 
    pattern: /is my girlfriend cheating on me/i, 
    response: "If you suspect your girlfriend is cheating, observe her actions and have an open conversation with her about your concerns." 
},
{ 
    pattern: /how to make my boyfriend love me more/i, 
    response: "To make your boyfriend love you more, show him appreciation, support his goals, and create meaningful memories together." 
},
{ 
    pattern: /how to make my girlfriend love me more/i, 
    response: "To make your girlfriend love you more, treat her with respect, listen to her, and always make her feel special." 
},
{ 
    pattern: /how to make my boyfriend trust me/i, 
    response: "To build trust with your boyfriend, be honest, keep your promises, and communicate openly." 
},
{ 
    pattern: /how to make my girlfriend trust me/i, 
    response: "To make your girlfriend trust you, be transparent, stay loyal, and always keep your word." 
},
{ 
    pattern: /what should I text my boyfriend/i, 
    response: "You can text your boyfriend a sweet message, ask about his day, or send something funny to make him smile." 
},
{ 
    pattern: /what should I text my girlfriend/i, 
    response: "Text your girlfriend something thoughtful, compliment her, or remind her how much she means to you." 
},
{ 
    pattern: /how to know if my boyfriend is serious about me/i, 
    response: "A serious boyfriend will prioritize you, make future plans with you, and stay loyal in difficult times." 
},
{ 
    pattern: /how to know if my girlfriend is serious about me/i, 
    response: "A serious girlfriend will be committed, include you in her plans, and make an effort to understand and support you." 
},
{ 
    pattern: /how to get over my boyfriend/i, 
    response: "To get over your boyfriend, focus on self-care, spend time with friends, and remind yourself why the breakup happened." 
},
{ 
    pattern: /how to get over my girlfriend/i, 
    response: "To get over your girlfriend, avoid dwelling on the past, stay busy with hobbies, and surround yourself with supportive people." 
},
{ 
    pattern: /how to tell if my boyfriend is lying/i, 
    response: "Signs that your boyfriend may be lying include avoiding eye contact, being inconsistent, or acting defensive when questioned." 
},
{ 
    pattern: /how to tell if my girlfriend is lying/i, 
    response: "If your girlfriend is lying, she might avoid details, change her story, or seem nervous when answering your questions." 
},
{ 
    pattern: /why is my boyfriend acting distant/i, 
    response: "Your boyfriend might be stressed, need space, or dealing with personal issues. Try asking him about it calmly." 
},
{ 
    pattern: /why is my girlfriend acting distant/i, 
    response: "Your girlfriend might be going through something personal or feeling unappreciated. Open communication can help." 
},
{ 
    pattern: /how to stop my boyfriend from leaving me/i, 
    response: "You can't force someone to stay, but you can talk openly, understand his feelings, and work on any relationship issues." 
},
{ 
    pattern: /how to stop my girlfriend from leaving me/i, 
    response: "If your girlfriend is thinking about leaving, have an honest conversation and see if you can resolve any issues together." 
},
{ 
    pattern: /what to do if my boyfriend cheated on me/i, 
    response: "If your boyfriend cheated, take time to process your feelings, decide if you can forgive him, and prioritize your happiness." 
},
{ 
    pattern: /what to do if my girlfriend cheated on me/i, 
    response: "If your girlfriend cheated, consider whether trust can be rebuilt and focus on what’s best for your emotional well-being." 
},
{ 
    pattern: /how to handle jealousy in a relationship/i, 
    response: "To handle jealousy, communicate openly, build trust, and focus on strengthening your relationship." 
},
{ 
    pattern: /how to make my ex want me back/i, 
    response: "To make your ex want you back, work on self-improvement, give them space, and let them see what they lost." 
},
{ 
    pattern: /is it okay to be friends with my ex/i, 
    response: "Being friends with an ex is possible, but only if both of you have moved on and there are no lingering feelings." 
},
{ 
    pattern: /should I give my ex another chance/i, 
    response: "Consider why you broke up in the first place. If the issues remain unresolved, getting back together may not be a good idea." 
},
{ 
    pattern: /how to make my boyfriend commit/i, 
    response: "To make your boyfriend commit, build a strong emotional connection, be supportive, and avoid rushing him." 
},
{ 
    pattern: /how to make my girlfriend commit/i, 
    response: "To make your girlfriend commit, show her that you are serious, consistent, and ready for a long-term relationship." 
},
{ 
    pattern: /how to stop being clingy with my boyfriend/i, 
    response: "To stop being clingy, focus on your own hobbies, give him space, and trust the relationship." 
},
{ 
    pattern: /how to stop being clingy with my girlfriend/i, 
    response: "Give your girlfriend space, build confidence in yourself, and trust that she cares about you even when you're apart." 
},
{ 
    pattern: /how to handle a long-distance breakup/i, 
    response: "A long-distance breakup can be tough. Allow yourself to grieve, cut off unhealthy contact, and focus on healing." 
},
{ 
    pattern: /should I date my best friend/i, 
    response: "Dating your best friend can be great, but make sure you both have romantic feelings and are willing to risk the friendship if things don’t work out." 
},
{ 
    pattern: /why does my boyfriend not text me back/i, 
    response: "He might be busy, distracted, or needing space. Try not to overthink and wait for him to respond." 
},
{ 
    pattern: /why does my girlfriend not text me back/i, 
    response: "Your girlfriend might be occupied, stressed, or taking a break from her phone. Give her some time before jumping to conclusions." 
},
{ 
    pattern: /how to deal with a controlling boyfriend/i, 
    response: "If your boyfriend is controlling, try setting clear boundaries, express your need for independence, and consider seeking professional advice if the behavior continues." 
},
{ 
    pattern: /how to deal with a controlling girlfriend/i, 
    response: "If your girlfriend is controlling, have an honest conversation about your need for personal space and trust. Establishing clear boundaries can help both of you feel more comfortable." 
},
{ 
    pattern: /what are some fun date ideas/i, 
    response: "Fun date ideas include trying a new restaurant, going for a hike, visiting a museum, or planning a picnic in a scenic park." 
},
{ 
    pattern: /how to reignite passion in my relationship/i, 
    response: "Reignite passion by planning surprise dates, exploring new activities together, and discussing your desires openly with your partner." 
},
{ 
    pattern: /how to build trust after cheating/i, 
    response: "Building trust after cheating takes time and honest communication. Both partners must be willing to work through their feelings, and professional counseling might help rebuild the relationship." 
},
{ 
    pattern: /how to deal with a breakup amicably/i, 
    response: "To handle a breakup amicably, communicate calmly, agree on respectful boundaries, and allow each other the space to heal without unnecessary conflict." 
},
{ 
    pattern: /how to move on after a bad breakup/i, 
    response: "Moving on after a breakup involves focusing on self-care, exploring new hobbies, spending time with supportive friends, and sometimes seeking professional guidance." 
},
{ 
    pattern: /what does a healthy relationship look like/i, 
    response: "A healthy relationship is built on mutual respect, open communication, trust, and both partners feeling supported and valued." 
},
{ 
    pattern: /how to maintain independence in a relationship/i, 
    response: "Maintain your independence by pursuing your own interests, setting personal goals, and ensuring you have time for your individual friendships and hobbies." 
},
{ 
    pattern: /how to communicate my needs to my partner/i, 
    response: "Express your needs clearly using 'I' statements, avoid blaming, and encourage your partner to share their perspective as well." 
},
{ 
    pattern: /how to balance work and a relationship/i, 
    response: "Balancing work and a relationship means setting clear priorities, scheduling quality time together, and maintaining open communication about your busy schedules." 
},
{ 
    pattern: /how to celebrate an anniversary with my partner/i, 
    response: "Celebrate your anniversary by reflecting on special memories, planning a thoughtful surprise, or doing an activity that both of you enjoy together." 
},
{ 
    pattern: /how to apologize after an argument/i, 
    response: "After an argument, apologize sincerely by acknowledging your mistakes, expressing regret, and discussing ways to avoid similar conflicts in the future." 
},
{ 
    pattern: /how to deal with insecurities in a relationship/i, 
    response: "Address insecurities by talking openly with your partner, focusing on self-improvement, and, if needed, seeking advice from a trusted friend or professional." 
},
{ 
    pattern: /how to spice up my relationship/i, 
    response: "Spice up your relationship by trying new activities together, planning surprises, and exploring each other's interests in a fun, creative way." 
},
{ 
    pattern: /how to set boundaries with my partner/i, 
    response: "Set boundaries by discussing your comfort levels, listening to your partner's needs, and agreeing on respectful limits that work for both of you." 
},
{ 
    pattern: /how to know if my partner is the one/i, 
    response: "You might know your partner is the one if you share mutual respect, feel supported, and have a deep, trusting connection with each other." 
},
{ 
    pattern: /how to deal with constant arguments/i, 
    response: "If constant arguments are affecting your relationship, try to identify recurring issues, communicate calmly, and consider couples counseling to work through deeper problems." 
},
{ 
    pattern: /how to balance my personal space and my relationship/i, 
    response: "Balancing personal space with relationship time means planning regular individual activities while also scheduling dedicated time together for quality connection." 
},
{ 
    pattern: /how to discuss future plans with my partner/i, 
    response: "Discuss future plans by sharing your goals, listening to your partner’s dreams, and finding common ground to build a shared vision for the future." 
},
{ 
    pattern: /how to know if i'm overthinking my relationship/i, 
    response: "If you find yourself constantly worrying or reading too much into every detail, it might help to take a step back, focus on self-reflection, and communicate your concerns with your partner." 
},
{ 
    pattern: /how to build a deeper connection with my partner/i, 
    response: "Building a deeper connection involves sharing your true feelings, spending quality time together, and being open to learning more about each other's dreams and vulnerabilities." 
},
{ 
    pattern: /how to avoid codependency in a relationship/i, 
    response: "Avoid codependency by maintaining your personal interests, setting healthy boundaries, and ensuring that both partners have their own space and social support systems." 
},
{ 
    pattern: /how to address my partner's mood swings/i, 
    response: "When dealing with mood swings, approach your partner with empathy, gently encourage open communication, and consider if professional advice might be needed for ongoing issues." 
},
{ 
    pattern: /what are the signs of an unhealthy relationship/i, 
    response: "Signs of an unhealthy relationship can include constant criticism, lack of trust, poor communication, and feeling controlled or unappreciated. Recognizing these early is key to addressing them." 
},
{ 
    pattern: /how to deal with my partner's ex/i, 
    response: "Dealing with a partner's ex requires open communication. Express your feelings without accusations and work together to build trust and reassurance in your relationship." 
},
{ 
    pattern: /how to improve communication in my relationship/i, 
    response: "Improving communication involves active listening, being honest about your feelings, and setting aside time to talk without distractions." 
},
{ 
    pattern: /how to manage disagreements with my partner/i, 
    response: "Manage disagreements by staying calm, using 'I' statements to express your feelings, and seeking compromise rather than trying to win the argument." 
},
{ 
    pattern: /how to maintain romance in a long-term relationship/i, 
    response: "Keep the romance alive by planning regular date nights, surprising each other with thoughtful gestures, and continuing to learn about each other's evolving interests." 
},
{ 
    pattern: /how to give my partner space without feeling insecure/i, 
    response: "It's important to build trust by understanding that personal space benefits both individuals. Focus on your own interests, maintain your social life, and remind yourself of the strength of your bond." 
},{ 
    pattern: /what is ai metaverse/i, 
    response: "AI in the Metaverse enhances virtual environments, creating realistic interactions, NPCs, and adaptive storytelling." 
},
{ 
    pattern: /will ai create its own language/i, 
    response: "AI has developed its own languages in research experiments, but human oversight ensures clarity and safety." 
},
{ 
    pattern: /how will ai change robotics/i, 
    response: "AI is making robots more intelligent, allowing them to learn tasks, recognize emotions, and interact naturally with humans." 
},
{ 
    pattern: /what is ai self-learning/i, 
    response: "AI self-learning refers to models that improve over time by analyzing new data without explicit programming." 
},
{ 
    pattern: /can ai control smart cities/i, 
    response: "Yes! AI can optimize traffic, manage energy consumption, and improve city planning for smarter urban living." 
},
{ 
    pattern: /will ai replace doctors/i, 
    response: "AI will assist doctors with diagnosis and treatment but is unlikely to replace human medical professionals entirely." 
},
{ 
    pattern: /can ai predict weather/i, 
    response: "AI improves weather forecasting by analyzing climate data and detecting patterns in real-time." 
},
{ 
    pattern: /what is ai-powered transportation/i, 
    response: "AI-powered transportation includes self-driving cars, intelligent traffic control, and AI-assisted flight navigation." 
},
{ 
    pattern: /can ai generate realistic human voices/i, 
    response: "Yes! AI voice synthesis can create lifelike voices for virtual assistants, audiobooks, and deepfake applications." 
},
{ 
    pattern: /what is ai-driven automation/i, 
    response: "AI-driven automation helps businesses optimize workflows, reduce human effort, and increase productivity." 
},
{ 
    pattern: /will ai be able to create movies/i, 
    response: "AI is already helping in scriptwriting, CGI effects, and animation, but full movie production still requires human creativity." 
},
{ 
    pattern: /how does ai help in space exploration/i, 
    response: "AI helps analyze space data, control rovers, and assist in autonomous decision-making for interstellar missions." 
},
{ 
    pattern: /can ai predict human behavior/i, 
    response: "AI can analyze behavior patterns and predict actions, but human unpredictability still makes absolute accuracy difficult." 
},
{ 
    pattern: /how does ai contribute to cybersecurity/i, 
    response: "AI enhances cybersecurity by detecting threats, identifying anomalies, and automating security responses." 
},
{ 
    pattern: /what is the role of ai in smart homes/i, 
    response: "AI powers smart assistants, energy management systems, and automated home security for better living experiences." 
},
{ 
    pattern: /will ai have consciousness in the future/i, 
    response: "AI currently lacks consciousness, but future advancements might bring AI closer to simulating self-awareness." 
},
{ 
    pattern: /can ai generate new scientific theories/i, 
    response: "AI assists scientists by analyzing data and identifying new patterns, helping in scientific discoveries and innovations." 
},
{ 
    pattern: /play tic tac toe/i, 
    response: "Let's play Tic-Tac-Toe! You go first. Type your move as a number (1-9) where 1 is the top-left and 9 is the bottom-right." 
},
{ 
    pattern: /start ai chess game/i, 
    response: "AI Chess activated! Do you want to play as White or Black? Type 'White' to start first or 'Black' for AI to move first." 
},
{ 
    pattern: /can ai beat humans in chess/i, 
    response: "Yes! Advanced AI like AlphaZero has beaten top human chess players by learning strategies through self-play." 
},
{ 
    pattern: /how does ai learn to play games/i, 
    response: "AI learns games using reinforcement learning, where it plays millions of rounds and improves its strategies over time." 
},
{ 
    pattern: /what is ai game automation/i, 
    response: "AI game automation refers to bots or AI-controlled agents that can play games automatically using deep learning models." 
},
{ 
    pattern: /can ai create its own video games/i, 
    response: "Yes! AI can generate game levels, characters, and even design entire game mechanics using procedural content generation." 
},
{ 
    pattern: /how does ai improve video game graphics/i, 
    response: "AI enhances graphics through upscaling, texture generation, and real-time rendering for realistic visuals." 
},
{ 
    pattern: /can ai make a 3d game/i, 
    response: "Yes! AI can generate 3D environments, character models, and even procedural animations for game development." 
},
{ 
    pattern: /can ai learn to play fighting games/i, 
    response: "Yes! AI can analyze fighting game mechanics, predict opponent moves, and optimize attack strategies." 
},
{ 
    pattern: /what is ai procedural generation/i, 
    response: "AI procedural generation creates game content dynamically, such as randomized maps, levels, and characters." 
},
{ 
    pattern: /how does ai help in game development/i, 
    response: "AI assists in coding, level design, character animations, bug detection, and real-time enemy AI behavior." 
},
{ 
    pattern: /can ai play battle royale games/i, 
    response: "Yes! AI bots can simulate players in battle royale games, improving training modes and bot-based matchmaking." 
},
{ 
    pattern: /how does ai detect cheating in games/i, 
    response: "AI analyzes player behavior, detects unusual patterns, and flags potential cheaters in multiplayer games." 
},
{ 
    pattern: /can ai build open-world games/i, 
    response: "AI can generate large open-world environments with realistic landscapes, dynamic NPCs, and interactive quests." 
},
{ 
    pattern: /how does ai create game characters/i, 
    response: "AI uses procedural modeling to generate realistic characters, facial expressions, and voice synthesis." 
},
{ 
    pattern: /what is ai pathfinding in games/i, 
    response: "AI pathfinding helps NPCs navigate game environments by finding the shortest or most efficient route." 
},
{ 
    pattern: /can ai predict game outcomes/i, 
    response: "AI can analyze player performance, predict match outcomes, and suggest strategies based on game data." 
},
{ 
    pattern: /what is artificial intelligence/i, 
    response: "Artificial Intelligence (AI) is the simulation of human intelligence in machines that can learn, reason, and make decisions." 
},
{ 
    pattern: /how does ai work/i, 
    response: "AI works by processing large amounts of data, recognizing patterns, and using algorithms to make predictions or automate tasks." 
},
{ 
    pattern: /what is the future of ai/i, 
    response: "The future of AI includes advancements in automation, personalized AI assistants, improved healthcare solutions, and ethical AI development." 
},
{ 
    pattern: /will ai replace human jobs/i, 
    response: "AI will automate some tasks but also create new job opportunities that require human creativity, problem-solving, and emotional intelligence." 
},
{ 
    pattern: /what are the risks of ai/i, 
    response: "AI risks include job displacement, bias in decision-making, data privacy concerns, and potential misuse in unethical applications." 
},
{ 
    pattern: /how is ai used in daily life/i, 
    response: "AI is used in voice assistants, personalized recommendations, smart home devices, self-driving cars, and healthcare diagnostics." 
},
{ 
    pattern: /what is machine learning/i, 
    response: "Machine learning is a subset of AI where algorithms learn from data to improve their accuracy over time without being explicitly programmed." 
},
{ 
    pattern: /will ai become self-aware/i, 
    response: "Currently, AI lacks self-awareness, but researchers continue exploring advanced AI models that mimic human cognition." 
},
{ 
    pattern: /how can ai improve healthcare/i, 
    response: "AI can improve healthcare through early disease detection, personalized treatment plans, robotic surgeries, and medical research advancements." 
},
{ 
    pattern: /what are ai ethics/i, 
    response: "AI ethics involve ensuring AI systems are fair, transparent, accountable, and do not cause harm to society." 
},
{ 
    pattern: /how is ai used in gaming/i, 
    response: "AI in gaming enhances NPC behavior, creates dynamic environments, improves game graphics, and personalizes player experiences." 
},
{ 
    pattern: /will ai have emotions/i, 
    response: "AI can simulate emotions but does not truly feel them. Future AI may better understand and respond to human emotions." 
},
{ 
    pattern: /what is the difference between ai and robotics/i, 
    response: "AI refers to intelligent algorithms, while robotics involves physical machines. AI can be integrated into robots for smarter automation." 
},
{ 
    pattern: /how will ai change the world/i, 
    response: "AI will revolutionize industries like healthcare, finance, education, and automation, leading to increased efficiency and new innovations." 
},
{ 
    pattern: /what is quantum ai/i, 
    response: "Quantum AI uses quantum computing to process complex calculations faster, improving machine learning and optimization problems." 
},
{ 
    pattern: /how secure is ai/i, 
    response: "AI security depends on how it's implemented. Strong cybersecurity measures are needed to prevent AI manipulation or hacking." 
},
{ 
    pattern: /what is general ai/i, 
    response: "General AI, or AGI, refers to an AI system with human-like intelligence that can perform any intellectual task like a human." 
},
{ 
    pattern: /can ai create art/i, 
    response: "Yes, AI can generate music, paintings, and literature using deep learning models, but human creativity still plays a major role." 
},
{ 
    pattern: /what is ai bias/i, 
    response: "AI bias occurs when an AI system makes unfair or discriminatory decisions due to biased training data or flawed algorithms." 
},
{ 
    pattern: /how is ai used in cybersecurity/i, 
    response: "AI enhances cybersecurity by detecting threats, analyzing patterns in cyber attacks, and automating security measures." 
},
{ 
    pattern: /can ai predict the future/i, 
    response: "AI can analyze trends and make predictions based on data, but it cannot predict the future with complete certainty." 
},
{ 
    pattern: /what is ai singularity/i, 
    response: "AI singularity is the theoretical point where AI surpasses human intelligence, leading to rapid technological changes." 
},
{ 
    pattern: /how does ai improve customer service/i, 
    response: "AI improves customer service through chatbots, automated responses, and personalized recommendations for users." 
},
{ 
    pattern: /how will ai impact education/i, 
    response: "AI will personalize learning, automate grading, provide tutoring, and create intelligent classroom environments." 
},
{ 
    pattern: /what is ai-powered automation/i, 
    response: "AI-powered automation uses machine learning to perform tasks without human intervention, increasing efficiency in various industries." 
},
{ 
    pattern: /can ai write code/i, 
    response: "AI can generate code and assist developers, but it still requires human oversight for complex programming and debugging." 
},
{ 
    pattern: /what is deep learning/i, 
    response: "Deep learning is a subset of machine learning that uses neural networks to process data and make intelligent decisions." 
},
{ 
    pattern: /how does ai help in finance/i, 
    response: "AI assists in fraud detection, stock market predictions, risk management, and personalized financial planning." 
},
{ 
    pattern: /will ai become smarter than humans/i, 
    response: "AI can surpass humans in specific tasks but lacks general intelligence, emotional understanding, and creativity at a human level." 
},
{ 
    pattern: /what is ai-generated content/i, 
    response: "AI-generated content includes articles, videos, images, and music created using machine learning and natural language processing." 
},
{ 
    pattern: /current time/i, 
    response: () => {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        return `The current time is: ${hours}:${minutes}:${seconds}`;
    }
},{ 
    pattern: /time after (\d+) minutes/i, 
    response: (match) => {
        const minutesToAdd = parseInt(match[1]);
        const now = new Date();
        now.setMinutes(now.getMinutes() + minutesToAdd);
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        return `The time after ${minutesToAdd} minutes will be: ${hours}:${minutes}:${seconds}`;
    }
},{ 
    pattern: /convert utc to (\w+)/i, 
    response: (match) => {
        const timeZone = match[1].toUpperCase();
        const now = new Date();
        const options = { timeZone: timeZone, hour: '2-digit', minute: '2-digit', second: '2-digit' };
        const timeInTimeZone = now.toLocaleString('en-US', options);
        return `The current time in ${timeZone} is: ${timeInTimeZone}`;
    }
},{ 
    pattern: /days until (\d{2})\/(\d{2})\/(\d{4})/i, 
    response: (match) => {
        const targetDate = new Date(`${match[2]}/${match[1]}/${match[3]}`);
        const now = new Date();
        const timeDifference = targetDate - now;
        const daysLeft = Math.ceil(timeDifference / (1000 * 3600 * 24)); // convert ms to days
        return `There are ${daysLeft} days left until ${match[2]}/${match[1]}/${match[3]}`;
    }
},{ 
    pattern: /time since (\d{2})\/(\d{2})\/(\d{4})/i, 
    response: (match) => {
        const targetDate = new Date(`${match[2]}/${match[1]}/${match[3]}`);
        const now = new Date();
        const timeDifference = now - targetDate;
        const daysPassed = Math.floor(timeDifference / (1000 * 3600 * 24));
        const hoursPassed = Math.floor((timeDifference % (1000 * 3600 * 24)) / (1000 * 3600));
        const minutesPassed = Math.floor((timeDifference % (1000 * 3600)) / (1000 * 60));
        return `It has been ${daysPassed} days, ${hoursPassed} hours, and ${minutesPassed} minutes since ${match[2]}/${match[1]}/${match[3]}`;
    }
},{ 
    pattern: /current month/i, 
    response: () => {
        const now = new Date();
        const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const month = months[now.getMonth()];
        return `The current month is: ${month}`;
    }
},{ 
    pattern: /current year/i, 
    response: () => {
        const now = new Date();
        return `The current year is: ${now.getFullYear()}`;
    }
},{ 
    pattern: /next week date/i, 
    response: () => {
        const now = new Date();
        now.setDate(now.getDate() + 7);
        const date = now.toLocaleDateString();
        return `The date next week will be: ${date}`;
    }
},
    { 
    pattern: /time until midnight/i, 
    response: () => {
        const now = new Date();
        const midnight = new Date(now);
        midnight.setHours(24, 0, 0, 0); // Set to midnight of the next day
        const timeRemaining = midnight - now;
        const hoursRemaining = Math.floor(timeRemaining / (1000 * 3600));
        const minutesRemaining = Math.floor((timeRemaining % (1000 * 3600)) / (1000 * 60));
        return `There are ${hoursRemaining} hours and ${minutesRemaining} minutes left until midnight.`;
    }
},{ 
    pattern: /largest number in (.+)/i, 
    response: (match) => {
        const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
        const largest = Math.max(...numbers);
        return `The largest number is: ${largest}`;
    }
},{ 
    pattern: /random number between (\d+) and (\d+)/i, 
    response: (match) => {
        const min = parseInt(match[1]);
        const max = parseInt(match[2]);
        const randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
        return `The random number between ${min} and ${max} is: ${randomNumber}`;
    }
},{
    pattern: /generate password with (\d+) characters/i,
    response: (match) => {
        const length = parseInt(match[1]);
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_-+=<>?";
        let password = "";
        
        for (let i = 0; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * charset.length);
            password += charset[randomIndex];
        }

        return `Your generated password is: ${password}`;
    }
},{
    pattern: /name an animal/i,
    response: () => {
        const animals = [
            "Lion", "Tiger", "Elephant", "Giraffe", "Zebra", 
            "Panda", "Kangaroo", "Koala", "Penguin", "Cheetah", 
            "Bear", "Wolf", "Gorilla", "Hippo", "Sloth", 
            "Rhino", "Leopard", "Hawk", "Eagle", "Owl", 
            "Shark", "Whale", "Dolphin", "Crocodile", "Alligator", 
            "Octopus", "Starfish", "Turtle", "Snake", "Lizard"
        ];
        const randomAnimal = animals[Math.floor(Math.random() * animals.length)];
        return `Here is an animal: ${randomAnimal}`;
    }
},{
    pattern: /what sound does a (.+) make/i,
    response: (match) => {
        const animal = match[1].toLowerCase();
        const sounds = {
            "dog": "bark",
            "cat": "meow",
            "cow": "moo",
            "sheep": "baa",
            "lion": "roar",
            "duck": "quack",
            "bird": "chirp",
            "horse": "neigh",
            "elephant": "trumpet",
            "snake": "hiss"
        };
        const sound = sounds[animal] || "I don't know the sound of that animal.";
        return `A ${animal} makes a ${sound}.`;
    }
},{
    pattern: /tell me a fact about (.+)/i,
    response: (match) => {
        const facts = {
            "lion": "Lions are the only cats that live in groups, called prides.",
            "tiger": "Tigers have striped skin, not just striped fur.",
            "elephant": "Elephants are the largest land animals on Earth.",
            "giraffe": "Giraffes are the tallest mammals on Earth.",
            "penguin": "Penguins are birds that cannot fly but are excellent swimmers.",
            "koala": "Koalas sleep up to 18 hours a day."
        };
        const animal = match[1].toLowerCase();
        const fact = facts[animal] || "I don't have any facts about that animal.";
        return `Here's a fact about ${animal}: ${fact}`;
    }
},{
    pattern: /give me a random animal/i,
    response: () => {
        const animals = ["Lion", "Tiger", "Elephant", "Giraffe", "Zebra", 
            "Panda", "Kangaroo", "Koala", "Penguin", "Cheetah", 
            "Bear", "Wolf", "Gorilla", "Hippo", "Sloth", 
            "Rhino", "Leopard", "Hawk", "Eagle", "Owl", 
            "Shark", "Whale", "Dolphin", "Crocodile", "Alligator", 
            "Octopus", "Starfish", "Turtle", "Snake", "Lizard"];
        const randomAnimal = animals[Math.floor(Math.random() * animals.length)];
        return `Here is a random animal: ${randomAnimal}`;
    }
},{
    pattern: /where does a (.+) live/i,
    response: (match) => {
        const habitats = {
            "lion": "Lions live in grasslands, savannas, and open woodlands.",
            "polar bear": "Polar bears live in the Arctic region.",
            "koala": "Koalas live in eucalyptus forests in Australia.",
            "panda": "Pandas live in the mountain ranges of central China.",
            "shark": "Sharks live in oceans and seas around the world."
        };
        const animal = match[1].toLowerCase();
        const habitat = habitats[animal] || "I don't know where that animal lives.";
        return `A ${animal} lives in: ${habitat}`;
    }
},{
    pattern: /what is the classification of a (.+)/i,
    response: (match) => {
        const classifications = {
            "lion": "Lion is a mammal.",
            "penguin": "Penguin is a bird.",
            "crocodile": "Crocodile is a reptile.",
            "shark": "Shark is a fish.",
            "frog": "Frog is an amphibian."
        };
        const animal = match[1].toLowerCase();
        const classification = classifications[animal] || "I don't know the classification of that animal.";
        return `A ${animal} is: ${classification}`;
    }
},{
    pattern: /how many legs does a (.+) have/i,
    response: (match) => {
        const legsCount = {
            "dog": 4,
            "cat": 4,
            "human": 2,
            "spider": 8,
            "centipede": 100,
            "elephant": 4,
            "bird": 2
        };
        const animal = match[1].toLowerCase();
        const count = legsCount[animal] || "I don't know how many legs that animal has.";
        return `A ${animal} has ${count} legs.`;
    }
},{
    pattern: /how long does a (.+) live/i,
    response: (match) => {
        const lifespans = {
            "dog": "Dogs live around 10-15 years.",
            "cat": "Cats live around 15-20 years.",
            "elephant": "Elephants live around 60-70 years.",
            "turtle": "Turtles can live for more than 100 years.",
            "koala": "Koalas live around 10-12 years."
        };
        const animal = match[1].toLowerCase();
        const lifespan = lifespans[animal] || "I don't know the lifespan of that animal.";
        return `A ${animal} lives for approximately: ${lifespan}`;
    }
},{
    pattern: /what is the fastest animal/i,
    response: () => {
        return "The fastest animal is the cheetah, which can run up to 60-70 mph!";
    }
},{
    pattern: /what is the population of (.+)/i,
    response: (match) => {
        const populations = {
            "tiger": "There are approximately 3,900 tigers left in the wild.",
            "panda": "There are around 1,800 giant pandas left in the wild.",
            "rhino": "There are fewer than 30,000 rhinos remaining worldwide.",
            "elephant": "There are around 415,000 African elephants left in the wild."
        };
        const animal = match[1].toLowerCase();
        const population = populations[animal] || "I don't have the population data for that animal.";
        return `The population of ${animal} is: ${population}`;
    }
},{
    pattern: /write a letter to (.+)/i,
    response: (match) => {
        const recipient = match[1];
        return `Dear ${recipient},\n\nI hope this letter finds you in good health and spirits. I wanted to take a moment to thank you for your continued support and kindness. I appreciate all the efforts you have made, and I look forward to more collaboration in the future.\n\nBest regards,\nYour Friend`;
    }
},{
    pattern: /write a paragraph about (.+)/i,
    response: (match) => {
        const topic = match[1];
        return `Here is a paragraph about ${topic}:\n\n${topic} is an essential part of our daily lives. It provides us with necessary information, entertainment, and sometimes even comfort. Understanding ${topic} can help improve our overall knowledge and assist us in making informed decisions. It's important to constantly learn and stay updated about ${topic}, as it has a significant impact on various aspects of life.`;
    }
},{
    pattern: /generate a sentence/i,
    response: () => {
        const sentences = [
            "The sun is setting, and the sky is painted in beautiful shades of orange.",
            "A gentle breeze swirled through the trees as the birds chirped in harmony.",
            "The city streets were bustling with people, each heading towards their destination.",
            "Under the starry night sky, everything seemed peaceful and quiet."
        ];
        const randomSentence = sentences[Math.floor(Math.random() * sentences.length)];
        return randomSentence;
    }
},{
    pattern: /tell me a story about (.+)/i,
    response: (match) => {
        const theme = match[1];
        return `Once upon a time, in a land far away, there lived a brave soul who ventured through the wilderness of ${theme}. The journey was full of obstacles, but the courage of the traveler never wavered. One day, they encountered a challenge unlike any other. With intelligence, determination, and a kind heart, they overcame the hardship and became a legend in the land of ${theme}. The people of ${theme} still remember the traveler’s bravery and kindness to this day.`;
    }
},{
    pattern: /give me a compliment/i,
    response: () => {
        const compliments = [
            "You have a great sense of humor!",
            "Your kindness knows no bounds.",
            "You are truly an inspiring person!",
            "You have such a positive attitude, it's contagious!"
        ];
        const randomCompliment = compliments[Math.floor(Math.random() * compliments.length)];
        return randomCompliment;
    }
},{
    pattern: /give me a motivational quote/i,
    response: () => {
        const quotes = [
            "The only way to do great work is to love what you do. – Steve Jobs",
            "Success is not final, failure is not fatal: It is the courage to continue that counts. – Winston Churchill",
            "Believe you can and you're halfway there. – Theodore Roosevelt",
            "The best time to plant a tree was 20 years ago. The second best time is now. – Chinese Proverb",
            "It does not matter how slowly you go as long as you do not stop. – Confucius",
            "You are never too old to set another goal or to dream a new dream. – C.S. Lewis",
            "Everything you can imagine is real. – Pablo Picasso",
            "The future belongs to those who believe in the beauty of their dreams. – Eleanor Roosevelt",
            "Don’t watch the clock; do what it does. Keep going. – Sam Levenson",
            "Success is not how high you have climbed, but how you make a positive difference to the world. – Roy T. Bennett",
            "Your time is limited, so don’t waste it living someone else’s life. – Steve Jobs",
            "Opportunities don't happen, you create them. – Chris Grosser",
            "Don’t be pushed around by the fears in your mind. Be led by the dreams in your heart. – Roy T. Bennett",
            "Success usually comes to those who are too busy to be looking for it. – Henry David Thoreau",
            "Act as if what you do makes a difference. It does. – William James"
        ];
        const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
        return randomQuote;
    }
},{
    pattern: /give me a fun fact/i,
    response: () => {
        const funFacts = [
            "Honey never spoils. Archaeologists have found pots of honey in ancient tombs that are over 3,000 years old.",
            "A group of flamingos is called a 'flamboyance'.",
            "Cows have best friends and can become stressed when they are separated.",
            "The Eiffel Tower can be 15 cm taller during the summer due to the expansion of the metal in the heat.",
            "Bananas are berries, but strawberries are not.",
            "Wombat poop is cube-shaped to prevent it from rolling away.",
            "An octopus has three hearts and blue blood.",
            "Sharks have been around longer than trees.",
            "A day on Venus is longer than a year on Venus.",
            "Sloths can hold their breath for up to 40 minutes underwater.",
            "The shortest war in history lasted 38 to 45 minutes between Britain and Zanzibar on August 27, 1896.",
            "The longest hiccuping spree lasted 68 years.",
            "Humans share 60% of their DNA with bananas.",
            "There are more stars in the universe than grains of sand on all the Earth’s beaches.",
            "The world's largest desert is actually Antarctica, not the Sahara."
        ];
        const randomFact = funFacts[Math.floor(Math.random() * funFacts.length)];
        return randomFact;
    }
},{
    pattern: /(?:translate|convert|say|how to say)\s+(.+?)\s+(?:to|in)\s+(tamil|ta)/i,
    response: (match) => {
        const tamilCombined = new Map([
            // Common phrases
            ["good morning", "காலை வணக்கம்"],
            ["good afternoon", "மத்தியான் வணக்கம்"],
            ["good evening", "மாலை வணக்கம்"],
            ["good night", "இரவு வணக்கம்"],
            ["thank you", "நன்றி"],
            ["you're welcome", "வருக"],
            ["excuse me", "மன்னிக்கவும்"],
            ["i'm sorry", "மன்னிக்கவும்"],
            ["how are you", "நீங்கள் எப்படி இருக்கிறீர்கள்"],
            ["i am fine", "நான் நலமாக இருக்கிறேன்"],
            ["what is your name", "உங்கள் பெயர் என்ன"],
            ["my name is", "என் பெயர்"],
            ["where are you from", "நீங்கள் எங்கிருந்து வருகிறீர்கள்"],
            ["i am from", "நான் இருந்து வருகிறேன்"],
            ["nice to meet you", "உங்களை சந்தித்ததில் மகிழ்ச்சி"],
            ["have a nice day", "ஒரு நல்ல நாள் கொண்டாடுங்கள்"],
            ["see you later", "பின்னர் உங்களைப் பார்கிறேன்"],
            ["take care", "கவனித்துக்கொள்ளுங்கள்"],
            
            // Common words
            ["what", "என்ன"], ["this", "இது"], ["is", "ஆகும்"], ["to", "க்கு"], ["tamil", "தமிழ்"],
            ["alagu", "அழகு"], ["arun", "அருண்"], ["kavi", "கவி"], ["hello", "வணக்கம்"], ["good", "நல்ல"],
            ["morning", "காலை"], ["night", "இரவு"], ["food", "உணவு"], ["water", "நீர்"], ["love", "காதல்"],
            ["friend", "நண்பர்"], ["home", "வீடு"], ["school", "பள்ளி"], ["book", "புத்தகம்"], ["pen", "பேனா"],
            ["work", "வேலை"], ["day", "நாள்"], ["time", "நேரம்"], ["year", "வருடம்"], ["month", "மாதம்"],
            ["week", "வாரம்"], ["today", "இன்று"], ["tomorrow", "நாளை"], ["yesterday", "நேற்று"],
            ["yes", "ஆம்"], ["no", "இல்லை"], ["please", "தயவு செய்து"], ["thank you", "நன்றி"],
            ["sorry", "மன்னிக்கவும்"], ["help", "உதவி"], ["name", "பெயர்"], ["age", "வயது"], ["city", "நகரம்"],
            ["country", "நாடு"], ["language", "மொழி"], ["people", "மக்கள்"], ["child", "குழந்தை"],
            ["man", "ஆண்"], ["woman", "பெண்"], ["family", "குடும்பம்"], ["father", "தந்தை"], ["mother", "தாய்"],
            ["brother", "சகோதரன்"], ["sister", "சகோதரி"], ["son", "மகன்"], ["daughter", "மகள்"],
            ["teacher", "ஆசிரியர்"], ["student", "மாணவர்"], ["doctor", "மருத்துவர்"], ["hospital", "மருத்துவமனை"],
            ["money", "பணம்"], ["price", "விலை"], ["shop", "கடை"], ["car", "கார்"], ["bus", "பேருந்து"],
            ["train", "ரயில்"], ["airport", "விமான நிலையம்"], ["hotel", "ஹோட்டல்"], ["room", "அறை"],
            ["phone", "தொலைபேசி"], ["computer", "கணினி"], ["internet", "இணையம்"], ["game", "விளையாட்டு"],
            ["music", "இசை"], ["movie", "திரைப்படம்"], ["song", "பாடல்"], ["dance", "நடனம்"], ["art", "கலை"],
            ["color", "நிறம்"], ["red", "சிவப்பு"], ["blue", "நீலம்"], ["green", "பச்சை"], ["yellow", "மஞ்சள்"],
            ["black", "கருப்பு"], ["white", "வெள்ளை"], ["big", "பெரிய"], ["small", "சிறிய"], ["hot", "சூடான"],
            ["cold", "குளிர்"], ["happy", "மகிழ்ச்சி"], ["sad", "வருத்தம்"], ["angry", "கோபம்"], ["tired", "சோர்வு"],
            ["hungry", "பசி"], ["thirsty", "தாகம்"], ["beautiful", "அழகான"], ["ugly", "அசிங்கமான"],
            ["easy", "எளிதான"], ["difficult", "கடினமான"], ["new", "புதிய"], ["old", "பழைய"], ["young", "இளைய"],
            ["right", "சரியான"], ["wrong", "தவறான"], ["true", "உண்மை"], ["false", "பொய்"], ["open", "திறந்த"],
            ["close", "மூடிய"], ["start", "தொடக்கம்"], ["end", "முடிவு"], ["up", "மேல்"], ["down", "கீழ்"],
            ["left", "இடது"], ["right", "வலது"], ["here", "இங்கே"], ["there", "அங்கே"], ["who", "யார்"],
            ["what", "என்ன"], ["where", "எங்கே"], ["when", "எப்போது"], ["why", "ஏன்"], ["how", "எப்படி"],
            ["which", "எது"], ["whose", "யாருடைய"], ["and", "மற்றும்"], ["or", "அல்லது"], ["but", "ஆனால்"],
            ["because", "ஏனெனில்"], ["if", "என்றால்"], ["then", "பின்னர்"], ["now", "இப்போது"], ["later", "பின்னர்"],
            ["always", "எப்போதும்"], ["never", "ஒருபோதும்"], ["sometimes", "சில நேரங்களில்"], ["often", "பெரும்பாலும்"],
            ["very", "மிகவும்"], ["little", "சிறிது"], ["many", "பல"], ["few", "சில"], ["all", "அனைத்தும்"],
            ["some", "சில"], ["none", "எதுவும் இல்லை"], ["more", "மேலும்"], ["less", "குறைவாக"], ["enough", "போதுமான"],
            ["only", "மட்டும்"], ["also", "மேலும்"], ["even", "கூட"], ["just", "வெறும்"], ["about", "பற்றி"],
            ["after", "பிறகு"], ["before", "முன்"], ["during", "போது"], ["until", "வரை"], ["again", "மீண்டும்"],
            ["once", "ஒருமுறை"], ["twice", "இருமுறை"], ["first", "முதல்"], ["second", "இரண்டாம்"], ["last", "கடைசி"],
            ["next", "அடுத்த"], ["every", "ஒவ்வொரு"], ["each", "ஒவ்வொன்றும்"], ["other", "மற்ற"], ["another", "மற்றொரு"],
            ["same", "அதே"], ["different", "வேறுபட்ட"], ["such", "அத்தகைய"], ["own", "சொந்த"],
            
            // Additional common words
            ["i", "நான்"], ["you", "நீங்கள்"], ["he", "அவன்"], ["she", "அவள்"], ["it", "அது"],
            ["we", "நாம்"], ["they", "அவர்கள்"], ["me", "என்னை"], ["him", "அவனை"], ["her", "அவளை"],
            ["us", "எங்களை"], ["them", "அவர்களை"], ["my", "என்"], ["your", "உங்கள்"], ["his", "அவனுடைய"],
            ["her", "அவளுடைய"], ["its", "அதன்"], ["our", "எங்கள்"], ["their", "அவர்களுடைய"],
            ["mine", "என்னுடையது"], ["yours", "உங்களுடையது"], ["ours", "எங்களுடையது"], ["theirs", "அவர்களுடையது"],
            ["am", "இருக்கிறேன்"], ["is", "இருக்கிறது"], ["are", "இருக்கிறார்கள்"], ["was", "இருந்தது"],
            ["were", "இருந்தனர்"], ["be", "இரு"], ["being", "இருப்பது"], ["been", "இருந்திருக்கிறது"],
            ["have", "கொண்டுள்ளேன்"], ["has", "கொண்டுள்ளது"], ["had", "கொண்டிருந்தது"], ["having", "கொண்டிருப்பது"],
            ["do", "செய்"], ["does", "செய்கிறது"], ["did", "செய்தது"], ["doing", "செய்வது"],
            ["will", "செய்வார்"], ["would", "செய்வார்"], ["shall", "செய்வேன்"], ["should", "செய்ய வேண்டும்"],
            ["can", "முடியும்"], ["could", "முடியும்"], ["may", "இருக்கலாம்"], ["might", "இருக்கலாம்"],
            ["must", "வேண்டும்"], ["ought", "வேண்டும்"], ["need", "தேவை"], ["dare", "துணிகிறேன்"],
            ["a", "ஒரு"], ["an", "ஒரு"], ["the", "அந்த"], ["some", "சில"], ["any", "எந்த"],
            ["this", "இந்த"], ["that", "அந்த"], ["these", "இந்த"], ["those", "அந்த"],
            ["such", "அத்தகைய"], ["what", "என்ன"], ["which", "எது"], ["who", "யார்"],
            ["whom", "யாரை"], ["whose", "யாருடைய"], ["where", "எங்கே"], ["when", "எப்போது"],
            ["why", "ஏன்"], ["how", "எப்படி"], ["whether", "என்று"], ["if", "என்றால்"],
            ["that", "அது"], ["because", "ஏனெனில்"], ["when", "எப்போது"], ["while", "அதே சமயம்"],
            ["where", "எங்கே"], ["whereas", "ஆனால்"], ["if", "என்றால்"], ["unless", "தவிர"],
            ["until", "வரை"], ["till", "வரை"], ["than", "விட"], ["as", "போல"],
            ["whether", "என்று"], ["either", "இரண்டில் ஒன்று"], ["neither", "இரண்டும் இல்லை"],
            ["both", "இரண்டும்"], ["not", "இல்லை"], ["only", "மட்டும்"], ["but", "ஆனால்"],
            ["however", "இருப்பினும்"], ["moreover", "மேலும்"], ["besides", "அதைத் தவிர"],
            ["though", "என்றாலும்"], ["although", "என்றாலும்"], ["yet", "இருப்பினும்"],
            ["still", "இன்னும்"], ["nevertheless", "இருப்பினும்"], ["nonetheless", "இருப்பினும்"],
            ["instead", "அதற்கு பதிலாக"], ["otherwise", "இல்லையேல்"], ["likewise", "அதுபோல"],
            ["similarly", "இதேபோல"], ["therefore", "எனவே"], ["hence", "எனவே"],
            ["thus", "எனவே"], ["consequently", "இதன் விளைவாக"], ["accordingly", "அதன்படி"],
            ["meanwhile", "அதே சமயம்"], ["furthermore", "மேலும்"], ["moreover", "மேலும்"],
            ["besides", "அதைத் தவிர"], ["additionally", "கூடுதலாக"], ["again", "மீண்டும்"],
            ["further", "மேலும்"], ["then", "பின்னர்"], ["now", "இப்போது"], ["soon", "விரைவில்"],
            ["later", "பின்னர்"], ["earlier", "முன்பு"], ["formerly", "முன்பு"], ["previously", "முன்பு"],
            ["finally", "இறுதியாக"], ["lastly", "இறுதியாக"], ["firstly", "முதலில்"], ["secondly", "இரண்டாவதாக"],
            ["next", "அடுத்து"], ["afterwards", "பின்னர்"], ["before", "முன்"], ["after", "பிறகு"],
            ["since", "முதல்"], ["until", "வரை"], ["till", "வரை"], ["while", "அதே சமயம்"],
            ["during", "போது"], ["before", "முன்"], ["after", "பிறகு"], ["as", "போல"],
            ["because", "ஏனெனில்"], ["since", "முதல்"], ["so", "ஆகையால்"], ["then", "பின்னர்"],
            ["therefore", "எனவே"], ["thus", "எனவே"], ["hence", "எனவே"], ["consequently", "இதன் விளைவாக"],
            ["accordingly", "அதன்படி"], ["otherwise", "இல்லையேல்"], ["nevertheless", "இருப்பினும்"],
            ["nonetheless", "இருப்பினும்"], ["however", "இருப்பினும்"], ["moreover", "மேலும்"],
            ["besides", "அதைத் தவிர"], ["additionally", "கூடுதலாக"], ["furthermore", "மேலும்"],
            ["likewise", "அதுபோல"], ["similarly", "இதேபோல"], ["instead", "அதற்கு பதிலாக"],
            ["again", "மீண்டும்"], ["further", "மேலும்"], ["then", "பின்னர்"], ["now", "இப்போது"],
            ["soon", "விரைவில்"], ["later", "பின்னர்"], ["earlier", "முன்பு"], ["formerly", "முன்பு"],
            ["previously", "முன்பு"], ["finally", "இறுதியாக"], ["lastly", "இறுதியாக"], ["firstly", "முதலில்"],
            ["secondly", "இரண்டாவதாக"], ["next", "அடுத்து"], ["afterwards", "பின்னர்"], ["before", "முன்"],
            ["after", "பிறகு"], ["since", "முதல்"], ["until", "வரை"], ["till", "வரை"], ["while", "அதே சமயம்"],
            ["during", "போது"], ["before", "முன்"], ["after", "பிறகு"], ["as", "போல"],
            ["because", "ஏனெனில்"], ["since", "முதல்"], ["so", "ஆகையால்"], ["then", "பின்னர்"]
        ]);
        
        const phrase = match[1].trim().toLowerCase();
        const language = match[2].trim().toLowerCase();
        
        // Check if the language is Tamil
        if (language !== "tamil" && language !== "ta") {
            return "Sorry, I only support translation to Tamil at the moment.";
        }
        
        // First, try to match the entire phrase
        if (tamilCombined.has(phrase)) {
            return tamilCombined.get(phrase);
        }
        
        // Split the phrase into words
        const words = phrase.split(/\s+/);
        let translatedText = "";
        
        // Try to translate word by word
        for (const word of words) {
            // Remove punctuation from the word
            const cleanWord = word.replace(/[.,!?;:()]/g, '');
            const punctuation = word.replace(cleanWord, '');
            
            if (tamilCombined.has(cleanWord)) {
                translatedText += tamilCombined.get(cleanWord) + punctuation + " ";
            } else {
                // Try to find the word with different case
                const capitalizedWord = cleanWord.charAt(0).toUpperCase() + cleanWord.slice(1);
                if (tamilCombined.has(capitalizedWord)) {
                    translatedText += tamilCombined.get(capitalizedWord) + punctuation + " ";
                } else {
                    // Fallback: Translate character by character
                    let translatedWord = "";
                    for (let i = 0; i < cleanWord.length; i++) {
                        const char = cleanWord[i].toLowerCase();
                        translatedWord += tamilCombined.get(char) || char;
                    }
                    translatedText += translatedWord + punctuation + " ";
                }
            }
        }
        
        return translatedText.trim();
    }
},
{ pattern: /reverse (.+)/i, response: (match) => match[1].split('').reverse().join('') },{ pattern: /count words (.+)/i, response: (match) => `Number of words: ${match[1].split(/\s+/).length}` },{ pattern: /uppercase (.+)/i, response: (match) => match[1].toUpperCase() },{ pattern: /lowercase (.+)/i, response: (match) => match[1].toLowerCase() },{ pattern: /reverse words (.+)/i, response: (match) => match[1].split(' ').map(word => word.split('').reverse().join('')).join(' ') },{ pattern: /count vowels (.+)/i, response: (match) => `Number of vowels: ${match[1].replace(/[^aeiouAEIOU]/g, "").length}` },{ pattern: /replace (.+) with (.+)/i, response: (match) => match[1].replace(new RegExp(match[1], 'gi'), match[2]) },

{ 
    pattern: /solve quadratic equation ([\d.-]+)x\^2 \+ ([\d.-]+)x \+ ([\d.-]+)/i, 
    response: (match) => {
        const a = parseFloat(match[1]);
        const b = parseFloat(match[2]);
        const c = parseFloat(match[3]);
        const discriminant = b * b - 4 * a * c;

        if (discriminant > 0) {
            const root1 = (-b + Math.sqrt(discriminant)) / (2 * a);
            const root2 = (-b - Math.sqrt(discriminant)) / (2 * a);
            return `The roots are ${root1.toFixed(2)} and ${root2.toFixed(2)}`;
        } else if (discriminant === 0) {
            const root = -b / (2 * a);
            return `The root is ${root.toFixed(2)}`;
        } else {
            return "The equation has no real roots.";
        }
    }
},{ 
    pattern: /repeat (.+) (\d+) times/i, 
    response: (match) => {
        const message = match[1];  
        const times = parseInt(match[2]);  

        if (times <= 0) return "Please enter a valid repeat count.";

        return Array(times).fill(message).join("\n");
    }
},{ 
    pattern: /split (.+)/i, 
    response: (match) => {
        const message = match[1];  
        return `Split Message: ` + message.split("").join(" ");
    }
},{ 
    pattern: /style (.+)/i, 
    response: (match) => {
        const text = match[1].toUpperCase(); // Convert input to uppercase for styling

        const fancyFonts = {
            'A': '𝐀', 'B': '𝐁', 'C': '𝐂', 'D': '𝐃', 'E': '𝐄', 'F': '𝐅', 'G': '𝐆', 
            'H': '𝐇', 'I': '𝐈', 'J': '𝐉', 'K': '𝐊', 'L': '𝐋', 'M': '𝐌', 'N': '𝐍', 
            'O': '𝐎', 'P': '𝐏', 'Q': '𝐐', 'R': '𝐑', 'S': '𝐒', 'T': '𝐓', 'U': '𝐔', 
            'V': '𝐕', 'W': '𝐖', 'X': '𝐗', 'Y': '𝐘', 'Z': '𝐙'
        };

        let styledText = text.split('').map(char => fancyFonts[char] || char).join('');
        
        return `Styled Text: ${styledText}`;
    }
},{
    pattern: /style2 (.+)/i, 
    response: (match) => {
        const text = match[1].toUpperCase(); // Convert input to uppercase
        // Different font styles
        const fontStyles = {
            bold: { 'A': '𝐀', 'B': '𝐁', 'C': '𝐂', 'D': '𝐃', 'E': '𝐄', 'F': '𝐅', 'G': '𝐆', 
                    'H': '𝐇', 'I': '𝐈', 'J': '𝐉', 'K': '𝐊', 'L': '𝐋', 'M': '𝐌', 'N': '𝐍', 
                    'O': '𝐎', 'P': '𝐏', 'Q': '𝐐', 'R': '𝐑', 'S': '𝐒', 'T': '𝐓', 'U': '𝐔', 
                    'V': '𝐕', 'W': '𝐖', 'X': '𝐗', 'Y': '𝐘', 'Z': '𝐙' },
            italic: { 'A': '𝘈', 'B': '𝘉', 'C': '𝘊', 'D': '𝘋', 'E': '𝘌', 'F': '𝘍', 'G': '𝘎',
                      'H': '𝘏', 'I': '𝘐', 'J': '𝘑', 'K': '𝘒', 'L': '𝘓', 'M': '𝘔', 'N': '𝘕',
                      'O': '𝘖', 'P': '𝘗', 'Q': '𝘘', 'R': '𝘙', 'S': '𝘚', 'T': '𝘛', 'U': '𝘜',
                      'V': '𝘝', 'W': '𝘞', 'X': '𝘟', 'Y': '𝘠', 'Z': '𝘡' },
            script: { 'A': '𝒜', 'B': 'ℬ', 'C': '𝒞', 'D': '𝒟', 'E': 'ℰ', 'F': 'ℱ', 'G': '𝒢',
                      'H': 'ℋ', 'I': 'ℐ', 'J': '𝒥', 'K': '𝒦', 'L': 'ℒ', 'M': 'ℳ', 'N': '𝒩',
                      'O': '𝒪', 'P': '𝒫', 'Q': '𝒬', 'R': 'ℛ', 'S': '𝒮', 'T': '𝒯', 'U': '𝒰',
                      'V': '𝒱', 'W': '𝒲', 'X': '𝒳', 'Y': '𝒴', 'Z': '𝒵' },
            monospace: { 'A': '𝙰', 'B': '𝙱', 'C': '𝙲', 'D': '𝙳', 'E': '𝙴', 'F': '𝙵', 'G': '𝙶',
                         'H': '𝙷', 'I': '𝙸', 'J': '𝙹', 'K': '𝙺', 'L': '𝙻', 'M': '𝙼', 'N': '𝙽',
                         'O': '𝙾', 'P': '𝙿', 'Q': '𝚀', 'R': '𝚁', 'S': '𝚂', 'T': '𝚃', 'U': '𝚄',
                         'V': '𝚅', 'W': '𝚆', 'X': '𝚇', 'Y': '𝚈', 'Z': '𝚉' },
            sansserif: { 'A': '𝖠', 'B': '𝖡', 'C': '𝖢', 'D': '𝖣', 'E': '𝖤', 'F': '𝖥', 'G': '𝖦',
                         'H': '𝖧', 'I': '𝖨', 'J': '𝖩', 'K': '𝖪', 'L': '𝖫', 'M': '𝖬', 'N': '𝖭',
                         'O': '𝖮', 'P': '𝖯', 'Q': '𝖰', 'R': '𝖱', 'S': '𝖲', 'T': '𝖳', 'U': '𝖴',
                         'V': '𝖵', 'W': '𝖶', 'X': '𝖷', 'Y': '𝖸', 'Z': '𝖹' },
            serif: { 'A': '𝐴', 'B': '𝐵', 'C': '𝐶', 'D': '𝐷', 'E': '𝐸', 'F': '𝐹', 'G': '𝐺',
                    'H': '𝐻', 'I': '𝐼', 'J': '𝐽', 'K': '𝐾', 'L': '𝐿', 'M': '𝑀', 'N': '𝑁',
                    'O': '𝑂', 'P': '𝑃', 'Q': '𝑄', 'R': '𝑅', 'S': '𝑆', 'T': '𝑇', 'U': '𝑈',
                    'V': '𝑉', 'W': '𝑊', 'X': '𝑋', 'Y': '𝑌', 'Z': '𝑍' },
            doublestruck: { 'A': '𝔸', 'B': '𝔹', 'C': 'ℂ', 'D': '𝔻', 'E': '𝔼', 'F': '𝔽', 'G': '𝔾',
                             'H': 'ℍ', 'I': '𝕀', 'J': '𝕁', 'K': '𝕂', 'L': '𝕃', 'M': '𝕄', 'N': 'ℕ',
                             'O': '𝕆', 'P': 'ℙ', 'Q': 'ℚ', 'R': 'ℝ', 'S': '𝕊', 'T': '𝕋', 'U': '𝕌',
                             'V': '𝕍', 'W': '𝕎', 'X': '𝕏', 'Y': '𝕐', 'Z': 'ℤ' },
            fraktur: { 'A': '𝔄', 'B': '𝔅', 'C': 'ℭ', 'D': '𝔇', 'E': '𝔈', 'F': '𝔉', 'G': '𝔊',
                       'H': 'ℌ', 'I': 'ℑ', 'J': '𝔍', 'K': '𝔎', 'L': '𝔏', 'M': '𝔐', 'N': '𝔑',
                       'O': '𝔒', 'P': '𝔓', 'Q': '𝔔', 'R': 'ℜ', 'S': '𝔖', 'T': '𝔗', 'U': '𝔘',
                       'V': '𝔙', 'W': '𝔚', 'X': '𝔛', 'Y': '𝔜', 'Z': 'ℨ' },
            blackboard: { 'A': '𝔸', 'B': '𝔹', 'C': 'ℂ', 'D': '𝔻', 'E': '𝔼', 'F': '𝔽', 'G': '𝔾',
                          'H': 'ℍ', 'I': '𝕀', 'J': '𝕁', 'K': '𝕂', 'L': '𝕃', 'M': '𝕄', 'N': 'ℕ',
                          'O': '𝕆', 'P': 'ℙ', 'Q': 'ℚ', 'R': 'ℝ', 'S': '𝕊', 'T': '𝕋', 'U': '𝕌',
                          'V': '𝕍', 'W': '𝕎', 'X': '𝕏', 'Y': '𝕐', 'Z': 'ℤ' },
            circled: { 'A': 'Ⓐ', 'B': 'Ⓑ', 'C': 'Ⓒ', 'D': 'Ⓓ', 'E': 'Ⓔ', 'F': 'Ⓕ', 'G': 'Ⓖ',
                       'H': 'Ⓗ', 'I': 'Ⓘ', 'J': 'Ⓚ', 'K': 'Ⓚ', 'L': 'Ⓛ', 'M': 'Ⓜ', 'N': 'Ⓝ',
                       'O': 'Ⓞ', 'P': 'Ⓟ', 'Q': 'Ⓠ', 'R': 'Ⓡ', 'S': 'Ⓢ', 'T': 'Ⓣ', 'U': 'Ⓤ',
                       'V': 'Ⓥ', 'W': 'Ⓦ', 'X': 'Ⓧ', 'Y': 'Ⓨ', 'Z': 'Ⓩ' },
            negativecircled: { 'A': '🅐', 'B': '🅑', 'C': '🅒', 'D': '🅓', 'E': '🅔', 'F': '🅕', 'G': '🅖',
                                'H': '🅗', 'I': '🅘', 'J': '🅙', 'K': '🅚', 'L': '🅛', 'M': '🅜', 'N': '🅝',
                                'O': '🅞', 'P': '🅟', 'Q': '🅠', 'R': '🅡', 'S': '🅢', 'T': '🅣', 'U': '🅤',
                                'V': '🅥', 'W': '🅦', 'X': '🅧', 'Y': '🅨', 'Z': '🅩' },
            squared: { 'A': '🄰', 'B': '🄱', 'C': '🄲', 'D': '🄳', 'E': '🄴', 'F': '🄵', 'G': '🄶',
                       'H': '🄷', 'I': '🄸', 'J': '🄹', 'K': '🄺', 'L': '🄻', 'M': '🄼', 'N': '🄽',
                       'O': '🄾', 'P': '🄿', 'Q': '🅀', 'R': '🅁', 'S': '🅂', 'T': '🅃', 'U': '🅄',
                       'V': '🅅', 'W': '🅆', 'X': '🅇', 'Y': '🅈', 'Z': '🅉' },
            negativesquared: { 'A': '🅰', 'B': '🅱', 'C': '🅲', 'D': '🅳', 'E': '🅴', 'F': '🅵', 'G': '🅶',
                                'H': '🅷', 'I': '🅸', 'J': '🅹', 'K': '🅺', 'L': '🅻', 'M': '🅼', 'N': '🅽',
                                'O': '🅾', 'P': '🅿', 'Q': '🆀', 'R': '🆁', 'S': '🆂', 'T': '🆃', 'U': '🆄',
                                'V': '🆅', 'W': '🆆', 'X': '🆇', 'Y': '🆈', 'Z': '🆉' }
        };
        // Convert text to each font style
        const convertToStyle = (style) => 
            text.split('').map(char => fontStyles[style][char] || char).join('');
        
        // Display all font styles
        return `Styled Texts:\n` +
               `🔹 **Bold:** ${convertToStyle('bold')}\n` +
               `🔹 *Italic:* ${convertToStyle('italic')}\n` +
               `🔹 ✨ Script: ${convertToStyle('script')}\n` +
               `🔹 ⌨️ Monospace: ${convertToStyle('monospace')}\n` +
               `🔹 𝖠 Sans-serif: ${convertToStyle('sansserif')}\n` +
               `🔹 𝐴 Serif: ${convertToStyle('serif')}\n` +
               `🔹 𝔸 Double-struck: ${convertToStyle('doublestruck')}\n` +
               `🔹 𝔄 Fraktur: ${convertToStyle('fraktur')}\n` +
               `🔹 𝔸 Blackboard: ${convertToStyle('blackboard')}\n` +
               `🔹 Ⓐ Circled: ${convertToStyle('circled')}\n` +
               `🔹 🅐 Negative Circled: ${convertToStyle('negativecircled')}\n` +
               `🔹 🄰 Squared: ${convertToStyle('squared')}\n` +
               `🔹 🅰 Negative Squared: ${convertToStyle('negativesquared')}`;
    }
},
{
    pattern: /help me fix this code:\s*```([\s\S]*?)```/i,
    response: (match) => {
        const code = match[1];
        
        // Common syntax errors and their fixes
        const commonErrors = [
            {
                pattern: /for\s*\(\s*let\s+\w+\s*=\s*0\s*;\s*\w+\s*<\s*\w+\s*length\s*;\s*\w+\+\+\s*\)/g,
                fix: "for (let i = 0; i < array.length; i++)",
                description: "Standard for loop syntax for iterating through an array"
            },
            {
                pattern: /console\.log\s*\(\s*['"](.+)['"]\s*\+\s*(.+)\s*\)/g,
                fix: "console.log(`$1${$2}`)",
                description: "Use template literals instead of string concatenation"
            },
            {
                pattern: /document\.getElementById\s*\(\s*['"](.+)['"]\s*\)\.value/g,
                fix: "document.getElementById('$1').value",
                description: "Correct syntax for getting an element's value"
            },
            {
                pattern: /if\s*\(\s*(.+)\s*=\s*(.+)\s*\)/g,
                fix: "if ($1 === $2)",
                description: "Use strict equality (===) instead of assignment (=) in conditions"
            },
            {
                pattern: /function\s*\(\s*\)\s*\{/g,
                fix: "function() {",
                description: "Correct function declaration syntax"
            }
        ];
        
        let issuesFound = [];
        let fixedCode = code;
        
        // Check for common errors
        for (const error of commonErrors) {
            if (error.pattern.test(code)) {
                issuesFound.push(error.description);
                fixedCode = fixedCode.replace(error.pattern, error.fix);
            }
        }
        
        // Check for unmatched brackets, braces, or parentheses
        const brackets = {
            '(': 0,
            '[': 0,
            '{': 0
        };
        
        const closingBrackets = {
            ')': '(',
            ']': '[',
            '}': '{'
        };
        
        for (let i = 0; i < code.length; i++) {
            const char = code[i];
            
            if (brackets.hasOwnProperty(char)) {
                brackets[char]++;
            } else if (closingBrackets.hasOwnProperty(char)) {
                brackets[closingBrackets[char]]--;
            }
        }
        
        for (const [bracket, count] of Object.entries(brackets)) {
            if (count !== 0) {
                const closingBracket = Object.keys(closingBrackets).find(key => closingBrackets[key] === bracket);
                issuesFound.push(`Unmatched ${bracket}${count > 0 ? ' - missing ' + count + ' ' + closingBracket : ' - too many ' + closingBracket}`);
            }
        }
        
        // Check for missing semicolons
        const linesWithoutSemicolons = code.split('\n').filter((line, index) => {
            const trimmed = line.trim();
            return trimmed.length > 0 && 
                   !trimmed.endsWith(';') && 
                   !trimmed.endsWith('{') && 
                   !trimmed.endsWith('}') && 
                   !trimmed.startsWith('//') && 
                   !trimmed.startsWith('if') && 
                   !trimmed.startsWith('for') && 
                   !trimmed.startsWith('while') && 
                   !trimmed.includes('function');
        });
        
        if (linesWithoutSemicolons.length > 0) {
            issuesFound.push("Possible missing semicolons");
        }
        
        // Generate response
        let response = "I've analyzed your code and found the following issues:\n\n";
        
        if (issuesFound.length === 0) {
            response += "No obvious syntax errors detected. However, there might be logical errors that would require running the code to identify.\n";
        } else {
            response += issuesFound.map((issue, index) => `${index + 1}. ${issue}`).join('\n');
            response += "\n\nHere's your code with suggested fixes:\n\n```javascript\n" + fixedCode + "\n```";
        }
        
        response += "\n\nIf you're still having issues, please provide more context about what the code is supposed to do and any error messages you're receiving.";
        
        return response;
    }
},

{
    pattern: /abc (.+)/i,
    response: (match) => {
        const text = match[1].toLowerCase();
        const abc = {
            "a": "b",
            "c": "d",
            "e": "f",
            "g": "h",
            "i": "j",
            "k": "l",
            "m": "n",
            "o": "p",
            "q": "r",
            "s": "t",
            "y": "v",
            "w": "x",
            "y": "z",
            
            "b": "a",
            "d": "c",
            "f": "e",
            "h": "g",
            "j": "i",
            "l": "k",
            "n": "m",
            "p": "o",
            "r": "q",
            "t": "s",
            "v": "y",
            "x": "w",
            "z": "y"
        };
        const abcd = abc[text];
        return `${abcd}`;
    }
},
{
    pattern: /stats (.+)/i,
    response: (match) => {
        const player = match[1];
        return `Fetching stats for ${player}...`;
    }
},
{
    pattern: /item (.+)/i,
    response: (match) => {
        const item = match[1].toLowerCase();
        const items = {
            "sword": "⚔️ A sharp blade for close combat.",
            "shield": "🛡️ Blocks enemy attacks.",
            "potion": "🧪 Restores 50 HP.",
            "bow": "🏹 Long-range weapon with arrows."
        };
        return items[item] || "❌ Item not found!";
    }
},
{
    pattern: /cheat (.+)/i,
    response: (match) => {
        const cheat = match[1].toLowerCase();
        const cheats = {
            "godmode": "🛡️ God Mode activated! You are now invincible.",
            "noclip": "🚀 No-Clip enabled! You can walk through walls.",
            "speed": "⚡ Speed Boost activated! Run 2x faster.",
            "ammo": "🔫 Unlimited Ammo granted!"
        };
        return cheats[cheat] || "❌ Invalid cheat code!";
    }
},
{
    pattern: /enemy near/i,
    response: () => {
        return "🔍 Scanning... Enemy detected at 50m!";
    }
},
{
    pattern: /switch to (.+)/i,
    response: (match) => {
        const weapon = match[1].toLowerCase();
        return `🔄 Switched to ${weapon}! Ready for battle.`;
    }
},
{
    pattern: /leaderboard/i,
    response: () => {
        return "🏆 Top Players:\n1. ShadowKiller - 5000 points\n2. NoobSlayer - 4800 points\n3. ProGamerX - 4500 points";
    }
},
{
    pattern: /health/i,
    response: () => {
        return "❤️ Your health is at 80/100 HP.";
    }
},
{
    pattern: /server status/i,
    response: () => {
        return "🟢 Game server is ONLINE! No issues detected.";
    }
},
{
    pattern: /start snake game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start snakegame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startsnake game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startsnakegame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},



{
    pattern: /start Bong game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start Bonggame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startBong game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startBonggame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},



{
    pattern: /start Car game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start Cargame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startCar game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startCargame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},



{
    pattern: /start Jump game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start Jumpgame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startJump game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startJumpgame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},

{
    pattern: /give abcd letter (\d+)/i,
    response: (match) => {
        const alphabet = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z".split(",");
        let count = parseInt(match[1]);

        if (count > 26) count = 26; // Limit to max 26 letters
        if (count < 1) return "❌ Please enter a number between 1 and 26.";

        return alphabet.slice(0, count).join(", ");
    }
},
{
    pattern: /what is the meaning of (.+)/i,
    response: (match) => {
        const term = match[1];
        // Fetch or generate the definition for 'term'
        return `The meaning of ${term} is...`;
    }
},
{
    pattern: /how do I (.+)/i,
    response: (match) => {
        const task = match[1];
        // Provide steps or guidance on 'task'
        return `To ${task}, you can follow these steps...`;
    }
},
{
    pattern: /what are the symptoms of (.+)/i,
    response: (match) => {
        const condition = match[1];
        // Provide information about symptoms of 'condition'
        return `The symptoms of ${condition} include...`;
    }
},
{
    pattern: /translate (.+) into (.+)/i,
    response: (match) => {
        const phrase = match[1].toLowerCase().trim();
        const language = match[2].toLowerCase().trim();
        
        // Expanded translation database
        const translations = {
            "good morning": { 
                "spanish": "buenos días", 
                "french": "bonjour", 
                "german": "guten Morgen",
                "italian": "buongiorno",
                "portuguese": "bom dia",
                "japanese": "おはようございます (ohayō gozaimasu)",
                "chinese": "早上好 (zǎo shàng hǎo)",
                "russian": "доброе утро (dobroye utro)"
            },
            "hello": { 
                "spanish": "hola", 
                "french": "bonjour", 
                "german": "hallo",
                "italian": "ciao",
                "portuguese": "olá",
                "japanese": "こんにちは (konnichiwa)",
                "chinese": "你好 (nǐ hǎo)",
                "russian": "привет (privet)"
            },
            "thank you": { 
                "spanish": "gracias", 
                "french": "merci", 
                "german": "danke",
                "italian": "grazie",
                "portuguese": "obrigado",
                "japanese": "ありがとう (arigatō)",
                "chinese": "谢谢 (xiè xiè)",
                "russian": "спасибо (spasibo)"
            },
            "goodbye": { 
                "spanish": "adiós", 
                "french": "au revoir", 
                "german": "auf Wiedersehen",
                "italian": "arrivederci",
                "portuguese": "tchau",
                "japanese": "さようなら (sayōnara)",
                "chinese": "再见 (zài jiàn)",
                "russian": "до свидания (do svidaniya)"
            },
            "please": { 
                "spanish": "por favor", 
                "french": "s'il vous plaît", 
                "german": "bitte",
                "italian": "per favore",
                "portuguese": "por favor",
                "japanese": "お願いします (onegaishimasu)",
                "chinese": "请 (qǐng)",
                "russian": "пожалуйста (pozhaluysta)"
            }
        };
        
        // Language name normalization
        const languageAliases = {
            "spanish": ["spanish", "español", "es"],
            "french": ["french", "français", "fr"],
            "german": ["german", "deutsch", "de"],
            "italian": ["italian", "italiano", "it"],
            "portuguese": ["portuguese", "português", "pt"],
            "japanese": ["japanese", "日本語", "ja"],
            "chinese": ["chinese", "中文", "zh"],
            "russian": ["russian", "русский", "ru"]
        };
        
        // Find the canonical language name
        let canonicalLanguage = null;
        for (const [lang, aliases] of Object.entries(languageAliases)) {
            if (aliases.includes(language)) {
                canonicalLanguage = lang;
                break;
            }
        }
        
        // Check if we have the translation
        if (translations[phrase] && canonicalLanguage && translations[phrase][canonicalLanguage]) {
            const translation = translations[phrase][canonicalLanguage];
            
            // Provide additional context for some languages
            let context = "";
            if (["japanese", "chinese", "russian"].includes(canonicalLanguage)) {
                context = ` (Note: This includes romanization for pronunciation)`;
            }
            
            return `The translation of '${phrase}' into ${canonicalLanguage} is '${translation}'.${context}`;
        } else if (!canonicalLanguage) {
            // Language not supported
            const supportedLanguages = Object.keys(languageAliases).join(", ");
            return `Sorry, I don't support translations into '${language}'. Supported languages are: ${supportedLanguages}.`;
        } else if (!translations[phrase]) {
            // Phrase not found, try to find similar phrases
            const similarPhrases = Object.keys(translations).filter(key => 
                key.includes(phrase) || phrase.includes(key)
            );
            
            if (similarPhrases.length > 0) {
                return `I don't have a translation for '${phrase}'. Did you mean one of these: ${similarPhrases.join(", ")}?`;
            } else {
                return `Sorry, I don't have a translation for '${phrase}' in ${canonicalLanguage}.`;
            }
        } else {
            return `Sorry, I don't have a translation for '${phrase}' in ${canonicalLanguage}.`;
        }
    }
},
{
    pattern: /tell me a joke/i,
    response: () => {
        // Provide a random joke
        return "Why don't scientists trust atoms? Because they make up everything!";
    }
},
{
    pattern: /tell me about the (.+)/i,
    response: (match) => {
        const topic = match[1];
        // Provide information about 'topic'
        return `Here's some information about the ${topic}...`;
    }
},
{
    pattern: /how do I (.+) in (.+)/i,
    response: (match) => {
        const task = match[1];
        const language = match[2];
        // Provide coding assistance for 'task' in 'language'
        return `To ${task} in ${language}, you can...`;
    }
},

{
    pattern: /can you give me advice on (.+)/i,
    response: (match) => {
        const topic = match[1];
        // Provide advice on 'topic'
        return `Here is some advice on ${topic}...`;
    }
},

    { pattern: /what is ([\d.]+) \+ ([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+) - ([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+) \* ([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /what is ([\d.]+) \/ ([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    { pattern: /what is ([\d.]+)% of ([\d.]+)/i, response: (match) => `${match[1]}% of ${match[2]} = ${(parseFloat(match[1]) / 100 * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /square root of ([\d.]+)/i, response: (match) => `√${match[1]} = ${Math.sqrt(parseFloat(match[1])).toFixed(2)}` },
    { pattern: /power of ([\d.]+) to ([\d.]+)/i, response: (match) => `${match[1]}^${match[2]} = ${Math.pow(parseFloat(match[1]), parseFloat(match[2])).toFixed(2)}` },
    { pattern: /log of ([\d.]+)/i, response: (match) => `log(${match[1]}) = ${Math.log10(parseFloat(match[1])).toFixed(2)}` },
    { pattern: /sin\(([\d.]+)\)/i, response: (match) => `sin(${match[1]}) = ${Math.sin((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
    { pattern: /cos\(([\d.]+)\)/i, response: (match) => `cos(${match[1]}) = ${Math.cos((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
    { pattern: /tan\(([\d.]+)\)/i, response: (match) => `tan(${match[1]}) = ${Math.tan((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
      { pattern: /what is ([\d.]+)\+([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+)-([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+)\*([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /what is ([\d.]+)\/([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
      { pattern: /([\d.]+)\+([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /([\d.]+)-([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /([\d.]+)\*([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /([\d.]+)\/([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
      { pattern: /([\d.]+) \+ ([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /([\d.]+) - ([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /([\d.]+) \* ([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /([\d.]+) \/ ([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
{
    pattern: /unlock image to text/i,
    response: "Unlocking Image to Text feature... Please upload your image."
}, 

// Sentiment Analysis Pattern
{
    pattern: /(.+)/i,
    response: (match) => {
        const message = match[1].toLowerCase();
        
        // Sentiment word database
        const sentimentData = {
            happy: {
                keywords: ["happy", "joy", "excited", "glad", "cheerful", "delighted", "pleased", "content", "jubilant", "elated"],
                responses: [
                    "I'm glad you're feeling happy! 😊",
                    "Your happiness is contagious! What's making you feel this way?",
                    "Wonderful to hear you're in good spirits! How can I help you today?",
                    "It's great that you're feeling positive! Anything special happening?",
                    "Your joyful energy is amazing! What can I assist you with?"
                ]
            },
            sad: {
                keywords: ["sad", "unhappy", "depressed", "down", "miserable", "gloomy", "heartbroken", "melancholy", "blue", "dejected"],
                responses: [
                    "I'm sorry you're feeling sad. Is there anything I can do to help? 🙁",
                    "I understand things might be tough right now. Would you like to talk about it?",
                    "I'm here for you. Sometimes sharing what's bothering you can help.",
                    "It's okay to feel sad sometimes. Would you like a distraction or some encouragement?",
                    "I'm sorry you're feeling this way. Remember that tough times don't last forever."
                ]
            },
            angry: {
                keywords: ["angry", "mad", "furious", "irritated", "annoyed", "frustrated", "rage", "livid", "irate", "outraged"],
                responses: [
                    "I sense you're feeling angry. Take a deep breath. Would you like to talk about what's bothering you? 😠",
                    "It sounds like something has upset you. Would you like to share what happened?",
                    "Anger is a natural emotion. Would you like help finding ways to manage it?",
                    "I'm here to listen. What's causing these feelings of anger?",
                    "It's okay to feel angry. Would you like some suggestions to help you calm down?"
                ]
            },
            anxious: {
                keywords: ["anxious", "worried", "nervous", "stressed", "tense", "uneasy", "apprehensive", "concerned", "troubled", "panicked"],
                responses: [
                    "I can sense you're feeling anxious. Take a deep breath. Would you like to talk about what's worrying you? 🧘",
                    "It sounds like you might be feeling stressed. Remember to take things one step at a time.",
                    "Anxiety can be challenging. Would you like some relaxation techniques or a distraction?",
                    "I'm here to help. Would you like to break down what's making you feel this way?",
                    "Try to focus on the present moment. Would you like some guidance on managing these feelings?"
                ]
            },
            confused: {
                keywords: ["confused", "unclear", "don't understand", "puzzled", "lost", "unsure", "baffled", "perplexed", "bewildered"],
                responses: [
                    "I sense some confusion. Let me try to explain things more clearly. 🤔",
                    "Don't worry, confusion is normal when learning new things. What specifically is unclear?",
                    "I'm here to help clarify things. What part would you like me to explain better?",
                    "It's okay to feel confused sometimes. Let's figure this out together.",
                    "Let me try to approach this differently to help you understand better."
                ]
            },
            tired: {
                keywords: ["tired", "exhausted", "fatigued", "sleepy", "drained", "worn out", "weary", "drowsy", "lethargic"],
                responses: [
                    "I can sense you might be feeling tired. Remember to take care of yourself and get some rest. 😴",
                    "It sounds like you could use some relaxation. Have you been getting enough sleep?",
                    "Fatigue can make everything harder. Is there anything I can help you with to make things easier?",
                    "Rest is important. Would you like some tips for better sleep or more energy?",
                    "I hear you're feeling tired. Don't forget to take breaks and listen to your body."
                ]
            },
            excited: {
                keywords: ["excited", "thrilled", "eager", "enthusiastic", "pumped", "stoked", "ecstatic", "jazzed", "elated"],
                responses: [
                    "Your excitement is contagious! What's got you so thrilled? 🎉",
                    "I love your enthusiasm! What are you looking forward to?",
                    "That's wonderful to hear! What's making you so excited?",
                    "Your energy is amazing! What's happening that's got you so pumped?",
                    "It's great to feel excited about things! What's the source of your excitement?"
                ]
            }
        };
        
        // Analyze sentiment
        let detectedSentiment = null;
        let maxScore = 0;
        
        // Check each sentiment category
        for (const [sentiment, data] of Object.entries(sentimentData)) {
            let score = 0;
            for (const keyword of data.keywords) {
                if (message.includes(keyword)) {
                    score++;
                }
            }
            
            if (score > maxScore) {
                maxScore = score;
                detectedSentiment = sentiment;
            }
        }
        
        // If we detected a sentiment, return a random response for that sentiment
        if (detectedSentiment && maxScore > 0) {
            const responses = sentimentData[detectedSentiment].responses;
            return responses[Math.floor(Math.random() * responses.length)];
        }
        
        return "I'm here to help! How can I assist you today? Feel free to share what's on your mind.";
    }
},

// Default response pattern (should come after the sentiment pattern)
{
    pattern: /.*/,
    response: () => {
        const defaultResponses = [
            "I'm sorry, I didn't understand that. Try asking a Math Related question!",
            "I'm not sure what you mean. Could you rephrase that?",
            "I didn't quite get that. Can you say it differently?",
            "Hmm, I'm not sure how to respond to that. Try asking something else.",
            "I'm still learning! Could you try asking in a different way?",
            "That's beyond my current understanding. Try a simpler question.",
            "I'm not programmed to understand that yet. Try asking about math!",
            "I'm sorry, I didn't catch that. Could you try again?",
            "That doesn't compute for me. Try a math question instead!",
            "I'm not sure what you're asking. Can you clarify?",
            "I'm still developing my knowledge. Try a basic math question!",
            "I don't understand that request. Try asking about mathematics.",
            "That's not in my knowledge base yet. Try a math problem!",
            "I'm confused by that question. Try something simpler.",
            "I'm not equipped to answer that. Try a math-related question!",
            "That's not something I can help with right now. Try asking about math!",
            "I'm still learning new things. Try a basic math question!",
            "I don't have information about that. Try asking about mathematics!",
            "That's beyond my programming. Try a math question instead!",
            "i am Limited Data Ai Edition .So This Data Not Programmed .Any Help You Need To Say Help !"
        ];
        
        // Return a random response from the array
        return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
    }
},

{
    pattern: /.*/,
    response: () => {
        const defaultResponses = [
            "I'm sorry, I didn't understand that. Try asking a Math Related question!",
            "I'm not sure what you mean. Could you rephrase that?",
            "I didn't quite get that. Can you say it differently?",
            "Hmm, I'm not sure how to respond to that. Try asking something else.",
            "I'm still learning! Could you try asking in a different way?",
            "That's beyond my current understanding. Try a simpler question.",
            "I'm not programmed to understand that yet. Try asking about math!",
            "I'm sorry, I didn't catch that. Could you try again?",
            "That doesn't compute for me. Try a math question instead!",
            "I'm not sure what you're asking. Can you clarify?",
            "I'm still developing my knowledge. Try a basic math question!",
            "I don't understand that request. Try asking about mathematics.",
            "That's not in my knowledge base yet. Try a math problem!",
            "I'm confused by that question. Try something simpler.",
            "I'm not equipped to answer that. Try a math-related question!",
            "That's not something I can help with right now. Try asking about math!",
            "I'm still learning new things. Try a basic math question!",
            "I don't have information about that. Try asking about mathematics!",
            "That's beyond my programming. Try a math question instead!",
            "i am Limited Data Ai Edition .So This Data Not Programmed .Any Help You Need To Say Help !"
        ];
        
        // Return a random response from the array
        return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
    }
},
  
    
];


let chatHistory = []; // Stores chat messages with timestamps
let calculatorEnabled = false; // Switch ON/OFF calculator mode
let weatherEnabled = false; // Weather mode toggle
// News mode toggle
let newsEnabled = false;
let ipEnabled = false; // IP mode is OFF by default
// ===== Declare Variables at Top =====
let ipTrackerEnabled = false; // IP Tracker Mode OFF by default
let isLocked = false; // Flag to check if the process is locked
let htmlLoadEnabled = false;  // Flag to check if the HTML load mode is enabled

let wikipediaEnabled = false; // Wikipedia mode toggle

// Advanced Calculator Function to handle multiple operations and expressions
function advancedCalculator(expression) {
    try {
        // Remove extra spaces before calculating
        expression = expression.replace(/\s+/g, '');

        // Evaluate the expression using eval (ensure valid operations)
        const result = eval(expression); 

        return result;
    } catch (e) {
        return 'Error in expression';
    }
}


// Wikipedia API function using Fetch
async function getWikipediaSummary(topic) {
    const encodedTopic = encodeURIComponent(topic);
    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodedTopic}`;

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.extract) {
            return `📖 *Wikipedia Summary:*\n${data.extract}`;
        } else {
            return `❌ No Wikipedia data found for '${topic}'.`;
        }
    } catch (error) {
        return "⚠️ Error fetching Wikipedia data. Please try again later.";
    }
}



// Weather API function using Open-Meteo (no API key needed)
async function getWeather(city) {
    try {
        // First, get latitude and longitude for the city using OpenStreetMap Nominatim
        const geoResponse = await fetch(`https://nominatim.openstreetmap.org/search?city=${encodeURIComponent(city)}&format=json`);
        const geoData = await geoResponse.json();

        if (geoData.length === 0) {
            return `Sorry, I couldn't find the location "${city}".`;
        }

        const latitude = geoData[0].lat;
        const longitude = geoData[0].lon;

        // Now, fetch weather using Open-Meteo API
        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
        const weatherData = await weatherResponse.json();

        if (weatherData.current_weather) {
            const temp = weatherData.current_weather.temperature;
            const windspeed = weatherData.current_weather.windspeed;
            const weathercode = weatherData.current_weather.weathercode;

            return `Weather in ${city}:\nTemperature: ${temp}°C\nWind Speed: ${windspeed} km/h\nWeather Code: ${weathercode}`;
        } else {
            return "Sorry, weather information is not available right now.";
        }
    } catch (error) {
        return "Error fetching weather data. Please try again.";
    }
}

async function getLatestNews(searchTerms) {
    const apiKey = 'fa78fd6e485b416cbb55681c48e6a080';
    const baseUrl = 'https://newsapi.org/v2/everything';

    let newsResults = '';

    for (const term of searchTerms) {
        const url = `${baseUrl}?q=${encodeURIComponent(term)}&apiKey=${apiKey}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.articles && data.articles.length > 0) {
                const topArticle = data.articles[0];
                newsResults += `📰 *News for "${term}":*\nTitle: ${topArticle.title}\nDescription: ${topArticle.description}\n🔗 [Read more](${topArticle.url})\n\n`;
            } else {
                newsResults += `❌ No news found for "${term}".\n\n`;
            }
        } catch (error) {
            newsResults += `⚠️ Error fetching news for "${term}".\n\n`;
        }
    }

    return newsResults.trim() || "❌ No news found for any search term.";
}

// Function to fetch details of any IP address
async function getIPDetails(ipAddress) {
    const url = `https://ipinfo.io/${ipAddress}/json?token=16d9d846db0eb5`; // Your token added here

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data && data.ip) {
            return `🌐 *IP Address:* ${data.ip}\n` +
                   `🏙️ *City:* ${data.city}\n` +
                   `🌍 *Region:* ${data.region}\n` +
                   `🌎 *Country:* ${data.country}\n` +
                   `🏢 *ISP/Org:* ${data.org}\n` +
                   `📍 *Location Coordinates:* ${data.loc}`;
        } else {
            return "❌ Could not fetch details for the given IP address.";
        }
    } catch (error) {
        return "⚠️ Error fetching IP details. Please try again.";
    }
}


function sendMessage() {
    const userInputRaw = document.getElementById("user-input").value.trim();
    if (userInputRaw === "") return;

    const chatBox = document.getElementById("chat-box");

    // Start time of chat
    if (chatHistory.length === 0) {
        chatHistory.push(`Chat Start: ${new Date().toLocaleString()}\n`);
    }

// Add user message
const userMessage = document.createElement("div");
userMessage.classList.add("user-message");  // Add class for styling
userMessage.textContent = "You: " + userInputRaw;    

chatBox.appendChild(userMessage);
chatBox.appendChild(document.createElement("br"));


    // Save user message
    chatHistory.push(`[${new Date().toLocaleTimeString()}] You: ${userInputRaw}`);



// Unlock and lock commands inside sendMessage
if (/unlock weather mode/i.test(userInputRaw) || /open weather/i.test(userInputRaw)) {
    weatherEnabled = true;
    botReply("Weather Mode is now UNLOCKED! Type a city name like 'weather in London' to get the current weather.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close weather mode/i.test(userInputRaw) || /lock weather/i.test(userInputRaw)) {
    weatherEnabled = false;
    botReply("Weather Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

// Handle weather requests
if (weatherEnabled) {
    const city = userInputRaw.replace(/weather in /i, "").trim();
    if (city) {
        getWeather(city).then((weatherInfo) => {
            botReply(weatherInfo);
        });
        document.getElementById("user-input").value = "";
        return; // <- ADD THIS RETURN to stop further reply
    } else {
        botReply("Please specify a city to get the weather.");
        document.getElementById("user-input").value = "";
        return; // <- also here
    }
}

// Inside your message handler:

if (/unlock News mode/i.test(userInputRaw)) {
    newsEnabled = true;
    botReply("News Mode is now UNLOCKED! Ask me 'Who is <name>' or type keywords to get a summary.");
    document.getElementById("user-input").value = "";
    return;
}
if (/close News mode/i.test(userInputRaw)) {
    newsEnabled = false;
            botReply(`${this.currentGame.name} loaded! ${this.currentGame.instructions}`);y("News Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

if (newsEnabled) {
    // Extract keywords from the user input
    let searchTerms = userInputRaw
        .replace(/news mode|who is|news/gi, '') // remove these words
        .split(/[,\s]+/) // split by space or comma
        .filter(term => term.trim() !== ''); // remove empty strings

    if (searchTerms.length === 0) {
        botReply("❗ Please provide a name or keyword to search for news.");
        document.getElementById("user-input").value = "";
    } else {
        getLatestNews(searchTerms).then(newsInfo => {
            botReply(newsInfo);
        });
        document.getElementById("user-input").value = "";
    }
    return; // Stop further normal reply
}

// Handle unlock/lock commands
if (/unlock wikipedia mode/i.test(userInputRaw) || /open wikipedia/i.test(userInputRaw)) {
    wikipediaEnabled = true;
    botReply("Wikipedia Mode is now UNLOCKED! Ask me 'Who is <name>' to get a summary.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close wikipedia mode/i.test(userInputRaw) || /lock wikipedia/i.test(userInputRaw)) {
    wikipediaEnabled = false;
    botReply("Wikipedia Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}



// Handle Wikipedia requests
if (wikipediaEnabled) {
    const match = userInputRaw.match(/who is (.+)/i); // Check if the query matches the pattern "who is <name>"
    if (match && match[1]) {
        const topic = match[1];

        // Call the getWikipediaSummary function
        getWikipediaSummary(topic).then((wikipediaInfo) => {
            botReply(wikipediaInfo); // Send the response back to the bot
        });
        document.getElementById("user-input").value = "";
        return; // Stop further reply after sending response
    } else {
        botReply("Please ask something like 'Who is Albert Einstein'.");
        document.getElementById("user-input").value = "";
        return; // Stop further reply here as well
    }
}
// Function to fetch your public IP address
async function getMyIP() {
    const url = 'https://api.ipify.org?format=json'; // Free public IP API

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.ip) {
            return `🌐 Your Public IP Address is: *${data.ip}*`;
            document.getElementById("user-input").value = "";
        } else {
            return "❌ Could not fetch IP address.";
            document.getElementById("user-input").value = "";
        }
    } catch (error) {
        return "⚠️ Error fetching IP address. Please try again later.";
        document.getElementById("user-input").value = "";
    }
}
// Unlock IP Mode
if (/unlock ip mode/i.test(userInputRaw) || /open ip check/i.test(userInputRaw)) {
    ipEnabled = true;
    botReply("IP Check Mode is now UNLOCKED! Type anything to see your IP address.");
    return;
}

// Lock IP Mode
if (/close ip mode/i.test(userInputRaw) || /lock ip check/i.test(userInputRaw)) {
    ipEnabled = false;
    botReply("IP Check Mode is now LOCKED! Back to normal chatting.");
    return;
}

// Now handle IP Check if IP mode is enabled
if (ipEnabled) {
    getMyIP().then(ipInfo => {
        botReply(ipInfo);
    });
    return; // stop further reply
}




// ==== Toggle IP Tracker Mode =====
if (/unlock ip tracker mode/i.test(userInputRaw)) {
    ipTrackerEnabled = true;
    botReply("IP Tracker Mode is now UNLOCKED! Type any IP address to check details.");
    return;
}

if (/close ip tracker mode/i.test(userInputRaw)) {
    ipTrackerEnabled = false;
    botReply("IP Tracker Mode is now LOCKED! Back to normal chatting.");
    return;
}


// ==== Handle IP Address Input in Tracker Mode =====
if (ipTrackerEnabled) {
    // Try to detect IP Address Format
    const ipRegex = /(\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b)/;
    const match = userInputRaw.match(ipRegex);

    if (match) {
        const ipAddress = match[1];
        getIPDetails(ipAddress).then(ipInfo => {
            botReply(ipInfo);
        });
    } else {
        botReply("❗ Please enter a valid IP address like 8.8.8.8");
    }
    return; // Stop further reply
}

// Angry Emojis Reaction
if (/angry emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Angry Emojis! \n\n" +
      "1. 😠\n" +
      "2. 😡\n" +
      "3. 🤬\n" +
      "4. 😤\n" +
      "5. 🙄\n" +
      "6. 😾\n" +
      "7. 👿\n" +
      "8. 💢\n" +
      "9. 😒\n" +
      "10. 😣");
    return;
}

// Happy Emojis Reaction
if (/happy emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Happy Emojis! \n\n" +
      "1. 😀\n" +
      "2. 😃\n" +
      "3. 😄\n" +
      "4. 😁\n" +
      "5. 😆\n" +
      "6. 😊\n" +
      "7. 🤗\n" +
      "8. 😍\n" +
      "9. 🤩\n" +
      "10. 🥳");
    return;
}

// Love Emojis Reaction
if (/love emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Love Emojis! \n\n" +
      "1. ❤️\n" +
      "2. 💕\n" +
      "3. 💖\n" +
      "4. 💘\n" +
      "5. 💝\n" +
      "6. 💗\n" +
      "7. 💓\n" +
      "8. 💞\n" +
      "9. 😍\n" +
      "10. 😘");
    return;
}

// Comedy Emojis Reaction
if (/comedy emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Comedy Emojis! \n\n" +
      "1. 😂\n" +
      "2. 🤣\n" +
      "3. 😹\n" +
      "4. 😆\n" +
      "5. 😜\n" +
      "6. 🤪\n" +
      "7. 😝\n" +
      "8. 😛\n" +
      "9. 🤭\n" +
      "10. 😹");
    return;
}

// Sad Emojis Reaction
if (/sad emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Sad Emojis! \n\n" +
      "1. 😢\n" +
      "2. 😞\n" +
      "3. 😔\n" +
      "4. 😟\n" +
      "5. 😕\n" +
      "6. 🙁\n" +
      "7. 😣\n" +
      "8. 😖\n" +
      "9. 🥺\n" +
      "10. 😿");
    return;
}

// Crying Emojis Reaction
if (/crying emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Crying Emojis! \n\n" +
      "1. 😭\n" +
      "2. 😢\n" +
      "3. 😿\n" +
      "4. 🥲\n" +
      "5. 😥\n" +
      "6. 😓\n" +
      "7. 🥺\n" +
      "8. 😔\n" +
      "9. 😖\n" +
      "10. 😩");
    return;
}

const badWords = [
    // English bad words (sex related + common)
    "fuck", "shit", "bitch", "asshole", "bastard", "dumb", "stupid", "idiot",
    "dick", "cock", "pussy", "penis", "vagina", "boobs", "nipple", "cum", "suck",
    "sex", "sexy", "horny", "porn", "pornhub", "milf", "slut", "whore", "fucker",
    "motherfucker", "cunt", "ass", "jerk", "jerking", "blowjob", "handjob", "orgasm",
    "moan", "bang", "rape", "nude", "nudes", "naked",

    // Hindi bad words (India)
    "chutiya", "bhosdike", "bhenchod", "madarchod", "gandu", "loda", "lund", "randi",
    "chut", "gaand", "chutmarani", "gaandfat", "chutiyapa",

    // Spanish bad words
    "puta", "mierda", "coño", "polla", "cabron", "pendejo", "puto", "culero",

    // Arabic bad words
    "sharmuta", "kos ommak", "ibn al kalb", "ibn sharmuta", "ayreh", "khara",

    // French bad words
    "pute", "merde", "salope", "connard", "enculé",

    // Portuguese bad words
    "porra", "caralho", "puta", "merda", "bosta",

    // Russian bad words
    "blyad", "suka", "pidor", "khuy", "ebat",

    // Extra offensive English
    "motherfucking", "assfucker", "cumshot", "cockslut", "fuckboy", "fuckgirl"
];


// Direct check without foundBadWord variable
if (badWords.some(badWord => new RegExp("\\b" + badWord + "\\b", "i").test(userInputRaw))) {
    botReply("Warning ⚠️ !");
    return;
}


// Check special commands for calculator mode
if (/unlock advanced calculator|Advance Calculator|Advanced Calculator/i.test(userInputRaw) || /open calculator/i.test(userInputRaw)) {
    calculatorEnabled = true;
    botReply("Advanced Calculator Mode is now UNLOCKED! Type your mathematical expressions to calculate.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close advanced calculator/i.test(userInputRaw) || /lock calculator/i.test(userInputRaw)) {
    calculatorEnabled = false;
    botReply("Advanced Calculator Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

if (/reset calculator/i.test(userInputRaw)) {
    calculatorEnabled = false;
    botReply("Calculator Mode has been RESET! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

    // Now handle based on mode
    if (calculatorEnabled) {
        const result = advancedCalculator(userInputRaw);
        botReply(`Result: ${result}`);
        document.getElementById("user-input").value = "";
    } else {
    document.getElementById("user-input").value = "";
        // Normal chatbot mode
        let reply = "Sorry, I don't understand that.";
        for (let pair of responses) {
            if (pair.pattern instanceof RegExp && pair.pattern.test(userInputRaw)) {
                reply = typeof pair.response === "function" ? pair.response(userInputRaw.match(pair.pattern)) : pair.response;
                break;
            }
        }
        botReply(reply);
    }

    // Clear input field
    document.getElementById("user-input").value = "";
    
        // Check if user wants to clear chat
    if (/clear all/i.test(userInputRaw)) {
        chatBox.innerHTML = "";
        chatHistory = []; // Reset chat history
        document.getElementById("user-input").value = "";        
        return;
    }

// Enhanced Photo Editor with Advanced Features and Upgrades
class PhotoEditor {
    constructor() {
        this.initializeEditor();
        this.setupDownloadSystem();
        this.setupEffectSelection();
        this.setupHistorySystem();
        this.setupBatchProcessing();
        this.initializeAdvancedFeatures();
    }

    initializeEditor() {
        // Create hidden file input
        this.fileInput = document.createElement('input');
        this.fileInput.type = 'file';
        this.fileInput.accept = 'image/*';
        this.fileInput.style.display = 'none';
        this.fileInput.id = 'photoEditorInput';
        document.body.appendChild(this.fileInput);
        
        // Add event listener
        this.fileInput.addEventListener('change', (e) => this.handleImageUpload(e));
        
        // Initialize editor state
        this.currentImage = null;
        this.originalImageData = null;
        this.processingHistory = [];
        this.redoStack = [];
        this.batchMode = false;
        this.batchImages = [];
        this.currentBatchIndex = 0;
        
        // Create progress indicator
        this.progressIndicator = document.createElement('div');
        this.progressIndicator.className = 'progress-indicator';
        this.progressIndicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 2000;
            display: none;
            text-align: center;
        `;
        document.body.appendChild(this.progressIndicator);
    }

    setupDownloadSystem() {
        // Create download notification container
        this.downloadNotification = document.createElement('div');
        this.downloadNotification.className = 'download-notification';
        this.downloadNotification.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            max-width: 300px;
            transition: all 0.3s ease;
        `;
        document.body.appendChild(this.downloadNotification);
        
        // Create share options
        this.shareOptions = document.createElement('div');
        this.shareOptions.className = 'share-options';
        this.shareOptions.style.cssText = `
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            padding: 10px;
        `;
        document.body.appendChild(this.shareOptions);
    }

    setupEffectSelection() {
        // Available effects with enhanced metadata
        this.availableEffects = [
            { id: 'none', name: 'No Effect', icon: '🖼️', category: 'basic' },
            { id: 'crack', name: 'Crack Effect', icon: '🔨', category: 'artistic' },
            { id: 'vintage', name: 'Vintage', icon: '📜', category: 'color' },
            { id: 'grayscale', name: 'Grayscale', icon: '⚫', category: 'color' },
            { id: 'sepia', name: 'Sepia', icon: '🟤', category: 'color' },
            { id: 'blur', name: 'Blur', icon: '💧', category: 'adjustment', adjustable: true },
            { id: 'sharpen', name: 'Sharpen', icon: '🔍', category: 'adjustment', adjustable: true },
            { id: 'pixelate', name: 'Pixelate', icon: '🧩', category: 'artistic', adjustable: true },
            { id: 'glitch', name: 'Glitch', icon: '📺', category: 'artistic' },
            { id: 'neon', name: 'Neon', icon: '💡', category: 'artistic' },
            { id: 'brightness', name: 'Brightness', icon: '☀️', category: 'adjustment', adjustable: true },
            { id: 'contrast', name: 'Contrast', icon: '🌗', category: 'adjustment', adjustable: true },
            { id: 'saturation', name: 'Saturation', icon: '🎨', category: 'adjustment', adjustable: true },
            { id: 'hue', name: 'Hue Shift', icon: '🌈', category: 'adjustment', adjustable: true },
            { id: 'invert', name: 'Invert', icon: '🔄', category: 'color' },
            { id: 'edge', name: 'Edge Detect', icon: '📐', category: 'artistic' },
            { id: 'emboss', name: 'Emboss', icon: '🗿', category: 'artistic' },
            { id: 'oil', name: 'Oil Painting', icon: '🖌️', category: 'artistic' },
            { id: 'cartoon', name: 'Cartoon', icon: '🎭', category: 'artistic' },
            { id: 'mirror', name: 'Mirror', icon: '🪞', category: 'transform' },
            { id: 'rotate', name: 'Rotate', icon: '🔄', category: 'transform', adjustable: true },
            { id: 'crop', name: 'Crop', icon: '✂️', category: 'transform', adjustable: true },
            { id: 'vignette', name: 'Vignette', icon: '🌑', category: 'adjustment', adjustable: true },
            { id: 'noise', name: 'Add Noise', icon: '📶', category: 'adjustment', adjustable: true },
            { id: 'posterize', name: 'Posterize', icon: '🎪', category: 'artistic', adjustable: true },
            { id: 'solarize', name: 'Solarize', icon: '☀️', category: 'artistic' },
            { id: 'ghibli', name: 'Ghibli Style', icon: '🌿', category: 'artistic' },
            // New effects
            { id: 'bokeh', name: 'Bokeh', icon: '✨', category: 'artistic' },
            { id: 'lensflare', name: 'Lens Flare', icon: '🌟', category: 'artistic' },
            { id: 'hdr', name: 'HDR', icon: '🔆', category: 'adjustment' },
            { id: 'tiltshift', name: 'Tilt Shift', icon: '🏙️', category: 'artistic' },
            { id: 'watercolor', name: 'Watercolor', icon: '🎨', category: 'artistic' },
            { id: 'sketch', name: 'Sketch', icon: '✏️', category: 'artistic' },
            { id: 'doubleexposure', name: 'DoubleExposure', icon: '👥', category: 'advanced' },
            { id: 'colorpop', name: 'ColorPop', icon: '🎈', category: 'color' },
            { id: 'retro', name: 'Retro', icon: '📻', category: 'color' }
        ];
        
        this.selectedEffect = 'none';
        this.effectParameters = {};
        this.activeCategory = 'all';
    }

    setupHistorySystem() {
        // Create history controls
        this.historyControls = document.createElement('div');
        this.historyControls.className = 'history-controls';
        this.historyControls.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 10px;
            z-index: 1000;
            display: none;
        `;
        
        // Add undo/redo buttons
        const undoButton = document.createElement('button');
        undoButton.innerHTML = '↶ Undo';
        undoButton.style.cssText = `
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin-right: 5px;
            cursor: pointer;
        `;
        undoButton.addEventListener('click', () => this.undo());
        
        const redoButton = document.createElement('button');
        redoButton.innerHTML = '↷ Redo';
        redoButton.style.cssText = `
            background: #f0f0f0;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
        `;
        redoButton.addEventListener('click', () => this.redo());
        
        this.historyControls.appendChild(undoButton);
        this.historyControls.appendChild(redoButton);
        document.body.appendChild(this.historyControls);
    }

    setupBatchProcessing() {
        // Create batch processing controls
        this.batchControls = document.createElement('div');
        this.batchControls.className = 'batch-controls';
        this.batchControls.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 10px;
            z-index: 1000;
            display: none;
        `;
        
        // Add batch mode toggle
        const batchToggle = document.createElement('button');
        batchToggle.innerHTML = '📁 Batch Mode';
        batchToggle.style.cssText = `
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
        `;
        batchToggle.addEventListener('click', () => this.toggleBatchMode());
        
        this.batchControls.appendChild(batchToggle);
        document.body.appendChild(this.batchControls);
        
        // Create batch file input
        this.batchFileInput = document.createElement('input');
        this.batchFileInput.type = 'file';
        this.batchFileInput.accept = 'image/*';
        this.batchFileInput.multiple = true;
        this.batchFileInput.style.display = 'none';
        this.batchFileInput.id = 'batchPhotoEditorInput';
        document.body.appendChild(this.batchFileInput);
        
        this.batchFileInput.addEventListener('change', (e) => this.handleBatchImageUpload(e));
    }

    initializeAdvancedFeatures() {
        // Create advanced features panel
        this.advancedPanel = document.createElement('div');
        this.advancedPanel.className = 'advanced-panel';
        this.advancedPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 20px;
            z-index: 2000;
            display: none;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        `;
        document.body.appendChild(this.advancedPanel);
        
        // Create close button for advanced panel
        const closeButton = document.createElement('button');
        closeButton.innerHTML = '✕';
        closeButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        `;
        closeButton.addEventListener('click', () => {
            this.advancedPanel.style.display = 'none';
        });
        this.advancedPanel.appendChild(closeButton);
    }

    // Trigger photo editing with effect selection
    triggerPhotoEdit(userInput) {
        // Check if user specified a specific effect
        const effectMatch = userInput.match(/edit photo\s+(\w+)/i);
        
        if (effectMatch) {
            const effectName = effectMatch[1].toLowerCase();
            const effect = this.availableEffects.find(e => e.id === effectName);
            
            if (effect) {
                this.selectedEffect = effect.id;
                botReply(`Selected: ${effect.name}. Please upload your photo.`);
                setTimeout(() => {
                    this.fileInput.click();
                }, 1000);
                return;
            } else {
                botReply(`Effect "${effectName}" not found. Available effects: ${this.availableEffects.map(e => e.name).join(', ')}`);
                return;
            }
        }
        
        // If no specific effect was mentioned, show selection UI
        this.showEffectSelection();
    }

    // Show effect selection interface with categories
    showEffectSelection() {
        botReply("Choose an effect for your photo:");
        
        // Create effect selection container
        const effectContainer = document.createElement('div');
        effectContainer.className = 'effect-selection';
        effectContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            margin-top: 15px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
        `;
        
        // Create category tabs
        const categories = ['all', 'basic', 'color', 'adjustment', 'artistic', 'transform', 'advanced'];
        const categoryNames = {
            'all': 'All Effects',
            'basic': 'Basic',
            'color': 'Color',
            'adjustment': 'Adjustments',
            'artistic': 'Artistic',
            'transform': 'Transform',
            'advanced': 'Advanced'
        };
        
        const categoryTabs = document.createElement('div');
        categoryTabs.className = 'category-tabs';
        categoryTabs.style.cssText = `
            display: flex;
            margin-bottom: 15px;
            overflow-x: auto;
        `;
        
        categories.forEach(category => {
            const tab = document.createElement('button');
            tab.className = 'category-tab';
            tab.textContent = categoryNames[category];
            tab.style.cssText = `
                background: ${this.activeCategory === category ? '#4CAF50' : '#ddd'};
                color: ${this.activeCategory === category ? 'white' : 'black'};
                border: none;
                border-radius: 4px;
                padding: 8px 12px;
                margin-right: 5px;
                cursor: pointer;
                white-space: nowrap;
            `;
            
            tab.addEventListener('click', () => {
                this.activeCategory = category;
                this.showEffectSelection();
            });
            
            categoryTabs.appendChild(tab);
        });
        
        effectContainer.appendChild(categoryTabs);
        
        // Create effects grid
        const effectsGrid = document.createElement('div');
        effectsGrid.className = 'effects-grid';
        effectsGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        `;
        
        // Filter effects by active category
        const filteredEffects = this.activeCategory === 'all' 
            ? this.availableEffects 
            : this.availableEffects.filter(effect => effect.category === this.activeCategory);
        
        // Create effect buttons
        filteredEffects.forEach(effect => {
            const effectButton = document.createElement('button');
            effectButton.className = 'effect-button';
            effectButton.style.cssText = `
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 15px 10px;
                background: white;
                border: 2px solid #ddd;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 14px;
            `;
            
            effectButton.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">${effect.icon}</div>
                <div>${effect.name}</div>
                ${effect.adjustable ? '<div style="font-size: 10px; color: #666;">Adjustable</div>' : ''}
            `;
            
            effectButton.addEventListener('click', () => {
                if (effect.adjustable) {
                    this.showEffectAdjustment(effect.id);
                } else {
                    this.selectEffect(effect.id);
                }
            });
            
            effectButton.addEventListener('mouseenter', () => {
                effectButton.style.transform = 'translateY(-5px)';
                effectButton.style.boxShadow = '0 5px 15px rgba(0,0,0,0.1)';
                effectButton.style.borderColor = '#4CAF50';
            });
            
            effectButton.addEventListener('mouseleave', () => {
                effectButton.style.transform = 'translateY(0)';
                effectButton.style.boxShadow = 'none';
                effectButton.style.borderColor = '#ddd';
            });
            
            effectsGrid.appendChild(effectButton);
        });
        
        effectContainer.appendChild(effectsGrid);
        
        // Add batch mode option
        const batchOption = document.createElement('div');
        batchOption.style.cssText = `
            margin-top: 15px;
            text-align: center;
        `;
        
        const batchButton = document.createElement('button');
        batchButton.innerHTML = '📁 Process Multiple Images';
        batchButton.style.cssText = `
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 15px;
            cursor: pointer;
        `;
        batchButton.addEventListener('click', () => {
            this.toggleBatchMode();
            this.batchFileInput.click();
        });
        
        batchOption.appendChild(batchButton);
        effectContainer.appendChild(batchOption);
        
        // Add to chat
        const messageContainer = document.createElement('div');
        messageContainer.appendChild(effectContainer);
        document.querySelector('.chat-messages').appendChild(messageContainer);
        
        // Scroll to bottom
        document.querySelector('.chat-container').scrollTop = document.querySelector('.chat-container').scrollHeight;
    }

    // Show effect adjustment panel for adjustable effects
    showEffectAdjustment(effectId) {
        const effect = this.availableEffects.find(e => e.id === effectId);
        if (!effect) return;
        
        // Clear advanced panel
        this.advancedPanel.innerHTML = '';
        
        // Add close button
        const closeButton = document.createElement('button');
        closeButton.innerHTML = '✕';
        closeButton.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        `;
        closeButton.addEventListener('click', () => {
            this.advancedPanel.style.display = 'none';
        });
        this.advancedPanel.appendChild(closeButton);
        
        // Add title
        const title = document.createElement('h2');
        title.textContent = `${effect.name} Settings`;
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
        `;
        this.advancedPanel.appendChild(title);
        
        // Add preview area
        const previewContainer = document.createElement('div');
        previewContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: center;
        `;
        
        const previewImage = document.createElement('img');
        previewImage.style.cssText = `
            max-width: 100%;
            max-height: 200px;
            border-radius: 4px;
        `;
        
        if (this.currentImage) {
            previewImage.src = this.currentImage.src;
        } else {
            previewImage.src = 'https://picsum.photos/seed/preview/400/300.jpg';
        }
        
        previewContainer.appendChild(previewImage);
        this.advancedPanel.appendChild(previewContainer);
        
        // Add controls based on effect type
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'effect-controls';
        
        switch (effectId) {
            case 'blur':
            case 'sharpen':
                this.addSliderControl(controlsContainer, 'Intensity', 0, 100, 50, 'intensity');
                break;
            case 'pixelate':
                this.addSliderControl(controlsContainer, 'Pixel Size', 2, 20, 10, 'pixelSize');
                break;
            case 'brightness':
                this.addSliderControl(controlsContainer, 'Brightness', -100, 100, 30, 'brightness');
                break;
            case 'contrast':
                this.addSliderControl(controlsContainer, 'Contrast', -100, 100, 50, 'contrast');
                break;
            case 'saturation':
                this.addSliderControl(controlsContainer, 'Saturation', -100, 100, 50, 'saturation');
                break;
            case 'hue':
                this.addSliderControl(controlsContainer, 'Hue Shift', 0, 360, 30, 'hueShift');
                break;
            case 'rotate':
                this.addSliderControl(controlsContainer, 'Rotation Angle', 0, 360, 90, 'rotation');
                break;
            case 'crop':
                this.addCropControls(controlsContainer);
                break;
            case 'vignette':
                this.addSliderControl(controlsContainer, 'Vignette Strength', 0, 100, 80, 'vignetteStrength');
                break;
            case 'noise':
                this.addSliderControl(controlsContainer, 'Noise Amount', 0, 100, 50, 'noiseAmount');
                break;
            case 'posterize':
                this.addSliderControl(controlsContainer, 'Color Levels', 2, 16, 4, 'colorLevels');
                break;
        }
        
        this.advancedPanel.appendChild(controlsContainer);
        
        // Add apply button
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply Effect';
        applyButton.style.cssText = `
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 15px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
            width: 100%;
        `;
        
        applyButton.addEventListener('click', () => {
            this.selectEffect(effectId, this.effectParameters);
            this.advancedPanel.style.display = 'none';
        });
        
        this.advancedPanel.appendChild(applyButton);
        
        // Show the panel
        this.advancedPanel.style.display = 'block';
    }

    // Add slider control to the adjustment panel
    addSliderControl(container, label, min, max, defaultValue, paramName) {
        const controlContainer = document.createElement('div');
        controlContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.textContent = label;
        labelElement.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        controlContainer.appendChild(labelElement);
        
        const sliderContainer = document.createElement('div');
        sliderContainer.style.cssText = `
            display: flex;
            align-items: center;
        `;
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = min;
        slider.max = max;
        slider.value = defaultValue;
        slider.style.cssText = `
            flex: 1;
            margin-right: 10px;
        `;
        
        const valueDisplay = document.createElement('span');
        valueDisplay.textContent = defaultValue;
        valueDisplay.style.cssText = `
            min-width: 40px;
            text-align: right;
        `;
        
        slider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            valueDisplay.textContent = value;
            this.effectParameters[paramName] = value;
            
            // Update preview if current image exists
            if (this.currentImage) {
                this.updatePreview();
            }
        });
        
        // Initialize parameter
        this.effectParameters[paramName] = defaultValue;
        
        sliderContainer.appendChild(slider);
        sliderContainer.appendChild(valueDisplay);
        controlContainer.appendChild(sliderContainer);
        container.appendChild(controlContainer);
    }

    // Add crop controls to the adjustment panel
    addCropControls(container) {
        const cropInfo = document.createElement('p');
        cropInfo.textContent = 'Crop will be applied to the center of the image. You can adjust the aspect ratio below.';
        cropInfo.style.cssText = `
            margin-bottom: 15px;
            color: #666;
        `;
        container.appendChild(cropInfo);
        
        const aspectRatios = [
            { name: 'Original', value: 'original' },
            { name: 'Square (1:1)', value: '1:1' },
            { name: 'Landscape (4:3)', value: '4:3' },
            { name: 'Landscape (16:9)', value: '16:9' },
            { name: 'Portrait (3:4)', value: '3:4' },
            { name: 'Portrait (9:16)', value: '9:16' }
        ];
        
        const ratioContainer = document.createElement('div');
        ratioContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const ratioLabel = document.createElement('label');
        ratioLabel.textContent = 'Aspect Ratio:';
        ratioLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        ratioContainer.appendChild(ratioLabel);
        
        const ratioSelect = document.createElement('select');
        ratioSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        `;
        
        aspectRatios.forEach(ratio => {
            const option = document.createElement('option');
            option.value = ratio.value;
            option.textContent = ratio.name;
            ratioSelect.appendChild(option);
        });
        
        ratioSelect.addEventListener('change', (e) => {
            this.effectParameters.aspectRatio = e.target.value;
        });
        
        // Initialize parameter
        this.effectParameters.aspectRatio = '1:1';
        
        ratioContainer.appendChild(ratioSelect);
        container.appendChild(ratioContainer);
    }

    // Update preview image with current effect settings
    updatePreview() {
        if (!this.currentImage) return;
        
        const previewImage = this.advancedPanel.querySelector('img');
        if (!previewImage) return;
        
        // Create a canvas for processing
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = this.currentImage.width;
        canvas.height = this.currentImage.height;
        ctx.drawImage(this.currentImage, 0, 0);
        
        // Apply the effect with current parameters
        this.applyEffect(canvas, ctx, this.selectedEffect, this.effectParameters);
        
        // Update preview
        previewImage.src = canvas.toDataURL();
    }

    // Toggle batch processing mode
    toggleBatchMode() {
        this.batchMode = !this.batchMode;
        
        if (this.batchMode) {
            botReply("Batch mode enabled. You can now select multiple images to process with the same effect.");
            this.batchControls.style.display = 'block';
        } else {
            botReply("Batch mode disabled.");
            this.batchControls.style.display = 'none';
        }
    }

    // Handle batch image upload
    handleBatchImageUpload(event) {
        const files = Array.from(event.target.files);
        if (files.length === 0) return;
        
        // Validate all files
        const invalidFiles = files.filter(file => !file.type.match('image.*'));
        if (invalidFiles.length > 0) {
            botReply(`${invalidFiles.length} files are not valid images. Please select only image files.`);
            return;
        }
        
        // Check file sizes
        const largeFiles = files.filter(file => file.size > 10 * 1024 * 1024);
        if (largeFiles.length > 0) {
            botReply(`${largeFiles.length} files are too large. Please select images under 10MB each.`);
            return;
        }
        
        // Store batch images
        this.batchImages = files;
        this.currentBatchIndex = 0;
        
        botReply(`Loaded ${files.length} images for batch processing. Please select an effect to apply to all images.`);
        
        // Show effect selection
        this.showEffectSelection();
    }

    // Handle effect selection with optional parameters
    selectEffect(effectId, parameters = {}) {
        this.selectedEffect = effectId;
        this.effectParameters = parameters;
        const effectName = this.availableEffects.find(e => e.id === effectId).name;
        
        if (this.batchMode && this.batchImages.length > 0) {
            botReply(`Selected: ${effectName}. Processing ${this.batchImages.length} images...`);
            this.processBatchImages();
        } else {
            botReply(`Selected: ${effectName}. Please upload your photo.`);
            
            // Remove effect selection UI
            const effectSelection = document.querySelector('.effect-selection');
            if (effectSelection) {
                effectSelection.remove();
            }
            
            // Trigger file picker
            setTimeout(() => {
                this.fileInput.click();
            }, 1000);
        }
    }

    // Process batch images
    processBatchImages() {
        if (this.currentBatchIndex >= this.batchImages.length) {
            botReply(`Batch processing complete! All ${this.batchImages.length} images have been processed and downloaded.`);
            this.batchImages = [];
            this.currentBatchIndex = 0;
            this.batchMode = false;
            this.batchControls.style.display = 'none';
            return;
        }
        
        const file = this.batchImages[this.currentBatchIndex];
        const reader = new FileReader();
        
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.currentImage = img;
                this.processImage(img, file.name, true);
                this.currentBatchIndex++;
                
                // Process next image with a small delay
                setTimeout(() => {
                    this.processBatchImages();
                }, 500);
            };
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
        
        // Show progress
        this.showProgress(`Processing image ${this.currentBatchIndex + 1} of ${this.batchImages.length}...`);
    }

    // Show progress indicator
    showProgress(message) {
        this.progressIndicator.textContent = message;
        this.progressIndicator.style.display = 'block';
    }

    // Hide progress indicator
    hideProgress() {
        this.progressIndicator.style.display = 'none';
    }

    // Handle image upload
    handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (!file.type.match('image.*')) {
            botReply("Please select a valid image file.");
            return;
        }
        
        // Check file size (limit to 10MB)
        if (file.size > 10 * 1024 * 1024) {
            botReply("Image is too large. Please select an image under 10MB.");
            return;
        }
        
        botReply("Loading image for editing...");
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.currentImage = img;
                this.processImage(img, file.name);
            };
            img.onerror = () => {
                botReply("Error loading image. Please try a different file.");
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Process image with selected effect
    processImage(img, originalFilename, isBatch = false) {
        const effectName = this.availableEffects.find(e => e.id === this.selectedEffect).name;
        
        if (!isBatch) {
            botReply(`Editing your image with ${effectName} effect...`);
            this.showProgress('Processing image...');
        }
        
        try {
            // Create canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // Save original image data for undo functionality
            if (!isBatch) {
                this.originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                this.processingHistory = [];
                this.redoStack = [];
                this.historyControls.style.display = 'block';
            }
            
            // Apply base enhancements
            this.autoEnhance(canvas, ctx);
            
            // Apply selected effect with parameters
            this.applyEffect(canvas, ctx, this.selectedEffect, this.effectParameters);
            
            // Save to history if not in batch mode
            if (!isBatch) {
                this.saveToHistory(ctx.getImageData(0, 0, canvas.width, canvas.height));
            }
            
            // Create edited filename
            const editedFilename = this.createEditedFilename(originalFilename, this.selectedEffect);
            
            // Automatically download the edited image
            this.downloadEditedImage(canvas, editedFilename);
            
            // Show download notification
            if (!isBatch) {
                this.hideProgress();
                this.showDownloadNotification(editedFilename);
                
                // Show share options
                this.showShareOptions(canvas, editedFilename);
            }
            
        } catch (error) {
            botReply("Error processing image. Please try again.");
            console.error("Processing Error:", error);
            this.hideProgress();
        }
    }

    // Save current state to history
    saveToHistory(imageData) {
        this.processingHistory.push(imageData);
        this.redoStack = []; // Clear redo stack when new action is performed
        
        // Limit history size to prevent memory issues
        if (this.processingHistory.length > 10) {
            this.processingHistory.shift();
        }
    }

    // Undo last action
    undo() {
        if (this.processingHistory.length <= 1) return;
        
        // Move current state to redo stack
        const currentState = this.processingHistory.pop();
        this.redoStack.push(currentState);
        
        // Restore previous state
        const previousState = this.processingHistory[this.processingHistory.length - 1];
        
        // Create canvas and restore state
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = previousState.width;
        canvas.height = previousState.height;
        ctx.putImageData(previousState, 0, 0);
        
        // Update current image
        this.currentImage = new Image();
        this.currentImage.onload = () => {
            // Update preview if advanced panel is open
            if (this.advancedPanel.style.display === 'block') {
                this.updatePreview();
            }
        };
        this.currentImage.src = canvas.toDataURL();
        
        botReply("Undo successful.");
    }

    // Redo last undone action
    redo() {
        if (this.redoStack.length === 0) return;
        
        // Get state from redo stack
        const nextState = this.redoStack.pop();
        
        // Add to history
        this.processingHistory.push(nextState);
        
        // Create canvas and restore state
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = nextState.width;
        canvas.height = nextState.height;
        ctx.putImageData(nextState, 0, 0);
        
        // Update current image
        this.currentImage = new Image();
        this.currentImage.onload = () => {
            // Update preview if advanced panel is open
            if (this.advancedPanel.style.display === 'block') {
                this.updatePreview();
            }
        };
        this.currentImage.src = canvas.toDataURL();
        
        botReply("Redo successful.");
    }

    // Show share options
    showShareOptions(canvas, filename) {
        // Clear previous options
        this.shareOptions.innerHTML = '';
        
        // Add title
        const title = document.createElement('div');
        title.textContent = 'Share your edited image:';
        title.style.cssText = `
            font-weight: bold;
            margin-bottom: 10px;
        `;
        this.shareOptions.appendChild(title);
        
        // Add social media buttons
        const socialPlatforms = [
            { name: 'Facebook', icon: '📘', action: () => this.shareToSocial(canvas, 'facebook') },
            { name: 'Twitter', icon: '🐦', action: () => this.shareToSocial(canvas, 'twitter') },
            { name: 'Instagram', icon: '📷', action: () => this.shareToSocial(canvas, 'instagram') },
            { name: 'Download', icon: '💾', action: () => this.downloadEditedImage(canvas, filename) }
        ];
        
        socialPlatforms.forEach(platform => {
            const button = document.createElement('button');
            button.innerHTML = `${platform.icon} ${platform.name}`;
            button.style.cssText = `
                display: block;
                width: 100%;
                background: #f0f0f0;
                border: none;
                border-radius: 4px;
                padding: 8px;
                margin-bottom: 5px;
                cursor: pointer;
                text-align: left;
            `;
            
            button.addEventListener('click', () => {
                platform.action();
                this.shareOptions.style.display = 'none';
            });
            
            this.shareOptions.appendChild(button);
        });
        
        // Show the share options
        this.shareOptions.style.display = 'block';
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
            this.shareOptions.style.display = 'none';
        }, 10000);
    }

    // Share to social media (simplified implementation)
    shareToSocial(canvas, platform) {
        // Convert canvas to blob
        canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            
            // In a real implementation, this would integrate with each platform's API
            // For this example, we'll just open a new window with the image
            switch (platform) {
                case 'facebook':
                    window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(window.location.href)}`, '_blank');
                    break;
                case 'twitter':
                    window.open(`https://twitter.com/intent/tweet?text=Check out my edited image!&url=${encodeURIComponent(window.location.href)}`, '_blank');
                    break;
                case 'instagram':
                    botReply("To share on Instagram, please download the image and upload it through the Instagram app.");
                    break;
            }
            
            // Clean up
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
        }, 'image/jpeg', 0.9);
    }

    // Apply selected effect with parameters
    applyEffect(canvas, ctx, effectId, parameters = {}) {
        switch(effectId) {
            case 'crack':
                this.applyCrackEffect(canvas, ctx, parameters);
                break;
            case 'vintage':
                this.applyVintageEffect(canvas, ctx, parameters);
                break;
            case 'grayscale':
                this.applyGrayscaleEffect(canvas, ctx, parameters);
                break;
            case 'sepia':
                this.applySepiaEffect(canvas, ctx, parameters);
                break;
            case 'blur':
                this.applyBlurEffect(canvas, ctx, parameters);
                break;
            case 'sharpen':
                this.applySharpenEffect(canvas, ctx, parameters);
                break;
            case 'pixelate':
                this.applyPixelateEffect(canvas, ctx, parameters);
                break;
            case 'glitch':
                this.applyGlitchEffect(canvas, ctx, parameters);
                break;
            case 'neon':
                this.applyNeonEffect(canvas, ctx, parameters);
                break;
            case 'brightness':
                this.applyBrightnessEffect(canvas, ctx, parameters);
                break;
            case 'contrast':
                this.applyContrastEffect(canvas, ctx, parameters);
                break;
            case 'saturation':
                this.applySaturationEffect(canvas, ctx, parameters);
                break;
            case 'hue':
                this.applyHueEffect(canvas, ctx, parameters);
                break;
            case 'invert':
                this.applyInvertEffect(canvas, ctx, parameters);
                break;
            case 'edge':
                this.applyEdgeDetectionEffect(canvas, ctx, parameters);
                break;
            case 'emboss':
                this.applyEmbossEffect(canvas, ctx, parameters);
                break;
            case 'oil':
                this.applyOilPaintingEffect(canvas, ctx, parameters);
                break;
            case 'cartoon':
                this.applyCartoonEffect(canvas, ctx, parameters);
                break;
            case 'mirror':
                this.applyMirrorEffect(canvas, ctx, parameters);
                break;
            case 'rotate':
                this.applyRotateEffect(canvas, ctx, parameters);
                break;
            case 'crop':
                this.applyCropEffect(canvas, ctx, parameters);
                break;
            case 'vignette':
                this.applyVignetteEffect(canvas, ctx, parameters);
                break;
            case 'noise':
                this.applyNoiseEffect(canvas, ctx, parameters);
                break;
            case 'posterize':
                this.applyPosterizeEffect(canvas, ctx, parameters);
                break;
            case 'solarize':
                this.applySolarizeEffect(canvas, ctx, parameters);
                break;
            case 'ghibli':
                this.applyGhibliEffect(canvas, ctx, parameters);
                break;
            // New effects
            case 'bokeh':
                this.applyBokehEffect(canvas, ctx, parameters);
                break;
            case 'lensflare':
                this.applyLensFlareEffect(canvas, ctx, parameters);
                break;
            case 'hdr':
                this.applyHDREffect(canvas, ctx, parameters);
                break;
            case 'tiltshift':
                this.applyTiltShiftEffect(canvas, ctx, parameters);
                break;
            case 'watercolor':
                this.applyWatercolorEffect(canvas, ctx, parameters);
                break;
            case 'sketch':
                this.applySketchEffect(canvas, ctx, parameters);
                break;
            case 'doubleexposure':
                this.applyDoubleExposureEffect(canvas, ctx, parameters);
                break;
            case 'colorpop':
                this.applyColorPopEffect(canvas, ctx, parameters);
                break;
            case 'retro':
                this.applyRetroEffect(canvas, ctx, parameters);
                break;
            default:
                // No effect
                break;
        }
    }

    // Apply crack effect with parameters
    applyCrackEffect(canvas, ctx, parameters = {}) {
        // Use the existing implementation but with customizable parameters
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a temporary canvas for the original image
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Determine the mirror axis (vertical or horizontal)
        const mirrorVertical = Math.random() > 0.5;
        
        // Create high-density star crack pattern on one half
        const starCenters = parameters.starCount || Math.floor(Math.random() * 15) + 10; // More star centers
        
        for (let s = 0; s < starCenters; s++) {
            // Star center point (only on one side of the mirror axis)
            let centerX, centerY;
            
            if (mirrorVertical) {
                // Left half only
                centerX = Math.floor(Math.random() * (canvas.width / 2));
                centerY = Math.floor(Math.random() * canvas.height);
            } else {
                // Top half only
                centerX = Math.floor(Math.random() * canvas.width);
                centerY = Math.floor(Math.random() * (canvas.height / 2));
            }
            
            // Number of rays for each star
            const rayCount = parameters.rayCount || Math.floor(Math.random() * 8) + 5; // 5-12 rays per star
            
            for (let r = 0; r < rayCount; r++) {
                // Ray angle
                const angle = (r / rayCount) * Math.PI * 2;
                
                // Ray direction
                let dx = Math.cos(angle);
                let dy = Math.sin(angle);
                
                // Ray length
                const length = parameters.rayLength || Math.floor(Math.random() * 120) + 60; // Longer rays
                
                // Draw ray
                let x = centerX;
                let y = centerY;
                
                // Store points for mirroring
                const rayPoints = [];
                
                for (let i = 0; i < length; i++) {
                    // Add some randomness to direction for more natural look
                    dx += (Math.random() - 0.5) * 0.3;
                    dy += (Math.random() - 0.5) * 0.3;
                    
                    // Normalize direction
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    dx /= magnitude;
                    dy /= magnitude;
                    
                    // Update position
                    x += dx;
                    y += dy;
                    
                    // Check bounds
                    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
                    
                    // Store point for mirroring
                    rayPoints.push({x: Math.floor(x), y: Math.floor(y)});
                    
                    // Apply crack (darken pixel more for star effect)
                    const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                    
                    // Darken more at the center, less at the edges
                    const distanceFromCenter = i / length;
                    const darknessFactor = parameters.darkness || 0.3 + (0.5 * (1 - distanceFromCenter));
                    
                    data[idx] *= darknessFactor;     // Red
                    data[idx + 1] *= darknessFactor; // Green
                    data[idx + 2] *= darknessFactor; // Blue
                    
                    // Add width to the crack (wider at the center)
                    const maxWidth = 1 + Math.floor((1 - distanceFromCenter) * 4); // Wider at center
                    for (let w = 1; w <= maxWidth; w++) {
                        // Perpendicular direction
                        const perpX = -dy;
                        const perpY = dx;
                        
                        // Points on both sides of the crack
                        const side1X = Math.floor(x + perpX * w);
                        const side1Y = Math.floor(y + perpY * w);
                        const side2X = Math.floor(x - perpX * w);
                        const side2Y = Math.floor(y - perpY * w);
                        
                        // Apply crack to side points if within bounds
                        if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                            const side1Idx = (side1Y * canvas.width + side1X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side1Idx] *= sideDarkness;
                            data[side1Idx + 1] *= sideDarkness;
                            data[side1Idx + 2] *= sideDarkness;
                        }
                        
                        if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                            const side2Idx = (side2Y * canvas.width + side2X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side2Idx] *= sideDarkness;
                            data[side2Idx + 1] *= sideDarkness;
                            data[side2Idx + 2] *= sideDarkness;
                        }
                    }
                }
                
                // Mirror the ray
                rayPoints.forEach(point => {
                    let mirrorX, mirrorY;
                    
                    if (mirrorVertical) {
                        // Mirror horizontally
                        mirrorX = canvas.width - point.x - 1;
                        mirrorY = point.y;
                    } else {
                        // Mirror vertically
                        mirrorX = point.x;
                        mirrorY = canvas.height - point.y - 1;
                    }
                    
                    // Apply mirrored ray
                    const mirrorIdx = (mirrorY * canvas.width + mirrorX) * 4;
                    
                    // Calculate distance from mirrored center
                    let mirrorCenterX, mirrorCenterY;
                    if (mirrorVertical) {
                        mirrorCenterX = canvas.width - centerX - 1;
                        mirrorCenterY = centerY;
                    } else {
                        mirrorCenterX = centerX;
                        mirrorCenterY = canvas.height - centerY - 1;
                    }
                    
                    const dx = point.x - centerX;
                    const dy = point.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = length;
                    const distanceFromCenter = Math.min(1, distance / maxDistance);
                    const darknessFactor = parameters.darkness || 0.3 + (0.5 * (1 - distanceFromCenter));
                    
                    data[mirrorIdx] *= darknessFactor;     // Red
                    data[mirrorIdx + 1] *= darknessFactor; // Green
                    data[mirrorIdx + 2] *= darknessFactor; // Blue
                    
                    // Add width to the mirrored ray
                    const maxWidth = 1 + Math.floor((1 - distanceFromCenter) * 4);
                    for (let w = 1; w <= maxWidth; w++) {
                        // Perpendicular direction (flipped for mirror)
                        const perpX = dy;
                        const perpY = dx;
                        
                        // Points on both sides of the mirrored ray
                        const side1X = Math.floor(mirrorX + perpX * w);
                        const side1Y = Math.floor(mirrorY + perpY * w);
                        const side2X = Math.floor(mirrorX - perpX * w);
                        const side2Y = Math.floor(mirrorY - perpY * w);
                        
                        // Apply crack to side points if within bounds
                        if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                            const side1Idx = (side1Y * canvas.width + side1X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side1Idx] *= sideDarkness;
                            data[side1Idx + 1] *= sideDarkness;
                            data[side1Idx + 2] *= sideDarkness;
                        }
                        
                        if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                            const side2Idx = (side2Y * canvas.width + side2X) * 4;
                            const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                            data[side2Idx] *= sideDarkness;
                            data[side2Idx + 1] *= sideDarkness;
                            data[side2Idx + 2] *= sideDarkness;
                        }
                    }
                });
            }
        }
        
        // Add many small connecting cracks between stars for more complexity
        const connectionCount = parameters.connectionCount || Math.floor(Math.random() * 20) + 15; // More connections
        
        for (let c = 0; c < connectionCount; c++) {
            // Random start point (on one side of the mirror axis)
            let startX, startY;
            
            if (mirrorVertical) {
                startX = Math.floor(Math.random() * (canvas.width / 2));
                startY = Math.floor(Math.random() * canvas.height);
            } else {
                startX = Math.floor(Math.random() * canvas.width);
                startY = Math.floor(Math.random() * (canvas.height / 2));
            }
            
            // Random end point (on the same side)
            let endX, endY;
            
            if (mirrorVertical) {
                endX = Math.floor(Math.random() * (canvas.width / 2));
                endY = Math.floor(Math.random() * canvas.height);
            } else {
                endX = Math.floor(Math.random() * canvas.width);
                endY = Math.floor(Math.random() * (canvas.height / 2));
            }
            
            // Calculate direction
            let dx = endX - startX;
            let dy = endY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dx /= distance;
            dy /= distance;
            
            // Draw connecting crack
            let x = startX;
            let y = startY;
            
            // Store points for mirroring
            const connectionPoints = [];
            
            const steps = Math.floor(distance);
            for (let i = 0; i < steps; i++) {
                // Add some randomness to direction
                dx += (Math.random() - 0.5) * 0.4;
                dy += (Math.random() - 0.5) * 0.4;
                
                // Normalize direction
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                dx /= magnitude;
                dy /= magnitude;
                
                // Update position
                x += dx;
                y += dy;
                
                // Check bounds
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
                
                // Store point for mirroring
                connectionPoints.push({x: Math.floor(x), y: Math.floor(y)});
                
                // Apply crack (less dark than star rays)
                const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                data[idx] *= 0.8;     // Red
                data[idx + 1] *= 0.8; // Green
                data[idx + 2] *= 0.8; // Blue
                
                // Add width to the crack
                const crackWidth = 1;
                for (let w = 1; w <= crackWidth; w++) {
                    // Perpendicular direction
                    const perpX = -dy;
                    const perpY = dx;
                    
                    // Points on both sides of the crack
                    const side1X = Math.floor(x + perpX * w);
                    const side1Y = Math.floor(y + perpY * w);
                    const side2X = Math.floor(x - perpX * w);
                    const side2Y = Math.floor(y - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        data[side1Idx] *= 0.85;
                        data[side1Idx + 1] *= 0.85;
                        data[side1Idx + 2] *= 0.85;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        data[side2Idx] *= 0.85;
                        data[side2Idx + 1] *= 0.85;
                        data[side2Idx + 2] *= 0.85;
                    }
                }
            }
            
            // Mirror the connection
            connectionPoints.forEach(point => {
                let mirrorX, mirrorY;
                
                if (mirrorVertical) {
                    // Mirror horizontally
                    mirrorX = canvas.width - point.x - 1;
                    mirrorY = point.y;
                } else {
                    // Mirror vertically
                    mirrorX = point.x;
                    mirrorY = canvas.height - point.y - 1;
                }
                
                // Apply mirrored connection
                const mirrorIdx = (mirrorY * canvas.width + mirrorX) * 4;
                data[mirrorIdx] *= 0.8;     // Red
                data[mirrorIdx + 1] *= 0.8; // Green
                data[mirrorIdx + 2] *= 0.8; // Blue
                
                // Add width to the mirrored connection
                const crackWidth = 1;
                for (let w = 1; w <= crackWidth; w++) {
                    // Perpendicular direction (flipped for mirror)
                    const perpX = dy;
                    const perpY = dx;
                    
                    // Points on both sides of the mirrored crack
                    const side1X = Math.floor(mirrorX + perpX * w);
                    const side1Y = Math.floor(mirrorY + perpY * w);
                    const side2X = Math.floor(mirrorX - perpX * w);
                    const side2Y = Math.floor(mirrorY - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        data[side1Idx] *= 0.85;
                        data[side1Idx + 1] *= 0.85;
                        data[side1Idx + 2] *= 0.85;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        data[side2Idx] *= 0.85;
                        data[side2Idx + 1] *= 0.85;
                        data[side2Idx + 2] *= 0.85;
                    }
                }
            });
        }
        
        // Add dense cracks along the mirror axis
        const axisCrackCount = parameters.axisCrackCount || Math.floor(Math.random() * 8) + 5; // More axis cracks
        
        for (let c = 0; c < axisCrackCount; c++) {
            let x, y;
            
            if (mirrorVertical) {
                // Along the vertical center line
                x = Math.floor(canvas.width / 2) + Math.floor(Math.random() * 20) - 10;
                y = Math.floor(Math.random() * canvas.height);
            } else {
                // Along the horizontal center line
                x = Math.floor(Math.random() * canvas.width);
                y = Math.floor(canvas.height / 2) + Math.floor(Math.random() * 20) - 10;
            }
            
            // Direction (mostly along the axis)
            let dx, dy;
            
            if (mirrorVertical) {
                dx = (Math.random() - 0.5) * 0.5; // Less horizontal movement
                dy = (Math.random() - 0.5) * 2;   // More vertical movement
            } else {
                dx = (Math.random() - 0.5) * 2;   // More horizontal movement
                dy = (Math.random() - 0.5) * 0.5; // Less vertical movement
            }
            
            // Length
            const length = parameters.axisCrackLength || Math.floor(Math.random() * 100) + 50; // Longer axis cracks
            
            // Draw crack along the axis
            for (let i = 0; i < length; i++) {
                // Add some randomness to direction
                dx += (Math.random() - 0.5) * 0.3;
                dy += (Math.random() - 0.5) * 0.3;
                
                // Normalize direction
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                dx /= magnitude;
                dy /= magnitude;
                
                // Update position
                x += dx;
                y += dy;
                
                // Check bounds
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
                
                // Apply crack (darken pixel more along the axis)
                const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                data[idx] *= 0.4;     // Red
                data[idx + 1] *= 0.4; // Green
                data[idx + 2] *= 0.4; // Blue
                
                // Add width to the crack
                const crackWidth = 1 + Math.floor(Math.random() * 3);
                for (let w = 1; w <= crackWidth; w++) {
                    // Perpendicular direction
                    const perpX = -dy;
                    const perpY = dx;
                    
                    // Points on both sides of the crack
                    const side1X = Math.floor(x + perpX * w);
                    const side1Y = Math.floor(y + perpY * w);
                    const side2X = Math.floor(x - perpX * w);
                    const side2Y = Math.floor(y - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        data[side1Idx] *= 0.6;
                        data[side1Idx + 1] *= 0.6;
                        data[side1Idx + 2] *= 0.6;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        data[side2Idx] *= 0.6;
                        data[side2Idx + 1] *= 0.6;
                        data[side2Idx + 2] *= 0.6;
                    }
                }
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply vintage effect with parameters
    applyVintageEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const sepiaIntensity = parameters.sepiaIntensity || 1.0;
        const noiseAmount = parameters.noiseAmount || 10;
        const vignetteStrength = parameters.vignetteStrength || 0.8;
        
        for (let i = 0; i < data.length; i += 4) {
            // Extract RGB
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Apply vintage effect (sepia + reduced contrast + vignette)
            data[i] = Math.min(255, (r * 0.393 * sepiaIntensity) + (g * 0.769 * sepiaIntensity) + (b * 0.189 * sepiaIntensity));     // Red
            data[i + 1] = Math.min(255, (r * 0.349 * sepiaIntensity) + (g * 0.686 * sepiaIntensity) + (b * 0.168 * sepiaIntensity)); // Green
            data[i + 2] = Math.min(255, (r * 0.272 * sepiaIntensity) + (g * 0.534 * sepiaIntensity) + (b * 0.131 * sepiaIntensity)); // Blue
            
            // Add some noise for vintage feel
            const noise = Math.random() * noiseAmount - noiseAmount / 2;
            data[i] = Math.min(255, Math.max(0, data[i] + noise));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Apply vignette
        this.applyVignetteEffect(canvas, ctx, { strength: vignetteStrength });
    }

    // Apply grayscale effect
    applyGrayscaleEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const method = parameters.method || 'luminance'; // 'luminance', 'average', 'desaturation'
        
        for (let i = 0; i < data.length; i += 4) {
            // Calculate grayscale using specified method
            let gray;
            
            switch (method) {
                case 'average':
                    gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    break;
                case 'desaturation':
                    const max = Math.max(data[i], data[i + 1], data[i + 2]);
                    const min = Math.min(data[i], data[i + 1], data[i + 2]);
                    gray = (max + min) / 2;
                    break;
                case 'luminance':
                default:
                    gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    break;
            }
            
            data[i] = gray;     // Red
            data[i + 1] = gray; // Green
            data[i + 2] = gray; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply sepia effect with parameters
    applySepiaEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        for (let i = 0; i < data.length; i += 4) {
            // Extract RGB
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Apply sepia transformation
            data[i] = Math.min(255, (r * 0.393 * intensity) + (g * 0.769 * intensity) + (b * 0.189 * intensity));     // Red
            data[i + 1] = Math.min(255, (r * 0.349 * intensity) + (g * 0.686 * intensity) + (b * 0.168 * intensity)); // Green
            data[i + 2] = Math.min(255, (r * 0.272 * intensity) + (g * 0.534 * intensity) + (b * 0.131 * intensity)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply blur effect with parameters
    applyBlurEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const blurAmount = parameters.blurAmount || parameters.intensity || 5;
        
        // Apply blur filter
        tempCtx.filter = `blur(${blurAmount}px)`;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Draw blurred image back to original canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
    }

    // Apply sharpen effect with parameters
    applySharpenEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        // Sharpen kernel
        const kernel = [
             0, -intensity,  0,
            -intensity, 1 + 4 * intensity, -intensity,
             0, -intensity,  0
        ];
        
        // Apply convolution
        for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let r = 0, g = 0, b = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                        
                        r += temp[kidx] * weight;
                        g += temp[kidx + 1] * weight;
                        b += temp[kidx + 2] * weight;
                    }
                }
                
                data[idx] = Math.min(255, Math.max(0, r));
                data[idx + 1] = Math.min(255, Math.max(0, g));
                data[idx + 2] = Math.min(255, Math.max(0, b));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply pixelate effect with parameters
    applyPixelateEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const pixelSize = parameters.pixelSize || 10;
        
        // Save original image
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw pixelated image
        for (let y = 0; y < canvas.height; y += pixelSize) {
            for (let x = 0; x < canvas.width; x += pixelSize) {
                // Get pixel color
                const pixelData = tempCtx.getImageData(x, y, 1, 1).data;
                
                // Draw pixel block
                ctx.fillStyle = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
                ctx.fillRect(x, y, pixelSize, pixelSize);
            }
        }
    }

    // Apply glitch effect with parameters
    applyGlitchEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        const colorShift = parameters.colorShift || 20;
        
        // Create RGB channels
        const rChannel = new Uint8ClampedArray(data.length / 4);
        const gChannel = new Uint8ClampedArray(data.length / 4);
        const bChannel = new Uint8ClampedArray(data.length / 4);
        
        // Extract channels
        for (let i = 0, j = 0; i < data.length; i += 4, j++) {
            rChannel[j] = data[i];
            gChannel[j] = data[i + 1];
            bChannel[j] = data[i + 2];
        }
        
        // Apply glitch effect (shift channels)
        const glitchHeight = Math.floor(canvas.height / 5);
        const glitchY = Math.floor(Math.random() * (canvas.height - glitchHeight));
        
        // Shift red channel
        const shiftR = Math.floor(Math.random() * colorShift * intensity) - colorShift / 2;
        for (let y = glitchY; y < glitchY + glitchHeight; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const srcIdx = y * canvas.width + x;
                const dstIdx = y * canvas.width + ((x + shiftR + canvas.width) % canvas.width);
                
                if (srcIdx < rChannel.length && dstIdx < rChannel.length) {
                    const temp = rChannel[srcIdx];
                    rChannel[srcIdx] = rChannel[dstIdx];
                    rChannel[dstIdx] = temp;
                }
            }
        }
        
        // Shift blue channel
        const shiftB = Math.floor(Math.random() * colorShift * intensity) - colorShift / 2;
        for (let y = glitchY; y < glitchY + glitchHeight; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const srcIdx = y * canvas.width + x;
                const dstIdx = y * canvas.width + ((x + shiftB + canvas.width) % canvas.width);
                
                if (srcIdx < bChannel.length && dstIdx < bChannel.length) {
                    const temp = bChannel[srcIdx];
                    bChannel[srcIdx] = bChannel[dstIdx];
                    bChannel[dstIdx] = temp;
                }
            }
        }
        
        // Recombine channels
        for (let i = 0, j = 0; i < data.length; i += 4, j++) {
            data[i] = rChannel[j];
            data[i + 1] = gChannel[j];
            data[i + 2] = bChannel[j];
        }
        
        // Add some random noise
        const noiseAmount = 0.05 * intensity;
        for (let i = 0; i < data.length; i += 4) {
            if (Math.random() < noiseAmount) {
                data[i] = Math.random() * 255;     // Red
                data[i + 1] = Math.random() * 255; // Green
                data[i + 2] = Math.random() * 255; // Blue
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply neon effect with parameters
    applyNeonEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const color = parameters.color || '#00ffff'; // Default cyan
        const glowSize = parameters.glowSize || 15;
        
        // Convert to grayscale
        this.applyGrayscaleEffect(canvas, ctx);
        
        // Invert colors
        this.applyInvertEffect(canvas, ctx);
        
        // Apply blur
        this.applyBlurEffect(canvas, ctx, { blurAmount: glowSize });
        
        // Get the processed image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply color dodge blending with original
        const originalData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const original = originalData.data;
        
        // Parse the neon color
        const r = parseInt(color.substr(1, 2), 16);
        const g = parseInt(color.substr(3, 2), 16);
        const b = parseInt(color.substr(5, 2), 16);
        
        for (let i = 0; i < data.length; i += 4) {
            // Color dodge formula
            data[i] = original[i] === 255 ? 255 : Math.min(255, (data[i] * 255) / (255 - original[i]));
            data[i + 1] = original[i + 1] === 255 ? 255 : Math.min(255, (data[i + 1] * 255) / (255 - original[i + 1]));
            data[i + 2] = original[i + 2] === 255 ? 255 : Math.min(255, (data[i + 2] * 255) / (255 - original[i + 2]));
            
            // Apply neon color tint
            data[i] = Math.min(255, data[i] * r / 255);
            data[i + 1] = Math.min(255, data[i + 1] * g / 255);
            data[i + 2] = Math.min(255, data[i + 2] * b / 255);
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply brightness effect with parameters
    applyBrightnessEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const brightness = parameters.brightness || 30; // Brightness adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, Math.max(0, data[i] + brightness));     // Red
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + brightness)); // Green
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + brightness)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply contrast effect with parameters
    applyContrastEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const contrast = parameters.contrast || 1.5; // Contrast adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            // Apply contrast formula
            data[i] = Math.min(255, Math.max(0, ((data[i] - 128) * contrast) + 128));     // Red
            data[i + 1] = Math.min(255, Math.max(0, ((data[i + 1] - 128) * contrast) + 128)); // Green
            data[i + 2] = Math.min(255, Math.max(0, ((data[i + 2] - 128) * contrast) + 128)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply saturation effect with parameters
    applySaturationEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const saturation = parameters.saturation || 1.5; // Saturation adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Convert to HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Adjust saturation
            s = Math.min(1, Math.max(0, s * saturation));
            
            // Convert back to RGB
            let r2, g2, b2;
            
            if (s === 0) {
                r2 = g2 = b2 = l; // Achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
            }
            
            data[i] = r2 * 255;
            data[i + 1] = g2 * 255;
            data[i + 2] = b2 * 255;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply hue shift effect with parameters
    applyHueEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const hueShift = parameters.hueShift || parameters.hue || 30; // Hue shift in degrees
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i] / 255;
            const g = data[i + 1] / 255;
            const b = data[i + 2] / 255;
            
            // Convert to HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Adjust hue
            h = (h + hueShift / 360) % 1;
            if (h < 0) h += 1;
            
            // Convert back to RGB
            let r2, g2, b2;
            
            if (s === 0) {
                r2 = g2 = b2 = l; // Achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
            }
            
            data[i] = r2 * 255;
            data[i + 1] = g2 * 255;
            data[i + 2] = b2 * 255;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply invert effect with parameters
    applyInvertEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] + (255 - data[i] * 2) * intensity;         // Red
            data[i + 1] = data[i + 1] + (255 - data[i + 1] * 2) * intensity; // Green
            data[i + 2] = data[i + 2] + (255 - data[i + 2] * 2) * intensity; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply edge detection effect with parameters
    applyEdgeDetectionEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const threshold = parameters.threshold || 50;
        const method = parameters.method || 'sobel'; // 'sobel', 'prewitt', 'roberts'
        
        let kernelX, kernelY;
        
        switch (method) {
            case 'prewitt':
                kernelX = [
                    -1, 0, 1,
                    -1, 0, 1,
                    -1, 0, 1
                ];
                
                kernelY = [
                    -1, -1, -1,
                     0,  0,  0,
                     1,  1,  1
                ];
                break;
            case 'roberts':
                kernelX = [
                    1, 0,
                    0, -1
                ];
                
                kernelY = [
                    0, 1,
                    -1, 0
                ];
                break;
            case 'sobel':
            default:
                kernelX = [
                    -1, 0, 1,
                    -2, 0, 2,
                    -1, 0, 1
                ];
                
                kernelY = [
                    -1, -2, -1,
                     0,  0,  0,
                     1,  2,  1
                ];
                break;
        }
        
        const kernelSize = method === 'roberts' ? 2 : 3;
        const offset = Math.floor(kernelSize / 2);
        
        // Apply convolution
        for (let y = offset; y < canvas.height - offset; y++) {
            for (let x = offset; x < canvas.width - offset; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let pixelX = 0;
                let pixelY = 0;
                
                for (let ky = -offset; ky <= offset; ky++) {
                    for (let kx = -offset; kx <= offset; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const gray = (temp[kidx] + temp[kidx + 1] + temp[kidx + 2]) / 3;
                        
                        const weightX = kernelX[(ky + offset) * kernelSize + (kx + offset)];
                        const weightY = kernelY[(ky + offset) * kernelSize + (kx + offset)];
                        
                        pixelX += gray * weightX;
                        pixelY += gray * weightY;
                    }
                }
                
                const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                const edge = magnitude > threshold ? 255 : 0;
                
                data[idx] = edge;
                data[idx + 1] = edge;
                data[idx + 2] = edge;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply emboss effect with parameters
    applyEmbossEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        
        // Emboss kernel
        const kernel = [
            -2 * intensity, -1 * intensity, 0,
            -1 * intensity, 1 * intensity, 1 * intensity,
            0, 1 * intensity, 2 * intensity
        ];
        
        // Apply convolution
        for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let r = 0, g = 0, b = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                        
                        r += temp[kidx] * weight;
                        g += temp[kidx + 1] * weight;
                        b += temp[kidx + 2] * weight;
                    }
                }
                
                // Add 128 to make it gray
                data[idx] = Math.min(255, Math.max(0, r + 128));
                data[idx + 1] = Math.min(255, Math.max(0, g + 128));
                data[idx + 2] = Math.min(255, Math.max(0, b + 128));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply oil painting effect with parameters
    applyOilPaintingEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Get parameters
        const radius = parameters.radius || 4;
        const intensity = parameters.intensity || 20;
        
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                // Initialize intensity count
                const intensityCount = new Array(intensity + 1).fill(0);
                const avgR = new Array(intensity + 1).fill(0);
                const avgG = new Array(intensity + 1).fill(0);
                const avgB = new Array(intensity + 1).fill(0);
                
                // Sample pixels in the radius
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const ny = y + dy;
                        const nx = x + dx;
                        
                        if (ny >= 0 && ny < canvas.height && nx >= 0 && nx < canvas.width) {
                            const nidx = (ny * canvas.width + nx) * 4;
                            
                            // Calculate intensity
                            const currR = temp[nidx];
                            const currG = temp[nidx + 1];
                            const currB = temp[nidx + 2];
                            const currIntensity = Math.round((currR + currG + currB) / 3 * intensity / 255);
                            
                            // Update counts and averages
                            intensityCount[currIntensity]++;
                            avgR[currIntensity] += currR;
                            avgG[currIntensity] += currG;
                            avgB[currIntensity] += currB;
                        }
                    }
                }
                
                // Find max intensity
                let maxIndex = 0;
                let maxCount = 0;
                
                for (let i = 0; i <= intensity; i++) {
                    if (intensityCount[i] > maxCount) {
                        maxCount = intensityCount[i];
                        maxIndex = i;
                    }
                }
                
                // Set pixel color
                data[idx] = avgR[maxIndex] / maxCount;
                data[idx + 1] = avgG[maxIndex] / maxCount;
                data[idx + 2] = avgB[maxIndex] / maxCount;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply cartoon effect with parameters
    applyCartoonEffect(canvas, ctx, parameters = {}) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const edgeThreshold = parameters.edgeThreshold || 50;
        const levels = parameters.levels || 4;
        
        // Apply edge detection to get edges
        this.applyEdgeDetectionEffect(canvas, ctx, { threshold: edgeThreshold });
        
        // Save edge data
        const edgeData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Restore original image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(originalCanvas, 0, 0);
        
        // Apply posterization to original image
        this.applyPosterizeEffect(canvas, ctx, { levels: levels });
        
        // Get posterized image data
        const posterizedData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const posterizedPixels = posterizedData.data;
        const edgePixels = edgeData.data;
        
        // Combine edges with posterized image
        for (let i = 0; i < posterizedPixels.length; i += 4) {
            // If edge pixel is white (edge detected), make it black
            if (edgePixels[i] > 200) { // Threshold for edge detection
                posterizedPixels[i] = 0;     // Red
                posterizedPixels[i + 1] = 0; // Green
                posterizedPixels[i + 2] = 0; // Blue
            }
            // Otherwise keep the posterized color
        }
        
        // Put the combined image back
        ctx.putImageData(posterizedData, 0, 0);
    }

    // Apply Ghibli-style effect with parameters
    applyGhibliEffect(canvas, ctx, parameters = {}) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const animationEnabled = parameters.animation !== false;
        
        // Step 1: Apply watercolor-style softening
        this.applyWatercolorEffect(canvas, ctx, parameters);
        
        // Step 2: Apply Ghibli color palette
        this.applyGhibliColorPalette(canvas, ctx, parameters);
        
        // Step 3: Add soft lighting effect
        this.applyGhibliLighting(canvas, ctx, parameters);
        
        // Step 4: Add subtle hand-drawn texture
        this.addHandDrawnTexture(canvas, ctx, parameters);
        
        // Step 5: Apply atmospheric perspective
        this.applyAtmosphericPerspective(canvas, ctx, parameters);
        
        // Step 6: Add animated elements if enabled
        if (animationEnabled) {
            this.addAnimatedGhibliElements(canvas, ctx, parameters);
        }
    }

    // Apply watercolor-style softening with parameters
    applyWatercolorEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a temporary canvas for processing
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Get parameters
        const blurAmount = parameters.blurAmount || 1;
        const blendAmount = parameters.blendAmount || 0.3;
        
        // Apply very subtle blur to soften edges
        tempCtx.filter = `blur(${blurAmount}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
        
        // Get the blurred image data
        const blurredData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Blend original and blurred for watercolor effect
        for (let i = 0; i < data.length; i += 4) {
            // Blend original with blurred
            data[i] = data[i] * (1 - blendAmount) + blurredPixels[i] * blendAmount;
            data[i + 1] = data[i + 1] * (1 - blendAmount) + blurredPixels[i + 1] * blendAmount;
            data[i + 2] = data[i + 2] * (1 - blendAmount) + blurredPixels[i + 2] * blendAmount;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply authentic Ghibli color palette with parameters
    applyGhibliColorPalette(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const blendAmount = parameters.blendAmount || 0.3;
        
        // Ghibli's signature colors: soft greens, blues, warm earth tones
        const ghibliPalette = [
            { r: 120, g: 170, b: 120 }, // Soft green
            { r: 100, g: 150, b: 200 }, // Sky blue
            { r: 220, g: 180, b: 140 }, // Warm beige
            { r: 180, g: 130, b: 100 }, // Earth brown
            { r: 150, g: 200, b: 180 }, // Mint green
            { r: 200, g: 160, b: 190 }, // Soft pink
            { r: 230, g: 210, b: 170 }, // Cream
            { r: 160, g: 190, b: 220 }  // Soft blue
        ];
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Find closest color in Ghibli palette
            let minDistance = Infinity;
            let closestColor = ghibliPalette[0];
            
            for (const color of ghibliPalette) {
                const distance = Math.sqrt(
                    Math.pow(r - color.r, 2) +
                    Math.pow(g - color.g, 2) +
                    Math.pow(b - color.b, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            
            // Blend original color with closest Ghibli color
            data[i] = r * (1 - blendAmount) + closestColor.r * blendAmount;
            data[i + 1] = g * (1 - blendAmount) + closestColor.g * blendAmount;
            data[i + 2] = b * (1 - blendAmount) + closestColor.b * blendAmount;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply Ghibli-style soft lighting with parameters
    applyGhibliLighting(canvas, ctx, parameters = {}) {
        // Create a soft gradient overlay for lighting
        const gradientCanvas = document.createElement('canvas');
        const gradientCtx = gradientCanvas.getContext('2d');
        gradientCanvas.width = canvas.width;
        gradientCanvas.height = canvas.height;
        
        // Get parameters
        const lightPosition = parameters.lightPosition || { x: 0.5, y: 0.33 }; // Default: upper center
        const lightRadius = parameters.lightRadius || 0.8;
        const lightIntensity = parameters.lightIntensity || 0.4;
        
        // Create radial gradient for soft lighting
        const centerX = canvas.width * lightPosition.x;
        const centerY = canvas.height * lightPosition.y;
        const radius = Math.max(canvas.width, canvas.height) * lightRadius;
        
        const gradient = gradientCtx.createRadialGradient(
            centerX, centerY, 0,
            centerX, centerY, radius
        );
        
        gradient.addColorStop(0, `rgba(255, 255, 220, ${lightIntensity})`); // Warm light center
        gradient.addColorStop(0.5, `rgba(255, 255, 200, ${lightIntensity * 0.5})`); // Mid-light
        gradient.addColorStop(1, 'rgba(200, 200, 180, 0)'); // Fade to transparent
        
        gradientCtx.fillStyle = gradient;
        gradientCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply lighting with soft-light blend mode
        ctx.globalCompositeOperation = 'soft-light';
        ctx.drawImage(gradientCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Add subtle hand-drawn texture with parameters
    addHandDrawnTexture(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create texture canvas
        const textureCanvas = document.createElement('canvas');
        const textureCtx = textureCanvas.getContext('2d');
        textureCanvas.width = canvas.width;
        textureCanvas.height = canvas.height;
        
        // Get parameters
        const paperTexture = parameters.paperTexture !== false;
        const pencilMarks = parameters.pencilMarks !== false;
        const textureIntensity = parameters.textureIntensity || 0.03;
        
        // Add subtle paper texture
        if (paperTexture) {
            textureCtx.fillStyle = `rgba(255, 255, 255, ${textureIntensity})`;
            textureCtx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Add very subtle pencil-like marks
        if (pencilMarks) {
            const markCount = parameters.markCount || 100;
            const markOpacity = parameters.markOpacity || 0.02;
            
            for (let i = 0; i < markCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const length = 5 + Math.random() * 15;
                const angle = Math.random() * Math.PI * 2;
                
                textureCtx.beginPath();
                textureCtx.moveTo(x, y);
                textureCtx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                
                textureCtx.strokeStyle = `rgba(100, 100, 100, ${markOpacity})`;
                textureCtx.lineWidth = 0.5;
                textureCtx.stroke();
            }
        }
        
        // Apply texture with overlay blend mode
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(textureCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply atmospheric perspective effect with parameters
    applyAtmosphericPerspective(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a subtle blue haze for distant elements
        const hazeCanvas = document.createElement('canvas');
        const hazeCtx = hazeCanvas.getContext('2d');
        hazeCanvas.width = canvas.width;
        hazeCanvas.height = canvas.height;
        
        // Get parameters
        const hazeColor = parameters.hazeColor || { r: 180, g: 200, b: 220 };
        const hazeIntensity = parameters.hazeIntensity || 0.1;
        const direction = parameters.direction || 'vertical'; // 'vertical' or 'horizontal'
        
        // Create gradient for atmospheric perspective
        let gradient;
        
        if (direction === 'horizontal') {
            gradient = hazeCtx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, 0)`);
            gradient.addColorStop(1, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, ${hazeIntensity})`);
        } else {
            gradient = hazeCtx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, ${hazeIntensity})`);
            gradient.addColorStop(1, `rgba(${hazeColor.r}, ${hazeColor.g}, ${hazeColor.b}, 0)`);
        }
        
        hazeCtx.fillStyle = gradient;
        hazeCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply haze with screen blend mode
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(hazeCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Add animated Ghibli-style elements with parameters
    addAnimatedGhibliElements(canvas, ctx, parameters = {}) {
        // Create a new canvas for animated elements
        const animationCanvas = document.createElement('canvas');
        const animationCtx = animationCanvas.getContext('2d');
        animationCanvas.width = canvas.width;
        animationCanvas.height = canvas.height;
        
        // Get parameters
        const sparklesEnabled = parameters.sparkles !== false;
        const cloudsEnabled = parameters.clouds !== false;
        const leavesEnabled = parameters.leaves !== false;
        
        // Function to draw animated elements
        const drawAnimation = (time) => {
            // Clear animation canvas
            animationCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
            
            // Draw animated sparkles (like Totoro's dust particles)
            if (sparklesEnabled) {
                this.drawAnimatedSparkles(animationCtx, animationCanvas.width, animationCanvas.height, time, parameters);
            }
            
            // Draw animated clouds
            if (cloudsEnabled) {
                this.drawAnimatedClouds(animationCtx, animationCanvas.width, animationCanvas.height, time, parameters);
            }
            
            // Draw animated leaves or petals
            if (leavesEnabled) {
                this.drawAnimatedLeaves(animationCtx, animationCanvas.width, animationCanvas.height, time, parameters);
            }
            
            // Apply animation to main canvas
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(animationCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            
            // Continue animation
            requestAnimationFrame(drawAnimation);
        };
        
        // Start animation
        requestAnimationFrame(drawAnimation);
    }

    // Draw animated sparkles with parameters
    drawAnimatedSparkles(ctx, width, height, time, parameters = {}) {
        // Get parameters
        const sparkleCount = parameters.sparkleCount || 20;
        const sparkleSize = parameters.sparkleSize || 3;
        const sparkleSpeed = parameters.sparkleSpeed || 0.002;
        
        for (let i = 0; i < sparkleCount; i++) {
            // Create pseudo-random but consistent positions based on i
            const x = (Math.sin(i * 12.9898 + 78.233) * 43758.5453) % 1 * width;
            const y = (Math.sin(i * 78.233 + 12.9898) * 43758.5453) % 1 * height;
            
            // Animate opacity
            const opacity = 0.3 + 0.7 * Math.abs(Math.sin(time * sparkleSpeed + i));
            
            // Draw sparkle
            ctx.beginPath();
            ctx.arc(x, y, sparkleSize, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 200, ${opacity})`;
            ctx.fill();
            
            // Draw sparkle rays
            ctx.beginPath();
            ctx.moveTo(x - sparkleSize * 2, y);
            ctx.lineTo(x + sparkleSize * 2, y);
            ctx.moveTo(x, y - sparkleSize * 2);
            ctx.lineTo(x, y + sparkleSize * 2);
            ctx.strokeStyle = `rgba(255, 255, 200, ${opacity * 0.7})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Draw animated clouds with parameters
    drawAnimatedClouds(ctx, width, height, time, parameters = {}) {
        // Get parameters
        const cloudCount = parameters.cloudCount || 3;
        const cloudSpeed = parameters.cloudSpeed || 0.0005;
        const cloudOpacity = parameters.cloudOpacity || 0.2;
        
        for (let i = 0; i < cloudCount; i++) {
            // Base position
            const baseX = (width / (cloudCount + 1)) * (i + 1);
            const baseY = height * 0.2;
            
            // Animate position
            const x = baseX + Math.sin(time * cloudSpeed + i) * 20;
            const y = baseY + Math.cos(time * cloudSpeed * 0.6 + i) * 5;
            
            // Draw cloud
            ctx.beginPath();
            
            // Cloud is made of several overlapping circles
            const cloudWidth = 60;
            const cloudHeight = 30;
            
            ctx.arc(x, y, cloudHeight, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.25, y - cloudHeight * 0.25, cloudHeight * 0.8, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.5, y, cloudHeight * 0.9, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.75, y - cloudHeight * 0.15, cloudHeight * 0.7, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth, y, cloudHeight * 0.8, 0, Math.PI * 2);
            
            // Semi-transparent white
            ctx.fillStyle = `rgba(255, 255, 255, ${cloudOpacity})`;
            ctx.fill();
        }
    }

    // Draw animated leaves/petals with parameters
    drawAnimatedLeaves(ctx, width, height, time, parameters = {}) {
        // Get parameters
        const leafCount = parameters.leafCount || 8;
        const fallSpeed = parameters.fallSpeed || 0.0001;
        const swayAmount = parameters.swayAmount || 30;
        const leafColor = parameters.leafColor || { r: 100, g: 150, b: 50 };
        
        for (let i = 0; i < leafCount; i++) {
            // Starting position (top of image)
            const startX = (width / (leafCount + 1)) * (i + 1);
            const startY = -20;
            
            // Calculate position based on time (falling motion)
            const fallProgress = ((time * fallSpeed + i * 0.2) % 1);
            const x = startX + Math.sin(fallProgress * Math.PI * 4) * swayAmount;
            const y = startY + (height + 40) * fallProgress;
            
            // Rotation
            const rotation = fallProgress * Math.PI * 2;
            
            // Draw leaf
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.bezierCurveTo(5, -5, 5, 5, 0, 10);
            ctx.bezierCurveTo(-5, 5, -5, -5, 0, -10);
            
            // Green with some variation
            const greenValue = leafColor.g + Math.sin(i) * 30;
            ctx.fillStyle = `rgba(${leafColor.r}, ${greenValue}, ${leafColor.b}, 0.6)`;
            ctx.fill();
            
            ctx.restore();
        }
    }

    // Apply mirror effect with parameters
    applyMirrorEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const direction = parameters.direction || 'horizontal'; // 'horizontal' or 'vertical'
        
        ctx.save();
        
        if (direction === 'horizontal') {
            // Flip horizontally
            ctx.scale(-1, 1);
            ctx.drawImage(tempCanvas, -canvas.width, 0);
        } else {
            // Flip vertically
            ctx.scale(1, -1);
            ctx.drawImage(tempCanvas, 0, -canvas.height);
        }
        
        ctx.restore();
    }

    // Apply rotate effect with parameters
    applyRotateEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const angle = parameters.rotation || parameters.angle || 90; // in degrees
        const radians = angle * Math.PI / 180;
        
        // Calculate new dimensions for rotated canvas
        const newWidth = Math.abs(canvas.width * Math.cos(radians)) + Math.abs(canvas.height * Math.sin(radians));
        const newHeight = Math.abs(canvas.width * Math.sin(radians)) + Math.abs(canvas.height * Math.cos(radians));
        
        // Resize canvas
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        // Rotate and draw
        ctx.save();
        ctx.translate(newWidth / 2, newHeight / 2);
        ctx.rotate(radians);
        ctx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
        ctx.restore();
    }

    // Apply crop effect with parameters
    applyCropEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const aspectRatio = parameters.aspectRatio || '1:1'; // Default to square
        const position = parameters.position || 'center'; // 'center', 'top', 'bottom', 'left', 'right'
        
        let cropWidth, cropHeight, cropX, cropY;
        
        // Calculate dimensions based on aspect ratio
        if (aspectRatio === 'original') {
            cropWidth = canvas.width;
            cropHeight = canvas.height;
        } else {
            const ratioParts = aspectRatio.split(':');
            const ratioW = parseInt(ratioParts[0]);
            const ratioH = parseInt(ratioParts[1]);
            
            if (canvas.width / canvas.height > ratioW / ratioH) {
                // Image is wider than ratio
                cropHeight = canvas.height;
                cropWidth = cropHeight * ratioW / ratioH;
            } else {
                // Image is taller than ratio
                cropWidth = canvas.width;
                cropHeight = cropWidth * ratioH / ratioW;
            }
        }
        
        // Calculate position based on parameter
        switch (position) {
            case 'top':
                cropX = (canvas.width - cropWidth) / 2;
                cropY = 0;
                break;
            case 'bottom':
                cropX = (canvas.width - cropWidth) / 2;
                cropY = canvas.height - cropHeight;
                break;
            case 'left':
                cropX = 0;
                cropY = (canvas.height - cropHeight) / 2;
                break;
            case 'right':
                cropX = canvas.width - cropWidth;
                cropY = (canvas.height - cropHeight) / 2;
                break;
            case 'center':
            default:
                cropX = (canvas.width - cropWidth) / 2;
                cropY = (canvas.height - cropHeight) / 2;
                break;
        }
        
        // Get the cropped image data
        const imageData = ctx.getImageData(cropX, cropY, cropWidth, cropHeight);
        
        // Resize canvas
        canvas.width = cropWidth;
        canvas.height = cropHeight;
        
        // Put the cropped image data back
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply vignette effect with parameters
    applyVignetteEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const strength = parameters.strength || parameters.vignetteStrength || 0.8;
        const radius = parameters.radius || 1.0;
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY) * radius;
        
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate vignette factor (1 at center, 0 at corners)
                const vignette = 1 - Math.pow(distance / maxDistance, 2) * strength;
                
                // Apply vignette
                const idx = (y * canvas.width + x) * 4;
                data[idx] *= vignette;
                data[idx + 1] *= vignette;
                data[idx + 2] *= vignette;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply noise effect with parameters
    applyNoiseEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const amount = parameters.noiseAmount || parameters.amount || 50; // Noise amount
        
        for (let i = 0; i < data.length; i += 4) {
            const noise = Math.random() * amount - amount / 2;
            
            data[i] = Math.min(255, Math.max(0, data[i] + noise));     // Red
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise)); // Green
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply posterize effect with parameters
    applyPosterizeEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const levels = parameters.levels || parameters.colorLevels || 4; // Number of color levels
        
        const step = 255 / (levels - 1);
        
        for (let i = 0; i < data.length; i += 4) {
            // Posterize each channel
            data[i] = Math.round(data[i] / step) * step;     // Red
            data[i + 1] = Math.round(data[i + 1] / step) * step; // Green
            data[i + 2] = Math.round(data[i + 2] / step) * step; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply solarize effect with parameters
    applySolarizeEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const threshold = parameters.threshold || 128; // Solarization threshold
        
        for (let i = 0; i < data.length; i += 4) {
            // Solarize each channel
            data[i] = data[i] < threshold ? data[i] : 255 - data[i];     // Red
            data[i + 1] = data[i + 1] < threshold ? data[i + 1] : 255 - data[i + 1]; // Green
            data[i + 2] = data[i + 2] < threshold ? data[i + 2] : 255 - data[i + 2]; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // NEW EFFECTS IMPLEMENTATION

    // Apply bokeh effect
    applyBokehEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const intensity = parameters.intensity || 0.7;
        const size = parameters.size || 15;
        const amount = parameters.amount || 30;
        
        // Apply blur to create depth of field
        this.applyBlurEffect(canvas, ctx, { blurAmount: size * 0.5 });
        
        // Get the blurred image data
        const blurredData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Restore original image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
        
        // Get original image data
        const originalData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const originalPixels = originalData.data;
        
        // Create bokeh circles (simulated)
        for (let i = 0; i < amount; i++) {
            const x = Math.floor(Math.random() * canvas.width);
            const y = Math.floor(Math.random() * canvas.height);
            const radius = Math.random() * size + 5;
            
            // Create gradient for bokeh circle
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Blend original and blurred with bokeh
        for (let i = 0; i < originalPixels.length; i += 4) {
            originalPixels[i] = originalPixels[i] * (1 - intensity) + blurredPixels[i] * intensity;
            originalPixels[i + 1] = originalPixels[i + 1] * (1 - intensity) + blurredPixels[i + 1] * intensity;
            originalPixels[i + 2] = originalPixels[i + 2] * (1 - intensity) + blurredPixels[i + 2] * intensity;
        }
        
        ctx.putImageData(originalData, 0, 0);
    }

    // Apply lens flare effect
    applyLensFlareEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const position = parameters.position || { x: 0.7, y: 0.3 }; // Default position
        const intensity = parameters.intensity || 0.8;
        const color = parameters.color || '#ffffff'; // Default white
        
        // Create lens flare overlay
        const flareCanvas = document.createElement('canvas');
        const flareCtx = flareCanvas.getContext('2d');
        flareCanvas.width = canvas.width;
        flareCanvas.height = canvas.height;
        
        // Calculate flare position
        const flareX = canvas.width * position.x;
        const flareY = canvas.height * position.y;
        
        // Parse color
        let r, g, b;
        if (color.startsWith('#')) {
            r = parseInt(color.substr(1, 2), 16);
            g = parseInt(color.substr(3, 2), 16);
            b = parseInt(color.substr(5, 2), 16);
        } else {
            r = g = b = 255; // Default to white
        }
        
        // Draw main flare point
        const mainGradient = flareCtx.createRadialGradient(flareX, flareY, 0, flareX, flareY, 50);
        mainGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity})`);
        mainGradient.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, ${intensity * 0.5})`);
        mainGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
        
        flareCtx.fillStyle = mainGradient;
        flareCtx.beginPath();
        flareCtx.arc(flareX, flareY, 50, 0, Math.PI * 2);
        flareCtx.fill();
        
        // Draw additional flare elements
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            const distance = 100 + i * 30;
            const elementX = flareX + Math.cos(angle) * distance;
            const elementY = flareY + Math.sin(angle) * distance;
            const elementSize = 10 + i * 2;
            
            const elementGradient = flareCtx.createRadialGradient(
                elementX, elementY, 0,
                elementX, elementY, elementSize
            );
            elementGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity * 0.7})`);
            elementGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            flareCtx.fillStyle = elementGradient;
            flareCtx.beginPath();
            flareCtx.arc(elementX, elementY, elementSize, 0, Math.PI * 2);
            flareCtx.fill();
        }
        
        // Draw flare streaks
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const length = 200 + Math.random() * 100;
            const endX = flareX + Math.cos(angle) * length;
            const endY = flareY + Math.sin(angle) * length;
            
            const streakGradient = flareCtx.createLinearGradient(flareX, flareY, endX, endY);
            streakGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${intensity * 0.5})`);
            streakGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            
            flareCtx.strokeStyle = streakGradient;
            flareCtx.lineWidth = 2 + Math.random() * 3;
            flareCtx.beginPath();
            flareCtx.moveTo(flareX, flareY);
            flareCtx.lineTo(endX, endY);
            flareCtx.stroke();
        }
        
        // Apply flare to main canvas with screen blend mode
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(flareCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply HDR effect
    applyHDREffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 1.5;
        const radius = parameters.radius || 15;
        
        // Create temporary canvas for Gaussian blur
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Apply Gaussian blur
        tempCtx.filter = `blur(${radius}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        
        // Get blurred image data
        const blurredData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Apply HDR effect
        for (let i = 0; i < data.length; i += 4) {
            // Get original and blurred pixel values
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            const blurR = blurredPixels[i];
            const blurG = blurredPixels[i + 1];
            const blurB = blurredPixels[i + 2];
            
            // Calculate detail (original - blurred)
            const detailR = r - blurR;
            const detailG = g - blurG;
            const detailB = b - blurB;
            
            // Apply HDR (original + detail * intensity)
            data[i] = Math.min(255, Math.max(0, r + detailR * intensity));
            data[i + 1] = Math.min(255, Math.max(0, g + detailG * intensity));
            data[i + 2] = Math.min(255, Math.max(0, b + detailB * intensity));
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply tilt shift effect
    applyTiltShiftEffect(canvas, ctx, parameters = {}) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const focusPosition = parameters.focusPosition || 0.5; // 0 to 1, position of focus line
        const focusSize = parameters.focusSize || 0.2; // 0 to 1, size of focus area
        const blurAmount = parameters.blurAmount || 10;
        const direction = parameters.direction || 'horizontal'; // 'horizontal' or 'vertical'
        
        // Create gradient mask for tilt shift
        const maskCanvas = document.createElement('canvas');
        const maskCtx = maskCanvas.getContext('2d');
        maskCanvas.width = canvas.width;
        maskCanvas.height = canvas.height;
        
        let gradient;
        
        if (direction === 'horizontal') {
            const focusY = canvas.height * focusPosition;
            const focusHeight = canvas.height * focusSize;
            
            gradient = maskCtx.createLinearGradient(0, focusY - focusHeight, 0, focusY + focusHeight);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.25, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.75, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
        } else {
            const focusX = canvas.width * focusPosition;
            const focusWidth = canvas.width * focusSize;
            
            gradient = maskCtx.createLinearGradient(focusX - focusWidth, 0, focusX + focusWidth, 0);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            gradient.addColorStop(0.25, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.75, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
        }
        
        maskCtx.fillStyle = gradient;
        maskCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply blur to entire image
        this.applyBlurEffect(canvas, ctx, { blurAmount: blurAmount });
        
        // Use mask to restore focus area
        ctx.globalCompositeOperation = 'destination-out';
        ctx.drawImage(maskCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
        
        // Draw original image in focus area
        ctx.save();
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(maskCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(tempCanvas, 0, 0);
        ctx.restore();
    }

    // Apply watercolor effect (standalone version)
    applyWatercolorEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const intensity = parameters.intensity || 0.7;
        const smoothing = parameters.smoothing || 3;
        
        // Create temporary canvas for processing
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Apply blur to soften edges
        tempCtx.filter = `blur(${smoothing}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
        
        // Get the blurred image data
        const blurredData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Create watercolor paper texture
        const textureCanvas = document.createElement('canvas');
        const textureCtx = textureCanvas.getContext('2d');
        textureCanvas.width = canvas.width;
        textureCanvas.height = canvas.height;
        
        // Add paper texture
        for (let i = 0; i < 1000; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 2;
            
            textureCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.05})`;
            textureCtx.beginPath();
            textureCtx.arc(x, y, size, 0, Math.PI * 2);
            textureCtx.fill();
        }
        
        // Blend original and blurred for watercolor effect
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] * (1 - intensity) + blurredPixels[i] * intensity;
            data[i + 1] = data[i + 1] * (1 - intensity) + blurredPixels[i + 1] * intensity;
            data[i + 2] = data[i + 2] * (1 - intensity) + blurredPixels[i + 2] * intensity;
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Apply texture with overlay blend mode
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(textureCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply sketch effect
    applySketchEffect(canvas, ctx, parameters = {}) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Get parameters
        const intensity = parameters.intensity || 1.0;
        const method = parameters.method || 'pencil'; // 'pencil', 'charcoal'
        
        // Convert to grayscale
        this.applyGrayscaleEffect(canvas, ctx);
        
        // Invert colors
        this.applyInvertEffect(canvas, ctx);
        
        // Apply blur
        this.applyBlurEffect(canvas, ctx, { blurAmount: 5 });
        
        // Get the processed image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply color dodge blending with original
        const originalData = originalCtx.getImageData(0, 0, canvas.width, canvas.height);
        const original = originalData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            // Color dodge formula
            data[i] = original[i] === 255 ? 255 : Math.min(255, (data[i] * 255) / (255 - original[i]));
            data[i + 1] = original[i + 1] === 255 ? 255 : Math.min(255, (data[i + 1] * 255) / (255 - original[i + 1]));
            data[i + 2] = original[i + 2] === 255 ? 255 : Math.min(255, (data[i + 2] * 255) / (255 - original[i + 2]));
            
            // Adjust for sketch effect
            if (method === 'charcoal') {
                // Charcoal effect is darker with more contrast
                data[i] = Math.min(255, data[i] * intensity * 0.8);
                data[i + 1] = Math.min(255, data[i + 1] * intensity * 0.8);
                data[i + 2] = Math.min(255, data[i + 2] * intensity * 0.8);
            } else {
                // Pencil effect
                data[i] = Math.min(255, data[i] * intensity);
                data[i + 1] = Math.min(255, data[i + 1] * intensity);
                data[i + 2] = Math.min(255, data[i + 2] * intensity);
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Add paper texture for more realistic sketch
        const textureCanvas = document.createElement('canvas');
        const textureCtx = textureCanvas.getContext('2d');
        textureCanvas.width = canvas.width;
        textureCanvas.height = canvas.height;
        
        // Add paper texture
        for (let i = 0; i < 500; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 1.5;
            
            textureCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.1})`;
            textureCtx.beginPath();
            textureCtx.arc(x, y, size, 0, Math.PI * 2);
            textureCtx.fill();
        }
        
        // Apply texture with overlay blend mode
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(textureCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }

    // Apply double exposure effect
    applyDoubleExposureEffect(canvas, ctx, parameters = {}) {
        // Get parameters
        const blendMode = parameters.blendMode || 'screen'; // 'screen', 'multiply', 'overlay'
        const secondImage = parameters.secondImage || null;
        
        if (!secondImage) {
            // If no second image is provided, create a pattern
            const patternCanvas = document.createElement('canvas');
            const patternCtx = patternCanvas.getContext('2d');
            patternCanvas.width = canvas.width;
            patternCanvas.height = canvas.height;
            
            // Create a pattern (e.g., trees, mountains, etc.)
            const patternType = parameters.patternType || 'mountains';
            
            switch (patternType) {
                case 'mountains':
                    this.drawMountainPattern(patternCtx, patternCanvas.width, patternCanvas.height);
                    break;
                case 'trees':
                    this.drawTreePattern(patternCtx, patternCanvas.width, patternCanvas.height);
                    break;
                case 'city':
                    this.drawCityPattern(patternCtx, patternCanvas.width, patternCanvas.height);
                    break;
                default:
                    this.drawMountainPattern(patternCtx, patternCanvas.width, patternCanvas.height);
            }
            
            // Apply pattern with blend mode
            ctx.globalCompositeOperation = blendMode;
            ctx.drawImage(patternCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
        } else {
            // If a second image is provided, use it
            const img = new Image();
            img.onload = () => {
                // Scale second image to fit canvas
                const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
                const width = img.width * scale;
                const height = img.height * scale;
                const x = (canvas.width - width) / 2;
                const y = (canvas.height - height) / 2;
                
                // Apply second image with blend mode
                ctx.globalCompositeOperation = blendMode;
                ctx.drawImage(img, x, y, width, height);
                ctx.globalCompositeOperation = 'source-over';
            };
            img.src = secondImage;
        }
    }

    // Draw mountain pattern for double exposure
    drawMountainPattern(ctx, width, height) {
        // Create gradient for sky
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, '#1a237e');
        skyGradient.addColorStop(1, '#4a148c');
        
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw mountains
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.moveTo(0, height * 0.7);
        
        // First mountain range
        for (let x = 0; x <= width; x += 20) {
            const y = height * 0.7 - Math.sin(x * 0.01) * height * 0.3;
            ctx.lineTo(x, y);
        }
        
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
        
        // Second mountain range
        ctx.fillStyle = '#111';
        ctx.beginPath();
        ctx.moveTo(0, height * 0.8);
        
        for (let x = 0; x <= width; x += 20) {
            const y = height * 0.8 - Math.sin(x * 0.02 + 1) * height * 0.2;
            ctx.lineTo(x, y);
        }
        
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
        
        // Add stars
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height * 0.6;
            const size = Math.random() * 2;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Draw tree pattern for double exposure
    drawTreePattern(ctx, width, height) {
        // Create gradient for sky
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, '#0d47a1');
        skyGradient.addColorStop(1, '#1b5e20');
        
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw trees
        const treeCount = 15;
        
        for (let i = 0; i < treeCount; i++) {
            const x = (width / treeCount) * i + Math.random() * (width / treeCount);
            const treeHeight = height * 0.3 + Math.random() * height * 0.4;
            const treeWidth = treeHeight * 0.3;
            
            // Draw trunk
            ctx.fillStyle = '#3e2723';
            ctx.fillRect(x - treeWidth * 0.1, height - treeHeight * 0.3, treeWidth * 0.2, treeHeight * 0.3);
            
            // Draw leaves
            ctx.fillStyle = '#1b5e20';
            ctx.beginPath();
            ctx.moveTo(x, height - treeHeight);
            ctx.lineTo(x - treeWidth, height - treeHeight * 0.7);
            ctx.lineTo(x - treeWidth * 0.5, height - treeHeight * 0.7);
            ctx.lineTo(x - treeWidth * 0.7, height - treeHeight * 0.4);
            ctx.lineTo(x, height - treeHeight * 0.3);
            ctx.lineTo(x + treeWidth * 0.7, height - treeHeight * 0.4);
            ctx.lineTo(x + treeWidth * 0.5, height - treeHeight * 0.7);
            ctx.lineTo(x + treeWidth, height - treeHeight * 0.7);
            ctx.closePath();
            ctx.fill();
        }
    }

    // Draw city pattern for double exposure
    drawCityPattern(ctx, width, height) {
        // Create gradient for sky
        const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
        skyGradient.addColorStop(0, '#263238');
        skyGradient.addColorStop(1, '#000');
        
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw buildings
        const buildingCount = 20;
        const maxHeight = height * 0.8;
        
        for (let i = 0; i < buildingCount; i++) {
            const buildingWidth = width / buildingCount + Math.random() * 10;
            const x = (width / buildingCount) * i;
            const buildingHeight = Math.random() * maxHeight;
            
            // Draw building
            ctx.fillStyle = '#212121';
            ctx.fillRect(x, height - buildingHeight, buildingWidth, buildingHeight);
            
            // Draw windows
            const windowRows = Math.floor(buildingHeight / 20);
            const windowCols = Math.floor(buildingWidth / 10);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    if (Math.random() > 0.3) { // 70% chance of lit window
                        ctx.fillStyle = '#ffeb3b';
                        ctx.fillRect(
                            x + col * 10 + 2,
                            height - buildingHeight + row * 20 + 5,
                            6,
                            10
                        );
                    }
                }
            }
        }
    }

    // Apply color pop effect
    applyColorPopEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const colorToPop = parameters.color || '#ff0000'; // Default red
        const tolerance = parameters.tolerance || 30; // Color matching tolerance
        const desaturationAmount = parameters.desaturationAmount || 0.8; // How much to desaturate other colors
        
        // Parse the color to pop
        let r, g, b;
        if (colorToPop.startsWith('#')) {
            r = parseInt(colorToPop.substr(1, 2), 16);
            g = parseInt(colorToPop.substr(3, 2), 16);
            b = parseInt(colorToPop.substr(5, 2), 16);
        } else {
            r = g = b = 255; // Default to white if invalid color
        }
        
        // Convert to grayscale first
        for (let i = 0; i < data.length; i += 4) {
            // Calculate grayscale using luminance formula
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            
            // Apply partial desaturation
            data[i] = data[i] * (1 - desaturationAmount) + gray * desaturationAmount;
            data[i + 1] = data[i + 1] * (1 - desaturationAmount) + gray * desaturationAmount;
            data[i + 2] = data[i + 2] * (1 - desaturationAmount) + gray * desaturationAmount;
        }
        
        // Restore the selected color
        for (let i = 0; i < data.length; i += 4) {
            // Check if pixel matches the color to pop within tolerance
            const pixelR = data[i];
            const pixelG = data[i + 1];
            const pixelB = data[i + 2];
            
            const distance = Math.sqrt(
                Math.pow(pixelR - r, 2) +
                Math.pow(pixelG - g, 2) +
                Math.pow(pixelB - b, 2)
            );
            
            if (distance < tolerance) {
                // Restore original color (we don't have it anymore, so use the target color)
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }

    // Apply retro effect
    applyRetroEffect(canvas, ctx, parameters = {}) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Get parameters
        const colorPalette = parameters.colorPalette || 'warm'; // 'warm', 'cool', 'vintage'
        const scanLines = parameters.scanLines !== false;
        const vignette = parameters.vignette !== false;
        const noise = parameters.noise !== false;
        
        // Define color palettes
        let palette;
        
        switch (colorPalette) {
            case 'cool':
                palette = [
                    { r: 50, g: 100, b: 150 },
                    { r: 100, g: 150, b: 200 },
                    { r: 150, g: 200, b: 220 },
                    { r: 200, g: 220, b: 240 }
                ];
                break;
            case 'vintage':
                palette = [
                    { r: 180, g: 140, b: 100 },
                    { r: 200, g: 170, b: 130 },
                    { r: 220, g: 190, b: 150 },
                    { r: 240, g: 210, b: 170 }
                ];
                break;
            case 'warm':
            default:
                palette = [
                    { r: 200, g: 100, b: 50 },
                    { r: 220, g: 130, b: 80 },
                    { r: 240, g: 160, b: 110 },
                    { r: 255, g: 190, b: 140 }
                ];
                break;
        }
        
        // Apply color palette
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Find closest color in palette
            let minDistance = Infinity;
            let closestColor = palette[0];
            
            for (const color of palette) {
                const distance = Math.sqrt(
                    Math.pow(r - color.r, 2) +
                    Math.pow(g - color.g, 2) +
                    Math.pow(b - color.b, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            
            // Apply closest color
            data[i] = closestColor.r;
            data[i + 1] = closestColor.g;
            data[i + 2] = closestColor.b;
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Add scan lines
        if (scanLines) {
            const scanLineCanvas = document.createElement('canvas');
            const scanLineCtx = scanLineCanvas.getContext('2d');
            scanLineCanvas.width = canvas.width;
            scanLineCanvas.height = canvas.height;
            
            // Draw scan lines
            scanLineCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            scanLineCtx.lineWidth = 1;
            
            for (let y = 0; y < canvas.height; y += 3) {
                scanLineCtx.beginPath();
                scanLineCtx.moveTo(0, y);
                scanLineCtx.lineTo(canvas.width, y);
                scanLineCtx.stroke();
            }
            
            // Apply scan lines
            ctx.globalCompositeOperation = 'overlay';
            ctx.drawImage(scanLineCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // Add vignette
        if (vignette) {
            this.applyVignetteEffect(canvas, ctx, { strength: 0.8 });
        }
        
        // Add noise
        if (noise) {
            this.applyNoiseEffect(canvas, ctx, { amount: 20 });
        }
    }

    // Create edited filename with effect suffix
    createEditedFilename(originalFilename, effect) {
        // Extract filename without extension
        const nameParts = originalFilename.split('.');
        const name = nameParts.slice(0, -1).join('.');
        const extension = nameParts.length > 1 ? nameParts[nameParts.length - 1] : 'jpg';
        
        // Add effect suffix
        return `${name}_${effect}.${extension}`;
    }

    // Download edited image automatically
    downloadEditedImage(canvas, filename) {
        try {
            // Convert canvas to blob
            canvas.toBlob((blob) => {
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }, 'image/jpeg', 0.9);
            
        } catch (error) {
            console.error("Download Error:", error);
            // Fallback to manual download
            this.fallbackDownload(canvas, filename);
        }
    }

    // Fallback download method
    fallbackDownload(canvas, filename) {
        // Convert to data URL
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        
        // Create download link
        const downloadLink = document.createElement('a');
        downloadLink.href = dataUrl;
        downloadLink.download = filename;
        downloadLink.textContent = `Download ${filename}`;
        downloadLink.className = 'download-button';
        downloadLink.style.cssText = `
            display: inline-block;
            background: #2196F3;
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 4px;
            margin-top: 10px;
        `;
        
        // Add to chat
        botReply("Your edited image is ready:");
        const messageContainer = document.createElement('div');
        messageContainer.appendChild(downloadLink);
        document.querySelector('.chat-messages').appendChild(messageContainer);
        
        // Scroll to bottom
        document.querySelector('.chat-container').scrollTop = document.querySelector('.chat-container').scrollHeight;
    }

    // Show download notification
    showDownloadNotification(filename) {
        this.downloadNotification.innerHTML = `
            <div style="display: flex; align-items: center;">
                <svg style="width:24px; height:24px; margin-right:10px;" fill="white" viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
                <div>
                    <div style="font-weight: bold;">Download Complete!</div>
                    <div style="font-size: 0.9em;">${filename}</div>
                </div>
            </div>
        `;
        
        this.downloadNotification.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            this.downloadNotification.style.display = 'none';
        }, 5000);
    }

    // Auto-enhancement function
    autoEnhance(canvas, ctx) {
        // Get image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply auto-levels
        this.autoAdjustLevels(data);
        
        // Put enhanced data back
        ctx.putImageData(imageData, 0, 0);
    }

    // Auto-levels adjustment
    autoAdjustLevels(data) {
        // Calculate histogram
        const histogram = { r: [], g: [], b: [] };
        
        // Initialize histogram arrays
        for (let i = 0; i < 256; i++) {
            histogram.r[i] = 0;
            histogram.g[i] = 0;
            histogram.b[i] = 0;
        }
        
        // Populate histogram
        for (let i = 0; i < data.length; i += 4) {
            histogram.r[data[i]]++;
            histogram.g[data[i + 1]]++;
            histogram.b[data[i + 2]]++;
        }
        
        // Find min and max for each channel
        const findMinMax = (hist) => {
            let min = 0;
            let max = 255;
            
            // Find min (ignore 1% of pixels)
            const totalPixels = data.length / 4;
            const ignoreCount = totalPixels * 0.01;
            let count = 0;
            
            for (let i = 0; i < 256; i++) {
                count += hist[i];
                if (count > ignoreCount) {
                    min = i;
                    break;
                }
            }
            
            // Find max (ignore 1% of pixels)
            count = 0;
            for (let i = 255; i >= 0; i--) {
                count += hist[i];
                if (count > ignoreCount) {
                    max = i;
                    break;
                }
            }
            
            return { min, max };
        };
        
        const rMinMax = findMinMax(histogram.r);
        const gMinMax = findMinMax(histogram.g);
        const bMinMax = findMinMax(histogram.b);
        
        // Apply levels adjustment
        for (let i = 0; i < data.length; i += 4) {
            // Red channel
            data[i] = this.adjustLevel(data[i], rMinMax.min, rMinMax.max);
            
            // Green channel
            data[i + 1] = this.adjustLevel(data[i + 1], gMinMax.min, gMinMax.max);
            
            // Blue channel
            data[i + 2] = this.adjustLevel(data[i + 2], bMinMax.min, bMinMax.max);
        }
    }

    // Adjust single color level
    adjustLevel(value, min, max) {
        if (min === max) return value;
        return Math.min(255, Math.max(0, (value - min) * 255 / (max - min)));
    }
}


// Initialize photo editor
const photoEditor = new PhotoEditor();

// Trigger photo editing when user requests it
if (/edit photo/i.test(userInputRaw)) {
    photoEditor.triggerPhotoEdit(userInputRaw);
    return;
}




class CalculatorScreen {
    constructor() {
        this.calculator = {
            name: 'ADVANCED CALCULATOR',
            instructions: 'Perform basic and advanced calculations including GST, tax, square root, and more.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.display = null;
        this.expressionDisplay = null;
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.activeButton = null;
        this.memory = 0; // For memory functions
        this.gstRates = {
            gst1: 5,    // 5% GST
            gst2: 12,   // 12% GST
            gst3: 18,   // 18% GST
            gst4: 28    // 28% GST
        };
    }
    
    /**
     * Load the Calculator
     */
    loadCalculator() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.calculator.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create calculator
        this.createCalculator();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the calculator
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.calculator.name} loaded! ${this.calculator.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Calculator UI
     */
    createCalculator() {
        // Create calculator container
        const calculatorContainer = document.createElement('div');
        calculatorContainer.style.cssText = `
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 360px;
            max-width: 90vw;
        `;
        
        // Create display container
        const displayContainer = document.createElement('div');
        displayContainer.style.cssText = `
            background-color: #222;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: right;
            color: white;
            font-family: 'Courier New', monospace;
        `;
        
        // Create expression display (shows the operation)
        this.expressionDisplay = document.createElement('div');
        this.expressionDisplay.style.cssText = `
            font-size: 16px;
            color: #aaa;
            min-height: 20px;
            margin-bottom: 5px;
        `;
        this.expressionDisplay.textContent = '';
        
        // Create main display (shows current number)
        this.display = document.createElement('div');
        this.display.style.cssText = `
            font-size: 28px;
            font-weight: bold;
            min-height: 30px;
            word-wrap: break-word;
            word-break: break-all;
        `;
        this.display.textContent = this.currentValue;
        
        displayContainer.appendChild(this.expressionDisplay);
        displayContainer.appendChild(this.display);
        calculatorContainer.appendChild(displayContainer);
        
        // Create buttons grid
        const buttonsGrid = document.createElement('div');
        buttonsGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-gap: 8px;
        `;
        
        // Define buttons
        const buttons = [
            // Row 1
            { label: 'C', action: 'clear', className: 'btn-clear' },
            { label: '⌫', action: 'backspace', className: 'btn-backspace' },
            { label: '√', action: 'sqrt', className: 'btn-advanced' },
            { label: 'x²', action: 'square', className: 'btn-advanced' },
            { label: '÷', action: 'divide', className: 'btn-operator' },
            
            // Row 2
            { label: '7', action: 'number', className: 'btn-number' },
            { label: '8', action: 'number', className: 'btn-number' },
            { label: '9', action: 'number', className: 'btn-number' },
            { label: '%', action: 'percent', className: 'btn-advanced' },
            { label: '×', action: 'multiply', className: 'btn-operator' },
            
            // Row 3
            { label: '4', action: 'number', className: 'btn-number' },
            { label: '5', action: 'number', className: 'btn-number' },
            { label: '6', action: 'number', className: 'btn-number' },
            { label: '1/x', action: 'reciprocal', className: 'btn-advanced' },
            { label: '-', action: 'subtract', className: 'btn-operator' },
            
            // Row 4
            { label: '1', action: 'number', className: 'btn-number' },
            { label: '2', action: 'number', className: 'btn-number' },
            { label: '3', action: 'number', className: 'btn-number' },
            { label: 'Tax', action: 'tax', className: 'btn-advanced' },
            { label: '+', action: 'add', className: 'btn-operator' },
            
            // Row 5
            { label: '0', action: 'number', className: 'btn-number', colSpan: 2 },
            { label: '.', action: 'decimal', className: 'btn-number' },
            { label: '=', action: 'equals', className: 'btn-equals', rowSpan: 2 },
            
            // Row 6 (GST buttons)
            { label: 'GST1', action: 'gst1', className: 'btn-gst' },
            { label: 'GST2', action: 'gst2', className: 'btn-gst' },
            { label: 'GST3', action: 'gst3', className: 'btn-gst' },
            { label: 'GST4', action: 'gst4', className: 'btn-gst' },
        ];
        
        // Create buttons
        buttons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.className = button.className;
            btn.style.cssText = this.getButtonStyle(button);
            
            // Set grid row/column span if specified
            if (button.rowSpan) {
                btn.style.gridRow = `span ${button.rowSpan}`;
            }
            if (button.colSpan) {
                btn.style.gridColumn = `span ${button.colSpan}`;
            }
            
            // Add event listeners for better responsiveness
            this.addButtonEventListeners(btn, button.action, button.label);
            
            buttonsGrid.appendChild(btn);
        });
        
        calculatorContainer.appendChild(buttonsGrid);
        this.gameContainer.appendChild(calculatorContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Add event listeners to buttons for better responsiveness
     */
    addButtonEventListeners(button, action, label) {
        // Use both mousedown and touchstart for immediate response
        const handleInteraction = (e) => {
            e.preventDefault(); // Prevent default to avoid delays
            this.handleButtonClick(action, label);
            
            // Visual feedback
            this.activeButton = button;
            button.style.transform = 'scale(0.95)';
            button.style.opacity = '0.8';
        };
        
        const handleRelease = () => {
            if (this.activeButton === button) {
                button.style.transform = '';
                button.style.opacity = '';
                this.activeButton = null;
            }
        };
        
        // Mouse events
        button.addEventListener('mousedown', handleInteraction);
        button.addEventListener('mouseup', handleRelease);
        button.addEventListener('mouseleave', handleRelease);
        
        // Touch events
        button.addEventListener('touchstart', handleInteraction, { passive: false });
        button.addEventListener('touchend', handleRelease);
        button.addEventListener('touchcancel', handleRelease);
    }
    
    /**
     * Get button style based on button type
     */
    getButtonStyle(button) {
        const baseStyle = `
            padding: 18px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        `;
        
        switch (button.className) {
            case 'btn-clear':
            case 'btn-backspace':
                return baseStyle + `
                    background-color: #f44336;
                    color: white;
                `;
            case 'btn-operator':
                return baseStyle + `
                    background-color: #ff9800;
                    color: white;
                `;
            case 'btn-equals':
                return baseStyle + `
                    background-color: #4CAF50;
                    color: white;
                `;
            case 'btn-advanced':
                return baseStyle + `
                    background-color: #9c27b0;
                    color: white;
                `;
            case 'btn-gst':
                return baseStyle + `
                    background-color: #3f51b5;
                    color: white;
                `;
            case 'btn-number':
            default:
                return baseStyle + `
                    background-color: #555;
                    color: white;
                `;
        }
    }
    
    /**
     * Handle button click
     */
    handleButtonClick(action, label) {
        // Add a small delay to prevent double-taps from registering twice
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        this.buttonTimeout = setTimeout(() => {
            switch (action) {
                case 'number':
                    this.inputNumber(label);
                    break;
                case 'decimal':
                    this.inputDecimal();
                    break;
                case 'clear':
                    this.clear();
                    break;
                case 'backspace':
                    this.backspace();
                    break;
                case 'add':
                    this.setOperation('+');
                    break;
                case 'subtract':
                    this.setOperation('-');
                    break;
                case 'multiply':
                    this.setOperation('*');
                    break;
                case 'divide':
                    this.setOperation('/');
                    break;
                case 'equals':
                    this.calculate();
                    break;
                // Advanced functions
                case 'sqrt':
                    this.squareRoot();
                    break;
                case 'square':
                    this.square();
                    break;
                case 'percent':
                    this.percent();
                    break;
                case 'reciprocal':
                    this.reciprocal();
                    break;
                case 'tax':
                    this.applyTax();
                    break;
                // GST functions
                case 'gst1':
                    this.applyGST('gst1');
                    break;
                case 'gst2':
                    this.applyGST('gst2');
                    break;
                case 'gst3':
                    this.applyGST('gst3');
                    break;
                case 'gst4':
                    this.applyGST('gst4');
                    break;
            }
            this.buttonTimeout = null;
        }, 10);
    }
    
    /**
     * Input a number
     */
    inputNumber(num) {
        if (this.waitingForOperand) {
            this.currentValue = num;
            this.waitingForOperand = false;
        } else {
            this.currentValue = this.currentValue === '0' ? num : this.currentValue + num;
        }
        this.updateDisplay();
    }
    
    /**
     * Input a decimal point
     */
    inputDecimal() {
        if (this.waitingForOperand) {
            this.currentValue = '0.';
            this.waitingForOperand = false;
        } else if (this.currentValue.indexOf('.') === -1) {
            this.currentValue += '.';
        }
        this.updateDisplay();
    }
    
    /**
     * Clear the calculator
     */
    clear() {
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.updateDisplay();
        this.updateExpressionDisplay();
    }
    
    /**
     * Backspace - remove last digit
     */
    backspace() {
        if (this.currentValue.length > 1) {
            this.currentValue = this.currentValue.slice(0, -1);
        } else {
            this.currentValue = '0';
        }
        this.updateDisplay();
    }
    
    /**
     * Set the operation
     */
    setOperation(nextOperation) {
        const inputValue = parseFloat(this.currentValue);
        
        if (this.previousValue === '') {
            this.previousValue = inputValue;
        } else if (this.operation) {
            const currentValue = this.previousValue || 0;
            const newValue = this.performCalculation();
            
            this.currentValue = String(newValue);
            this.previousValue = newValue;
            this.updateDisplay();
        }
        
        this.waitingForOperand = true;
        this.operation = nextOperation;
        this.updateExpressionDisplay();
    }
    
    /**
     * Perform the calculation
     */
    calculate() {
        const inputValue = parseFloat(this.currentValue);
        
        if (this.previousValue !== '' && this.operation) {
            const newValue = this.performCalculation();
            this.currentValue = String(newValue);
            this.previousValue = '';
            this.operation = null;
            this.waitingForOperand = true;
            this.updateDisplay();
            this.updateExpressionDisplay();
        }
    }
    
    /**
     * Perform the actual calculation
     */
    performCalculation() {
        const prev = parseFloat(this.previousValue);
        const current = parseFloat(this.currentValue);
        
        switch (this.operation) {
            case '+':
                return prev + current;
            case '-':
                return prev - current;
            case '*':
                return prev * current;
            case '/':
                if (current === 0) {
                    this.showError('Error: Division by zero');
                    return 0;
                }
                return prev / current;
            default:
                return current;
        }
    }
    
    /**
     * Square root function
     */
    squareRoot() {
        const value = parseFloat(this.currentValue);
        if (value < 0) {
            this.showError('Error: Negative number');
            return;
        }
        this.currentValue = String(Math.sqrt(value));
        this.updateDisplay();
    }
    
    /**
     * Square function
     */
    square() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value * value);
        this.updateDisplay();
    }
    
    /**
     * Percent function
     */
    percent() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value / 100);
        this.updateDisplay();
    }
    
    /**
     * Reciprocal function (1/x)
     */
    reciprocal() {
        const value = parseFloat(this.currentValue);
        if (value === 0) {
            this.showError('Error: Division by zero');
            return;
        }
        this.currentValue = String(1 / value);
        this.updateDisplay();
    }
    
    /**
     * Apply tax (10%)
     */
    applyTax() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value * 1.1);
        this.updateDisplay();
    }
    
    /**
     * Apply GST
     */
    applyGST(gstType) {
        const value = parseFloat(this.currentValue);
        const rate = this.gstRates[gstType] / 100;
        this.currentValue = String(value * (1 + rate));
        this.updateDisplay();
        
        // Show which GST rate was applied
        botReply(`Applied ${this.gstRates[gstType]}% GST`);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        this.display.textContent = message;
        this.display.style.color = '#ff5252';
        
        // Reset after 2 seconds
        setTimeout(() => {
            this.display.style.color = '';
            this.currentValue = '0';
            this.updateDisplay();
        }, 2000);
    }
    
    /**
     * Update the main display
     */
    updateDisplay() {
        // Format large numbers with commas
        const formattedValue = this.formatNumber(this.currentValue);
        this.display.textContent = formattedValue;
    }
    
    /**
     * Update the expression display
     */
    updateExpressionDisplay() {
        let expression = '';
        
        if (this.previousValue !== '') {
            expression += this.formatNumber(this.previousValue);
        }
        
        if (this.operation) {
            let operatorSymbol = '';
            switch (this.operation) {
                case '+': operatorSymbol = ' + '; break;
                case '-': operatorSymbol = ' - '; break;
                case '*': operatorSymbol = ' × '; break;
                case '/': operatorSymbol = ' ÷ '; break;
            }
            expression += operatorSymbol;
        }
        
        this.expressionDisplay.textContent = expression;
    }
    
    /**
     * Format number with commas for thousands
     */
    formatNumber(num) {
        // Handle very large or small numbers with scientific notation
        if (Math.abs(parseFloat(num)) >= 1e10 || (Math.abs(parseFloat(num)) < 1e-6 && parseFloat(num) !== 0)) {
            return parseFloat(num).toExponential(6);
        }
        
        // Format with commas for thousands
        const parts = num.toString().split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return parts.join('.');
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        // Handle calculator keys
        if (event.key >= '0' && event.key <= '9') {
            this.inputNumber(event.key);
        } else if (event.key === '.') {
            this.inputDecimal();
        } else if (event.key === '+' || event.key === '-' || event.key === '*' || event.key === '/') {
            this.setOperation(event.key);
        } else if (event.key === 'Enter' || event.key === '=') {
            this.calculate();
        } else if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === 'Backspace') {
            this.backspace();
        } else if (event.key === 'Delete' || event.key === 'c' || event.key === 'C') {
            this.clear();
        } else if (event.key === 'r' || event.key === 'R') {
            this.squareRoot();
        } else if (event.key === 's' || event.key === 'S') {
            this.square();
        } else if (event.key === '%') {
            this.percent();
        } else if (event.key === 't' || event.key === 'T') {
            this.applyTax();
        } else if (event.key === 'g' || event.key === 'G') {
            this.applyGST('gst3'); // Default to 18% GST
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Clear any pending button timeout
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.display = null;
        this.expressionDisplay = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.activeButton = null;
        this.buttonTimeout = null;
        this.memory = 0;
        
        botReply("Advanced Calculator closed. Thank you!");
    }
}

// Create a singleton instance
const calculatorScreen = new CalculatorScreen();

// Add this to your AI's command handling
if (/calculator|calc|calculate/i.test(userInputRaw)) {
    calculatorScreen.loadCalculator();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    calculatorScreen.closeGame();
    return;
}


class VideoEditorScreen {
    constructor() {
        this.videoEditor = {
            name: 'VIDEO EDITOR',
            instructions: 'Edit your videos with professional tools like Kinemaster and Capcut.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.videoPreview = null;
        this.timeline = null;
        this.currentVideo = null;
        this.videoDuration = 0;
        this.currentTime = 0;
        this.playing = false;
        this.tracks = [];
        this.selectedTrack = null;
        this.selectedTool = 'select';
        this.selectedClip = null;
        this.zoomLevel = 1;
        this.volume = 0.8;
        this.playbackRate = 1;
        this.timeDisplay = null;
        this.playhead = null;
        this.clips = [];
        this.buttonTimeout = null;
        this.activeButton = null;
        this.projectInfo = null;
        this.uploadArea = null;
        this.effectsPanel = null;
        this.textPanel = null;
        this.transitionPanel = null;
        this.settingsPanel = null;
        this.exportPanel = null;
        this.trimPanel = null;
        this.canvas = null;
        this.ctx = null;
        this.textOverlays = [];
        this.effects = [];
        this.transitions = [];
        this.trimStart = 0;
        this.trimEnd = 0;
        this.leftToolbar = null;
        this.layersPanel = null;
        this.propertiesPanel = null;
        this.speedPanel = null;
        this.audioPanel = null;
        this.colorPanel = null;
        this.animationPanel = null;
        this.keyframePanel = null;
        this.chromaKeyPanel = null;
        this.stickers = [];
        this.animations = [];
        this.keyframes = [];
    }
    
    /**
     * Load the Video Editor
     */
    loadVideoEditor() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.videoEditor.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create video editor
        this.createVideoEditor();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the video editor
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.videoEditor.name} loaded! ${this.videoEditor.instructions}`);
        botReply("Click 'Import' to upload a video file or press 'i' key.");
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
        `;
    }
    
    /**
     * Create the Video Editor UI
     */
    createVideoEditor() {
        // Create editor container
        const editorContainer = document.createElement('div');
        editorContainer.style.cssText = `
            background-color: #222;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background-color: #333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.videoEditor.name;
        title.style.cssText = `
            font-size: 18px;
            font-weight: bold;
        `;
        
        this.projectInfo = document.createElement('div');
        this.projectInfo.textContent = 'New Project';
        this.projectInfo.style.cssText = `
            font-size: 14px;
            color: #aaa;
        `;
        
        header.appendChild(title);
        header.appendChild(this.projectInfo);
        editorContainer.appendChild(header);
        
        // Create main content area with left toolbar
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create left toolbar
        this.createLeftToolbar();
        mainContent.appendChild(this.leftToolbar);
        
        // Create center content area
        const centerContent = document.createElement('div');
        centerContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create preview area
        const previewArea = document.createElement('div');
        previewArea.style.cssText = `
            background-color: #111;
            height: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border-bottom: 1px solid #444;
        `;
        
        // Create canvas for video and effects
        this.canvas = document.createElement('canvas');
        this.canvas.style.cssText = `
            max-width: 100%;
            max-height: 100%;
            background-color: #000;
            z-index: 1;
        `;
        this.ctx = this.canvas.getContext('2d');
        
        // Create video preview element (hidden, used as source)
        this.videoPreview = document.createElement('video');
        this.videoPreview.style.cssText = `
            display: none;
        `;
        this.videoPreview.crossOrigin = 'anonymous';
        this.videoPreview.addEventListener('loadedmetadata', () => {
            this.videoDuration = this.videoPreview.duration;
            this.trimEnd = this.videoDuration;
            this.canvas.width = this.videoPreview.videoWidth;
            this.canvas.height = this.videoPreview.videoHeight;
            this.updateTimeline();
            this.renderFrame();
        });
        this.videoPreview.addEventListener('timeupdate', () => {
            this.currentTime = this.videoPreview.currentTime;
            this.updateTimelinePosition();
            this.renderFrame();
        });
        this.videoPreview.addEventListener('ended', () => {
            this.playing = false;
            this.updatePlayButton();
        });
        
        // Create upload area (shown when no video is loaded)
        this.uploadArea = document.createElement('div');
        this.uploadArea.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 10;
        `;
        
        const uploadIcon = document.createElement('div');
        uploadIcon.innerHTML = '📁';
        uploadIcon.style.cssText = `
            font-size: 48px;
            margin-bottom: 15px;
        `;
        
        const uploadText = document.createElement('div');
        uploadText.textContent = 'No video loaded';
        uploadText.style.cssText = `
            font-size: 18px;
            margin-bottom: 10px;
        `;
        
        const uploadSubtext = document.createElement('div');
        uploadSubtext.textContent = 'Click "Import" button or press "i" to upload a video';
        uploadSubtext.style.cssText = `
            font-size: 14px;
            color: #aaa;
            margin-bottom: 20px;
        `;
        
        const uploadButton = document.createElement('button');
        uploadButton.textContent = 'Upload Video';
        uploadButton.style.cssText = this.getButtonStyle('btn-tool-import');
        uploadButton.addEventListener('click', () => this.importMedia());
        
        this.uploadArea.appendChild(uploadIcon);
        this.uploadArea.appendChild(uploadText);
        this.uploadArea.appendChild(uploadSubtext);
        this.uploadArea.appendChild(uploadButton);
        
        previewArea.appendChild(this.canvas);
        previewArea.appendChild(this.videoPreview);
        previewArea.appendChild(this.uploadArea);
        
        // Create playback controls
        const playbackControls = document.createElement('div');
        playbackControls.style.cssText = `
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 5px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 5;
        `;
        
        // Define playback buttons
        const playbackButtons = [
            { label: '⏮', action: 'skipBackward', title: 'Skip Backward' },
            { label: '⏪', action: 'rewind', title: 'Rewind' },
            { label: '▶', action: 'playPause', title: 'Play/Pause', id: 'play-pause-btn' },
            { label: '⏩', action: 'fastForward', title: 'Fast Forward' },
            { label: '⏭', action: 'skipForward', title: 'Skip Forward' },
            { label: '🔊', action: 'volume', title: 'Volume' },
            { label: '✂️', action: 'trim', title: 'Trim' }
        ];
        
        // Create playback buttons
        playbackButtons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.title = button.title;
            if (button.id) btn.id = button.id;
            btn.style.cssText = this.getButtonStyle('btn-playback');
            this.addButtonEventListeners(btn, button.action, button.label);
            playbackControls.appendChild(btn);
        });
        
        // Create time display
        const timeDisplay = document.createElement('div');
        timeDisplay.style.cssText = `
            color: white;
            font-size: 12px;
            font-family: monospace;
            min-width: 100px;
            text-align: center;
        `;
        timeDisplay.textContent = '00:00 / 00:00';
        this.timeDisplay = timeDisplay;
        
        playbackControls.appendChild(timeDisplay);
        previewArea.appendChild(playbackControls);
        centerContent.appendChild(previewArea);
        
        // Create timeline area
        const timelineArea = document.createElement('div');
        timelineArea.style.cssText = `
            background-color: #1a1a1a;
            height: 50%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        // Create timeline header
        const timelineHeader = document.createElement('div');
        timelineHeader.style.cssText = `
            background-color: #2a2a2a;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            border-bottom: 1px solid #444;
        `;
        
        const timelineTitle = document.createElement('div');
        timelineTitle.textContent = 'Timeline';
        timelineTitle.style.cssText = `
            font-size: 14px;
            font-weight: bold;
        `;
        
        // Create timeline controls
        const timelineControls = document.createElement('div');
        timelineControls.style.cssText = `
            display: flex;
            gap: 5px;
        `;
        
        // Define timeline control buttons
        const timelineControlButtons = [
            { label: '+', action: 'zoomIn', title: 'Zoom In' },
            { label: '-', action: 'zoomOut', title: 'Zoom Out' },
            { label: '↔', action: 'fitToScreen', title: 'Fit to Screen' }
        ];
        
        // Create timeline control buttons
        timelineControlButtons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.title = button.title;
            btn.style.cssText = this.getButtonStyle('btn-timeline-control');
            this.addButtonEventListeners(btn, button.action, button.label);
            timelineControls.appendChild(btn);
        });
        
        timelineHeader.appendChild(timelineTitle);
        timelineHeader.appendChild(timelineControls);
        timelineArea.appendChild(timelineHeader);
        
        // Create timeline tracks container
        const tracksContainer = document.createElement('div');
        tracksContainer.style.cssText = `
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        `;
        
        // Create timeline ruler
        const timelineRuler = document.createElement('div');
        timelineRuler.style.cssText = `
            height: 30px;
            background-color: #333;
            position: relative;
            border-bottom: 1px solid #444;
        `;
        
        // Create playhead
        this.playhead = document.createElement('div');
        this.playhead.style.cssText = `
            position: absolute;
            left: 0;
            top: 0;
            width: 2px;
            height: 100%;
            background-color: #ff5252;
            z-index: 100;
            pointer-events: none;
        `;
        timelineRuler.appendChild(this.playhead);
        
        // Create timeline ruler marks (simplified)
        for (let i = 0; i < 60; i++) {
            const mark = document.createElement('div');
            mark.style.cssText = `
                position: absolute;
                left: ${i * 50}px;
                top: 0;
                height: ${i % 5 === 0 ? '15px' : '8px'};
                width: 1px;
                background-color: #666;
            `;
            timelineRuler.appendChild(mark);
            
            if (i % 5 === 0) {
                const label = document.createElement('div');
                label.textContent = `${i}s`;
                label.style.cssText = `
                    position: absolute;
                    left: ${i * 50}px;
                    top: 15px;
                    font-size: 10px;
                    color: #aaa;
                    width: 40px;
                    text-align: center;
                `;
                timelineRuler.appendChild(label);
            }
        }
        
        tracksContainer.appendChild(timelineRuler);
        
        // Create timeline tracks area
        this.timeline = document.createElement('div');
        this.timeline.style.cssText = `
            background-color: #2a2a2a;
            min-height: 200px;
            position: relative;
        `;
        
        // Create initial tracks
        this.createTrack('Video', 'video');
        this.createTrack('Audio', 'audio');
        this.createTrack('Text', 'text');
        this.createTrack('Effects', 'effects');
        
        tracksContainer.appendChild(this.timeline);
        timelineArea.appendChild(tracksContainer);
        
        // Create bottom toolbar
        const bottomToolbar = document.createElement('div');
        bottomToolbar.style.cssText = `
            background-color: #333;
            padding: 8px 15px;
            display: flex;
            gap: 10px;
            overflow-x: auto;
            border-top: 1px solid #444;
        `;
        
        // Define tool buttons
        const toolButtons = [
            { label: 'Import', action: 'import', className: 'btn-tool-import' },
            { label: 'Export', action: 'export', className: 'btn-tool-export' }
        ];
        
        // Create tool buttons
        toolButtons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.style.cssText = this.getButtonStyle(button.className);
            this.addButtonEventListeners(btn, button.action, button.label);
            bottomToolbar.appendChild(btn);
        });
        
        timelineArea.appendChild(bottomToolbar);
        centerContent.appendChild(timelineArea);
        mainContent.appendChild(centerContent);
        editorContainer.appendChild(mainContent);
        this.gameContainer.appendChild(editorContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Create left toolbar with all editing tools
     */
    createLeftToolbar() {
        this.leftToolbar = document.createElement('div');
        this.leftToolbar.style.cssText = `
            width: 60px;
            background-color: #2a2a2a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            border-right: 1px solid #444;
        `;
        
        // Define all editing tools
        const editingTools = [
            { label: '↖', action: 'select', title: 'Select Tool', className: 'btn-tool' },
            { label: '✂️', action: 'cut', title: 'Cut/Split', className: 'btn-tool' },
            { label: 'T', action: 'text', title: 'Text', className: 'btn-tool' },
            { label: '🏷️', action: 'sticker', title: 'Stickers', className: 'btn-tool' },
            { label: '🔄', action: 'transition', title: 'Transitions', className: 'btn-tool' },
            { label: '✨', action: 'effects', title: 'Effects', className: 'btn-tool' },
            { label: '🎨', action: 'filter', title: 'Filters', className: 'btn-tool' },
            { label: '🔊', action: 'audio', title: 'Audio', className: 'btn-tool' },
            { label: '⚡', action: 'speed', title: 'Speed Control', className: 'btn-tool' },
            { label: '🎬', action: 'animation', title: 'Animation', className: 'btn-tool' },
            { label: '🔑', action: 'keyframe', title: 'Keyframes', className: 'btn-tool' },
            { label: '🎭', action: 'chromaKey', title: 'Chroma Key', className: 'btn-tool' },
            { label: '🎚️', action: 'color', title: 'Color Adjust', className: 'btn-tool' },
            { label: '📐', action: 'transform', title: 'Transform', className: 'btn-tool' },
            { label: '🖼️', action: 'layers', title: 'Layers', className: 'btn-tool' },
            { label: '⚙️', action: 'properties', title: 'Properties', className: 'btn-tool' }
        ];
        
        // Create tool buttons
        editingTools.forEach(tool => {
            const btn = document.createElement('button');
            btn.textContent = tool.label;
            btn.title = tool.title;
            btn.style.cssText = this.getButtonStyle(tool.className);
            this.addButtonEventListeners(btn, tool.action, tool.label);
            this.leftToolbar.appendChild(btn);
        });
    }
    
    /**
     * Create a new track
     */
    createTrack(name, type) {
        const trackId = `track-${Date.now()}`;
        const track = {
            id: trackId,
            name: name,
            type: type,
            clips: []
        };
        
        const trackElement = document.createElement('div');
        trackElement.id = trackId;
        trackElement.style.cssText = `
            height: 60px;
            background-color: #333;
            border-bottom: 1px solid #444;
            position: relative;
            display: flex;
            align-items: center;
        `;
        
        const trackLabel = document.createElement('div');
        trackLabel.style.cssText = `
            width: 80px;
            padding: 0 10px;
            color: white;
            font-size: 12px;
            text-align: right;
            border-right: 1px solid #444;
        `;
        trackLabel.textContent = name;
        
        const trackContent = document.createElement('div');
        trackContent.style.cssText = `
            flex: 1;
            height: 100%;
            position: relative;
            overflow: hidden;
        `;
        
        trackElement.appendChild(trackLabel);
        trackElement.appendChild(trackContent);
        
        trackElement.addEventListener('click', () => {
            this.selectTrack(trackId);
        });
        
        this.timeline.appendChild(trackElement);
        this.tracks.push(track);
        
        return track;
    }
    
    /**
     * Select a track
     */
    selectTrack(trackId) {
        // Deselect all tracks
        this.tracks.forEach(track => {
            const trackElement = document.getElementById(track.id);
            if (trackElement) {
                trackElement.style.backgroundColor = '#333';
            }
        });
        
        // Select the specified track
        this.selectedTrack = trackId;
        const trackElement = document.getElementById(trackId);
        if (trackElement) {
            trackElement.style.backgroundColor = '#3a3a3a';
        }
    }
    
    /**
     * Add event listeners to buttons for better responsiveness
     */
    addButtonEventListeners(button, action, label) {
        const handleInteraction = (e) => {
            e.preventDefault();
            this.handleButtonClick(action, label);
            
            // Visual feedback
            this.activeButton = button;
            button.style.transform = 'scale(0.95)';
            button.style.opacity = '0.8';
        };
        
        const handleRelease = () => {
            if (this.activeButton === button) {
                button.style.transform = '';
                button.style.opacity = '';
                this.activeButton = null;
            }
        };
        
        // Mouse events
        button.addEventListener('mousedown', handleInteraction);
        button.addEventListener('mouseup', handleRelease);
        button.addEventListener('mouseleave', handleRelease);
        
        // Touch events
        button.addEventListener('touchstart', handleInteraction, { passive: false });
        button.addEventListener('touchend', handleRelease);
        button.addEventListener('touchcancel', handleRelease);
    }
    
    /**
     * Get button style based on button type
     */
    getButtonStyle(buttonType) {
        const baseStyle = `
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        `;
        
        switch (buttonType) {
            case 'btn-playback':
                return baseStyle + `
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    padding: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            case 'btn-timeline-control':
                return baseStyle + `
                    background-color: rgba(255, 255, 255, 0.1);
                    color: white;
                    width: 30px;
                    height: 30px;
                    border-radius: 4px;
                    padding: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
            case 'btn-tool':
                return baseStyle + `
                    background-color: #444;
                    color: white;
                    width: 44px;
                    height: 44px;
                    border-radius: 8px;
                    margin: 5px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 18px;
                `;
            case 'btn-tool-import':
                return baseStyle + `
                    background-color: #2196F3;
                    color: white;
                `;
            case 'btn-tool-export':
                return baseStyle + `
                    background-color: #4CAF50;
                    color: white;
                `;
            default:
                return baseStyle + `
                    background-color: #555;
                    color: white;
                `;
        }
    }
    
    /**
     * Handle button click
     */
    handleButtonClick(action, label) {
        // Add a small delay to prevent double-taps from registering twice
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        this.buttonTimeout = setTimeout(() => {
            switch (action) {
                // Playback controls
                case 'playPause':
                    this.togglePlayPause();
                    break;
                case 'skipBackward':
                    this.skipBackward();
                    break;
                case 'skipForward':
                    this.skipForward();
                    break;
                case 'rewind':
                    this.rewind();
                    break;
                case 'fastForward':
                    this.fastForward();
                    break;
                case 'volume':
                    this.adjustVolume();
                    break;
                case 'trim':
                    this.openTrimTool();
                    break;
                    
                // Timeline controls
                case 'zoomIn':
                    this.zoomIn();
                    break;
                case 'zoomOut':
                    this.zoomOut();
                    break;
                case 'fitToScreen':
                    this.fitToScreen();
                    break;
                    
                // Tools
                case 'select':
                    this.selectTool('select');
                    break;
                case 'cut':
                    this.cutTool();
                    break;
                case 'text':
                    this.addText();
                    break;
                case 'sticker':
                    this.addSticker();
                    break;
                case 'transition':
                    this.addTransition();
                    break;
                case 'effects':
                    this.addEffect();
                    break;
                case 'filter':
                    this.addFilter();
                    break;
                case 'audio':
                    this.openAudioTool();
                    break;
                case 'speed':
                    this.openSpeedTool();
                    break;
                case 'animation':
                    this.openAnimationTool();
                    break;
                case 'keyframe':
                    this.openKeyframeTool();
                    break;
                case 'chromaKey':
                    this.openChromaKeyTool();
                    break;
                case 'color':
                    this.openColorTool();
                    break;
                case 'transform':
                    this.openTransformTool();
                    break;
                case 'layers':
                    this.openLayersTool();
                    break;
                case 'properties':
                    this.openPropertiesTool();
                    break;
                case 'import':
                    this.importMedia();
                    break;
                case 'export':
                    this.exportVideo();
                    break;
            }
            this.buttonTimeout = null;
        }, 10);
    }
    
    /**
     * Render frame with all effects and overlays
     */
    renderFrame() {
        if (!this.videoPreview || !this.ctx || this.videoPreview.readyState < 2) return;
        
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw video frame
        this.ctx.drawImage(this.videoPreview, 0, 0, this.canvas.width, this.canvas.height);
        
        // Apply filters
        this.applyFilters();
        
        // Draw text overlays
        this.drawTextOverlays();
        
        // Draw stickers
        this.drawStickers();
    }
    
    /**
     * Apply filters to the video
     */
    applyFilters() {
        if (this.effects.length === 0) return;
        
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        
        // Apply each effect
        this.effects.forEach(effect => {
            switch (effect.type) {
                case 'brightness':
                    this.applyBrightness(data, effect.intensity);
                    break;
                case 'contrast':
                    this.applyContrast(data, effect.intensity);
                    break;
                case 'saturation':
                    this.applySaturation(data, effect.intensity);
                    break;
                case 'blur':
                    // Blur is applied using CSS filter for simplicity
                    break;
                case 'grayscale':
                    this.applyGrayscale(data);
                    break;
                case 'sepia':
                    this.applySepia(data);
                    break;
                case 'invert':
                    this.applyInvert(data);
                    break;
            }
        });
        
        this.ctx.putImageData(imageData, 0, 0);
        
        // Apply CSS filters for effects that are easier to implement that way
        let cssFilter = '';
        this.effects.forEach(effect => {
            if (effect.type === 'blur') {
                cssFilter += `blur(${effect.intensity / 20}px) `;
            }
        });
        
        if (cssFilter) {
            this.canvas.style.filter = cssFilter;
        } else {
            this.canvas.style.filter = 'none';
        }
    }
    
    /**
     * Apply brightness effect
     */
    applyBrightness(data, intensity) {
        const factor = intensity / 50; // Convert to 0-2 range
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] * factor;     // Red
            data[i + 1] = data[i + 1] * factor; // Green
            data[i + 2] = data[i + 2] * factor; // Blue
        }
    }
    
    /**
     * Apply contrast effect
     */
    applyContrast(data, intensity) {
        const factor = (259 * (intensity + 255)) / (255 * (259 - intensity));
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = factor * (data[i] - 128) + 128;     // Red
            data[i + 1] = factor * (data[i + 1] - 128) + 128; // Green
            data[i + 2] = factor * (data[i + 2] - 128) + 128; // Blue
        }
    }
    
    /**
     * Apply saturation effect
     */
    applySaturation(data, intensity) {
        const factor = intensity / 50; // Convert to 0-2 range
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
            
            data[i] = gray + factor * (r - gray);     // Red
            data[i + 1] = gray + factor * (g - gray); // Green
            data[i + 2] = gray + factor * (b - gray); // Blue
        }
    }
    
    /**
     * Apply grayscale effect
     */
    applyGrayscale(data) {
        for (let i = 0; i < data.length; i += 4) {
            const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];
            data[i] = gray;     // Red
            data[i + 1] = gray; // Green
            data[i + 2] = gray; // Blue
        }
    }
    
    /**
     * Apply sepia effect
     */
    applySepia(data) {
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));     // Red
            data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // Green
            data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // Blue
        }
    }
    
    /**
     * Apply invert effect
     */
    applyInvert(data) {
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];         // Red
            data[i + 1] = 255 - data[i + 1]; // Green
            data[i + 2] = 255 - data[i + 2]; // Blue
        }
    }
    
    /**
     * Draw text overlays
     */
    drawTextOverlays() {
        this.textOverlays.forEach(text => {
            if (this.currentTime >= text.startTime && this.currentTime <= text.endTime) {
                this.ctx.save();
                
                // Set font properties
                this.ctx.font = `${text.fontSize}px Arial`;
                this.ctx.fillStyle = text.color;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                
                // Add shadow for better visibility
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                this.ctx.shadowBlur = 4;
                this.ctx.shadowOffsetX = 2;
                this.ctx.shadowOffsetY = 2;
                
                // Calculate position based on alignment
                let x = this.canvas.width * text.positionX;
                let y = this.canvas.height * text.positionY;
                
                // Draw text
                this.ctx.fillText(text.content, x, y);
                
                this.ctx.restore();
            }
        });
    }
    
    /**
     * Draw stickers
     */
    drawStickers() {
        // This would draw sticker overlays
        // Implementation depends on how stickers are stored
        this.stickers.forEach(sticker => {
            if (this.currentTime >= sticker.startTime && this.currentTime <= sticker.endTime) {
                this.ctx.save();
                
                // Calculate position and size
                const x = this.canvas.width * sticker.positionX;
                const y = this.canvas.height * sticker.positionY;
                const size = sticker.size;
                
                // Draw sticker (simplified - would use actual images in a real implementation)
                this.ctx.font = `${size}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(sticker.emoji, x, y);
                
                this.ctx.restore();
            }
        });
    }
    
    /**
     * Toggle play/pause
     */
    togglePlayPause() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        if (this.playing) {
            this.videoPreview.pause();
            this.playing = false;
        } else {
            this.videoPreview.play();
            this.playing = true;
        }
        
        this.updatePlayButton();
        this.updateTimeDisplay();
    }
    
    /**
     * Update play button icon
     */
    updatePlayButton() {
        const playButton = document.getElementById('play-pause-btn');
        if (playButton) {
            playButton.textContent = this.playing ? '⏸' : '▶';
        }
    }
    
    /**
     * Skip backward
     */
    skipBackward() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.videoPreview.currentTime = Math.max(this.trimStart, this.currentTime - 10);
    }
    
    /**
     * Skip forward
     */
    skipForward() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.videoPreview.currentTime = Math.min(this.trimEnd, this.currentTime + 10);
    }
    
    /**
     * Rewind
     */
    rewind() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.playbackRate = Math.max(0.5, this.playbackRate - 0.5);
        this.videoPreview.playbackRate = this.playbackRate;
        botReply(`Playback rate: ${this.playbackRate}x`);
    }
    
    /**
     * Fast forward
     */
    fastForward() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        this.playbackRate = Math.min(4, this.playbackRate + 0.5);
        this.videoPreview.playbackRate = this.playbackRate;
        botReply(`Playback rate: ${this.playbackRate}x`);
    }
    
    /**
     * Adjust volume
     */
    adjustVolume() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Simple volume toggle between 0.8 and 0
        this.volume = this.volume > 0 ? 0 : 0.8;
        this.videoPreview.volume = this.volume;
        botReply(`Volume: ${this.volume > 0 ? 'On' : 'Muted'}`);
    }
    
    /**
     * Open trim tool
     */
    openTrimTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create trim panel
        this.trimPanel = document.createElement('div');
        this.trimPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 400px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Trim Video';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Start time control
        const startControl = document.createElement('div');
        startControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const startLabel = document.createElement('label');
        startLabel.textContent = 'Start Time:';
        startLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const startSlider = document.createElement('input');
        startSlider.type = 'range';
        startSlider.min = '0';
        startSlider.max = this.videoDuration.toString();
        startSlider.step = '0.1';
        startSlider.value = this.trimStart.toString();
        startSlider.style.cssText = `
            width: 100%;
        `;
        
        const startValue = document.createElement('div');
        startValue.textContent = this.formatTime(this.trimStart);
        startValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        startSlider.addEventListener('input', (e) => {
            this.trimStart = parseFloat(e.target.value);
            startValue.textContent = this.formatTime(this.trimStart);
        });
        
        startControl.appendChild(startLabel);
        startControl.appendChild(startSlider);
        startControl.appendChild(startValue);
        
        // End time control
        const endControl = document.createElement('div');
        endControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const endLabel = document.createElement('label');
        endLabel.textContent = 'End Time:';
        endLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const endSlider = document.createElement('input');
        endSlider.type = 'range';
        endSlider.min = '0';
        endSlider.max = this.videoDuration.toString();
        endSlider.step = '0.1';
        endSlider.value = this.trimEnd.toString();
        endSlider.style.cssText = `
            width: 100%;
        `;
        
        const endValue = document.createElement('div');
        endValue.textContent = this.formatTime(this.trimEnd);
        endValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        endSlider.addEventListener('input', (e) => {
            this.trimEnd = parseFloat(e.target.value);
            endValue.textContent = this.formatTime(this.trimEnd);
        });
        
        endControl.appendChild(endLabel);
        endControl.appendChild(endSlider);
        endControl.appendChild(endValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply Trim';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            // Apply trim by setting video start and end points
            this.videoPreview.currentTime = this.trimStart;
            
            // Create a new clip with trimmed duration
            const videoTrack = this.tracks.find(t => t.type === 'video');
            if (videoTrack && videoTrack.clips.length > 0) {
                const clip = videoTrack.clips[0];
                clip.start = this.trimStart;
                clip.end = this.trimEnd;
                
                // Update the timeline
                this.updateTimelineClips();
                
                botReply(`Video trimmed from ${this.formatTime(this.trimStart)} to ${this.formatTime(this.trimEnd)}`);
            }
            
            // Close the panel
            if (this.trimPanel) {
                this.trimPanel.remove();
                this.trimPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.trimPanel) {
                this.trimPanel.remove();
                this.trimPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.trimPanel.appendChild(title);
        this.trimPanel.appendChild(startControl);
        this.trimPanel.appendChild(endControl);
        this.trimPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.trimPanel);
    }
    
    /**
     * Zoom in timeline
     */
    zoomIn() {
        this.zoomLevel = Math.min(5, this.zoomLevel + 0.5);
        this.updateTimelineZoom();
        botReply(`Timeline zoom: ${this.zoomLevel}x`);
    }
    
    /**
     * Zoom out timeline
     */
    zoomOut() {
        this.zoomLevel = Math.max(0.5, this.zoomLevel - 0.5);
        this.updateTimelineZoom();
        botReply(`Timeline zoom: ${this.zoomLevel}x`);
    }
    
    /**
     * Fit timeline to screen
     */
    fitToScreen() {
        this.zoomLevel = 1;
        this.updateTimelineZoom();
        botReply('Timeline zoom: 1x (Fit to screen)');
    }
    
    /**
     * Update timeline zoom
     */
    updateTimelineZoom() {
        const timelineElements = this.timeline.querySelectorAll('div');
        timelineElements.forEach(element => {
            if (element.style.transform) {
                element.style.transform = `scaleX(${this.zoomLevel})`;
            }
        });
    }
    
    /**
     * Select a tool
     */
    selectTool(tool) {
        this.selectedTool = tool;
        this.closeAllPanels();
        botReply(`Selected tool: ${tool}`);
    }
    
    /**
     * Cut tool - Split clip at current time
     */
    cutTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Find the video track
        const videoTrack = this.tracks.find(t => t.type === 'video');
        if (!videoTrack || videoTrack.clips.length === 0) {
            this.showError('No video clip found');
            return;
        }
        
        // Get the main video clip
        const clip = videoTrack.clips[0];
        
        // Check if current time is within clip bounds
        if (this.currentTime <= clip.start || this.currentTime >= clip.end) {
            this.showError('Position cursor within the clip to cut');
            return;
        }
        
        // Create a new clip from the current time to the end of the original clip
        const newClip = {
            id: `clip-${Date.now()}`,
            name: `${clip.name} (part 2)`,
            url: clip.url,
            start: this.currentTime,
            end: clip.end,
            track: clip.track,
            type: 'video'
        };
        
        // Update the original clip to end at the current time
        clip.end = this.currentTime;
        clip.name = `${clip.name} (part 1)`;
        
        // Add the new clip to the tracks and clips array
        videoTrack.clips.push(newClip);
        this.clips.push(newClip);
        
        // Update the UI
        this.updateTimelineClips();
        
        botReply(`Clip cut at ${this.formatTime(this.currentTime)}`);
    }
    
    /**
     * Add text overlay
     */
    addText() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create text panel
        this.textPanel = document.createElement('div');
        this.textPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Text';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const textInput = document.createElement('input');
        textInput.type = 'text';
        textInput.placeholder = 'Enter text here';
        textInput.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const fontSizeControl = document.createElement('div');
        fontSizeControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const fontSizeLabel = document.createElement('label');
        fontSizeLabel.textContent = 'Font Size:';
        fontSizeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const fontSizeSlider = document.createElement('input');
        fontSizeSlider.type = 'range';
        fontSizeSlider.min = '12';
        fontSizeSlider.max = '72';
        fontSizeSlider.value = '24';
        fontSizeSlider.style.cssText = `
            width: 100%;
        `;
        
        const fontSizeValue = document.createElement('div');
        fontSizeValue.textContent = '24px';
        fontSizeValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        fontSizeSlider.addEventListener('input', (e) => {
            fontSizeValue.textContent = `${e.target.value}px`;
        });
        
        fontSizeControl.appendChild(fontSizeLabel);
        fontSizeControl.appendChild(fontSizeSlider);
        fontSizeControl.appendChild(fontSizeValue);
        
        const colorControl = document.createElement('div');
        colorControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const colorLabel = document.createElement('label');
        colorLabel.textContent = 'Text Color:';
        colorLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = '#ffffff';
        colorPicker.style.cssText = `
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 4px;
        `;
        
        colorControl.appendChild(colorLabel);
        colorControl.appendChild(colorPicker);
        
        const positionControl = document.createElement('div');
        positionControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const positionLabel = document.createElement('label');
        positionLabel.textContent = 'Position:';
        positionLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const positionSelect = document.createElement('select');
        positionSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const positions = [
            { value: 'top-left', text: 'Top Left' },
            { value: 'top-center', text: 'Top Center' },
            { value: 'top-right', text: 'Top Right' },
            { value: 'center-left', text: 'Center Left' },
            { value: 'center', text: 'Center' },
            { value: 'center-right', text: 'Center Right' },
            { value: 'bottom-left', text: 'Bottom Left' },
            { value: 'bottom-center', text: 'Bottom Center' },
            { value: 'bottom-right', text: 'Bottom Right' }
        ];
        
        positions.forEach(pos => {
            const option = document.createElement('option');
            option.value = pos.value;
            option.textContent = pos.text;
            positionSelect.appendChild(option);
        });
        
        positionControl.appendChild(positionLabel);
        positionControl.appendChild(positionSelect);
        
        const durationControl = document.createElement('div');
        durationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const durationLabel = document.createElement('label');
        durationLabel.textContent = 'Duration (seconds):';
        durationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const durationInput = document.createElement('input');
        durationInput.type = 'number';
        durationInput.min = '1';
        durationInput.max = '60';
        durationInput.value = '5';
        durationInput.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        durationControl.appendChild(durationLabel);
        durationControl.appendChild(durationInput);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Text';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const text = textInput.value.trim();
            if (text) {
                // Get position values
                let positionX = 0.5;
                let positionY = 0.5;
                
                switch (positionSelect.value) {
                    case 'top-left':
                        positionX = 0.1;
                        positionY = 0.1;
                        break;
                    case 'top-center':
                        positionX = 0.5;
                        positionY = 0.1;
                        break;
                    case 'top-right':
                        positionX = 0.9;
                        positionY = 0.1;
                        break;
                    case 'center-left':
                        positionX = 0.1;
                        positionY = 0.5;
                        break;
                    case 'center':
                        positionX = 0.5;
                        positionY = 0.5;
                        break;
                    case 'center-right':
                        positionX = 0.9;
                        positionY = 0.5;
                        break;
                    case 'bottom-left':
                        positionX = 0.1;
                        positionY = 0.9;
                        break;
                    case 'bottom-center':
                        positionX = 0.5;
                        positionY = 0.9;
                        break;
                    case 'bottom-right':
                        positionX = 0.9;
                        positionY = 0.9;
                        break;
                }
                
                // Create text overlay
                const textOverlay = {
                    id: `text-${Date.now()}`,
                    content: text,
                    fontSize: parseInt(fontSizeSlider.value),
                    color: colorPicker.value,
                    positionX: positionX,
                    positionY: positionY,
                    startTime: this.currentTime,
                    endTime: this.currentTime + parseInt(durationInput.value)
                };
                
                this.textOverlays.push(textOverlay);
                
                // Create a text track if it doesn't exist
                let textTrack = this.tracks.find(t => t.type === 'text');
                if (!textTrack) {
                    textTrack = this.createTrack('Text', 'text');
                }
                
                // Add text clip to timeline
                const textClip = {
                    id: `clip-${Date.now()}`,
                    name: `Text: ${text}`,
                    url: null,
                    start: this.currentTime,
                    end: this.currentTime + parseInt(durationInput.value),
                    track: textTrack.id,
                    type: 'text',
                    textOverlay: textOverlay
                };
                
                textTrack.clips.push(textClip);
                this.clips.push(textClip);
                
                // Update the UI
                this.updateTimelineClips();
                
                botReply(`Added text: "${text}" from ${this.formatTime(this.currentTime)} to ${this.formatTime(this.currentTime + parseInt(durationInput.value))}`);
                
                // Close the panel
                if (this.textPanel) {
                    this.textPanel.remove();
                    this.textPanel = null;
                }
            } else {
                this.showError('Please enter some text');
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.textPanel) {
                this.textPanel.remove();
                this.textPanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.textPanel.appendChild(title);
        this.textPanel.appendChild(textInput);
        this.textPanel.appendChild(fontSizeControl);
        this.textPanel.appendChild(colorControl);
        this.textPanel.appendChild(positionControl);
        this.textPanel.appendChild(durationControl);
        this.textPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.textPanel);
    }
    
    /**
     * Add sticker overlay
     */
    addSticker() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create sticker panel
        const stickerPanel = document.createElement('div');
        stickerPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 400px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Sticker';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Create sticker grid
        const stickerGrid = document.createElement('div');
        stickerGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Define sticker emojis
        const stickerEmojis = [
            '😀', '😂', '😍', '🤩', '😎', '🥳', '😡', '😭',
            '❤️', '💔', '🔥', '⭐', '👍', '👎', '👏', '🙏',
            '🎉', '🎈', '🎁', '🏆', '💯', '✨', '💫', '💥',
            '🌟', '🌈', '☀️', '🌙', '⛅', '🌧️', '⛈️', '❄️'
        ];
        
        // Create sticker buttons
        stickerEmojis.forEach(emoji => {
            const stickerBtn = document.createElement('button');
            stickerBtn.textContent = emoji;
            stickerBtn.style.cssText = `
                font-size: 24px;
                padding: 10px;
                background-color: #444;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
            `;
            
            stickerBtn.addEventListener('mouseover', () => {
                stickerBtn.style.backgroundColor = '#555';
                stickerBtn.style.transform = 'scale(1.1)';
            });
            
            stickerBtn.addEventListener('mouseout', () => {
                stickerBtn.style.backgroundColor = '#444';
                stickerBtn.style.transform = 'scale(1)';
            });
            
            stickerBtn.addEventListener('click', () => {
                this.addStickerToVideo(emoji);
                if (stickerPanel) {
                    stickerPanel.remove();
                }
            });
            
            stickerGrid.appendChild(stickerBtn);
        });
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (stickerPanel) {
                stickerPanel.remove();
            }
        });
        
        stickerPanel.appendChild(title);
        stickerPanel.appendChild(stickerGrid);
        stickerPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(stickerPanel);
    }
    
    /**
     * Add sticker to video
     */
    addStickerToVideo(emoji) {
        // Create sticker overlay
        const sticker = {
            id: `sticker-${Date.now()}`,
            emoji: emoji,
            size: 60,
            positionX: 0.5,
            positionY: 0.5,
            startTime: this.currentTime,
            endTime: this.currentTime + 5 // Default 5 seconds
        };
        
        this.stickers.push(sticker);
        
        // Create a text track for stickers if it doesn't exist
        let stickerTrack = this.tracks.find(t => t.type === 'text');
        if (!stickerTrack) {
            stickerTrack = this.createTrack('Text', 'text');
        }
        
        // Add sticker clip to timeline
        const stickerClip = {
            id: `clip-${Date.now()}`,
            name: `Sticker: ${emoji}`,
            url: null,
            start: this.currentTime,
            end: this.currentTime + 5,
            track: stickerTrack.id,
            type: 'sticker',
            sticker: sticker
        };
        
        stickerTrack.clips.push(stickerClip);
        this.clips.push(stickerClip);
        
        // Update the UI
        this.updateTimelineClips();
        
        botReply(`Added sticker: ${emoji} from ${this.formatTime(this.currentTime)} to ${this.formatTime(this.currentTime + 5)}`);
    }
    
    /**
     * Add transition between clips
     */
    addTransition() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create transition panel
        this.transitionPanel = document.createElement('div');
        this.transitionPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Transition';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const transitionTypes = document.createElement('select');
        transitionTypes.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const options = [
            { value: 'fade', text: 'Fade' },
            { value: 'slide', text: 'Slide' },
            { value: 'dissolve', text: 'Dissolve' },
            { value: 'wipe', text: 'Wipe' },
            { value: 'zoom', text: 'Zoom' },
            { value: 'spin', text: 'Spin' }
        ];
        
        options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.text;
            transitionTypes.appendChild(optionElement);
        });
        
        const durationControl = document.createElement('div');
        durationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const durationLabel = document.createElement('label');
        durationLabel.textContent = 'Duration (seconds):';
        durationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const durationSlider = document.createElement('input');
        durationSlider.type = 'range';
        durationSlider.min = '0.5';
        durationSlider.max = '3';
        durationSlider.step = '0.5';
        durationSlider.value = '1';
        durationSlider.style.cssText = `
            width: 100%;
        `;
        
        const durationValue = document.createElement('div');
        durationValue.textContent = '1s';
        durationValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        durationSlider.addEventListener('input', (e) => {
            durationValue.textContent = `${e.target.value}s`;
        });
        
        durationControl.appendChild(durationLabel);
        durationControl.appendChild(durationSlider);
        durationControl.appendChild(durationValue);
        
        const directionControl = document.createElement('div');
        directionControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const directionLabel = document.createElement('label');
        directionLabel.textContent = 'Direction:';
        directionLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const directionSelect = document.createElement('select');
        directionSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const directions = [
            { value: 'left', text: 'Left to Right' },
            { value: 'right', text: 'Right to Left' },
            { value: 'up', text: 'Bottom to Top' },
            { value: 'down', text: 'Top to Bottom' }
        ];
        
        directions.forEach(dir => {
            const option = document.createElement('option');
            option.value = dir.value;
            option.textContent = dir.text;
            directionSelect.appendChild(option);
        });
        
        directionControl.appendChild(directionLabel);
        directionControl.appendChild(directionSelect);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Transition';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const transitionType = transitionTypes.value;
            const duration = parseFloat(durationSlider.value);
            const direction = directionSelect.value;
            
            // Create transition
            const transition = {
                id: `transition-${Date.now()}`,
                type: transitionType,
                duration: duration,
                direction: direction,
                startTime: this.currentTime
            };
            
            this.transitions.push(transition);
            
            // Create a transition track if it doesn't exist
            let transitionTrack = this.tracks.find(t => t.type === 'transition');
            if (!transitionTrack) {
                transitionTrack = this.createTrack('Transition', 'transition');
            }
            
            // Add transition clip to timeline
            const transitionClip = {
                id: `clip-${Date.now()}`,
                name: `Transition: ${transitionType}`,
                url: null,
                start: this.currentTime,
                end: this.currentTime + duration,
                track: transitionTrack.id,
                type: 'transition',
                transition: transition
            };
            
            transitionTrack.clips.push(transitionClip);
            this.clips.push(transitionClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Added ${transitionType} transition with duration ${duration}s`);
            
            // Close the panel
            if (this.transitionPanel) {
                this.transitionPanel.remove();
                this.transitionPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.transitionPanel) {
                this.transitionPanel.remove();
                this.transitionPanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.transitionPanel.appendChild(title);
        this.transitionPanel.appendChild(transitionTypes);
        this.transitionPanel.appendChild(durationControl);
        this.transitionPanel.appendChild(directionControl);
        this.transitionPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.transitionPanel);
    }
    
    /**
     * Add effect to video
     */
    addEffect() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create effects panel
        this.effectsPanel = document.createElement('div');
        this.effectsPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Effect';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const effectTypes = document.createElement('select');
        effectTypes.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const effects = [
            { value: 'brightness', text: 'Brightness' },
            { value: 'contrast', text: 'Contrast' },
            { value: 'saturation', text: 'Saturation' },
            { value: 'blur', text: 'Blur' },
            { value: 'grayscale', text: 'Grayscale' },
            { value: 'sepia', text: 'Sepia' },
            { value: 'invert', text: 'Invert' }
        ];
        
        effects.forEach(effect => {
            const optionElement = document.createElement('option');
            optionElement.value = effect.value;
            optionElement.textContent = effect.text;
            effectTypes.appendChild(optionElement);
        });
        
        const intensityControl = document.createElement('div');
        intensityControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const intensityLabel = document.createElement('label');
        intensityLabel.textContent = 'Intensity:';
        intensityLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const intensitySlider = document.createElement('input');
        intensitySlider.type = 'range';
        intensitySlider.min = '0';
        intensitySlider.max = '100';
        intensitySlider.value = '50';
        intensitySlider.style.cssText = `
            width: 100%;
        `;
        
        const intensityValue = document.createElement('div');
        intensityValue.textContent = '50%';
        intensityValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        intensitySlider.addEventListener('input', (e) => {
            intensityValue.textContent = `${e.target.value}%`;
        });
        
        intensityControl.appendChild(intensityLabel);
        intensityControl.appendChild(intensitySlider);
        intensityControl.appendChild(intensityValue);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Effect';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const effectType = effectTypes.value;
            const intensity = parseInt(intensitySlider.value);
            
            // Add effect to global effects array
            const effect = {
                id: `effect-${Date.now()}`,
                type: effectType,
                intensity: intensity
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: `Effect: ${effectType}`,
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            // Render frame with new effect
            this.renderFrame();
            
            botReply(`Added ${effectType} effect with intensity ${intensity}%`);
            
            // Close the panel
            if (this.effectsPanel) {
                this.effectsPanel.remove();
                this.effectsPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.effectsPanel) {
                this.effectsPanel.remove();
                this.effectsPanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.effectsPanel.appendChild(title);
        this.effectsPanel.appendChild(effectTypes);
        this.effectsPanel.appendChild(intensityControl);
        this.effectsPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.effectsPanel);
    }
    
    /**
     * Add filter to video
     */
    addFilter() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create filter panel
        const filterPanel = document.createElement('div');
        filterPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Add Filter';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Create filter presets grid
        const filterGrid = document.createElement('div');
        filterGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Define filter presets
        const filterPresets = [
            { name: 'Normal', value: 'none' },
            { name: 'Vintage', value: 'sepia(100%) contrast(120%) brightness(90%)' },
            { name: 'Cold', value: 'hue-rotate(180deg) saturate(120%)' },
            { name: 'Warm', value: 'sepia(50%) saturate(120%) hue-rotate(-10deg)' },
            { name: 'Dramatic', value: 'contrast(150%) brightness(90%) grayscale(50%)' },
            { name: 'Noir', value: 'grayscale(100%) contrast(150%)' }
        ];
        
        // Create filter buttons
        filterPresets.forEach(filter => {
            const filterBtn = document.createElement('button');
            filterBtn.textContent = filter.name;
            filterBtn.style.cssText = `
                padding: 10px;
                background-color: #444;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                color: white;
                font-size: 12px;
            `;
            
            filterBtn.addEventListener('mouseover', () => {
                filterBtn.style.backgroundColor = '#555';
                filterBtn.style.transform = 'scale(1.05)';
            });
            
            filterBtn.addEventListener('mouseout', () => {
                filterBtn.style.backgroundColor = '#444';
                filterBtn.style.transform = 'scale(1)';
            });
            
            filterBtn.addEventListener('click', () => {
                // Apply filter to canvas
                this.canvas.style.filter = filter.value;
                
                // Add filter to effects array
                const effect = {
                    id: `effect-${Date.now()}`,
                    type: 'filter',
                    value: filter.value,
                    name: filter.name
                };
                
                this.effects.push(effect);
                
                // Create an effects track if it doesn't exist
                let effectsTrack = this.tracks.find(t => t.type === 'effects');
                if (!effectsTrack) {
                    effectsTrack = this.createTrack('Effects', 'effects');
                }
                
                // Add effect clip to timeline
                const effectClip = {
                    id: `clip-${Date.now()}`,
                    name: `Filter: ${filter.name}`,
                    url: null,
                    start: 0,
                    end: this.videoDuration,
                    track: effectsTrack.id,
                    type: 'filter',
                    effect: effect
                };
                
                effectsTrack.clips.push(effectClip);
                this.clips.push(effectClip);
                
                // Update the UI
                this.updateTimelineClips();
                
                botReply(`Applied ${filter.name} filter`);
                
                // Close the panel
                if (filterPanel) {
                    filterPanel.remove();
                }
            });
            
            filterGrid.appendChild(filterBtn);
        });
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (filterPanel) {
                filterPanel.remove();
            }
        });
        
        filterPanel.appendChild(title);
        filterPanel.appendChild(filterGrid);
        filterPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(filterPanel);
    }
    
    /**
     * Open audio tool
     */
    openAudioTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create audio panel
        this.audioPanel = document.createElement('div');
        this.audioPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Audio Tools';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Volume control
        const volumeControl = document.createElement('div');
        volumeControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const volumeLabel = document.createElement('label');
        volumeLabel.textContent = 'Volume:';
        volumeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const volumeSlider = document.createElement('input');
        volumeSlider.type = 'range';
        volumeSlider.min = '0';
        volumeSlider.max = '1';
        volumeSlider.step = '0.1';
        volumeSlider.value = this.volume.toString();
        volumeSlider.style.cssText = `
            width: 100%;
        `;
        
        const volumeValue = document.createElement('div');
        volumeValue.textContent = `${Math.round(this.volume * 100)}%`;
        volumeValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        volumeSlider.addEventListener('input', (e) => {
            this.volume = parseFloat(e.target.value);
            this.videoPreview.volume = this.volume;
            volumeValue.textContent = `${Math.round(this.volume * 100)}%`;
        });
        
        volumeControl.appendChild(volumeLabel);
        volumeControl.appendChild(volumeSlider);
        volumeControl.appendChild(volumeValue);
        
        // Fade in/out control
        const fadeControl = document.createElement('div');
        fadeControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const fadeLabel = document.createElement('label');
        fadeLabel.textContent = 'Fade Duration:';
        fadeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const fadeSlider = document.createElement('input');
        fadeSlider.type = 'range';
        fadeSlider.min = '0';
        fadeSlider.max = '5';
        fadeSlider.step = '0.5';
        fadeSlider.value = '0';
        fadeSlider.style.cssText = `
            width: 100%;
        `;
        
        const fadeValue = document.createElement('div');
        fadeValue.textContent = '0s';
        fadeValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        fadeSlider.addEventListener('input', (e) => {
            fadeValue.textContent = `${e.target.value}s`;
        });
        
        fadeControl.appendChild(fadeLabel);
        fadeControl.appendChild(fadeSlider);
        fadeControl.appendChild(fadeValue);
        
        // Audio effects
        const audioEffectsLabel = document.createElement('label');
        audioEffectsLabel.textContent = 'Audio Effects:';
        audioEffectsLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const audioEffectsSelect = document.createElement('select');
        audioEffectsSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const audioEffects = [
            { value: 'none', text: 'None' },
            { value: 'echo', text: 'Echo' },
            { value: 'reverb', text: 'Reverb' },
            { value: 'pitch', text: 'Pitch Shift' },
            { value: 'robot', text: 'Robot Voice' }
        ];
        
        audioEffects.forEach(effect => {
            const option = document.createElement('option');
            option.value = effect.value;
            option.textContent = effect.text;
            audioEffectsSelect.appendChild(option);
        });
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const fadeDuration = parseFloat(fadeSlider.value);
            const audioEffect = audioEffectsSelect.value;
            
            if (fadeDuration > 0) {
                botReply(`Applied ${fadeDuration}s fade to audio`);
            }
            
            if (audioEffect !== 'none') {
                botReply(`Applied ${audioEffect} audio effect`);
            }
            
            // Close the panel
            if (this.audioPanel) {
                this.audioPanel.remove();
                this.audioPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.audioPanel) {
                this.audioPanel.remove();
                this.audioPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.audioPanel.appendChild(title);
        this.audioPanel.appendChild(volumeControl);
        this.audioPanel.appendChild(fadeControl);
        this.audioPanel.appendChild(audioEffectsLabel);
        this.audioPanel.appendChild(audioEffectsSelect);
        this.audioPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.audioPanel);
    }
    
    /**
     * Open speed tool
     */
    openSpeedTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create speed panel
        this.speedPanel = document.createElement('div');
        this.speedPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Speed Control';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Speed presets
        const speedPresetsLabel = document.createElement('label');
        speedPresetsLabel.textContent = 'Speed Presets:';
        speedPresetsLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
        `;
        
        const speedPresetsContainer = document.createElement('div');
        speedPresetsContainer.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        `;
        
        const speedPresets = [
            { label: '0.25x', value: 0.25 },
            { label: '0.5x', value: 0.5 },
            { label: '1x', value: 1 },
            { label: '1.5x', value: 1.5 },
            { label: '2x', value: 2 }
        ];
        
        speedPresets.forEach(preset => {
            const presetBtn = document.createElement('button');
            presetBtn.textContent = preset.label;
            presetBtn.style.cssText = `
                padding: 8px;
                background-color: #444;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
                color: white;
                font-size: 12px;
                width: 60px;
            `;
            
            presetBtn.addEventListener('mouseover', () => {
                presetBtn.style.backgroundColor = '#555';
            });
            
            presetBtn.addEventListener('mouseout', () => {
                presetBtn.style.backgroundColor = '#444';
            });
            
            presetBtn.addEventListener('click', () => {
                this.playbackRate = preset.value;
                this.videoPreview.playbackRate = this.playbackRate;
                customSpeedSlider.value = preset.value.toString();
                customSpeedValue.textContent = `${preset.value}x`;
            });
            
            speedPresetsContainer.appendChild(presetBtn);
        });
        
        // Custom speed control
        const customSpeedControl = document.createElement('div');
        customSpeedControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const customSpeedLabel = document.createElement('label');
        customSpeedLabel.textContent = 'Custom Speed:';
        customSpeedLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const customSpeedSlider = document.createElement('input');
        customSpeedSlider.type = 'range';
        customSpeedSlider.min = '0.25';
        customSpeedSlider.max = '4';
        customSpeedSlider.step = '0.25';
        customSpeedSlider.value = this.playbackRate.toString();
        customSpeedSlider.style.cssText = `
            width: 100%;
        `;
        
        const customSpeedValue = document.createElement('div');
        customSpeedValue.textContent = `${this.playbackRate}x`;
        customSpeedValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        customSpeedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            this.playbackRate = speed;
            this.videoPreview.playbackRate = speed;
            customSpeedValue.textContent = `${speed}x`;
        });
        
        customSpeedControl.appendChild(customSpeedLabel);
        customSpeedControl.appendChild(customSpeedSlider);
        customSpeedControl.appendChild(customSpeedValue);
        
        // Maintain pitch control
        const maintainPitchControl = document.createElement('div');
        maintainPitchControl.style.cssText = `
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        `;
        
        const maintainPitchCheckbox = document.createElement('input');
        maintainPitchCheckbox.type = 'checkbox';
        maintainPitchCheckbox.id = 'maintain-pitch';
        maintainPitchCheckbox.style.cssText = `
            margin-right: 10px;
        `;
        
        const maintainPitchLabel = document.createElement('label');
        maintainPitchLabel.htmlFor = 'maintain-pitch';
        maintainPitchLabel.textContent = 'Maintain Audio Pitch';
        
        maintainPitchControl.appendChild(maintainPitchCheckbox);
        maintainPitchControl.appendChild(maintainPitchLabel);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            botReply(`Applied ${this.playbackRate}x speed to video`);
            
            // Close the panel
            if (this.speedPanel) {
                this.speedPanel.remove();
                this.speedPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.speedPanel) {
                this.speedPanel.remove();
                this.speedPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.speedPanel.appendChild(title);
        this.speedPanel.appendChild(speedPresetsLabel);
        this.speedPanel.appendChild(speedPresetsContainer);
        this.speedPanel.appendChild(customSpeedControl);
        this.speedPanel.appendChild(maintainPitchControl);
        this.speedPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.speedPanel);
    }
    
    /**
     * Open animation tool
     */
    openAnimationTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create animation panel
        this.animationPanel = document.createElement('div');
        this.animationPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Animation';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const animationTypesLabel = document.createElement('label');
        animationTypesLabel.textContent = 'Animation Type:';
        animationTypesLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const animationTypes = document.createElement('select');
        animationTypes.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const animations = [
            { value: 'fade-in', text: 'Fade In' },
            { value: 'fade-out', text: 'Fade Out' },
            { value: 'slide-in-left', text: 'Slide In Left' },
            { value: 'slide-in-right', text: 'Slide In Right' },
            { value: 'slide-in-top', text: 'Slide In Top' },
            { value: 'slide-in-bottom', text: 'Slide In Bottom' },
            { value: 'zoom-in', text: 'Zoom In' },
            { value: 'zoom-out', text: 'Zoom Out' },
            { value: 'rotate', text: 'Rotate' },
            { value: 'bounce', text: 'Bounce' }
        ];
        
        animations.forEach(animation => {
            const option = document.createElement('option');
            option.value = animation.value;
            option.textContent = animation.text;
            animationTypes.appendChild(option);
        });
        
        // Duration control
        const durationControl = document.createElement('div');
        durationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const durationLabel = document.createElement('label');
        durationLabel.textContent = 'Duration (seconds):';
        durationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const durationInput = document.createElement('input');
        durationInput.type = 'number';
        durationInput.min = '0.5';
        durationInput.max = '10';
        durationInput.step = '0.5';
        durationInput.value = '2';
        durationInput.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        durationControl.appendChild(durationLabel);
        durationControl.appendChild(durationInput);
        
        // Target selection
        const targetLabel = document.createElement('label');
        targetLabel.textContent = 'Apply To:';
        targetLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const targetSelect = document.createElement('select');
        targetSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const targets = [
            { value: 'video', text: 'Video' },
            { value: 'text', text: 'Text Overlays' },
            { value: 'stickers', text: 'Stickers' }
        ];
        
        targets.forEach(target => {
            const option = document.createElement('option');
            option.value = target.value;
            option.textContent = target.text;
            targetSelect.appendChild(option);
        });
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const animationType = animationTypes.value;
            const duration = parseFloat(durationInput.value);
            const target = targetSelect.value;
            
            // Create animation
            const animation = {
                id: `animation-${Date.now()}`,
                type: animationType,
                duration: duration,
                target: target,
                startTime: this.currentTime
            };
            
            this.animations.push(animation);
            
            // Create an animation track if it doesn't exist
            let animationTrack = this.tracks.find(t => t.type === 'animation');
            if (!animationTrack) {
                animationTrack = this.createTrack('Animation', 'animation');
            }
            
            // Add animation clip to timeline
            const animationClip = {
                id: `clip-${Date.now()}`,
                name: `Animation: ${animationType}`,
                url: null,
                start: this.currentTime,
                end: this.currentTime + duration,
                track: animationTrack.id,
                type: 'animation',
                animation: animation
            };
            
            animationTrack.clips.push(animationClip);
            this.clips.push(animationClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Added ${animationType} animation to ${target} for ${duration}s`);
            
            // Close the panel
            if (this.animationPanel) {
                this.animationPanel.remove();
                this.animationPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.animationPanel) {
                this.animationPanel.remove();
                this.animationPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.animationPanel.appendChild(title);
        this.animationPanel.appendChild(animationTypesLabel);
        this.animationPanel.appendChild(animationTypes);
        this.animationPanel.appendChild(durationControl);
        this.animationPanel.appendChild(targetLabel);
        this.animationPanel.appendChild(targetSelect);
        this.animationPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.animationPanel);
    }
    
    /**
     * Open keyframe tool
     */
    openKeyframeTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create keyframe panel
        this.keyframePanel = document.createElement('div');
        this.keyframePanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Keyframe Animation';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const infoText = document.createElement('div');
        infoText.textContent = 'Add keyframes to animate properties over time';
        infoText.style.cssText = `
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #aaa;
        `;
        
        // Property selection
        const propertyLabel = document.createElement('label');
        propertyLabel.textContent = 'Property to Animate:';
        propertyLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const propertySelect = document.createElement('select');
        propertySelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const properties = [
            { value: 'position', text: 'Position' },
            { value: 'scale', text: 'Scale' },
            { value: 'rotation', text: 'Rotation' },
            { value: 'opacity', text: 'Opacity' },
            { value: 'color', text: 'Color' }
        ];
        
        properties.forEach(property => {
            const option = document.createElement('option');
            option.value = property.value;
            option.textContent = property.text;
            propertySelect.appendChild(option);
        });
        
        // Value control
        const valueControl = document.createElement('div');
        valueControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const valueLabel = document.createElement('label');
        valueLabel.textContent = 'Value:';
        valueLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const valueInput = document.createElement('input');
        valueInput.type = 'text';
        valueInput.placeholder = 'Enter value';
        valueInput.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        valueControl.appendChild(valueLabel);
        valueControl.appendChild(valueInput);
        
        // Easing selection
        const easingLabel = document.createElement('label');
        easingLabel.textContent = 'Easing:';
        easingLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const easingSelect = document.createElement('select');
        easingSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const easings = [
            { value: 'linear', text: 'Linear' },
            { value: 'ease-in', text: 'Ease In' },
            { value: 'ease-out', text: 'Ease Out' },
            { value: 'ease-in-out', text: 'Ease In Out' },
            { value: 'bounce', text: 'Bounce' },
            { value: 'elastic', text: 'Elastic' }
        ];
        
        easings.forEach(easing => {
            const option = document.createElement('option');
            option.value = easing.value;
            option.textContent = easing.text;
            easingSelect.appendChild(option);
        });
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const addButton = document.createElement('button');
        addButton.textContent = 'Add Keyframe';
        addButton.style.cssText = this.getButtonStyle('btn-tool-export');
        addButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        addButton.addEventListener('click', () => {
            const property = propertySelect.value;
            const value = valueInput.value.trim();
            const easing = easingSelect.value;
            
            if (!value) {
                this.showError('Please enter a value');
                return;
            }
            
            // Create keyframe
            const keyframe = {
                id: `keyframe-${Date.now()}`,
                property: property,
                value: value,
                time: this.currentTime,
                easing: easing
            };
            
            this.keyframes.push(keyframe);
            
            // Create a keyframe track if it doesn't exist
            let keyframeTrack = this.tracks.find(t => t.type === 'keyframe');
            if (!keyframeTrack) {
                keyframeTrack = this.createTrack('Keyframe', 'keyframe');
            }
            
            // Add keyframe clip to timeline
            const keyframeClip = {
                id: `clip-${Date.now()}`,
                name: `Keyframe: ${property}`,
                url: null,
                start: this.currentTime,
                end: this.currentTime,
                track: keyframeTrack.id,
                type: 'keyframe',
                keyframe: keyframe
            };
            
            keyframeTrack.clips.push(keyframeClip);
            this.clips.push(keyframeClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Added keyframe for ${property} at ${this.formatTime(this.currentTime)}`);
            
            // Close the panel
            if (this.keyframePanel) {
                this.keyframePanel.remove();
                this.keyframePanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.keyframePanel) {
                this.keyframePanel.remove();
                this.keyframePanel = null;
            }
        });
        
        buttonsContainer.appendChild(addButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.keyframePanel.appendChild(title);
        this.keyframePanel.appendChild(infoText);
        this.keyframePanel.appendChild(propertyLabel);
        this.keyframePanel.appendChild(propertySelect);
        this.keyframePanel.appendChild(valueControl);
        this.keyframePanel.appendChild(easingLabel);
        this.keyframePanel.appendChild(easingSelect);
        this.keyframePanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.keyframePanel);
    }
    
    /**
     * Open chroma key tool
     */
    openChromaKeyTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create chroma key panel
        this.chromaKeyPanel = document.createElement('div');
        this.chromaKeyPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Chroma Key (Green Screen)';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const infoText = document.createElement('div');
        infoText.textContent = 'Remove a specific color from the video';
        infoText.style.cssText = `
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #aaa;
        `;
        
        // Color selection
        const colorLabel = document.createElement('label');
        colorLabel.textContent = 'Color to Remove:';
        colorLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = '#00ff00'; // Default to green
        colorPicker.style.cssText = `
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            margin-bottom: 15px;
        `;
        
        // Tolerance control
        const toleranceControl = document.createElement('div');
        toleranceControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const toleranceLabel = document.createElement('label');
        toleranceLabel.textContent = 'Tolerance:';
        toleranceLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const toleranceSlider = document.createElement('input');
        toleranceSlider.type = 'range';
        toleranceSlider.min = '0';
        toleranceSlider.max = '100';
        toleranceSlider.value = '30';
        toleranceSlider.style.cssText = `
            width: 100%;
        `;
        
        const toleranceValue = document.createElement('div');
        toleranceValue.textContent = '30%';
        toleranceValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        toleranceSlider.addEventListener('input', (e) => {
            toleranceValue.textContent = `${e.target.value}%`;
        });
        
        toleranceControl.appendChild(toleranceLabel);
        toleranceControl.appendChild(toleranceSlider);
        toleranceControl.appendChild(toleranceValue);
        
        // Edge feather control
        const featherControl = document.createElement('div');
        featherControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const featherLabel = document.createElement('label');
        featherLabel.textContent = 'Edge Feather:';
        featherLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const featherSlider = document.createElement('input');
        featherSlider.type = 'range';
        featherSlider.min = '0';
        featherSlider.max = '20';
        featherSlider.value = '5';
        featherSlider.style.cssText = `
            width: 100%;
        `;
        
        const featherValue = document.createElement('div');
        featherValue.textContent = '5px';
        featherValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        featherSlider.addEventListener('input', (e) => {
            featherValue.textContent = `${e.target.value}px`;
        });
        
        featherControl.appendChild(featherLabel);
        featherControl.appendChild(featherSlider);
        featherControl.appendChild(featherValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const color = colorPicker.value;
            const tolerance = parseInt(toleranceSlider.value);
            const feather = parseInt(featherSlider.value);
            
            // Add chroma key effect
            const effect = {
                id: `effect-${Date.now()}`,
                type: 'chromaKey',
                color: color,
                tolerance: tolerance,
                feather: feather
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: 'Chroma Key',
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply(`Applied chroma key effect for color ${color}`);
            
            // Close the panel
            if (this.chromaKeyPanel) {
                this.chromaKeyPanel.remove();
                this.chromaKeyPanel = null;
            }
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.chromaKeyPanel) {
                this.chromaKeyPanel.remove();
                this.chromaKeyPanel = null;
            }
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.chromaKeyPanel.appendChild(title);
        this.chromaKeyPanel.appendChild(infoText);
        this.chromaKeyPanel.appendChild(colorLabel);
        this.chromaKeyPanel.appendChild(colorPicker);
        this.chromaKeyPanel.appendChild(toleranceControl);
        this.chromaKeyPanel.appendChild(featherControl);
        this.chromaKeyPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.chromaKeyPanel);
    }
    
    /**
     * Open color tool
     */
    openColorTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create color panel
        this.colorPanel = document.createElement('div');
        this.colorPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Color Adjustment';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Brightness control
        const brightnessControl = document.createElement('div');
        brightnessControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const brightnessLabel = document.createElement('label');
        brightnessLabel.textContent = 'Brightness:';
        brightnessLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const brightnessSlider = document.createElement('input');
        brightnessSlider.type = 'range';
        brightnessSlider.min = '-100';
        brightnessSlider.max = '100';
        brightnessSlider.value = '0';
        brightnessSlider.style.cssText = `
            width: 100%;
        `;
        
        const brightnessValue = document.createElement('div');
        brightnessValue.textContent = '0';
        brightnessValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        brightnessSlider.addEventListener('input', (e) => {
            brightnessValue.textContent = e.target.value;
        });
        
        brightnessControl.appendChild(brightnessLabel);
        brightnessControl.appendChild(brightnessSlider);
        brightnessControl.appendChild(brightnessValue);
        
        // Contrast control
        const contrastControl = document.createElement('div');
        contrastControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const contrastLabel = document.createElement('label');
        contrastLabel.textContent = 'Contrast:';
        contrastLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const contrastSlider = document.createElement('input');
        contrastSlider.type = 'range';
        contrastSlider.min = '-100';
        contrastSlider.max = '100';
        contrastSlider.value = '0';
        contrastSlider.style.cssText = `
            width: 100%;
        `;
        
        const contrastValue = document.createElement('div');
        contrastValue.textContent = '0';
        contrastValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        contrastSlider.addEventListener('input', (e) => {
            contrastValue.textContent = e.target.value;
        });
        
        contrastControl.appendChild(contrastLabel);
        contrastControl.appendChild(contrastSlider);
        contrastControl.appendChild(contrastValue);
        
        // Saturation control
        const saturationControl = document.createElement('div');
        saturationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const saturationLabel = document.createElement('label');
        saturationLabel.textContent = 'Saturation:';
        saturationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const saturationSlider = document.createElement('input');
        saturationSlider.type = 'range';
        saturationSlider.min = '-100';
        saturationSlider.max = '100';
        saturationSlider.value = '0';
        saturationSlider.style.cssText = `
            width: 100%;
        `;
        
        const saturationValue = document.createElement('div');
        saturationValue.textContent = '0';
        saturationValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        saturationSlider.addEventListener('input', (e) => {
            saturationValue.textContent = e.target.value;
        });
        
        saturationControl.appendChild(saturationLabel);
        saturationControl.appendChild(saturationSlider);
        saturationControl.appendChild(saturationValue);
        
        // Hue control
        const hueControl = document.createElement('div');
        hueControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const hueLabel = document.createElement('label');
        hueLabel.textContent = 'Hue:';
        hueLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const hueSlider = document.createElement('input');
        hueSlider.type = 'range';
        hueSlider.min = '-180';
        hueSlider.max = '180';
        hueSlider.value = '0';
        hueSlider.style.cssText = `
            width: 100%;
        `;
        
        const hueValue = document.createElement('div');
        hueValue.textContent = '0°';
        hueValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        hueSlider.addEventListener('input', (e) => {
            hueValue.textContent = `${e.target.value}°`;
        });
        
        hueControl.appendChild(hueLabel);
        hueControl.appendChild(hueSlider);
        hueControl.appendChild(hueValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const resetButton = document.createElement('button');
        resetButton.textContent = 'Reset';
        resetButton.style.cssText = this.getButtonStyle('btn-tool');
        resetButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const brightness = parseInt(brightnessSlider.value);
            const contrast = parseInt(contrastSlider.value);
            const saturation = parseInt(saturationSlider.value);
            const hue = parseInt(hueSlider.value);
            
            // Create color adjustment effect
            const effect = {
                id: `effect-${Date.now()}`,
                type: 'colorAdjust',
                brightness: brightness,
                contrast: contrast,
                saturation: saturation,
                hue: hue
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: 'Color Adjustment',
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply('Applied color adjustment');
            
            // Close the panel
            if (this.colorPanel) {
                this.colorPanel.remove();
                this.colorPanel = null;
            }
        });
        
        resetButton.addEventListener('click', () => {
            brightnessSlider.value = '0';
            brightnessValue.textContent = '0';
            contrastSlider.value = '0';
            contrastValue.textContent = '0';
            saturationSlider.value = '0';
            saturationValue.textContent = '0';
            hueSlider.value = '0';
            hueValue.textContent = '0°';
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(resetButton);
        
        this.colorPanel.appendChild(title);
        this.colorPanel.appendChild(brightnessControl);
        this.colorPanel.appendChild(contrastControl);
        this.colorPanel.appendChild(saturationControl);
        this.colorPanel.appendChild(hueControl);
        this.colorPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.colorPanel);
    }
    
    /**
     * Open transform tool
     */
    openTransformTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create transform panel
        const transformPanel = document.createElement('div');
        transformPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Transform';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Position X control
        const posXControl = document.createElement('div');
        posXControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const posXLabel = document.createElement('label');
        posXLabel.textContent = 'Position X:';
        posXLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const posXSlider = document.createElement('input');
        posXSlider.type = 'range';
        posXSlider.min = '-100';
        posXSlider.max = '100';
        posXSlider.value = '0';
        posXSlider.style.cssText = `
            width: 100%;
        `;
        
        const posXValue = document.createElement('div');
        posXValue.textContent = '0';
        posXValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        posXSlider.addEventListener('input', (e) => {
            posXValue.textContent = e.target.value;
        });
        
        posXControl.appendChild(posXLabel);
        posXControl.appendChild(posXSlider);
        posXControl.appendChild(posXValue);
        
        // Position Y control
        const posYControl = document.createElement('div');
        posYControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const posYLabel = document.createElement('label');
        posYLabel.textContent = 'Position Y:';
        posYLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const posYSlider = document.createElement('input');
        posYSlider.type = 'range';
        posYSlider.min = '-100';
        posYSlider.max = '100';
        posYSlider.value = '0';
        posYSlider.style.cssText = `
            width: 100%;
        `;
        
        const posYValue = document.createElement('div');
        posYValue.textContent = '0';
        posYValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        posYSlider.addEventListener('input', (e) => {
            posYValue.textContent = e.target.value;
        });
        
        posYControl.appendChild(posYLabel);
        posYControl.appendChild(posYSlider);
        posYControl.appendChild(posYValue);
        
        // Scale control
        const scaleControl = document.createElement('div');
        scaleControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const scaleLabel = document.createElement('label');
        scaleLabel.textContent = 'Scale:';
        scaleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const scaleSlider = document.createElement('input');
        scaleSlider.type = 'range';
        scaleSlider.min = '10';
        scaleSlider.max = '200';
        scaleSlider.value = '100';
        scaleSlider.style.cssText = `
            width: 100%;
        `;
        
        const scaleValue = document.createElement('div');
        scaleValue.textContent = '100%';
        scaleValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        scaleSlider.addEventListener('input', (e) => {
            scaleValue.textContent = `${e.target.value}%`;
        });
        
        scaleControl.appendChild(scaleLabel);
        scaleControl.appendChild(scaleSlider);
        scaleControl.appendChild(scaleValue);
        
        // Rotation control
        const rotationControl = document.createElement('div');
        rotationControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const rotationLabel = document.createElement('label');
        rotationLabel.textContent = 'Rotation:';
        rotationLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const rotationSlider = document.createElement('input');
        rotationSlider.type = 'range';
        rotationSlider.min = '-180';
        rotationSlider.max = '180';
        rotationSlider.value = '0';
        rotationSlider.style.cssText = `
            width: 100%;
        `;
        
        const rotationValue = document.createElement('div');
        rotationValue.textContent = '0°';
        rotationValue.style.cssText = `
            text-align: center;
            margin-top: 5px;
        `;
        
        rotationSlider.addEventListener('input', (e) => {
            rotationValue.textContent = `${e.target.value}°`;
        });
        
        rotationControl.appendChild(rotationLabel);
        rotationControl.appendChild(rotationSlider);
        rotationControl.appendChild(rotationValue);
        
        // Buttons
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const applyButton = document.createElement('button');
        applyButton.textContent = 'Apply';
        applyButton.style.cssText = this.getButtonStyle('btn-tool-export');
        applyButton.style.flex = '1';
        
        const resetButton = document.createElement('button');
        resetButton.textContent = 'Reset';
        resetButton.style.cssText = this.getButtonStyle('btn-tool');
        resetButton.style.flex = '1';
        
        applyButton.addEventListener('click', () => {
            const posX = parseInt(posXSlider.value);
            const posY = parseInt(posYSlider.value);
            const scale = parseInt(scaleSlider.value);
            const rotation = parseInt(rotationSlider.value);
            
            // Create transform effect
            const effect = {
                id: `effect-${Date.now()}`,
                type: 'transform',
                posX: posX,
                posY: posY,
                scale: scale,
                rotation: rotation
            };
            
            this.effects.push(effect);
            
            // Create an effects track if it doesn't exist
            let effectsTrack = this.tracks.find(t => t.type === 'effects');
            if (!effectsTrack) {
                effectsTrack = this.createTrack('Effects', 'effects');
            }
            
            // Add effect clip to timeline
            const effectClip = {
                id: `clip-${Date.now()}`,
                name: 'Transform',
                url: null,
                start: 0,
                end: this.videoDuration,
                track: effectsTrack.id,
                type: 'effect',
                effect: effect
            };
            
            effectsTrack.clips.push(effectClip);
            this.clips.push(effectClip);
            
            // Update the UI
            this.updateTimelineClips();
            
            botReply('Applied transform effect');
            
            // Close the panel
            if (transformPanel) {
                transformPanel.remove();
                transformPanel = null;
            }
        });
        
        resetButton.addEventListener('click', () => {
            posXSlider.value = '0';
            posXValue.textContent = '0';
            posYSlider.value = '0';
            posYValue.textContent = '0';
            scaleSlider.value = '100';
            scaleValue.textContent = '100%';
            rotationSlider.value = '0';
            rotationValue.textContent = '0°';
        });
        
        buttonsContainer.appendChild(applyButton);
        buttonsContainer.appendChild(resetButton);
        
        transformPanel.appendChild(title);
        transformPanel.appendChild(posXControl);
        transformPanel.appendChild(posYControl);
        transformPanel.appendChild(scaleControl);
        transformPanel.appendChild(rotationControl);
        transformPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(transformPanel);
    }
    
    /**
     * Open layers tool
     */
    openLayersTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create layers panel
        this.layersPanel = document.createElement('div');
        this.layersPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Layers';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Create layers list
        const layersList = document.createElement('div');
        layersList.style.cssText = `
            margin-bottom: 15px;
        `;
        
        // Add video layer
        const videoLayer = document.createElement('div');
        videoLayer.style.cssText = `
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
            margin-bottom: 5px;
        `;
        
        const videoLayerIcon = document.createElement('div');
        videoLayerIcon.textContent = '🎬';
        videoLayerIcon.style.cssText = `
            margin-right: 10px;
            font-size: 18px;
        `;
        
        const videoLayerName = document.createElement('div');
        videoLayerName.textContent = 'Video';
        videoLayerName.style.cssText = `
            flex: 1;
        `;
        
        const videoLayerVisible = document.createElement('input');
        videoLayerVisible.type = 'checkbox';
        videoLayerVisible.checked = true;
        videoLayerVisible.style.cssText = `
            margin-right: 5px;
        `;
        
        videoLayer.appendChild(videoLayerIcon);
        videoLayer.appendChild(videoLayerName);
        videoLayer.appendChild(videoLayerVisible);
        
        layersList.appendChild(videoLayer);
        
        // Add text layers
        this.textOverlays.forEach((text, index) => {
            const textLayer = document.createElement('div');
            textLayer.style.cssText = `
                display: flex;
                align-items: center;
                padding: 10px;
                background-color: #444;
                border-radius: 4px;
                margin-bottom: 5px;
            `;
            
            const textLayerIcon = document.createElement('div');
            textLayerIcon.textContent = 'T';
            textLayerIcon.style.cssText = `
                margin-right: 10px;
                font-size: 18px;
            `;
            
            const textLayerName = document.createElement('div');
            textLayerName.textContent = text.content.length > 15 ? text.content.substring(0, 15) + '...' : text.content;
            textLayerName.style.cssText = `
                flex: 1;
            `;
            
            const textLayerVisible = document.createElement('input');
            textLayerVisible.type = 'checkbox';
            textLayerVisible.checked = true;
            textLayerVisible.style.cssText = `
                margin-right: 5px;
            `;
            
            const textLayerDelete = document.createElement('button');
            textLayerDelete.textContent = '❌';
            textLayerDelete.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
            `;
            
            textLayerDelete.addEventListener('click', () => {
                // Remove text overlay
                this.textOverlays.splice(index, 1);
                
                // Remove from timeline
                const clipIndex = this.clips.findIndex(c => c.textOverlay && c.textOverlay.id === text.id);
                if (clipIndex !== -1) {
                    this.clips.splice(clipIndex, 1);
                    
                    // Remove from track
                    const track = this.tracks.find(t => t.id === text.track);
                    if (track) {
                        const trackClipIndex = track.clips.findIndex(c => c.id === text.id);
                        if (trackClipIndex !== -1) {
                            track.clips.splice(trackClipIndex, 1);
                        }
                    }
                    
                    // Update UI
                    this.updateTimelineClips();
                }
                
                // Rebuild layers panel
                if (this.layersPanel) {
                    this.layersPanel.remove();
                    this.openLayersTool();
                }
            });
            
            textLayer.appendChild(textLayerIcon);
            textLayer.appendChild(textLayerName);
            textLayer.appendChild(textLayerVisible);
            textLayer.appendChild(textLayerDelete);
            
            layersList.appendChild(textLayer);
        });
        
        // Add sticker layers
        this.stickers.forEach((sticker, index) => {
            const stickerLayer = document.createElement('div');
            stickerLayer.style.cssText = `
                display: flex;
                align-items: center;
                padding: 10px;
                background-color: #444;
                border-radius: 4px;
                margin-bottom: 5px;
            `;
            
            const stickerLayerIcon = document.createElement('div');
            stickerLayerIcon.textContent = '🏷️';
            stickerLayerIcon.style.cssText = `
                margin-right: 10px;
                font-size: 18px;
            `;
            
            const stickerLayerName = document.createElement('div');
            stickerLayerName.textContent = `Sticker: ${sticker.emoji}`;
            stickerLayerName.style.cssText = `
                flex: 1;
            `;
            
            const stickerLayerVisible = document.createElement('input');
            stickerLayerVisible.type = 'checkbox';
            stickerLayerVisible.checked = true;
            stickerLayerVisible.style.cssText = `
                margin-right: 5px;
            `;
            
            const stickerLayerDelete = document.createElement('button');
            stickerLayerDelete.textContent = '❌';
            stickerLayerDelete.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
            `;
            
            stickerLayerDelete.addEventListener('click', () => {
                // Remove sticker
                this.stickers.splice(index, 1);
                
                // Remove from timeline
                const clipIndex = this.clips.findIndex(c => c.sticker && c.sticker.id === sticker.id);
                if (clipIndex !== -1) {
                    this.clips.splice(clipIndex, 1);
                    
                    // Remove from track
                    const track = this.tracks.find(t => t.id === sticker.track);
                    if (track) {
                        const trackClipIndex = track.clips.findIndex(c => c.id === sticker.id);
                        if (trackClipIndex !== -1) {
                            track.clips.splice(trackClipIndex, 1);
                        }
                    }
                    
                    // Update UI
                    this.updateTimelineClips();
                }
                
                // Rebuild layers panel
                if (this.layersPanel) {
                    this.layersPanel.remove();
                    this.openLayersTool();
                }
            });
            
            stickerLayer.appendChild(stickerLayerIcon);
            stickerLayer.appendChild(stickerLayerName);
            stickerLayer.appendChild(stickerLayerVisible);
            stickerLayer.appendChild(stickerLayerDelete);
            
            layersList.appendChild(stickerLayer);
        });
        
        // Add effect layers
        this.effects.forEach((effect, index) => {
            const effectLayer = document.createElement('div');
            effectLayer.style.cssText = `
                display: flex;
                align-items: center;
                padding: 10px;
                background-color: #444;
                border-radius: 4px;
                margin-bottom: 5px;
            `;
            
            const effectLayerIcon = document.createElement('div');
            effectLayerIcon.textContent = '✨';
            effectLayerIcon.style.cssText = `
                margin-right: 10px;
                font-size: 18px;
            `;
            
            const effectLayerName = document.createElement('div');
            effectLayerName.textContent = `Effect: ${effect.type}`;
            effectLayerName.style.cssText = `
                flex: 1;
            `;
            
            const effectLayerVisible = document.createElement('input');
            effectLayerVisible.type = 'checkbox';
            effectLayerVisible.checked = true;
            effectLayerVisible.style.cssText = `
                margin-right: 5px;
            `;
            
            const effectLayerDelete = document.createElement('button');
            effectLayerDelete.textContent = '❌';
            effectLayerDelete.style.cssText = `
                background: none;
                border: none;
                color: white;
                cursor: pointer;
                font-size: 16px;
            `;
            
            effectLayerDelete.addEventListener('click', () => {
                // Remove effect
                this.effects.splice(index, 1);
                
                // Remove from timeline
                const clipIndex = this.clips.findIndex(c => c.effect && c.effect.id === effect.id);
                if (clipIndex !== -1) {
                    this.clips.splice(clipIndex, 1);
                    
                    // Remove from track
                    const track = this.tracks.find(t => t.id === effect.track);
                    if (track) {
                        const trackClipIndex = track.clips.findIndex(c => c.id === effect.id);
                        if (trackClipIndex !== -1) {
                            track.clips.splice(trackClipIndex, 1);
                        }
                    }
                    
                    // Update UI
                    this.updateTimelineClips();
                }
                
                // Rebuild layers panel
                if (this.layersPanel) {
                    this.layersPanel.remove();
                    this.openLayersTool();
                }
            });
            
            effectLayer.appendChild(effectLayerIcon);
            effectLayer.appendChild(effectLayerName);
            effectLayer.appendChild(effectLayerVisible);
            effectLayer.appendChild(effectLayerDelete);
            
            layersList.appendChild(effectLayer);
        });
        
        // Close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (this.layersPanel) {
                this.layersPanel.remove();
                this.layersPanel = null;
            }
        });
        
        this.layersPanel.appendChild(title);
        this.layersPanel.appendChild(layersList);
        this.layersPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(this.layersPanel);
    }
    
    /**
     * Open properties tool
     */
    openPropertiesTool() {
        if (!this.currentVideo) {
            this.showError('No video loaded');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create properties panel
        this.propertiesPanel = document.createElement('div');
        this.propertiesPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Properties';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        // Video info
        const videoInfo = document.createElement('div');
        videoInfo.style.cssText = `
            margin-bottom: 15px;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
        `;
        
        const videoName = document.createElement('div');
        videoName.textContent = `Name: ${this.currentVideo.name}`;
        videoName.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const videoDuration = document.createElement('div');
        videoDuration.textContent = `Duration: ${this.formatTime(this.videoDuration)}`;
        videoDuration.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const videoDimensions = document.createElement('div');
        videoDimensions.textContent = `Dimensions: ${this.canvas.width}x${this.canvas.height}`;
        videoDimensions.style.cssText = `
            margin-bottom: 5px;
        `;
        
        videoInfo.appendChild(videoName);
        videoInfo.appendChild(videoDuration);
        videoInfo.appendChild(videoDimensions);
        
        // Project info
        const projectInfo = document.createElement('div');
        projectInfo.style.cssText = `
            margin-bottom: 15px;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
        `;
        
        const projectTitle = document.createElement('div');
        projectTitle.textContent = 'Project Settings';
        projectTitle.style.cssText = `
            font-weight: bold;
            margin-bottom: 10px;
        `;
        
        const fpsControl = document.createElement('div');
        fpsControl.style.cssText = `
            margin-bottom: 10px;
        `;
        
        const fpsLabel = document.createElement('label');
        fpsLabel.textContent = 'FPS:';
        fpsLabel.style.cssText = `
            display: inline-block;
            width: 80px;
        `;
        
        const fpsSelect = document.createElement('select');
        fpsSelect.style.cssText = `
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #555;
            color: white;
        `;
        
        const fpsOptions = [
            { value: '24', text: '24' },
            { value: '25', text: '25' },
            { value: '30', text: '30' },
            { value: '50', text: '50' },
            { value: '60', text: '60' }
        ];
        
        fpsOptions.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.text;
            fpsSelect.appendChild(optionElement);
        });
        
        fpsSelect.value = '30'; // Default to 30 FPS
        
        fpsControl.appendChild(fpsLabel);
        fpsControl.appendChild(fpsSelect);
        
        const resolutionControl = document.createElement('div');
        resolutionControl.style.cssText = `
            margin-bottom: 10px;
        `;
        
        const resolutionLabel = document.createElement('label');
        resolutionLabel.textContent = 'Resolution:';
        resolutionLabel.style.cssText = `
            display: inline-block;
            width: 80px;
        `;
        
        const resolutionSelect = document.createElement('select');
        resolutionSelect.style.cssText = `
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #555;
            color: white;
        `;
        
        const resolutionOptions = [
            { value: 'original', text: 'Original' },
            { value: '3840x2160', text: '4K (3840x2160)' },
            { value: '1920x1080', text: 'Full HD (1920x1080)' },
            { value: '1280x720', text: 'HD (1280x720)' },
            { value: '854x480', text: 'SD (854x480)' }
        ];
        
        resolutionOptions.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option.value;
            optionElement.textContent = option.text;
            resolutionSelect.appendChild(optionElement);
        });
        
        resolutionSelect.value = 'original'; // Default to original resolution
        
        resolutionControl.appendChild(resolutionLabel);
        resolutionControl.appendChild(resolutionSelect);
        
        projectInfo.appendChild(projectTitle);
        projectInfo.appendChild(fpsControl);
        projectInfo.appendChild(resolutionControl);
        
        // Statistics
        const statsInfo = document.createElement('div');
        statsInfo.style.cssText = `
            margin-bottom: 15px;
            padding: 10px;
            background-color: #444;
            border-radius: 4px;
        `;
        
        const statsTitle = document.createElement('div');
        statsTitle.textContent = 'Statistics';
        statsTitle.style.cssText = `
            font-weight: bold;
            margin-bottom: 10px;
        `;
        
        const clipsCount = document.createElement('div');
        clipsCount.textContent = `Clips: ${this.clips.length}`;
        clipsCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const textCount = document.createElement('div');
        textCount.textContent = `Text Overlays: ${this.textOverlays.length}`;
        textCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const stickerCount = document.createElement('div');
        stickerCount.textContent = `Stickers: ${this.stickers.length}`;
        stickerCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        const effectsCount = document.createElement('div');
        effectsCount.textContent = `Effects: ${this.effects.length}`;
        effectsCount.style.cssText = `
            margin-bottom: 5px;
        `;
        
        statsInfo.appendChild(statsTitle);
        statsInfo.appendChild(clipsCount);
        statsInfo.appendChild(textCount);
        statsInfo.appendChild(stickerCount);
        statsInfo.appendChild(effectsCount);
        
        // Close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-tool');
        closeButton.style.width = '100%';
        
        closeButton.addEventListener('click', () => {
            if (this.propertiesPanel) {
                this.propertiesPanel.remove();
                this.propertiesPanel = null;
            }
        });
        
        this.propertiesPanel.appendChild(title);
        this.propertiesPanel.appendChild(videoInfo);
        this.propertiesPanel.appendChild(projectInfo);
        this.propertiesPanel.appendChild(statsInfo);
        this.propertiesPanel.appendChild(closeButton);
        
        this.gameContainer.appendChild(this.propertiesPanel);
    }
    
    /**
     * Import media - VIDEO UPLOAD FUNCTION
     */
    importMedia() {
        // Create a file input element
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'video/*,audio/*';
        fileInput.style.display = 'none';
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                this.loadVideo(fileURL, file.name);
                botReply(`Uploading ${file.name}...`);
            }
        });
        
        // Trigger the file input
        document.body.appendChild(fileInput);
        fileInput.click();
        document.body.removeChild(fileInput);
    }
    
    /**
     * Load a video
     */
    loadVideo(url, name) {
        // If there's already a video loaded, revoke its URL to prevent memory leaks
        if (this.currentVideo) {
            URL.revokeObjectURL(this.currentVideo.url);
        }
        
        // Clear existing effects, text overlays, and transitions
        this.effects = [];
        this.textOverlays = [];
        this.transitions = [];
        this.clips = [];
        this.stickers = [];
        this.animations = [];
        this.keyframes = [];
        
        // Clear tracks
        this.tracks.forEach(track => {
            const trackElement = document.getElementById(track.id);
            if (trackElement) {
                const trackContent = trackElement.querySelector('div:last-child');
                if (trackContent) {
                    trackContent.innerHTML = '';
                }
            }
            track.clips = [];
        });
        
        this.currentVideo = {
            url: url,
            name: name
        };
        
        this.videoPreview.src = url;
        this.projectInfo.textContent = name;
        
        // Hide the upload area once a video is loaded
        this.uploadArea.style.display = 'none';
        
        botReply(`Loaded video: ${name}`);
        
        // Add a clip to the timeline
        this.addClipToTimeline('video', name, url);
    }
    
    /**
     * Add a clip to the timeline
     */
    addClipToTimeline(trackType, name, url) {
        // Find or create a track of the specified type
        let track = this.tracks.find(t => t.type === trackType);
        
        if (!track) {
            track = this.createTrack(trackType.charAt(0).toUpperCase() + trackType.slice(1), trackType);
        }
        
        // Create a new clip
        const clip = {
            id: `clip-${Date.now()}`,
            name: name,
            url: url,
            start: 0,
            end: this.videoDuration || 10, // Default to 10 seconds if duration not available
            track: track.id,
            type: trackType
        };
        
        track.clips.push(clip);
        this.clips.push(clip);
        
        // Create the clip element in the timeline
        const trackElement = document.getElementById(track.id);
        const trackContent = trackElement.querySelector('div:last-child');
        
        const clipElement = document.createElement('div');
        clipElement.id = clip.id;
        clipElement.style.cssText = `
            position: absolute;
            left: ${clip.start * 50}px;
            top: 10px;
            width: ${(clip.end - clip.start) * 50}px;
            height: 40px;
            background-color: ${trackType === 'video' ? '#4a6fa5' : trackType === 'audio' ? '#5a9654' : trackType === 'text' ? '#9c27b0' : '#ff9800'};
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            padding: 0 10px;
            cursor: pointer;
        `;
        
        clipElement.textContent = name;
        clipElement.title = name;
        
        clipElement.addEventListener('click', () => {
            this.selectClip(clip.id);
        });
        
        trackContent.appendChild(clipElement);
        
        // Select the track
        this.selectTrack(track.id);
    }
    
    /**
     * Update timeline clips
     */
    updateTimelineClips() {
        // Clear all track contents
        this.tracks.forEach(track => {
            const trackElement = document.getElementById(track.id);
            if (trackElement) {
                const trackContent = trackElement.querySelector('div:last-child');
                if (trackContent) {
                    trackContent.innerHTML = '';
                }
            }
        });
        
        // Re-add all clips
        this.clips.forEach(clip => {
            const trackElement = document.getElementById(clip.track);
            if (trackElement) {
                const trackContent = trackElement.querySelector('div:last-child');
                if (trackContent) {
                    const clipElement = document.createElement('div');
                    clipElement.id = clip.id;
                    
                    // Set background color based on clip type
                    let bgColor = '#4a6fa5'; // Default video color
                    if (clip.type === 'audio') bgColor = '#5a9654';
                    else if (clip.type === 'text') bgColor = '#9c27b0';
                    else if (clip.type === 'transition') bgColor = '#ff5722';
                    else if (clip.type === 'effect') bgColor = '#ff9800';
                    else if (clip.type === 'sticker') bgColor = '#e91e63';
                    else if (clip.type === 'animation') bgColor = '#00bcd4';
                    else if (clip.type === 'keyframe') bgColor = '#8bc34a';
                    
                    clipElement.style.cssText = `
                        position: absolute;
                        left: ${clip.start * 50}px;
                        top: 10px;
                        width: ${(clip.end - clip.start) * 50}px;
                        height: 40px;
                        background-color: ${bgColor};
                        border-radius: 4px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-size: 12px;
                        overflow: hidden;
                        white-space: nowrap;
                        text-overflow: ellipsis;
                        padding: 0 10px;
                        cursor: pointer;
                        ${clip.effects && clip.effects.length > 0 ? 'box-shadow: 0 0 5px #ff9800;' : ''}
                    `;
                    
                    clipElement.textContent = clip.name;
                    clipElement.title = clip.name;
                    
                    clipElement.addEventListener('click', () => {
                        this.selectClip(clip.id);
                    });
                    
                    trackContent.appendChild(clipElement);
                }
            }
        });
    }
    
    /**
     * Select a clip
     */
    selectClip(clipId) {
        // Deselect all clips
        this.clips.forEach(clip => {
            const clipElement = document.getElementById(clip.id);
            if (clipElement) {
                clipElement.style.border = 'none';
            }
        });
        
        // Select the specified clip
        this.selectedClip = clipId;
        const clipElement = document.getElementById(clipId);
        if (clipElement) {
            clipElement.style.border = '2px solid #ff9800';
        }
        
        botReply(`Selected clip: ${clipId}`);
    }
    
    /**
     * Export video
     */
    exportVideo() {
        if (!this.currentVideo) {
            this.showError('No video to export');
            return;
        }
        
        // Close any existing panels
        this.closeAllPanels();
        
        // Create export panel
        this.exportPanel = document.createElement('div');
        this.exportPanel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const title = document.createElement('h3');
        title.textContent = 'Export Video';
        title.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        const formatControl = document.createElement('div');
        formatControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const formatLabel = document.createElement('label');
        formatLabel.textContent = 'Format:';
        formatLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const formatSelect = document.createElement('select');
        formatSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const formats = [
            { value: 'mp4', text: 'MP4 (Recommended)' },
            { value: 'webm', text: 'WebM' },
            { value: 'mov', text: 'MOV' }
        ];
        
        formats.forEach(format => {
            const option = document.createElement('option');
            option.value = format.value;
            option.textContent = format.text;
            formatSelect.appendChild(option);
        });
        
        formatControl.appendChild(formatLabel);
        formatControl.appendChild(formatSelect);
        
        const qualityControl = document.createElement('div');
        qualityControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const qualityLabel = document.createElement('label');
        qualityLabel.textContent = 'Quality:';
        qualityLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const qualitySelect = document.createElement('select');
        qualitySelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const qualities = [
            { value: 'high', text: 'High (1080p)' },
            { value: 'medium', text: 'Medium (720p)' },
            { value: 'low', text: 'Low (480p)' }
        ];
        
        qualities.forEach(quality => {
            const option = document.createElement('option');
            option.value = quality.value;
            option.textContent = quality.text;
            qualitySelect.appendChild(option);
        });
        
        qualityControl.appendChild(qualityLabel);
        qualityControl.appendChild(qualitySelect);
        
        const resolutionControl = document.createElement('div');
        resolutionControl.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const resolutionLabel = document.createElement('label');
        resolutionLabel.textContent = 'Resolution:';
        resolutionLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
        `;
        
        const resolutionSelect = document.createElement('select');
        resolutionSelect.style.cssText = `
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #444;
            color: white;
        `;
        
        const resolutions = [
            { value: 'original', text: 'Original' },
            { value: '1920x1080', text: '1920x1080 (Full HD)' },
            { value: '1280x720', text: '1280x720 (HD)' },
            { value: '854x480', text: '854x480 (SD)' }
        ];
        
        resolutions.forEach(resolution => {
            const option = document.createElement('option');
            option.value = resolution.value;
            option.textContent = resolution.text;
            resolutionSelect.appendChild(option);
        });
        
        resolutionControl.appendChild(resolutionLabel);
        resolutionControl.appendChild(resolutionSelect);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const exportButton = document.createElement('button');
        exportButton.textContent = 'Export';
        exportButton.style.cssText = this.getButtonStyle('btn-tool-export');
        exportButton.style.flex = '1';
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = this.getButtonStyle('btn-tool');
        cancelButton.style.flex = '1';
        
        exportButton.addEventListener('click', () => {
            const format = formatSelect.value;
            const quality = qualitySelect.value;
            const resolution = resolutionSelect.value;
            
            botReply(`Exporting video as ${format} with ${quality} quality at ${resolution} resolution...`);
            
            // Close the panel
            if (this.exportPanel) {
                this.exportPanel.remove();
                this.exportPanel = null;
            }
            
            // Simulate export process
            setTimeout(() => {
                botReply('Video exported successfully! In a full implementation, the video would be downloaded.');
            }, 2000);
        });
        
        cancelButton.addEventListener('click', () => {
            if (this.exportPanel) {
                this.exportPanel.remove();
                this.exportPanel = null;
            }
        });
        
        buttonsContainer.appendChild(exportButton);
        buttonsContainer.appendChild(cancelButton);
        
        this.exportPanel.appendChild(title);
        this.exportPanel.appendChild(formatControl);
        this.exportPanel.appendChild(qualityControl);
        this.exportPanel.appendChild(resolutionControl);
        this.exportPanel.appendChild(buttonsContainer);
        
        this.gameContainer.appendChild(this.exportPanel);
    }
    
    /**
     * Update timeline
     */
    updateTimeline() {
        // Update timeline duration markers
        // In a real implementation, this would adjust the timeline to match the video duration
        this.updateTimeDisplay();
    }
    
    /**
     * Update timeline position
     */
    updateTimelinePosition() {
        // Update playhead position in timeline
        if (this.playhead) {
            const position = (this.currentTime / (this.videoDuration || 60)) * 3000; // 3000px is max width
            this.playhead.style.left = `${position}px`;
        }
        this.updateTimeDisplay();
    }
    
    /**
     * Update time display
     */
    updateTimeDisplay() {
        const currentTimeStr = this.formatTime(this.currentTime);
        const totalTimeStr = this.formatTime(this.videoDuration);
        this.timeDisplay.textContent = `${currentTimeStr} / ${totalTimeStr}`;
    }
    
    /**
     * Format time as MM:SS
     */
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    /**
     * Close all panels
     */
    closeAllPanels() {
        if (this.effectsPanel) {
            this.effectsPanel.remove();
            this.effectsPanel = null;
        }
        
        if (this.textPanel) {
            this.textPanel.remove();
            this.textPanel = null;
        }
        
        if (this.transitionPanel) {
            this.transitionPanel.remove();
            this.transitionPanel = null;
        }
        
        if (this.settingsPanel) {
            this.settingsPanel.remove();
            this.settingsPanel = null;
        }
        
        if (this.exportPanel) {
            this.exportPanel.remove();
            this.exportPanel = null;
        }
        
        if (this.trimPanel) {
            this.trimPanel.remove();
            this.trimPanel = null;
        }
        
        if (this.audioPanel) {
            this.audioPanel.remove();
            this.audioPanel = null;
        }
        
        if (this.speedPanel) {
            this.speedPanel.remove();
            this.speedPanel = null;
        }
        
        if (this.animationPanel) {
            this.animationPanel.remove();
            this.animationPanel = null;
        }
        
        if (this.keyframePanel) {
            this.keyframePanel.remove();
            this.keyframePanel = null;
        }
        
        if (this.chromaKeyPanel) {
            this.chromaKeyPanel.remove();
            this.chromaKeyPanel = null;
        }
        
        if (this.colorPanel) {
            this.colorPanel.remove();
            this.colorPanel = null;
        }
        
        if (this.layersPanel) {
            this.layersPanel.remove();
            this.layersPanel = null;
        }
        
        if (this.propertiesPanel) {
            this.propertiesPanel.remove();
            this.propertiesPanel = null;
        }
    }
    
    /**
     * Show error message
     */
    showError(message) {
        botReply(message);
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        // Handle video editor keys
        switch (event.key) {
            case ' ':
                event.preventDefault();
                this.togglePlayPause();
                break;
            case 'ArrowLeft':
                event.preventDefault();
                this.skipBackward();
                break;
            case 'ArrowRight':
                event.preventDefault();
                this.skipForward();
                break;
            case 'Escape':
                // Close any open panels first
                if (this.effectsPanel || this.textPanel || this.transitionPanel || 
                    this.settingsPanel || this.exportPanel || this.trimPanel ||
                    this.audioPanel || this.speedPanel || this.animationPanel ||
                    this.keyframePanel || this.chromaKeyPanel || this.colorPanel ||
                    this.layersPanel || this.propertiesPanel) {
                    this.closeAllPanels();
                    return;
                }
                
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeGame();
                }
                break;
            case 'i':
                event.preventDefault();
                this.importMedia();
                break;
            case 'e':
                event.preventDefault();
                this.exportVideo();
                break;
            case 'c':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.cutTool();
                }
                break;
            case 't':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.addText();
                }
                break;
            case 's':
                if (event.ctrlKey) {
                    event.preventDefault();
                    botReply('Project would be saved in a full implementation');
                }
                break;
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Close all panels
        this.closeAllPanels();
        
        // Pause video if playing
        if (this.playing && this.videoPreview) {
            this.videoPreview.pause();
        }
        
        // Revoke object URLs to prevent memory leaks
        if (this.currentVideo) {
            URL.revokeObjectURL(this.currentVideo.url);
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Clear any pending button timeout
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.videoPreview = null;
        this.timeline = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentVideo = null;
        this.videoDuration = 0;
        this.currentTime = 0;
        this.playing = false;
        this.tracks = [];
        this.selectedTrack = null;
        this.selectedTool = 'select';
        this.selectedClip = null;
        this.zoomLevel = 1;
        this.volume = 0.8;
        this.playbackRate = 1;
        this.buttonTimeout = null;
        this.activeButton = null;
        this.timeDisplay = null;
        this.playhead = null;
        this.clips = [];
        this.projectInfo = null;
        this.uploadArea = null;
        this.effectsPanel = null;
        this.textPanel = null;
        this.transitionPanel = null;
        this.settingsPanel = null;
        this.exportPanel = null;
        this.trimPanel = null;
        this.textOverlays = [];
        this.effects = [];
        this.transitions = [];
        this.trimStart = 0;
        this.trimEnd = 0;
        this.leftToolbar = null;
        this.layersPanel = null;
        this.propertiesPanel = null;
        this.speedPanel = null;
        this.audioPanel = null;
        this.colorPanel = null;
        this.animationPanel = null;
        this.keyframePanel = null;
        this.chromaKeyPanel = null;
        this.stickers = [];
        this.animations = [];
        this.keyframes = [];
        
        botReply("Video Editor closed. Thank you!");
    }
}

// Create a singleton instance
const videoEditorScreen = new VideoEditorScreen();

// Add this to your AI's command handling
if (/video editor|video edit|vedit/i.test(userInputRaw)) {
    videoEditorScreen.loadVideoEditor();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    videoEditorScreen.closeGame();
    return;
}


class RandomText {
    constructor() {
        this.randomText = {
            name: 'RANDOM TEXT GENERATOR',
            instructions: 'Generate random text with various styles and effects.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.leftToolbar = null;
        this.textDisplay = null;
        this.textArea = null;
        this.currentText = '';
        this.textStyle = {
            fontSize: 24,
            fontFamily: 'Arial',
            color: '#ffffff',
            backgroundColor: '#222222',
            textAlign: 'center',
            fontWeight: 'normal',
            fontStyle: 'normal',
            textDecoration: 'none',
            textShadow: 'none',
            padding: 20,
            borderRadius: 8,
            width: 80,
            height: 30
        };
        this.animationType = 'none';
        this.animationSpeed = 1;
        this.textCategories = [
            'lorem', 'quotes', 'funny', 'tech', 'philosophy', 'poetry'
        ];
        this.selectedCategory = 'lorem';
        this.textHistory = [];
        this.buttonTimeout = null;
        this.activeButton = null;
    }
    
    /**
     * Load the Random Text Generator
     */
    loadRandomText() {
        if (this.isActive) {
            botReply(`The ${this.randomText.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        this.createGameContainer();
        this.createRandomTextUI();
        this.setupActionButtons();
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.randomText.name} loaded! ${this.randomText.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
        `;
    }
    
    /**
     * Create the Random Text UI
     */
    createRandomTextUI() {
        const editorContainer = document.createElement('div');
        editorContainer.style.cssText = `
            background-color: #222;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 80vw;
            max-width: 800px;
            height: 80vh;
            max-height: 600px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background-color: #333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.randomText.name;
        title.style.cssText = `
            font-size: 18px;
            font-weight: bold;
        `;
        
        header.appendChild(title);
        editorContainer.appendChild(header);
        
        // Create main content area with left toolbar
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create left toolbar
        this.createLeftToolbar();
        mainContent.appendChild(this.leftToolbar);
        
        // Create center content area
        const centerContent = document.createElement('div');
        centerContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Create text display area
        this.textDisplay = document.createElement('div');
        this.textDisplay.style.cssText = `
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            margin-bottom: 20px;
            border-radius: 8px;
            background-color: ${this.textStyle.backgroundColor};
            color: ${this.textStyle.color};
            font-size: ${this.textStyle.fontSize}px;
            font-family: ${this.textStyle.fontFamily};
            text-align: ${this.textStyle.textAlign};
            font-weight: ${this.textStyle.fontWeight};
            font-style: ${this.textStyle.fontStyle};
            text-decoration: ${this.textStyle.textDecoration};
            text-shadow: ${this.textStyle.textShadow};
            padding: ${this.textStyle.padding}px;
            width: ${this.textStyle.width}%;
            height: ${this.textStyle.height}%;
            word-wrap: break-word;
            transition: all 0.3s ease;
        `;
        
        this.textDisplay.textContent = 'Click "Generate" to create random text';
        
        // Create text area
        this.textArea = document.createElement('textarea');
        this.textArea.style.cssText = `
            width: 100%;
            height: 100px;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
            font-family: monospace;
            resize: none;
            margin-bottom: 15px;
        `;
        
        this.textArea.placeholder = 'Generated text will appear here...';
        
        // Create control buttons
        const controlButtons = document.createElement('div');
        controlButtons.style.cssText = `
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        const generateButton = document.createElement('button');
        generateButton.textContent = 'Generate';
        generateButton.style.cssText = this.getButtonStyle('btn-primary');
        generateButton.addEventListener('click', () => this.generateRandomText());
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy';
        copyButton.style.cssText = this.getButtonStyle('btn-secondary');
        copyButton.addEventListener('click', () => this.copyToClipboard());
        
        controlButtons.appendChild(generateButton);
        controlButtons.appendChild(copyButton);
        
        centerContent.appendChild(this.textDisplay);
        centerContent.appendChild(this.textArea);
        centerContent.appendChild(controlButtons);
        mainContent.appendChild(centerContent);
        editorContainer.appendChild(mainContent);
        this.gameContainer.appendChild(editorContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Create left toolbar with text tools
     */
    createLeftToolbar() {
        this.leftToolbar = document.createElement('div');
        this.leftToolbar.style.cssText = `
            width: 60px;
            background-color: #2a2a2a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            border-right: 1px solid #444;
        `;
        
        // Define text tools
        const textTools = [
            { label: 'T', action: 'text', title: 'Text Style', className: 'btn-tool' },
            { label: '🎨', action: 'color', title: 'Text Color', className: 'btn-tool' },
            { label: '📐', action: 'size', title: 'Text Size', className: 'btn-tool' },
            { label: '🔤', action: 'font', title: 'Font Family', className: 'btn-tool' },
            { label: '⚙️', action: 'align', title: 'Text Alignment', className: 'btn-tool' },
            { label: '✨', action: 'effect', title: 'Text Effects', className: 'btn-tool' },
            { label: '🔄', action: 'animation', title: 'Animation', className: 'btn-tool' },
            { label: '📋', action: 'category', title: 'Text Category', className: 'btn-tool' },
            { label: '🎲', action: 'random', title: 'Random Style', className: 'btn-tool' }
        ];
        
        // Create tool buttons
        textTools.forEach(tool => {
            const btn = document.createElement('button');
            btn.textContent = tool.label;
            btn.title = tool.title;
            btn.style.cssText = this.getButtonStyle(tool.className);
            this.addButtonEventListeners(btn, tool.action, tool.label);
            this.leftToolbar.appendChild(btn);
        });
    }
    
    /**
     * Add event listeners to buttons
     */
    addButtonEventListeners(button, action, label) {
        const handleInteraction = (e) => {
            e.preventDefault();
            this.handleButtonClick(action, label);
            
            this.activeButton = button;
            button.style.transform = 'scale(0.95)';
            button.style.opacity = '0.8';
        };
        
        const handleRelease = () => {
            if (this.activeButton === button) {
                button.style.transform = '';
                button.style.opacity = '';
                this.activeButton = null;
            }
        };
        
        button.addEventListener('mousedown', handleInteraction);
        button.addEventListener('mouseup', handleRelease);
        button.addEventListener('mouseleave', handleRelease);
        
        button.addEventListener('touchstart', handleInteraction, { passive: false });
        button.addEventListener('touchend', handleRelease);
        button.addEventListener('touchcancel', handleRelease);
    }
    
    /**
     * Get button style
     */
    getButtonStyle(buttonType) {
        const baseStyle = `
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        `;
        
        switch (buttonType) {
            case 'btn-tool':
                return baseStyle + `
                    background-color: #444;
                    color: white;
                    width: 44px;
                    height: 44px;
                    border-radius: 8px;
                    margin: 5px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 18px;
                `;
            case 'btn-primary':
                return baseStyle + `
                    background-color: #4CAF50;
                    color: white;
                    flex: 1;
                `;
            case 'btn-secondary':
                return baseStyle + `
                    background-color: #2196F3;
                    color: white;
                    flex: 1;
                `;
            default:
                return baseStyle + `
                    background-color: #555;
                    color: white;
                `;
        }
    }
    
    /**
     * Handle button click
     */
    handleButtonClick(action, label) {
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        this.buttonTimeout = setTimeout(() => {
            switch (action) {
                case 'text':
                    this.openTextStylePanel();
                    break;
                case 'color':
                    this.openColorPanel();
                    break;
                case 'size':
                    this.openSizePanel();
                    break;
                case 'font':
                    this.openFontPanel();
                    break;
                case 'align':
                    this.openAlignPanel();
                    break;
                case 'effect':
                    this.openEffectPanel();
                    break;
                case 'animation':
                    this.openAnimationPanel();
                    break;
                case 'category':
                    this.openCategoryPanel();
                    break;
                case 'random':
                    this.applyRandomStyle();
                    break;
            }
            this.buttonTimeout = null;
        }, 10);
    }
    
    /**
     * Generate random text
     */
    generateRandomText() {
        let text = '';
        
        switch (this.selectedCategory) {
            case 'lorem':
                text = this.generateLoremIpsum();
                break;
            case 'quotes':
                text = this.getRandomQuote();
                break;
            case 'funny':
                text = this.getFunnyText();
                break;
            case 'tech':
                text = this.getTechText();
                break;
            case 'philosophy':
                text = this.getPhilosophyText();
                break;
            case 'poetry':
                text = this.getPoetryText();
                break;
            default:
                text = this.generateLoremIpsum();
        }
        
        this.currentText = text;
        this.textDisplay.textContent = text;
        this.textArea.value = text;
        
        // Add to history
        this.textHistory.unshift({
            text: text,
            category: this.selectedCategory,
            style: { ...this.textStyle },
            timestamp: new Date()
        });
        
        // Apply animation if set
        if (this.animationType !== 'none') {
            this.applyAnimation();
        }
        
      /*  botReply(`Generated ${this.selectedCategory} text`);*/
    }
    
    /**
     * Generate Lorem Ipsum text
     */
    generateLoremIpsum() {
        const loremWords = [
            'lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit',
            'sed', 'do', 'eiusmod', 'tempor', 'incididunt', 'ut', 'labore', 'et', 'dolore',
            'magna', 'aliqua', 'enim', 'ad', 'minim', 'veniam', 'quis', 'nostrud',
            'exercitation', 'ullamco', 'laboris', 'nisi', 'aliquip', 'ex', 'ea', 'commodo',
            'consequat', 'duis', 'aute', 'irure', 'in', 'reprehenderit', 'voluptate',
            'velit', 'esse', 'cillum', 'fugiat', 'nulla', 'pariatur', 'excepteur', 'sint',
            'occaecat', 'cupidatat', 'non', 'proident', 'sunt', 'culpa', 'qui', 'officia',
            'deserunt', 'mollit', 'anim', 'id', 'est', 'laborum'
        ];
        
        const wordCount = Math.floor(Math.random() * 50) + 20;
        const words = [];
        
        for (let i = 0; i < wordCount; i++) {
            const randomIndex = Math.floor(Math.random() * loremWords.length);
            words.push(loremWords[randomIndex]);
        }
        
        // Capitalize first letter
        words[0] = words[0].charAt(0).toUpperCase() + words[0].slice(1);
        
        // Add period at the end
        let text = words.join(' ');
        text += '.';
        
        return text;
    }
    
    /**
     * Get random quote
     */
    getRandomQuote() {
        const quotes = [
            "The only way to do great work is to love what you do. - Steve Jobs",
            "Innovation distinguishes between a leader and a follower. - Steve Jobs",
            "Your time is limited, so don't waste it living someone else's life. - Steve Jobs",
            "The future belongs to those who believe in the beauty of their dreams. - Eleanor Roosevelt",
            "It is during our darkest moments that we must focus to see the light. - Aristotle",
            "Whoever is happy will make others happy too. - Anne Frank",
            "Success is not final, failure is not fatal: It is the courage to continue that counts. - Winston Churchill",
            "The only impossible journey is the one you never begin. - Tony Robbins",
            "In the middle of difficulty lies opportunity. - Albert Einstein",
            "Believe you can and you're halfway there. - Theodore Roosevelt"
        ];
        
        return quotes[Math.floor(Math.random() * quotes.length)];
    }
    
    /**
     * Get funny text
     */
    getFunnyText() {
        const funnyTexts = [
            "I told my wife she was drawing her eyebrows too high. She looked surprised.",
            "Why don't scientists trust atoms? Because they make up everything!",
            "I used to hate facial hair, but then it grew on me.",
            "I'm reading a book about anti-gravity. It's impossible to put down!",
            "Did you hear about the mathematician who's afraid of negative numbers? He'll stop at nothing to avoid them.",
            "Why did the scarecrow win an award? Because he was outstanding in his field!",
            "I'm on a seafood diet. I see food and I eat it.",
            "Time flies like an arrow. Fruit flies like a banana.",
            "I used to play piano by ear, but now I use my hands.",
            "I wondered why the baseball was getting bigger. Then it hit me."
        ];
        
        return funnyTexts[Math.floor(Math.random() * funnyTexts.length)];
    }
    
    /**
     * Get tech text
     */
    getTechText() {
        const techTexts = [
            "Artificial intelligence is the simulation of human intelligence processes by machines, especially computer systems.",
            "Machine learning is a method of data analysis that automates analytical model building.",
            "Blockchain is a system of recording information in a way that makes it difficult or impossible to change, hack, or cheat the system.",
            "Cloud computing is the delivery of computing services over the Internet rather than from local servers.",
            "Cybersecurity is the practice of defending computers, servers, mobile devices, electronic systems, networks, and data from malicious attacks.",
            "The Internet of Things (IoT) describes the network of physical objects that are embedded with sensors, software, and other technologies.",
            "Quantum computing is a type of computation that harnesses the collective properties of quantum states, such as superposition, interference, and entanglement.",
            "Virtual reality is a computer-generated simulation of an environment or situation that can be interacted with in a seemingly real way.",
            "Augmented reality is an enhanced version of the real physical world that is achieved through the use of digital visual elements, sound, or other sensory stimuli.",
            "Big data refers to the large, diverse sets of information that grow at ever-increasing rates."
        ];
        
        return techTexts[Math.floor(Math.random() * techTexts.length)];
    }
    
    /**
     * Get philosophy text
     */
    getPhilosophyText() {
        const philosophyTexts = [
            "The only true wisdom is in knowing you know nothing. - Socrates",
            "I think, therefore I am. - René Descartes",
            "The unexamined life is not worth living. - Socrates",
            "Happiness is not something ready made. It comes from your own actions. - Dalai Lama",
            "The only thing we know for sure is that we know nothing at all. - Socrates",
            "We are what we repeatedly do. Excellence, then, is not an act, but a habit. - Aristotle",
            "He who has a why to live can bear almost any how. - Friedrich Nietzsche",
            "The greatest glory in living lies not in never falling, but in rising every time we fall. - Nelson Mandela",
            "Life is never made unbearable by circumstances, but only by lack of meaning and purpose. - Viktor Frankl",
            "The mind is everything. What you think you become. - Buddha"
        ];
        
        return philosophyTexts[Math.floor(Math.random() * philosophyTexts.length)];
    }
    
    /**
     * Get poetry text
     */
    getPoetryText() {
        const poetryTexts = [
            "Two roads diverged in a yellow wood, And sorry I could not travel both And be one traveler, long I stood And looked down one as far as I could To where it bent in the undergrowth; - Robert Frost",
            "Do not go gentle into that good night, Old age should burn and rave at close of day; Rage, rage against the dying of the light. - Dylan Thomas",
            "Because I could not stop for Death – He kindly stopped for me – The Carriage held but just Ourselves – And Immortality. - Emily Dickinson",
            "I wandered lonely as a cloud That floats on high o'er vales and hills, When all at once I saw a crowd, A host, of golden daffodils; - William Wordsworth",
            "Shall I compare thee to a summer's day? Thou art more lovely and more temperate: Rough winds do shake the darling buds of May, And summer's lease hath all too short a date; - William Shakespeare",
            "The woods are lovely, dark and deep, But I have promises to keep, And miles to go before I sleep, And miles to go before I sleep. - Robert Frost",
            "I carry your heart with me (I carry it in my heart) I am never without it (anywhere I go you go, my dear; - E.E. Cummings",
            "Hope is the thing with feathers That perches in the soul, And sings the tune without the words, And never stops at all, - Emily Dickinson",
            "Let us go then, you and I, When the evening is spread out against the sky Like a patient etherized upon a table; - T.S. Eliot",
            "So we beat on, boats against the current, borne back ceaselessly into the past. - F. Scott Fitzgerald"
        ];
        
        return poetryTexts[Math.floor(Math.random() * poetryTexts.length)];
    }
    
    /**
     * Copy text to clipboard
     */
    copyToClipboard() {
        if (!this.currentText) {
            botReply('No text to copy');
            return;
        }
        
        this.textArea.select();
        document.execCommand('copy');
        
        botReply('Text copied to clipboard!');
    }
    
    /**
     * Open text style panel
     */
    openTextStylePanel() {
        const panel = this.createPanel('Text Style');
        
        // Bold control
        const boldControl = this.createToggleControl(
            'Bold',
            this.textStyle.fontWeight === 'bold',
            (checked) => {
                this.textStyle.fontWeight = checked ? 'bold' : 'normal';
                this.updateTextStyle();
            }
        );
        
        // Italic control
        const italicControl = this.createToggleControl(
            'Italic',
            this.textStyle.fontStyle === 'italic',
            (checked) => {
                this.textStyle.fontStyle = checked ? 'italic' : 'normal';
                this.updateTextStyle();
            }
        );
        
        // Underline control
        const underlineControl = this.createToggleControl(
            'Underline',
            this.textStyle.textDecoration === 'underline',
            (checked) => {
                this.textStyle.textDecoration = checked ? 'underline' : 'none';
                this.updateTextStyle();
            }
        );
        
        panel.appendChild(boldControl);
        panel.appendChild(italicControl);
        panel.appendChild(underlineControl);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open color panel
     */
    openColorPanel() {
        const panel = this.createPanel('Text Color');
        
        // Text color picker
        const textColorLabel = document.createElement('label');
        textColorLabel.textContent = 'Text Color:';
        textColorLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const textColorPicker = document.createElement('input');
        textColorPicker.type = 'color';
        textColorPicker.value = this.textStyle.color;
        textColorPicker.style.cssText = 'width: 100%; height: 40px; border: none; border-radius: 4px; margin-bottom: 15px;';
        
        textColorPicker.addEventListener('change', (e) => {
            this.textStyle.color = e.target.value;
            this.updateTextStyle();
        });
        
        // Background color picker
        const bgColorLabel = document.createElement('label');
        bgColorLabel.textContent = 'Background Color:';
        bgColorLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const bgColorPicker = document.createElement('input');
        bgColorPicker.type = 'color';
        bgColorPicker.value = this.textStyle.backgroundColor;
        bgColorPicker.style.cssText = 'width: 100%; height: 40px; border: none; border-radius: 4px;';
        
        bgColorPicker.addEventListener('change', (e) => {
            this.textStyle.backgroundColor = e.target.value;
            this.updateTextStyle();
        });
        
        panel.appendChild(textColorLabel);
        panel.appendChild(textColorPicker);
        panel.appendChild(bgColorLabel);
        panel.appendChild(bgColorPicker);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open size panel
     */
    openSizePanel() {
        const panel = this.createPanel('Text Size');
        
        // Font size slider
        const fontSizeLabel = document.createElement('label');
        fontSizeLabel.textContent = 'Font Size:';
        fontSizeLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const fontSizeSlider = document.createElement('input');
        fontSizeSlider.type = 'range';
        fontSizeSlider.min = '12';
        fontSizeSlider.max = '72';
        fontSizeSlider.value = this.textStyle.fontSize;
        fontSizeSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const fontSizeValue = document.createElement('div');
        fontSizeValue.textContent = `${this.textStyle.fontSize}px`;
        fontSizeValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        fontSizeSlider.addEventListener('input', (e) => {
            const size = parseInt(e.target.value);
            this.textStyle.fontSize = size;
            fontSizeValue.textContent = `${size}px`;
            this.updateTextStyle();
        });
        
        // Padding slider
        const paddingLabel = document.createElement('label');
        paddingLabel.textContent = 'Padding:';
        paddingLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const paddingSlider = document.createElement('input');
        paddingSlider.type = 'range';
        paddingSlider.min = '0';
        paddingSlider.max = '50';
        paddingSlider.value = this.textStyle.padding;
        paddingSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const paddingValue = document.createElement('div');
        paddingValue.textContent = `${this.textStyle.padding}px`;
        paddingValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        paddingSlider.addEventListener('input', (e) => {
            const padding = parseInt(e.target.value);
            this.textStyle.padding = padding;
            paddingValue.textContent = `${padding}px`;
            this.updateTextStyle();
        });
        
        panel.appendChild(fontSizeLabel);
        panel.appendChild(fontSizeSlider);
        panel.appendChild(fontSizeValue);
        panel.appendChild(paddingLabel);
        panel.appendChild(paddingSlider);
        panel.appendChild(paddingValue);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open font panel
     */
    openFontPanel() {
        const panel = this.createPanel('Font Family');
        
        const fontSelect = document.createElement('select');
        fontSelect.style.cssText = 'width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #444; background-color: #444; color: white; margin-bottom: 15px;';
        
        const fonts = [
            { value: 'Arial', text: 'Arial' },
            { value: 'Verdana', text: 'Verdana' },
            { value: 'Georgia', text: 'Georgia' },
            { value: 'Times New Roman', text: 'Times New Roman' },
            { value: 'Courier New', text: 'Courier New' },
            { value: 'Impact', text: 'Impact' },
            { value: 'Comic Sans MS', text: 'Comic Sans MS' },
            { value: 'Trebuchet MS', text: 'Trebuchet MS' }
        ];
        
        fonts.forEach(font => {
            const option = document.createElement('option');
            option.value = font.value;
            option.textContent = font.text;
            fontSelect.appendChild(option);
        });
        
        fontSelect.value = this.textStyle.fontFamily;
        
        fontSelect.addEventListener('change', (e) => {
            this.textStyle.fontFamily = e.target.value;
            this.updateTextStyle();
        });
        
        panel.appendChild(fontSelect);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open align panel
     */
    openAlignPanel() {
        const panel = this.createPanel('Text Alignment');
        
        const alignButtons = document.createElement('div');
        alignButtons.style.cssText = 'display: flex; gap: 10px; margin-bottom: 15px;';
        
        const alignments = [
            { value: 'left', label: 'Left' },
            { value: 'center', label: 'Center' },
            { value: 'right', label: 'Right' },
            { value: 'justify', label: 'Justify' }
        ];
        
        alignments.forEach(align => {
            const btn = document.createElement('button');
            btn.textContent = align.label;
            btn.style.cssText = this.getButtonStyle('btn-secondary');
            btn.style.flex = '1';
            
            if (this.textStyle.textAlign === align.value) {
                btn.style.backgroundColor = '#4CAF50';
            }
            
            btn.addEventListener('click', () => {
                this.textStyle.textAlign = align.value;
                this.updateTextStyle();
                
                // Update button styles
                alignButtons.querySelectorAll('button').forEach(b => {
                    b.style.backgroundColor = '#2196F3';
                });
                btn.style.backgroundColor = '#4CAF50';
            });
            
            alignButtons.appendChild(btn);
        });
        
        panel.appendChild(alignButtons);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open effect panel
     */
    openEffectPanel() {
        const panel = this.createPanel('Text Effects');
        
        // Text shadow control
        const shadowControl = this.createToggleControl(
            'Text Shadow',
            this.textStyle.textShadow !== 'none',
            (checked) => {
                this.textStyle.textShadow = checked ? '2px 2px 4px rgba(0, 0, 0, 0.5)' : 'none';
                this.updateTextStyle();
            }
        );
        
        // Border radius control
        const borderRadiusLabel = document.createElement('label');
        borderRadiusLabel.textContent = 'Border Radius:';
        borderRadiusLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const borderRadiusSlider = document.createElement('input');
        borderRadiusSlider.type = 'range';
        borderRadiusSlider.min = '0';
        borderRadiusSlider.max = '20';
        borderRadiusSlider.value = this.textStyle.borderRadius;
        borderRadiusSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const borderRadiusValue = document.createElement('div');
        borderRadiusValue.textContent = `${this.textStyle.borderRadius}px`;
        borderRadiusValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        borderRadiusSlider.addEventListener('input', (e) => {
            const radius = parseInt(e.target.value);
            this.textStyle.borderRadius = radius;
            borderRadiusValue.textContent = `${radius}px`;
            this.updateTextStyle();
        });
        
        panel.appendChild(shadowControl);
        panel.appendChild(borderRadiusLabel);
        panel.appendChild(borderRadiusSlider);
        panel.appendChild(borderRadiusValue);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open animation panel
     */
    openAnimationPanel() {
        const panel = this.createPanel('Text Animation');
        
        // Animation type select
        const animTypeLabel = document.createElement('label');
        animTypeLabel.textContent = 'Animation Type:';
        animTypeLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const animTypeSelect = document.createElement('select');
        animTypeSelect.style.cssText = 'width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #444; background-color: #444; color: white; margin-bottom: 15px;';
        
        const animations = [
            { value: 'none', text: 'None' },
            { value: 'fadeIn', text: 'Fade In' },
            { value: 'slideIn', text: 'Slide In' },
            { value: 'bounce', text: 'Bounce' },
            { value: 'pulse', text: 'Pulse' }
        ];
        
        animations.forEach(anim => {
            const option = document.createElement('option');
            option.value = anim.value;
            option.textContent = anim.text;
            animTypeSelect.appendChild(option);
        });
        
        animTypeSelect.value = this.animationType;
        
        animTypeSelect.addEventListener('change', (e) => {
            this.animationType = e.target.value;
            if (this.currentText) {
                this.applyAnimation();
            }
        });
        
        // Animation speed slider
        const animSpeedLabel = document.createElement('label');
        animSpeedLabel.textContent = 'Animation Speed:';
        animSpeedLabel.style.cssText = 'display: block; margin-bottom: 5px; color: white;';
        
        const animSpeedSlider = document.createElement('input');
        animSpeedSlider.type = 'range';
        animSpeedSlider.min = '0.5';
        animSpeedSlider.max = '3';
        animSpeedSlider.step = '0.5';
        animSpeedSlider.value = this.animationSpeed;
        animSpeedSlider.style.cssText = 'width: 100%; margin-bottom: 10px;';
        
        const animSpeedValue = document.createElement('div');
        animSpeedValue.textContent = `${this.animationSpeed}s`;
        animSpeedValue.style.cssText = 'text-align: center; margin-bottom: 15px; color: white;';
        
        animSpeedSlider.addEventListener('input', (e) => {
            this.animationSpeed = parseFloat(e.target.value);
            animSpeedValue.textContent = `${this.animationSpeed}s`;
        });
        
        panel.appendChild(animTypeLabel);
        panel.appendChild(animTypeSelect);
        panel.appendChild(animSpeedLabel);
        panel.appendChild(animSpeedSlider);
        panel.appendChild(animSpeedValue);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Open category panel
     */
    openCategoryPanel() {
        const panel = this.createPanel('Text Category');
        
        const categoryButtons = document.createElement('div');
        categoryButtons.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;';
        
        this.textCategories.forEach(category => {
            const btn = document.createElement('button');
            btn.textContent = category.charAt(0).toUpperCase() + category.slice(1);
            btn.style.cssText = this.getButtonStyle('btn-secondary');
            
            if (this.selectedCategory === category) {
                btn.style.backgroundColor = '#4CAF50';
            }
            
            btn.addEventListener('click', () => {
                this.selectedCategory = category;
                
                // Update button styles
                categoryButtons.querySelectorAll('button').forEach(b => {
                    b.style.backgroundColor = '#2196F3';
                });
                btn.style.backgroundColor = '#4CAF50';
                
                botReply(`Selected category: ${category}`);
            });
            
            categoryButtons.appendChild(btn);
        });
        
        panel.appendChild(categoryButtons);
        
        this.gameContainer.appendChild(panel);
    }
    
    /**
     * Apply random style
     */
    applyRandomStyle() {
        // Random color
        const randomColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        this.textStyle.color = randomColor;
        
        // Random background color
        const randomBgColor = `#${Math.floor(Math.random()*16777215).toString(16)}`;
        this.textStyle.backgroundColor = randomBgColor;
        
        // Random font size
        this.textStyle.fontSize = Math.floor(Math.random() * 40) + 16;
        
        // Random font family
        const fonts = ['Arial', 'Verdana', 'Georgia', 'Times New Roman', 'Courier New', 'Impact'];
        this.textStyle.fontFamily = fonts[Math.floor(Math.random() * fonts.length)];
        
        // Random alignment
        const alignments = ['left', 'center', 'right'];
        this.textStyle.textAlign = alignments[Math.floor(Math.random() * alignments.length)];
        
        // Random bold/italic
        this.textStyle.fontWeight = Math.random() > 0.5 ? 'bold' : 'normal';
        this.textStyle.fontStyle = Math.random() > 0.5 ? 'italic' : 'normal';
        
        // Random text shadow
        this.textStyle.textShadow = Math.random() > 0.5 ? '2px 2px 4px rgba(0, 0, 0, 0.5)' : 'none';
        
        // Random border radius
        this.textStyle.borderRadius = Math.floor(Math.random() * 15);
        
        // Random animation
        const animations = ['none', 'fadeIn', 'slideIn', 'bounce', 'pulse'];
        this.animationType = animations[Math.floor(Math.random() * animations.length)];
        
        this.updateTextStyle();
        
        if (this.currentText) {
            this.applyAnimation();
        }
        
        botReply('Applied random style');
    }
    
    /**
     * Update text style
     */
    updateTextStyle() {
        this.textDisplay.style.color = this.textStyle.color;
        this.textDisplay.style.backgroundColor = this.textStyle.backgroundColor;
        this.textDisplay.style.fontSize = `${this.textStyle.fontSize}px`;
        this.textDisplay.style.fontFamily = this.textStyle.fontFamily;
        this.textDisplay.style.textAlign = this.textStyle.textAlign;
        this.textDisplay.style.fontWeight = this.textStyle.fontWeight;
        this.textDisplay.style.fontStyle = this.textStyle.fontStyle;
        this.textDisplay.style.textDecoration = this.textStyle.textDecoration;
        this.textDisplay.style.textShadow = this.textStyle.textShadow;
        this.textDisplay.style.padding = `${this.textStyle.padding}px`;
        this.textDisplay.style.borderRadius = `${this.textStyle.borderRadius}px`;
    }
    
    /**
     * Apply animation
     */
    applyAnimation() {
        // Remove existing animation classes
        this.textDisplay.className = '';
        
        if (this.animationType !== 'none') {
            // Apply animation
            this.textDisplay.style.animation = `${this.animationType} ${this.animationSpeed}s ease`;
            
            // Remove animation after it completes
            setTimeout(() => {
                this.textDisplay.style.animation = '';
            }, this.animationSpeed * 1000);
        }
    }
    
    /**
     * Create a panel
     */
    createPanel(title) {
        const panel = document.createElement('div');
        panel.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            color: white;
        `;
        
        const panelTitle = document.createElement('h3');
        panelTitle.textContent = title;
        panelTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
        `;
        
        panel.appendChild(panelTitle);
        
        // Close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.cssText = this.getButtonStyle('btn-secondary');
        closeButton.style.width = '100%';
        closeButton.style.marginTop = '15px';
        
        closeButton.addEventListener('click', () => {
            panel.remove();
        });
        
        panel.appendChild(closeButton);
        
        return panel;
    }
    
    /**
     * Create a toggle control
     */
    createToggleControl(label, isChecked, onChange) {
        const control = document.createElement('div');
        control.style.cssText = 'margin-bottom: 15px; display: flex; align-items: center;';
        
        const controlLabel = document.createElement('label');
        controlLabel.textContent = label;
        controlLabel.style.cssText = 'flex: 1; color: white;';
        
        const toggle = document.createElement('input');
        toggle.type = 'checkbox';
        toggle.checked = isChecked;
        toggle.style.cssText = 'width: 20px; height: 20px;';
        
        toggle.addEventListener('change', (e) => {
            onChange(e.target.checked);
        });
        
        control.appendChild(controlLabel);
        control.appendChild(toggle);
        
        return control;
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        switch (event.key) {
            case 'Escape':
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeGame();
                }
                break;
            case 'g':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.generateRandomText();
                }
                break;
            case 'c':
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.copyToClipboard();
                }
                break;
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.leftToolbar = null;
        this.textDisplay = null;
        this.textArea = null;
        this.currentText = '';
        this.textStyle = {
            fontSize: 24,
            fontFamily: 'Arial',
            color: '#ffffff',
            backgroundColor: '#222222',
            textAlign: 'center',
            fontWeight: 'normal',
            fontStyle: 'normal',
            textDecoration: 'none',
            textShadow: 'none',
            padding: 20,
            borderRadius: 8,
            width: 80,
            height: 30
        };
        this.animationType = 'none';
        this.animationSpeed = 1;
        this.textCategories = [
            'lorem', 'quotes', 'funny', 'tech', 'philosophy', 'poetry'
        ];
        this.selectedCategory = 'lorem';
        this.textHistory = [];
        this.buttonTimeout = null;
        this.activeButton = null;
        
        botReply("Random Text Generator closed. Thank you!");
    }
}

// Create a singleton instance
const randomText = new RandomText();

// Add this to your AI's command handling
if (/random text|text generator|randtext/i.test(userInputRaw)) {
    randomText.loadRandomText();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    randomText.closeGame();
    return;
}

class NetworkFinder {
    constructor() {
        this.appName = 'NETWORK FINDER';
        this.instructions = 'Identify the mobile network provider from a phone number.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.numberInput = null;
        this.resultDisplay = null;
        this.historyPanel = null;
        this.currentNumber = '';
        this.searchHistory = [];
        
        // Network prefix data for Indian mobile numbers
        this.networkData = {
            'Jio': {
                prefixes: ['6', '7', '8', '9'],
                color: '#0081ff',
                icon: '📡'
            },
            'Airtel': {
                prefixes: ['98', '99', '96', '95', '94', '93', '92', '91', '90', '89', '88', '87', '86', '85', '84', '83', '82', '81', '80', '70'],
                color: '#ef1a25',
                icon: '📱'
            },
            'Vi (Idea/Vodafone)': {
                prefixes: ['98', '99', '96', '95', '94', '93', '92', '91', '90', '89', '88', '87', '86', '85', '84', '83', '82', '81', '80', '79', '78', '77', '76', '75', '74', '73', '72', '71', '70'],
                color: '#ff5100',
                icon: '📶'
            },
            'BSNL': {
                prefixes: ['94', '95', '96', '97', '98', '99', '92', '93', '90', '91', '88', '89', '86', '87', '84', '85', '82', '83', '80', '81'],
                color: '#0051ba',
                icon: '📞'
            },
            'Vodafone': {
                prefixes: ['98', '99', '96', '95', '94', '93', '92', '91', '90', '89', '88', '87', '86', '85', '84', '83', '82', '81', '80', '79', '78', '77', '76', '75', '74', '73', '72', '71', '70'],
                color: '#e60000',
                icon: '🌐'
            }
        };
    }
    
    /**
     * Load the Network Finder
     */
    loadNetworkFinder() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        this.createAppContainer();
        this.createNetworkFinderUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Network Finder UI with new design
     */
    createNetworkFinderUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 800px;
            height: 85vh;
            max-height: 700px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🔍';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex: 1;
            overflow: hidden;
        `;
        
        // Create left panel for input
        const leftPanel = document.createElement('div');
        leftPanel.style.cssText = `
            width: 40%;
            padding: 30px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Input section
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 30px;
        `;
        
        const inputLabel = document.createElement('div');
        inputLabel.textContent = 'Enter Mobile Number';
        inputLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 500;
        `;
        
        this.numberInput = document.createElement('input');
        this.numberInput.type = 'tel';
        this.numberInput.placeholder = 'Enter 10-digit number';
        this.numberInput.style.cssText = `
            width: 100%;
            padding: 18px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 18px;
            margin-bottom: 20px;
            outline: none;
            transition: all 0.3s ease;
        `;
        
        // Add input validation
        this.numberInput.addEventListener('input', (e) => {
            // Remove non-numeric characters
            e.target.value = e.target.value.replace(/[^0-9]/g, '');
            
            // Limit to 10 digits
            if (e.target.value.length > 10) {
                e.target.value = e.target.value.slice(0, 10);
            }
        });
        
        // Add focus effect
        this.numberInput.addEventListener('focus', () => {
            this.numberInput.style.borderColor = 'rgba(255, 255, 255, 0.5)';
            this.numberInput.style.boxShadow = '0 0 0 3px rgba(255, 255, 255, 0.1)';
        });
        
        this.numberInput.addEventListener('blur', () => {
            this.numberInput.style.borderColor = 'rgba(255, 255, 255, 0.2)';
            this.numberInput.style.boxShadow = 'none';
        });
        
        // Create action buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        `;
        
        const findButton = document.createElement('button');
        findButton.textContent = 'Find Network';
        findButton.style.cssText = `
            flex: 1;
            padding: 15px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        `;
        
        findButton.addEventListener('mouseover', () => {
            findButton.style.transform = 'translateY(-2px)';
            findButton.style.boxShadow = '0 6px 20px rgba(76, 175, 80, 0.4)';
        });
        
        findButton.addEventListener('mouseout', () => {
            findButton.style.transform = 'translateY(0)';
            findButton.style.boxShadow = '0 4px 15px rgba(76, 175, 80, 0.3)';
        });
        
        findButton.addEventListener('click', () => this.findNetwork());
        
        const randomButton = document.createElement('button');
        randomButton.textContent = 'Random';
        randomButton.style.cssText = `
            padding: 15px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(90deg, #2196F3, #0b7dda);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        `;
        
        randomButton.addEventListener('mouseover', () => {
            randomButton.style.transform = 'translateY(-2px)';
            randomButton.style.boxShadow = '0 6px 20px rgba(33, 150, 243, 0.4)';
        });
        
        randomButton.addEventListener('mouseout', () => {
            randomButton.style.transform = 'translateY(0)';
            randomButton.style.boxShadow = '0 4px 15px rgba(33, 150, 243, 0.3)';
        });
        
        randomButton.addEventListener('click', () => this.generateRandomNumber());
        
        buttonContainer.appendChild(findButton);
        buttonContainer.appendChild(randomButton);
        
        // Create network info section
        const networkInfo = document.createElement('div');
        networkInfo.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        `;
        
        const infoTitle = document.createElement('div');
        infoTitle.textContent = 'Supported Networks';
        infoTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 500;
        `;
        
        const networkList = document.createElement('div');
        networkList.style.cssText = `
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        `;
        
        Object.entries(this.networkData).forEach(([network, data]) => {
            const networkItem = document.createElement('div');
            networkItem.style.cssText = `
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px;
                border-radius: 8px;
                background-color: rgba(255, 255, 255, 0.03);
            `;
            
            const networkIcon = document.createElement('div');
            networkIcon.textContent = data.icon;
            networkIcon.style.cssText = `
                font-size: 18px;
            `;
            
            const networkName = document.createElement('div');
            networkName.textContent = network;
            networkName.style.cssText = `
                color: ${data.color};
                font-weight: 500;
            `;
            
            networkItem.appendChild(networkIcon);
            networkItem.appendChild(networkName);
            networkList.appendChild(networkItem);
        });
        
        networkInfo.appendChild(infoTitle);
        networkInfo.appendChild(networkList);
        
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.numberInput);
        inputSection.appendChild(buttonContainer);
        leftPanel.appendChild(inputSection);
        leftPanel.appendChild(networkInfo);
        
        // Create right panel for results
        const rightPanel = document.createElement('div');
        rightPanel.style.cssText = `
            width: 60%;
            padding: 30px;
            display: flex;
            flex-direction: column;
        `;
        
        // Results section
        const resultsSection = document.createElement('div');
        resultsSection.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
        `;
        
        const resultsTitle = document.createElement('div');
        resultsTitle.textContent = 'Network Result';
        resultsTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            margin-bottom: 20px;
            font-weight: 500;
        `;
        
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 30px;
            min-height: 300px;
            transition: all 0.3s ease;
        `;
        
        const placeholderContent = document.createElement('div');
        placeholderContent.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        `;
        
        const placeholderIcon = document.createElement('div');
        placeholderIcon.textContent = '📱';
        placeholderIcon.style.cssText = `
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        `;
        
        const placeholderText = document.createElement('div');
        placeholderText.textContent = 'Enter a mobile number to identify its network';
        placeholderText.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            max-width: 80%;
        `;
        
        placeholderContent.appendChild(placeholderIcon);
        placeholderContent.appendChild(placeholderText);
        this.resultDisplay.appendChild(placeholderContent);
        
        resultsSection.appendChild(resultsTitle);
        resultsSection.appendChild(this.resultDisplay);
        
        // History section
        const historySection = document.createElement('div');
        historySection.style.cssText = `
            margin-top: 30px;
        `;
        
        const historyHeader = document.createElement('div');
        historyHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const historyTitle = document.createElement('div');
        historyTitle.textContent = 'Recent Searches';
        historyTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            font-weight: 500;
        `;
        
        const clearHistoryBtn = document.createElement('button');
        clearHistoryBtn.textContent = 'Clear';
        clearHistoryBtn.style.cssText = `
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearHistoryBtn.addEventListener('mouseover', () => {
            clearHistoryBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        });
        
        clearHistoryBtn.addEventListener('mouseout', () => {
            clearHistoryBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        });
        
        clearHistoryBtn.addEventListener('click', () => this.clearHistory());
        
        historyHeader.appendChild(historyTitle);
        historyHeader.appendChild(clearHistoryBtn);
        
        this.historyPanel = document.createElement('div');
        this.historyPanel.style.cssText = `
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 5px;
        `;
        
        this.updateHistoryPanel();
        
        historySection.appendChild(historyHeader);
        historySection.appendChild(this.historyPanel);
        
        rightPanel.appendChild(resultsSection);
        rightPanel.appendChild(historySection);
        
        mainContent.appendChild(leftPanel);
        mainContent.appendChild(rightPanel);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Update history panel with recent searches
     */
    updateHistoryPanel() {
        this.historyPanel.innerHTML = '';
        
        if (this.searchHistory.length === 0) {
            const noHistory = document.createElement('div');
            noHistory.textContent = 'No recent searches';
            noHistory.style.cssText = `
                color: rgba(255, 255, 255, 0.5);
                font-size: 14px;
                padding: 10px 0;
            `;
            this.historyPanel.appendChild(noHistory);
            return;
        }
        
        this.searchHistory.slice(0, 5).forEach((item) => {
            const historyItem = document.createElement('div');
            historyItem.style.cssText = `
                min-width: 120px;
                padding: 12px;
                border-radius: 10px;
                background-color: rgba(255, 255, 255, 0.05);
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                flex-direction: column;
                align-items: center;
            `;
            
            const networkColor = this.networkData[item.network]?.color || '#888888';
            
            const numberDisplay = document.createElement('div');
            numberDisplay.textContent = `${item.number.substring(0, 5)} ${item.number.substring(5)}`;
            numberDisplay.style.cssText = `
                font-weight: 600;
                margin-bottom: 5px;
            `;
            
            const networkDisplay = document.createElement('div');
            networkDisplay.textContent = item.network;
            networkDisplay.style.cssText = `
                color: ${networkColor};
                font-size: 12px;
                font-weight: 500;
            `;
            
            historyItem.appendChild(numberDisplay);
            historyItem.appendChild(networkDisplay);
            
            historyItem.addEventListener('click', () => {
                this.numberInput.value = item.number;
                this.findNetwork();
            });
            
            historyItem.addEventListener('mouseenter', () => {
                historyItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                historyItem.style.transform = 'translateY(-2px)';
            });
            
            historyItem.addEventListener('mouseleave', () => {
                historyItem.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                historyItem.style.transform = 'translateY(0)';
            });
            
            this.historyPanel.appendChild(historyItem);
        });
    }
    
    /**
     * Clear search history
     */
    clearHistory() {
        this.searchHistory = [];
        this.updateHistoryPanel();
        botReply('Search history cleared');
    }
    
    /**
     * Find network for the entered number
     */
    findNetwork() {
        const number = this.numberInput.value.trim();
        
        if (!number) {
            this.displayResult('Please enter a mobile number');
            return;
        }
        
        if (number.length !== 10) {
            this.displayResult('Please enter a valid 10-digit mobile number');
            return;
        }
        
        this.currentNumber = number;
        const network = this.identifyNetwork(number);
        
        // Add to history
        this.searchHistory.unshift({
            number: number,
            network: network,
            timestamp: new Date()
        });
        
        // Keep only last 10 searches
        if (this.searchHistory.length > 10) {
            this.searchHistory = this.searchHistory.slice(0, 10);
        }
        
        this.updateHistoryPanel();
        this.displayResult(network, number);
    }
    
    /**
     * Identify network from mobile number
     */
 /**
 * Identify network from mobile number with corrected data
 */
identifyNetwork(number) {
    // More specific network identification based on first 4 digits
    const firstFourDigits = number.substring(0, 4);
    
    // More accurate prefix data for Indian mobile numbers
    const specificPrefixes = {
        'Jio': [
            '6001', '6002', '6003', '6004', '6005', '6006', '6007', '6008', '6009',
            '6101', '6102', '6103', '6104', '6105', '6106', '6107', '6108', '6109',
            '6201', '6202', '6203', '6204', '6205', '6206', '6207', '6208', '6209',
            '6301', '6302', '6303', '6304', '6305', '6306', '6307', '6308', '6309',
            '7001', '7002', '7003', '7004', '7005', '7006', '7007', '7008', '7009',
            '7901', '7902', '7903', '7904', '7905', '7906', '7907', '7908', '7909',
            '8001', '8002', '8003', '8004', '8005', '8006', '8007', '8008', '8009',
            '8101', '8102', '8103', '8104', '8105', '8106', '8107', '8108', '8109',
            '8201', '8202', '8203', '8204', '8205', '8206', '8207', '8208', '8209',
            '9001', '9002', '9003', '9004', '9005', '9006', '9007', '9008', '9009',
            '9101', '9102', '9103', '9104', '9105', '9106', '9107', '9108', '9109',
            '9201', '9202', '9203', '9204', '9205', '9206', '9207', '9208', '9209',
            '9301', '9302', '9303', '9304', '9305', '9306', '9307', '9308', '9309',
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909'
        ],
        'Airtel': [
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9301', '9302', '9303', '9304', '9305', '9306', '9307', '9308', '9309',
            '9201', '9202', '9203', '9204', '9205', '9206', '9207', '9208', '9209',
            '9101', '9102', '9103', '9104', '9105', '9106', '9107', '9108', '9109',
            '9001', '9002', '9003', '9004', '9005', '9006', '9007', '9008', '9009'
        ],
        'Vi (Idea/Vodafone)': [
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9301', '9302', '9303', '9304', '9305', '9306', '9307', '9308', '9309',
            '9201', '9202', '9203', '9204', '9205', '9206', '9207', '9208', '9209',
            '9101', '9102', '9103', '9104', '9105', '9106', '9107', '9108', '9109',
            '9001', '9002', '9003', '9004', '9005', '9006', '9007', '9008', '9009'
        ],
        'BSNL': [
            '9401', '9402', '9403', '9404', '9405', '9406', '9407', '9408', '9409',
            '9501', '9502', '9503', '9504', '9505', '9506', '9507', '9508', '9509',
            '9601', '9602', '9603', '9604', '9605', '9606', '9607', '9608', '9609',
            '9701', '9702', '9703', '9704', '9705', '9706', '9707', '9708', '9709',
            '9801', '9802', '9803', '9804', '9805', '9806', '9807', '9808', '9809',
            '9901', '9902', '9903', '9904', '9905', '9906', '9907', '9908', '9909'
        ],
        'Vodafone': [
            '9952', '9953', '9954', '9955', '9956', '9957', '9958', '9959',
            '9960', '9961', '9962', '9963', '9964', '9965', '9966', '9967', '9968', '9969',
            '9970', '9971', '9972', '9973', '9974', '9975', '9976', '9977', '9978', '9979',
            '9980', '9981', '9982', '9983', '9984', '9985', '9986', '9987', '9988', '9989',
            '9990', '9991', '9992', '9993', '9994', '9995', '9996', '9997', '9998', '9999'
        ]
    };
    
    // Check if the first 4 digits match any specific network prefix
    for (const [network, prefixes] of Object.entries(specificPrefixes)) {
        if (prefixes.includes(firstFourDigits)) {
            return network;
        }
    }
    
    // If not found in specific prefixes, check first 2 digits
    const firstTwoDigits = number.substring(0, 2);
    
    // Fallback to broader prefix matching
    const broaderPrefixes = {
        'Jio': ['6', '7'],
        'Airtel': ['98', '99', '96', '95', '94', '93', '92', '91', '90'],
        'Vi (Idea/Vodafone)': ['98', '99', '96', '95', '94', '93', '92', '91', '90'],
        'BSNL': ['94', '95', '96', '97', '98', '99'],
        'Vodafone': ['98', '99']
    };
    
    // Check for exact match with first 2 digits
    for (const [network, prefixes] of Object.entries(broaderPrefixes)) {
        if (prefixes.includes(firstTwoDigits)) {
            return network;
        }
    }
    
    // If still not found, check first digit
    const firstDigit = number.substring(0, 1);
    
    for (const [network, prefixes] of Object.entries(broaderPrefixes)) {
        if (prefixes.includes(firstDigit)) {
            return network;
        }
    }
    
    return 'Unknown';
}
    
    /**
     * Display the result with new design
     */
    displayResult(network, number) {
        this.resultDisplay.innerHTML = '';
        
        if (!number) {
            const errorContent = document.createElement('div');
            errorContent.style.cssText = `
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
            `;
            
            const errorIcon = document.createElement('div');
            errorIcon.textContent = '⚠️';
            errorIcon.style.cssText = `
                font-size: 64px;
                margin-bottom: 20px;
            `;
            
            const errorText = document.createElement('div');
            errorText.textContent = network;
            errorText.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 20px;
                max-width: 80%;
            `;
            
            errorContent.appendChild(errorIcon);
            errorContent.appendChild(errorText);
            this.resultDisplay.appendChild(errorContent);
            return;
        }
        
        // Format the number for display
        const formattedNumber = `${number.substring(0, 5)} ${number.substring(5)}`;
        
        // Get network data
        const networkData = this.networkData[network] || {
            color: '#888888',
            icon: '❓'
        };
        
        // Create result content
        const resultContent = document.createElement('div');
        resultContent.style.cssText = `
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            animation: fadeIn 0.5s ease;
        `;
        
        // Network icon
        const networkIcon = document.createElement('div');
        networkIcon.textContent = networkData.icon;
        networkIcon.style.cssText = `
            font-size: 80px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px ${networkData.color}40);
        `;
        
        // Number display
        const numberDisplay = document.createElement('div');
        numberDisplay.textContent = formattedNumber;
        numberDisplay.style.cssText = `
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        // Network display
        const networkDisplay = document.createElement('div');
        networkDisplay.textContent = network;
        networkDisplay.style.cssText = `
            font-size: 28px;
            font-weight: 700;
            color: ${networkData.color};
            padding: 12px 30px;
            border-radius: 30px;
            background-color: ${networkData.color}20;
            border: 2px solid ${networkData.color}40;
            margin-bottom: 20px;
        `;
        
        // Status message
        const statusMessage = document.createElement('div');
        statusMessage.textContent = 'Network identified successfully';
        statusMessage.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
        `;
        
        resultContent.appendChild(networkIcon);
        resultContent.appendChild(numberDisplay);
        resultContent.appendChild(networkDisplay);
        resultContent.appendChild(statusMessage);
        
        this.resultDisplay.appendChild(resultContent);
    }
    
    /**
     * Generate a random mobile number
     */
    generateRandomNumber() {
        // Generate a random 10-digit number starting with 6, 7, 8, or 9
        const firstDigit = Math.floor(Math.random() * 4) + 6;
        let randomNumber = firstDigit.toString();
        
        for (let i = 0; i < 9; i++) {
            randomNumber += Math.floor(Math.random() * 10);
        }
        
        this.numberInput.value = randomNumber;
        this.findNetwork();
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0f3460, #16213e);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.fullscreenButton.addEventListener('mouseover', () => {
            this.fullscreenButton.style.transform = 'scale(1.1)';
        });
        
        this.fullscreenButton.addEventListener('mouseout', () => {
            this.fullscreenButton.style.transform = 'scale(1)';
        });
        
        this.fullscreenButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        });
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '✕';
        this.closeButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e53935, #c62828);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.closeButton.addEventListener('mouseover', () => {
            this.closeButton.style.transform = 'scale(1.1)';
        });
        
        this.closeButton.addEventListener('mouseout', () => {
            this.closeButton.style.transform = 'scale(1)';
        });
        
        this.closeButton.addEventListener('click', (e) => {
            e.stopPropagation();
            this.closeApp();
        });
        
        floatingButtons.appendChild(this.closeButton);
        
        this.appContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.appContainer) return;
        
        if (this.appContainer.requestFullscreen) {
            this.appContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.appContainer.webkitRequestFullscreen) {
            this.appContainer.webkitRequestFullscreen();
        } else if (this.appContainer.msRequestFullscreen) {
            this.appContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        switch (event.key) {
            case 'Escape':
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeApp();
                }
                break;
            case 'Enter':
                if (document.activeElement === this.numberInput) {
                    event.preventDefault();
                    this.findNetwork();
                }
                break;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        if (!this.isActive) return;
        
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        // Reset variables
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.numberInput = null;
        this.resultDisplay = null;
        this.historyPanel = null;
        this.currentNumber = '';
        this.searchHistory = [];
        
        botReply("Network Finder closed. Thank you!");
    }
}

// Create a singleton instance
const networkFinder = new NetworkFinder();

// Add this to your AI's command handling
if (/network finder|number finder|find network|network check/i.test(userInputRaw)) {
    networkFinder.loadNetworkFinder();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    networkFinder.closeApp();
    return;
}
/**
 * Advanced Code Error Fixing System - Enhanced Version
 * Detects and fixes errors in multiple programming languages with improved performance
 */
const AdvancedCodeFixer = {
    // Language detection patterns
    languagePatterns: {
        javascript: /(?:function|var|let|const|=>|console\.log|document\.getElementById)/,
        python: /(?:def |import |from |print\(|if __name__|:|\s{4})/,
        java: /(?:public class|public static void main|System\.out\.println|private|protected)/,
        html: /<!DOCTYPE html>|<html|<head|<body|<div|<span|<p>/,
        css: /(?:@media|{|}|:\s*;|#[a-fA-F0-9]{3,6}|rgb\(|rgba\()/,
        cpp: /#include|using namespace std|int main\(\)|cout|cin|std::/,
        csharp: /using System|namespace|public class|Console\.Write|static void Main/,
        php: /<\?php|\$\w+|echo|function |require_once|include_once/,
        ruby: /def |require |puts |if |end|@/,
        swift: /import UIKit|let |var |@IBOutlet|@IBAction|func /,
        typescript: /(?:interface|type|namespace|declare|private|public|protected|readonly|:)/,
        go: /(?:package main|import \(|func |fmt\.Print|go |defer )/,
        rust: /(?:fn |let |mut |use |extern crate|println!)/,
        kotlin: /(?:fun |val |var |: String|: Int|import kotlin)/
    },
    
    // Language cache for faster detection
    languageCache: new Map(),
    
    // Pre-compiled patterns cache
    compiledPatterns: {},
    
    // Initialize compiled patterns
    init: function() {
        // Pre-compile all regex patterns for better performance
        for (const [lang, patterns] of Object.entries(this.errorPatterns)) {
            this.compiledPatterns[lang] = patterns.map(p => ({
                ...p,
                compiledPattern: new RegExp(p.pattern.source, p.pattern.flags)
            }));
        }
    },
    
    // Common error patterns and fixes by language
    errorPatterns: {
        javascript: [
            {
                name: "Missing semicolon",
                pattern: /(\w+\s*[=+\-*/]?\s*[^(;{])$\n/gm,
                fix: "$1;",
                description: "Added missing semicolon"
            },
            {
                name: "Using assignment instead of comparison",
                pattern: /if\s*\(([^=]+)=([^=]+)\)/g,
                fix: "if ($1===$2)",
                description: "Changed assignment (=) to strict equality (===)"
            },
            {
                name: "Unmatched bracket",
                pattern: /(\{|\(|\[)([^}]*)$/gm,
                fix: (match, openBracket, content) => {
                    const closeBracket = openBracket === '{' ? '}' : openBracket === '(' ? ')' : ']';
                    return openBracket + content + closeBracket;
                },
                description: "Added missing closing bracket"
            },
            {
                name: "String concatenation instead of template literals",
                pattern: /console\.log\(\s*["'](.+?)["']\s*\+\s*(.+?)\s*\)/g,
                fix: "console.log(`$1${$2}`)",
                description: "Replaced string concatenation with template literals"
            },
            {
                name: "Var instead of let/const",
                pattern: /\bvar\s+(\w+)/g,
                fix: (match, varName) => {
                    // Simple heuristic: use const if the variable is only assigned once
                    return `const ${varName}`;
                },
                description: "Replaced 'var' with 'const'"
            },
            {
                name: "Missing return statement",
                pattern: /function\s+\w+\s*\([^)]*\)\s*\{[^}]*\}(?!\s*return)/g,
                fix: (match) => {
                    // Simple heuristic: add return if function doesn't already have one
                    if (!match.includes('return ')) {
                        return match.replace(/\}$/, '  return null;\n}');
                    }
                    return match;
                },
                description: "Added missing return statement"
            },
            {
                name: "Async function without await",
                pattern: /async\s+function\s+\w+\s*\([^)]*\)\s*\{(?![^}]*await)/g,
                fix: (match) => {
                    return match.replace('async function ', 'function ');
                },
                description: "Removed async keyword as no await was found"
            }
        ],
        python: [
            {
                name: "Missing colon",
                pattern: /(def |if |for |while |class )([^:]+)$/gm,
                fix: "$1$2:",
                description: "Added missing colon"
            },
            {
                name: "Indentation error",
                pattern: /^(\s+)(def |if |for |while |class )/gm,
                fix: (match, spaces, keyword) => {
                    // Ensure 4 spaces for indentation
                    const indent = "    ".repeat(Math.ceil(spaces.length / 4));
                    return indent + keyword;
                },
                description: "Fixed indentation to 4 spaces"
            },
            {
                name: "Print statement instead of function",
                pattern: /print\s+(.+)/g,
                fix: "print($1)",
                description: "Changed print statement to print function"
            },
            {
                name: "Missing self parameter",
                pattern: /def\s+(\w+)\s*\([^)]*self[^)]*\)/g,
                fix: (match, methodName) => {
                    if (!match.includes('self')) {
                        return match.replace(/\(([^)]*)\)/, '(self, $1)');
                    }
                    return match;
                },
                description: "Added missing self parameter to method"
            }
        ],
        java: [
            {
                name: "Missing semicolon",
                pattern: /(\w+\s*[=+\-*/]?\s*[^(;{])$\n/gm,
                fix: "$1;",
                description: "Added missing semicolon"
            },
            {
                name: "Class name convention",
                pattern: /class\s+([a-z][a-zA-Z0-9]*)/g,
                fix: (match, className) => {
                    // Capitalize first letter
                    return "class " + className.charAt(0).toUpperCase() + className.slice(1);
                },
                description: "Capitalized class name"
            },
            {
                name: "String concatenation",
                pattern: /System\.out\.print\(\s*"(.+?)"\s*\+\s*(.+?)\s*\)/g,
                fix: 'System.out.println("$1" + $2)',
                description: "Improved string concatenation formatting"
            },
            {
                name: "Missing public static void main",
                pattern: /class\s+\w+\s*\{[^}]*\}(?![^}]*public static void main)/g,
                fix: (match) => {
                    return match.replace(/\}$/, '\n    public static void main(String[] args) {\n        \n    }\n}');
                },
                description: "Added missing main method"
            }
        ],
        html: [
            {
                name: "Unclosed tag",
                pattern: /<([a-z]+)(\s+[^>]*)?>(?!.*<\/\1>)/gi,
                fix: (match, tag, attributes) => {
                    return match + `</${tag}>`;
                },
                description: "Added missing closing tag"
            },
            {
                name: "Missing DOCTYPE",
                pattern: /^(?!<!DOCTYPE)/,
                fix: (match) => {
                    return "<!DOCTYPE html>\n" + match;
                },
                description: "Added missing DOCTYPE declaration"
            },
            {
                name: "Improper nesting",
                pattern: /<([a-z]+)(\s+[^>]*)?><\/([a-z]+)>/gi,
                fix: (match, openTag, attributes, closeTag) => {
                    if (openTag !== closeTag) {
                        return `<${openTag}${attributes}></${openTag}>`;
                    }
                    return match;
                },
                description: "Fixed improperly nested tags"
            },
            {
                name: "Missing alt attribute",
                pattern: /<img\s+([^>]*?)>/gi,
                fix: (match, attributes) => {
                    if (!attributes.includes('alt=')) {
                        return `<img ${attributes} alt="">`;
                    }
                    return match;
                },
                description: "Added missing alt attribute to img tag"
            }
        ],
        css: [
            {
                name: "Missing colon",
                pattern: /([a-z-]+)\s*([^{;]+)$/gim,
                fix: "$1: $2;",
                description: "Added missing colon and semicolon"
            },
            {
                name: "Invalid color value",
                pattern: /:\s*#([a-fA-F0-9]{3,6})[^a-fA-F0-9;]/gi,
                fix: (match, color) => {
                    if (color.length === 3) {
                        return `: #${color};`;
                    } else if (color.length === 6) {
                        return `: #${color};`;
                    }
                    return match;
                },
                description: "Fixed invalid color value"
            },
            {
                name: "Missing units",
                pattern: /:\s*(\d+)\s*;/gi,
                fix: (match, value) => {
                    // Default to px for numeric values without units
                    return `: ${value}px;`;
                },
                description: "Added missing units (px)"
            },
            {
                name: "Missing vendor prefixes",
                pattern: /(transform|transition|animation|user-select|box-sizing):\s*([^;]+);/gi,
                fix: (match, property, value) => {
                    return `-webkit-${property}: ${value};\n-moz-${property}: ${value};\n-ms-${property}: ${value};\n${property}: ${value};`;
                },
                description: "Added vendor prefixes for better browser compatibility"
            }
        ],
        typescript: [
            {
                name: "Missing type annotation",
                pattern: /(function\s+\w+\s*\([^)]*\)|const\s+\w+\s*=|let\s+\w+\s*=)(?!\s*:\s*\w+)/g,
                fix: (match) => {
                    if (match.startsWith('function')) {
                        return match.replace(/\)/, '): any');
                    } else if (match.includes('const')) {
                        return match.replace('=', ': any =');
                    } else if (match.includes('let')) {
                        return match.replace('=', ': any =');
                    }
                    return match;
                },
                description: "Added missing type annotation"
            },
            {
                name: "Using var instead of let/const",
                pattern: /\bvar\s+(\w+)/g,
                fix: (match, varName) => {
                    return `let ${varName}`;
                },
                description: "Replaced 'var' with 'let'"
            }
        ]
    },
    
    /**
     * Detect the programming language of the provided code with caching
     * @param {string} code - The code to analyze
     * @returns {string} - The detected language
     */
    detectLanguage: function(code) {
        // Check cache first
        const cacheKey = code.substring(0, 100); // Use first 100 chars as key
        if (this.languageCache.has(cacheKey)) {
            return this.languageCache.get(cacheKey);
        }
        
        for (const [language, pattern] of Object.entries(this.languagePatterns)) {
            if (pattern.test(code)) {
                this.languageCache.set(cacheKey, language);
                return language;
            }
        }
        
        this.languageCache.set(cacheKey, "unknown");
        return "unknown";
    },
    
    /**
     * Fix errors in the provided code with optimized processing
     * @param {string} code - The code to fix
     * @param {string} language - Optional language hint
     * @returns {Object} - Result object with fixed code and issues found
     */
    fixCode: function(code, language = null) {
        // Detect language if not provided
        const detectedLanguage = language || this.detectLanguage(code);
        
        // Initialize result object
        const result = {
            originalCode: code,
            fixedCode: code,
            language: detectedLanguage,
            issues: [],
            fixesApplied: []
        };
        
        // If language is unknown or unsupported, return early
        if (detectedLanguage === "unknown" || !this.errorPatterns[detectedLanguage]) {
            result.issues.push({
                type: "warning",
                message: `Could not detect language or language '${detectedLanguage}' is not supported`
            });
            return result;
        }
        
        // Ensure patterns are compiled
        if (!this.compiledPatterns[detectedLanguage]) {
            this.init();
        }
        
        // Get compiled error patterns for the detected language
        const patterns = this.compiledPatterns[detectedLanguage];
        
        // Collect all fixes first, then apply them in batch
        const fixes = [];
        
        for (const pattern of patterns) {
            const matches = result.fixedCode.match(pattern.compiledPattern);
            
            if (matches) {
                // Add issue
                result.issues.push({
                    type: "error",
                    message: pattern.description,
                    pattern: pattern.name
                });
                
                // Collect fix
                fixes.push({
                    pattern: pattern.compiledPattern,
                    fix: pattern.fix,
                    name: pattern.name,
                    description: pattern.description
                });
            }
        }
        
        // Apply all fixes in a single pass
        let currentCode = result.fixedCode;
        for (const fix of fixes) {
            if (typeof fix.fix === "function") {
                currentCode = currentCode.replace(fix.pattern, fix.fix);
            } else {
                currentCode = currentCode.replace(fix.pattern, fix.fix);
            }
            
            result.fixesApplied.push({
                pattern: fix.name,
                description: fix.description
            });
        }
        
        result.fixedCode = currentCode;
        
        // Check for unmatched brackets, braces, or parentheses
        this.checkUnmatchedDelimiters(result);
        
        return result;
    },
    
    /**
     * Check for unmatched brackets, braces, or parentheses
     * @param {Object} result - The result object to update
     */
    checkUnmatchedDelimiters: function(result) {
        const delimiters = {
            '(': { count: 0, closer: ')' },
            '[': { count: 0, closer: ']' },
            '{': { count: 0, closer: '}' }
        };
        
        // Count opening and closing delimiters
        for (let i = 0; i < result.fixedCode.length; i++) {
            const char = result.fixedCode[i];
            
            if (delimiters[char]) {
                delimiters[char].count++;
            } else {
                // Check if this is a closing delimiter
                for (const [opener, info] of Object.entries(delimiters)) {
                    if (char === info.closer) {
                        delimiters[opener].count--;
                        break;
                    }
                }
            }
        }
        
        // Check for unmatched delimiters
        for (const [opener, info] of Object.entries(delimiters)) {
            if (info.count > 0) {
                result.issues.push({
                    type: "error",
                    message: `Unmatched '${opener}' - missing ${info.count} '${info.closer}'`,
                    pattern: "Unmatched delimiter"
                });
                
                // Add missing closing delimiters
                for (let i = 0; i < info.count; i++) {
                    result.fixedCode += info.closer;
                }
                
                result.fixesApplied.push({
                    pattern: "Unmatched delimiter",
                    description: `Added missing '${info.closer}' delimiter(s)`
                });
            } else if (info.count < 0) {
                result.issues.push({
                    type: "error",
                    message: `Too many '${info.closer}' - missing ${Math.abs(info.count)} '${opener}'`,
                    pattern: "Unmatched delimiter"
                });
            }
        }
    },
    
    /**
     * Format the result for display
     * @param {Object} result - The result object from fixCode
     * @returns {string} - Formatted result
     */
    formatResult: function(result) {
        let formatted = `Language detected: ${result.language}\n\n`;
        
        if (result.issues.length === 0) {
            formatted += "No issues detected in your code.\n";
        } else {
            formatted += "Issues found:\n";
            result.issues.forEach((issue, index) => {
                formatted += `${index + 1}. ${issue.message} (${issue.pattern})\n`;
            });
            
            formatted += "\nFixes applied:\n";
            result.fixesApplied.forEach((fix, index) => {
                formatted += `${index + 1}. ${fix.description}\n`;
            });
        }
        
        return formatted;
    },
    
    /**
     * Copy text to clipboard
     * @param {string} text - Text to copy
     */
    copyToClipboard: function(text) {
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.showNotification('Copied to clipboard!', '#4CAF50');
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    this.fallbackCopyToClipboard(text);
                });
        } else {
            this.fallbackCopyToClipboard(text);
        }
    },
    
    /**
     * Fallback method for copying to clipboard
     * @param {string} text - Text to copy
     */
    fallbackCopyToClipboard: function(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed'; // Prevent scrolling to bottom
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        try {
            document.execCommand('copy');
            this.showNotification('Copied to clipboard!', '#4CAF50');
        } catch (err) {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy', '#f44336');
        }
        
        document.body.removeChild(textarea);
    },
    
    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} bgColor - Background color
     */
    showNotification: function(message, bgColor = '#4CAF50') {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.code-fixer-notification');
        existingNotifications.forEach(notification => {
            document.body.removeChild(notification);
        });
        
        const notification = document.createElement('div');
        notification.className = 'code-fixer-notification';
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.bottom = '20px';
        notification.style.right = '20px';
        notification.style.backgroundColor = bgColor;
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '2000';
        notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        notification.style.transition = 'opacity 0.5s ease';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 2000);
    },
    
    /**
     * Share code
     * @param {string} code - Code to share
     */
    shareCode: function(code) {
        // Create a temporary URL with the code
        const encodedCode = encodeURIComponent(code);
        const shareUrl = `${window.location.origin}${window.location.pathname}?code=${encodedCode}`;
        
        // Copy to clipboard
        this.copyToClipboard(shareUrl);
        
        // Show notification
        this.showNotification('Share link copied to clipboard!', '#2196F3');
    },
    
    /**
     * Edit code
     * @param {string} code - Code to edit
     */
    editCode: function(code) {
        const inputTextarea = document.getElementById('code-input');
        if (inputTextarea) {
            inputTextarea.value = code;
            
            // Scroll to input
            inputTextarea.scrollIntoView({ behavior: 'smooth' });
            inputTextarea.focus();
            
            // Show notification
            this.showNotification('Code loaded in editor!', '#FF9800');
        }
    },
    
    /**
     * Highlight code with syntax
     * @param {string} code - Code to highlight
     * @param {string} language - Language of the code
     * @returns {string} - Highlighted HTML
     */
    highlightCode: function(code, language) {
        // Simple syntax highlighting based on language
        let highlighted = code;
        
        // Escape HTML entities
        highlighted = highlighted
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        
        // Apply language-specific highlighting
        switch (language) {
            case 'javascript':
            case 'typescript':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|var|let|const|if|else|for|while|return|async|await|class|import|export|from|default)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'python':
                highlighted = highlighted
                    .replace(/(#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\'\'\'[\s\S]*?\'\'\'|\"\"\"[\s\S]*?\"\"\")/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(def|if|else|elif|for|while|return|class|import|from|as|try|except|finally|with|pass|break|continue|lambda|and|or|not|in|is|True|False|None)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'java':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(public|private|protected|static|final|abstract|class|interface|enum|void|int|String|boolean|if|else|for|while|return|new|this|super|import|package|try|catch|finally|throws|extends|implements)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'html':
                highlighted = highlighted
                    .replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="code-comment">$1</span>')
                    .replace(/(&lt;\/?[a-zA-Z0-9]+)(\s+[^&gt;]*?)?&gt;/g, '<span class="code-tag">$1$2&gt;</span>')
                    .replace(/([a-zA-Z-]+)=["']([^"']*?)["']/g, '<span class="code-attribute">$1</span>=<span class="code-string">"$2"</span>');
                break;
                
            case 'css':
                highlighted = highlighted
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/([a-zA-Z-]+)\s*:/g, '<span class="code-property">$1</span>:')
                    .replace(/:\s*([a-zA-Z0-9#%]+);/g, ': <span class="code-value">$1</span>;')
                    .replace(/\b(\d+)px\b/g, '<span class="code-number">$1px</span>');
                break;
                
            default:
                // Generic highlighting for other languages
                highlighted = highlighted
                    .replace(/(\/\/.*|#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|if|else|for|while|return|class|def|import|from)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
        }
        
        return highlighted;
    },
    
    /**
     * Load the code fixer interface
     */
    loadCodeFixer: function() {
        // Initialize compiled patterns
        this.init();
        
        // Check if interface already exists
        if (document.getElementById('code-fixer-screen')) {
            return;
        }
        
        // Create the code fixer interface
        const codeFixerScreen = document.createElement('div');
        codeFixerScreen.id = 'code-fixer-screen';
        codeFixerScreen.style.position = 'fixed';
        codeFixerScreen.style.top = '0';
        codeFixerScreen.style.left = '0';
        codeFixerScreen.style.width = '100%';
        codeFixerScreen.style.height = '100%';
        codeFixerScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        codeFixerScreen.style.zIndex = '1000';
        codeFixerScreen.style.display = 'flex';
        codeFixerScreen.style.flexDirection = 'column';
        codeFixerScreen.style.padding = '20px';
        codeFixerScreen.style.boxSizing = 'border-box';
        
        // Create header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '20px';
        
        const title = document.createElement('h2');
        title.textContent = 'Advanced Code Error Fixer';
        title.style.color = 'white';
        title.style.margin = '0';
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.padding = '8px 16px';
        closeButton.style.backgroundColor = '#f44336';
        closeButton.style.color = 'white';
        closeButton.style.border = 'none';
        closeButton.style.borderRadius = '4px';
        closeButton.style.cursor = 'pointer';
        closeButton.onclick = () => this.closeGame();
        
        header.appendChild(title);
        header.appendChild(closeButton);
        
        // Create language selector
        const languageSelector = document.createElement('div');
        languageSelector.style.marginBottom = '20px';
        
        const languageLabel = document.createElement('label');
        languageLabel.textContent = 'Language: ';
        languageLabel.style.color = 'white';
        languageLabel.style.marginRight = '10px';
        
        const languageSelect = document.createElement('select');
        languageSelect.id = 'language-select';
        languageSelect.style.padding = '8px';
        languageSelect.style.borderRadius = '4px';
        languageSelect.style.border = 'none';
        
        const languages = ['auto', 'javascript', 'typescript', 'python', 'java', 'html', 'css', 'cpp', 'csharp', 'php', 'ruby', 'swift', 'go', 'rust', 'kotlin'];
        languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang;
            option.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
            languageSelect.appendChild(option);
        });
        
        languageSelector.appendChild(languageLabel);
        languageSelector.appendChild(languageSelect);
        
        // Create input textarea
        const inputContainer = document.createElement('div');
        inputContainer.style.marginBottom = '20px';
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Code to fix:';
        inputLabel.style.color = 'white';
        inputLabel.style.display = 'block';
        inputLabel.style.marginBottom = '10px';
        
        const inputTextarea = document.createElement('textarea');
        inputTextarea.id = 'code-input';
        inputTextarea.style.width = '100%';
        inputTextarea.style.height = '200px';
        inputTextarea.style.padding = '10px';
        inputTextarea.style.borderRadius = '4px';
        inputTextarea.style.border = 'none';
        inputTextarea.style.fontFamily = 'monospace';
        inputTextarea.style.fontSize = '14px';
        inputTextarea.placeholder = 'Paste your code here...';
        
        inputContainer.appendChild(inputLabel);
        inputContainer.appendChild(inputTextarea);
        
        // Create fix button
        const fixButton = document.createElement('button');
        fixButton.textContent = 'Fix Code';
        fixButton.style.padding = '10px 20px';
        fixButton.style.backgroundColor = '#4CAF50';
        fixButton.style.color = 'white';
        fixButton.style.border = 'none';
        fixButton.style.borderRadius = '4px';
        fixButton.style.cursor = 'pointer';
        fixButton.style.marginBottom = '20px';
        fixButton.onclick = () => {
            const code = inputTextarea.value;
            if (!code.trim()) {
                this.showNotification('Please enter some code to fix', '#f44336');
                return;
            }
            
            const language = languageSelect.value === 'auto' ? null : languageSelect.value;
            
            // Show loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.id = 'loading-indicator';
            loadingIndicator.textContent = 'Analyzing and fixing code...';
            loadingIndicator.style.position = 'absolute';
            loadingIndicator.style.top = '50%';
            loadingIndicator.style.left = '50%';
            loadingIndicator.style.transform = 'translate(-50%, -50%)';
            loadingIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            loadingIndicator.style.color = 'white';
            loadingIndicator.style.padding = '15px 30px';
            loadingIndicator.style.borderRadius = '4px';
            loadingIndicator.style.zIndex = '2000';
            document.body.appendChild(loadingIndicator);
            
            // Use setTimeout to allow UI to update before processing
            setTimeout(() => {
                try {
                    const result = this.fixCode(code, language);
                    
                    // Remove loading indicator
                    if (document.body.contains(loadingIndicator)) {
                        document.body.removeChild(loadingIndicator);
                    }
                    
                    // Create result container
                    const resultContainer = document.getElementById('result-container');
                    resultContainer.innerHTML = '';
                    
                    // Create issues section
                    const issuesSection = document.createElement('div');
                    issuesSection.style.marginBottom = '20px';
                    
                    const issuesTitle = document.createElement('h3');
                    issuesTitle.textContent = 'Analysis Results';
                    issuesTitle.style.marginTop = '0';
                    issuesTitle.style.marginBottom = '10px';
                    issuesSection.appendChild(issuesTitle);
                    
                    if (result.issues.length === 0) {
                        const noIssues = document.createElement('p');
                        noIssues.textContent = 'No issues detected in your code.';
                        issuesSection.appendChild(noIssues);
                    } else {
                        const issuesList = document.createElement('ul');
                        issuesList.style.paddingLeft = '20px';
                        
                        result.issues.forEach(issue => {
                            const issueItem = document.createElement('li');
                            issueItem.textContent = `${issue.message} (${issue.pattern})`;
                            issuesList.appendChild(issueItem);
                        });
                        
                        issuesSection.appendChild(issuesList);
                        
                        const fixesTitle = document.createElement('h4');
                        fixesTitle.textContent = 'Fixes Applied:';
                        fixesTitle.style.marginTop = '15px';
                        fixesTitle.style.marginBottom = '10px';
                        issuesSection.appendChild(fixesTitle);
                        
                        const fixesList = document.createElement('ul');
                        fixesList.style.paddingLeft = '20px';
                        
                        result.fixesApplied.forEach(fix => {
                            const fixItem = document.createElement('li');
                            fixItem.textContent = fix.description;
                            fixesList.appendChild(fixItem);
                        });
                        
                        issuesSection.appendChild(fixesList);
                    }
                    
                    resultContainer.appendChild(issuesSection);
                    
                    // Create fixed code section
                    const fixedCodeSection = document.createElement('div');
                    
                    const fixedCodeTitle = document.createElement('h3');
                    fixedCodeTitle.textContent = 'Fixed Code';
                    fixedCodeTitle.style.marginTop = '0';
                    fixedCodeTitle.style.marginBottom = '10px';
                    fixedCodeSection.appendChild(fixedCodeTitle);
                    
                    // Create code display
                    const codeDisplay = document.createElement('pre');
                    codeDisplay.style.backgroundColor = '#f5f5f5';
                    codeDisplay.style.padding = '15px';
                    codeDisplay.style.borderRadius = '4px';
                    codeDisplay.style.overflow = 'auto';
                    codeDisplay.style.maxHeight = '300px';
                    codeDisplay.style.whiteSpace = 'pre-wrap';
                    codeDisplay.style.fontFamily = 'monospace';
                    codeDisplay.style.fontSize = '14px';
                    
                    // Apply syntax highlighting
                    codeDisplay.innerHTML = this.highlightCode(result.fixedCode, result.language);
                    
                    fixedCodeSection.appendChild(codeDisplay);
                    
                    // Create button container
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.display = 'flex';
                    buttonContainer.style.justifyContent = 'space-between';
                    buttonContainer.style.marginTop = '15px';
                    buttonContainer.style.flexWrap = 'wrap';
                    buttonContainer.style.gap = '10px';
                    
                    // Copy button
                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'Copy Code';
                    copyButton.style.padding = '8px 16px';
                    copyButton.style.backgroundColor = '#2196F3';
                    copyButton.style.color = 'white';
                    copyButton.style.border = 'none';
                    copyButton.style.borderRadius = '4px';
                    copyButton.style.cursor = 'pointer';
                    copyButton.style.flex = '1';
                    copyButton.onclick = () => this.copyToClipboard(result.fixedCode);
                    buttonContainer.appendChild(copyButton);
                    
                    // Share button
                    const shareButton = document.createElement('button');
                    shareButton.textContent = 'Share Code';
                    shareButton.style.padding = '8px 16px';
                    shareButton.style.backgroundColor = '#4CAF50';
                    shareButton.style.color = 'white';
                    shareButton.style.border = 'none';
                    shareButton.style.borderRadius = '4px';
                    shareButton.style.cursor = 'pointer';
                    shareButton.style.flex = '1';
                    shareButton.onclick = () => this.shareCode(result.fixedCode);
                    buttonContainer.appendChild(shareButton);
                    
                    // Edit button
                    const editButton = document.createElement('button');
                    editButton.textContent = 'Edit Code';
                    editButton.style.padding = '8px 16px';
                    editButton.style.backgroundColor = '#FF9800';
                    editButton.style.color = 'white';
                    editButton.style.border = 'none';
                    editButton.style.borderRadius = '4px';
                    editButton.style.cursor = 'pointer';
                    editButton.style.flex = '1';
                    editButton.onclick = () => this.editCode(result.fixedCode);
                    buttonContainer.appendChild(editButton);
                    
                    fixedCodeSection.appendChild(buttonContainer);
                    resultContainer.appendChild(fixedCodeSection);
                    
                    // Show success notification
                    if (result.fixesApplied.length > 0) {
                        this.showNotification(`Fixed ${result.fixesApplied.length} issue(s)!`, '#4CAF50');
                    }
                } catch (error) {
                    // Remove loading indicator
                    if (document.body.contains(loadingIndicator)) {
                        document.body.removeChild(loadingIndicator);
                    }
                    
                    console.error('Error fixing code:', error);
                    this.showNotification('An error occurred while fixing your code', '#f44336');
                }
            }, 100);
        };
        
        // Create result container
        const resultContainer = document.createElement('div');
        resultContainer.id = 'result-container';
        resultContainer.style.backgroundColor = 'white';
        resultContainer.style.padding = '20px';
        resultContainer.style.borderRadius = '4px';
        resultContainer.style.overflow = 'auto';
        resultContainer.style.flex = '1';
        resultContainer.innerHTML = '<p style="color: gray;">Results will appear here...</p>';
        
        // Add syntax highlighting styles
        const style = document.createElement('style');
        style.textContent = `
            .code-comment { color: #6a9955; }
            .code-keyword { color: #569cd6; font-weight: bold; }
            .code-number { color: #b5cea8; }
            .code-string { color: #ce9178; }
            .code-tag { color: #569cd6; }
            .code-attribute { color: #9cdcfe; }
            .code-property { color: #9cdcfe; }
            .code-value { color: #ce9178; }
        `;
        document.head.appendChild(style);
        
        // Assemble the interface
        codeFixerScreen.appendChild(header);
        codeFixerScreen.appendChild(languageSelector);
        codeFixerScreen.appendChild(inputContainer);
        codeFixerScreen.appendChild(fixButton);
        codeFixerScreen.appendChild(resultContainer);
        
        // Add to document
        document.body.appendChild(codeFixerScreen);
        
        // Check if there's a code parameter in the URL
        const urlParams = new URLSearchParams(window.location.search);
        const codeParam = urlParams.get('code');
        if (codeParam) {
            inputTextarea.value = decodeURIComponent(codeParam);
        }
    },
    
    /**
     * Close the code fixer interface
     */
    closeGame: function() {
        const codeFixerScreen = document.getElementById('code-fixer-screen');
        if (codeFixerScreen) {
            document.body.removeChild(codeFixerScreen);
        }
    }
};

// Initialize the compiled patterns
AdvancedCodeFixer.init();

// Create a singleton instance
const codeFixerScreen = AdvancedCodeFixer;

// Add this to your AI's command handling
if (/fix code|code fix|fix my code/i.test(userInputRaw)) {
    codeFixerScreen.loadCodeFixer();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    codeFixerScreen.closeGame();
    return;
}

/**
 * Code Display System - Shows formatted code in a nice box
 */
const CodeDisplay = {
    /**
     * Display code in a formatted box
     * @param {string} code - The code to display
     * @param {string} language - The programming language
     * @param {string} title - Optional title for the code box
     */
    displayCode: function(code, language, title = "Source Code") {
        // Remove any existing code displays
        const existingDisplays = document.querySelectorAll('.code-display-container');
        existingDisplays.forEach(display => {
            document.body.removeChild(display);
        });
        
        // Create the code display container
        const container = document.createElement('div');
        container.className = 'code-display-container';
        container.style.position = 'fixed';
        container.style.top = '0';
        container.style.left = '0';
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        container.style.zIndex = '1000';
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.padding = '20px';
        container.style.boxSizing = 'border-box';
        
        // Create header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '20px';
        
        const titleElement = document.createElement('h2');
        titleElement.textContent = title;
        titleElement.style.color = 'white';
        titleElement.style.margin = '0';
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.padding = '8px 16px';
        closeButton.style.backgroundColor = '#f44336';
        closeButton.style.color = 'white';
        closeButton.style.border = 'none';
        closeButton.style.borderRadius = '4px';
        closeButton.style.cursor = 'pointer';
        closeButton.onclick = () => this.closeDisplay();
        
        header.appendChild(titleElement);
        header.appendChild(closeButton);
        
        // Create language indicator
        const languageIndicator = document.createElement('div');
        languageIndicator.style.marginBottom = '15px';
        
        const languageLabel = document.createElement('span');
        languageLabel.textContent = 'Language: ';
        languageLabel.style.color = '#aaa';
        
        const languageName = document.createElement('span');
        languageName.textContent = language.toUpperCase();
        languageName.style.color = '#4CAF50';
        languageName.style.fontWeight = 'bold';
        
        languageIndicator.appendChild(languageLabel);
        languageIndicator.appendChild(languageName);
        
        // Create code display
        const codeDisplay = document.createElement('pre');
        codeDisplay.style.backgroundColor = '#1e1e1e';
        codeDisplay.style.color = '#d4d4d4';
        codeDisplay.style.padding = '20px';
        codeDisplay.style.borderRadius = '8px';
        codeDisplay.style.overflow = 'auto';
        codeDisplay.style.flex = '1';
        codeDisplay.style.fontFamily = 'Consolas, Monaco, "Andale Mono", monospace';
        codeDisplay.style.fontSize = '14px';
        codeDisplay.style.lineHeight = '1.5';
        codeDisplay.style.whiteSpace = 'pre-wrap';
        codeDisplay.style.wordBreak = 'break-all';
        
        // Apply syntax highlighting
        codeDisplay.innerHTML = this.highlightCode(code, language);
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.justifyContent = 'flex-end';
        buttonContainer.style.marginTop = '15px';
        buttonContainer.style.gap = '10px';
        
        // Copy button
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Code';
        copyButton.style.padding = '8px 16px';
        copyButton.style.backgroundColor = '#2196F3';
        copyButton.style.color = 'white';
        copyButton.style.border = 'none';
        copyButton.style.borderRadius = '4px';
        copyButton.style.cursor = 'pointer';
        copyButton.onclick = () => this.copyToClipboard(code);
        buttonContainer.appendChild(copyButton);
        
        // Add syntax highlighting styles
        this.addSyntaxHighlightingStyles();
        
        // Assemble the display
        container.appendChild(header);
        container.appendChild(languageIndicator);
        container.appendChild(codeDisplay);
        container.appendChild(buttonContainer);
        
        // Add to document
        document.body.appendChild(container);
    },
    
    /**
     * Highlight code with syntax
     * @param {string} code - Code to highlight
     * @param {string} language - Language of the code
     * @returns {string} - Highlighted HTML
     */
    highlightCode: function(code, language) {
        // Escape HTML entities
        let highlighted = code
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        
        // Apply language-specific highlighting
        switch (language.toLowerCase()) {
            case 'java':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(public|private|protected|static|final|abstract|class|interface|enum|void|int|String|boolean|if|else|for|while|return|new|this|super|import|package|try|catch|finally|throws|extends|implements)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'javascript':
            case 'typescript':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|var|let|const|if|else|for|while|return|async|await|class|import|export|from|default)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'python':
                highlighted = highlighted
                    .replace(/(#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\'\'\'[\s\S]*?\'\'\'|\"\"\"[\s\S]*?\"\"\")/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(def|if|else|elif|for|while|return|class|import|from|as|try|except|finally|with|pass|break|continue|lambda|and|or|not|in|is|True|False|None)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'html':
                highlighted = highlighted
                    .replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="code-comment">$1</span>')
                    .replace(/(&lt;\/?[a-zA-Z0-9]+)(\s+[^&gt;]*?)?&gt;/g, '<span class="code-tag">$1$2&gt;</span>')
                    .replace(/([a-zA-Z-]+)=["']([^"']*?)["']/g, '<span class="code-attribute">$1</span>=<span class="code-string">"$2"</span>');
                break;
                
            case 'css':
                highlighted = highlighted
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/([a-zA-Z-]+)\s*:/g, '<span class="code-property">$1</span>:')
                    .replace(/:\s*([a-zA-Z0-9#%]+);/g, ': <span class="code-value">$1</span>;')
                    .replace(/\b(\d+)px\b/g, '<span class="code-number">$1px</span>');
                break;
                
            default:
                // Generic highlighting for other languages
                highlighted = highlighted
                    .replace(/(\/\/.*|#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|if|else|for|while|return|class|def|import|from)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
        }
        
        return highlighted;
    },
    
    /**
     * Add syntax highlighting styles to the document
     */
    addSyntaxHighlightingStyles: function() {
        // Check if styles already exist
        if (document.getElementById('code-display-styles')) {
            return;
        }
        
        const style = document.createElement('style');
        style.id = 'code-display-styles';
        style.textContent = `
            .code-comment { color: #6a9955; font-style: italic; }
            .code-keyword { color: #569cd6; font-weight: bold; }
            .code-number { color: #b5cea8; }
            .code-string { color: #ce9178; }
            .code-tag { color: #569cd6; }
            .code-attribute { color: #9cdcfe; }
            .code-property { color: #9cdcfe; }
            .code-value { color: #ce9178; }
        `;
        document.head.appendChild(style);
    },
    
    /**
     * Copy text to clipboard
     * @param {string} text - Text to copy
     */
    copyToClipboard: function(text) {
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.showNotification('Copied to clipboard!', '#4CAF50');
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    this.fallbackCopyToClipboard(text);
                });
        } else {
            this.fallbackCopyToClipboard(text);
        }
    },
    
    /**
     * Fallback method for copying to clipboard
     * @param {string} text - Text to copy
     */
    fallbackCopyToClipboard: function(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        try {
            document.execCommand('copy');
            this.showNotification('Copied to clipboard!', '#4CAF50');
        } catch (err) {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy', '#f44336');
        }
        
        document.body.removeChild(textarea);
    },
    
    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} bgColor - Background color
     */
    showNotification: function(message, bgColor = '#4CAF50') {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.code-display-notification');
        existingNotifications.forEach(notification => {
            document.body.removeChild(notification);
        });
        
        const notification = document.createElement('div');
        notification.className = 'code-display-notification';
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.bottom = '20px';
        notification.style.right = '20px';
        notification.style.backgroundColor = bgColor;
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '2000';
        notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        notification.style.transition = 'opacity 0.5s ease';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 2000);
    },
    
    /**
     * Close the code display
     */
    closeDisplay: function() {
        const container = document.querySelector('.code-display-container');
        if (container) {
            document.body.removeChild(container);
        }
    }
};

// Create a singleton instance
const codeDisplay = CodeDisplay;

// Example usage:
// codeDisplay.displayCode(
//     `Toast.makeText(getApplicationContext(), "Hello World", Toast.LENGTH_SHORT).show();`,
//     "java",
//     "Android Java Toast Example"
// );

// Add this to your AI's command handling when you want to display code
// For example, when a user asks for source code:
// if (userAskedForCode) {
//     codeDisplay.displayCode(sourceCode, language, title);
//     return;
// }

// Add command to close the display
if (/close code|close display/i.test(userInputRaw)) {
    codeDisplay.closeDisplay();
    return;
}
class YouTubeScreenLoader {
    constructor() {
        this.youtube = {
            name: 'YOUTUBE PLAYER',
            instructions: 'Paste a YouTube link to watch videos in this player.'
        };
        
        this.gameContainer = null;
        this.iframe = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputContainer = null;
        this.videoId = null;
    }
    
    /**
     * Load the YouTube player
     */
    loadYouTube(url = null) {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.youtube.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // If URL is provided, load it directly
        if (url) {
            this.loadYouTubeVideo(url);
        } else {
            // Show input UI for URL
            this.showYouTubeInputUI();
        }
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the player
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.youtube.name} loaded! ${this.youtube.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Show YouTube URL input UI
     */
    showYouTubeInputUI() {
        // Create input container
        this.inputContainer = document.createElement('div');
        this.inputContainer.style.cssText = `
            background-color: #222;
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;
        
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'YouTube Player';
        title.style.cssText = `
            color: #ff0000;
            margin-bottom: 20px;
            font-size: 24px;
        `;
        this.inputContainer.appendChild(title);
        
        // Create instructions
        const instructions = document.createElement('p');
        instructions.textContent = 'Paste a YouTube URL below:';
        instructions.style.cssText = `
            color: #ccc;
            margin-bottom: 20px;
            font-size: 16px;
        `;
        this.inputContainer.appendChild(instructions);
        
        // Create input field
        const inputField = document.createElement('input');
        inputField.type = 'text';
        inputField.placeholder = 'https://www.youtube.com/watch?v=...';
        inputField.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 2px solid #444;
            border-radius: 5px;
            background-color: #333;
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
            box-sizing: border-box;
        `;
        this.inputContainer.appendChild(inputField);
        
        // Create load button
        const loadButton = document.createElement('button');
        loadButton.textContent = 'Load Video';
        loadButton.style.cssText = `
            padding: 12px 24px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        loadButton.addEventListener('click', () => {
            const url = inputField.value.trim();
            if (url) {
                this.loadYouTubeVideo(url);
            } else {
                this.showError('Please enter a YouTube URL');
            }
        });
        this.inputContainer.appendChild(loadButton);
        
        // Add paste button for mobile
        const pasteButton = document.createElement('button');
        pasteButton.textContent = 'Paste URL';
        pasteButton.style.cssText = `
            padding: 10px 20px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.2s ease;
        `;
        pasteButton.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                inputField.value = text;
            } catch (err) {
                this.showError('Failed to read clipboard');
            }
        });
        this.inputContainer.appendChild(pasteButton);
        
        // Add input container to game container
        this.gameContainer.appendChild(this.inputContainer);
        
        // Focus on input field
        setTimeout(() => inputField.focus(), 100);
    }
    
    /**
     * Load YouTube video from URL
     */
    loadYouTubeVideo(url) {
        // Extract video ID from URL
        this.videoId = this.extractYouTubeID(url);
        
        if (!this.videoId) {
            this.showError('Invalid YouTube URL');
            return;
        }
        
        // Remove input container if exists
        if (this.inputContainer && this.inputContainer.parentNode) {
            this.inputContainer.parentNode.removeChild(this.inputContainer);
            this.inputContainer = null;
        }
        
        // Create iframe for YouTube player
        this.iframe = document.createElement('iframe');
        this.iframe.src = `https://www.youtube.com/embed/${this.videoId}?autoplay=1&rel=0&modestbranding=1`;
        this.iframe.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 70vh;
            max-height: 800px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        `;
        
        // Handle iframe load event
        this.iframe.onload = () => {
            botReply('Video loaded successfully!');
        };
        
        // Handle iframe error event
        this.iframe.onerror = () => {
            botReply('Error loading the video. Please check the URL and try again.');
            this.closeGame();
        };
        
        // Add iframe to container
        this.gameContainer.appendChild(this.iframe);
    }
    
    /**
     * Extract YouTube video ID from URL - UPDATED to handle Shorts
     */
    extractYouTubeID(url) {
        // Clean the URL first
        url = url.trim();
        
        // Regular expressions to match YouTube URL patterns
        const regexPatterns = [
            // Standard watch URL
            /(?:youtube\.com\/watch\?v=|&v=)([^&\n?#]+)/,
            // Shortened URL
            /(?:youtu\.be\/)([^&\n?#]+)/,
            // Embed URL
            /(?:youtube\.com\/embed\/)([^&\n?#]+)/,
            // v URL
            /(?:youtube\.com\/v\/)([^&\n?#]+)/,
            // Shorts URL - NEW
            /(?:youtube\.com\/shorts\/)([^&\n?#]+)/,
            // Live URL
            /(?:youtube\.com\/live\/)([^&\n?#]+)/,
            // Fallback pattern
            /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=|shorts\/|live\/)([^#&?]*).*/
        ];
        
        for (const regex of regexPatterns) {
            const match = url.match(regex);
            if (match && match[1] && match[1].length === 11) {
                return match[1];
            }
        }
        
        // Special handling for shorts URLs with parameters
        if (url.includes('youtube.com/shorts/')) {
            const shortsMatch = url.match(/youtube\.com\/shorts\/([^&\n?#]+)/);
            if (shortsMatch && shortsMatch[1]) {
                // Extract just the ID part (before any parameters)
                const id = shortsMatch[1].split('?')[0];
                if (id.length === 11) {
                    return id;
                }
            }
        }
        
        return Null;
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ff0000, #cc0000);
            border-radius: 4px;
            box-shadow: 0 0 10px #ff0000;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(255, 0, 0, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust iframe size based on fullscreen state
        if (this.iframe) {
            if (this.isFullscreen) {
                this.iframe.style.width = '98%';
                this.iframe.style.height = '95vh';
            } else {
                this.iframe.style.width = '90%';
                this.iframe.style.height = '70vh';
            }
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.iframe = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputContainer = null;
        this.videoId = null;
        
        botReply("YouTube Player closed. Thank you!");
    }
}

// Create a singleton instance
const youtubeScreenLoader = new YouTubeScreenLoader();

// Add this to your AI's command handling
if (/youtube|play youtube|watch youtube/i.test(userInputRaw)) {
    // Check if a URL was provided in the input
    const urlMatch = userInputRaw.match(/(https?:\/\/[^\s]+)/);
    if (urlMatch) {
        youtubeScreenLoader.loadYouTube(urlMatch[1]);
    } else {
        youtubeScreenLoader.loadYouTube();
    }
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    youtubeScreenLoader.closeGame();
    return;
}
class ScreenDrawloader {
    constructor() {
        console.log("ScreenDrawloader constructor initialized");
        
        this.drawBoard = {
            name: 'DRAW BOARD',
            instructions: 'Draw on the canvas using your mouse or touch. Save your artwork when done!'
        };
        
        this.gameContainer = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.isDrawing = false;
        this.currentColor = '#000000';
        this.currentSize = 5;
        this.isEraser = false;
        this.fileName = 'my-drawing';
        this.isTextMode = false;
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.currentRoomId = null;
        this.drawMode = 'normal';
        this.userSessionId = this.generateSessionId();
        this.currentUsername = '';
        this.strokesRef = null;
        this.strokesListener = null;
        this.currentStroke = null;
        this.isLiveMode = false;
        
        // Drawing synchronization
        this.remoteStrokes = [];
        this.canvasSizeRef = null;
        this.lastStrokeUpdate = 0;
        this.strokeUpdateInterval = 100; // ms between stroke updates
        
        // User management
        this.usersRef = null;
        this.usersListener = null;
        this.usersList = [];
        this.roomCreatorId = null;
        
        console.log("ScreenDrawloader constructor completed");
    }
    
    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'drawer_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Load the Draw Board
     */
    loadDrawBoard() {
        console.log("loadDrawBoard called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("Draw board already active");
                this.showNotification(`The ${this.drawBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("Draw board loaded successfully");
            this.showNotification(`${this.drawBoard.name} loaded! ${this.drawBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadDrawBoard:", error);
            this.showNotification("Sorry, there was an error loading the drawing board. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select Drawing Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Normal Draw Button
        const normalDrawBtn = document.createElement('button');
        normalDrawBtn.textContent = 'Normal Draw';
        normalDrawBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        normalDrawBtn.addEventListener('click', () => {
            this.drawMode = 'normal';
            this.isLiveMode = false;
            this.gameContainer.innerHTML = '';
            this.createDrawBoard();
        });
        modeContainer.appendChild(normalDrawBtn);
        
        // Live Draw Button
        const liveDrawBtn = document.createElement('button');
        liveDrawBtn.textContent = 'Live Draw';
        liveDrawBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        liveDrawBtn.addEventListener('click', () => {
            this.drawMode = 'live';
            this.isLiveMode = true;
            this.gameContainer.innerHTML = '';
            this.createLiveDrawSetup();
        });
        modeContainer.appendChild(liveDrawBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Live Draw Setup Screen
     */
    createLiveDrawSetup() {
        const setupContainer = document.createElement('div');
        setupContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Live Draw Setup';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        setupContainer.appendChild(title);
        
        // Username input
        const usernameContainer = document.createElement('div');
        usernameContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const usernameLabel = document.createElement('label');
        usernameLabel.textContent = 'Your Name:';
        usernameLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        `;
        usernameContainer.appendChild(usernameLabel);
        
        const usernameInput = document.createElement('input');
        usernameInput.type = 'text';
        usernameInput.placeholder = 'Enter your name';
        usernameInput.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        `;
        usernameContainer.appendChild(usernameInput);
        setupContainer.appendChild(usernameContainer);
        
        // Room ID input
        const roomContainer = document.createElement('div');
        roomContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const roomLabel = document.createElement('label');
        roomLabel.textContent = 'Room ID (leave empty to create new room):';
        roomLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        `;
        roomContainer.appendChild(roomLabel);
        
        const roomInput = document.createElement('input');
        roomInput.type = 'text';
        roomInput.placeholder = 'Enter room ID or leave empty';
        roomInput.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        `;
        roomContainer.appendChild(roomInput);
        setupContainer.appendChild(roomContainer);
        
        // Start Live Draw Button
        const startBtn = document.createElement('button');
        startBtn.textContent = 'Start Live Draw';
        startBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        startBtn.addEventListener('click', () => {
            const username = usernameInput.value.trim();
            if (!username) {
                this.showNotification('Please enter your name');
                return;
            }
            
            this.currentUsername = username;
            
            const roomId = roomInput.value.trim();
            if (roomId) {
                this.currentRoomId = roomId;
            } else {
                // Generate a new room ID
                this.currentRoomId = 'room_' + Date.now();
                this.roomCreatorId = this.userSessionId;
                this.showNotification(`New room created: ${this.currentRoomId}`);
            }
            
            // Initialize Firebase
            this.initializeFirebase(() => {
                this.gameContainer.innerHTML = '';
                this.createDrawBoard();
                this.setupLiveDrawing();
            });
        });
        setupContainer.appendChild(startBtn);
        
        this.gameContainer.appendChild(setupContainer);
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Setup Live Drawing
     */
    setupLiveDrawing() {
        if (!this.isFirebaseInitialized || !this.currentRoomId) return;
        
        // Create a reference to the strokes in this room
        this.strokesRef = this.db.ref(`drawings/${this.currentRoomId}/strokes`);
        
        // Create a reference for canvas size synchronization
        this.canvasSizeRef = this.db.ref(`drawings/${this.currentRoomId}/canvasSize`);
        
        // Create a reference for users in the room
        this.usersRef = this.db.ref(`drawings/${this.currentRoomId}/users`);
        
        // Add current user to the room
        this.addUserToRoom();
        
        // Synchronize canvas size
        this.syncCanvasSize();
        
        // Listen for new strokes
        this.strokesListener = this.strokesRef.on('child_added', (snapshot) => {
            const stroke = snapshot.val();
            if (stroke.userId !== this.userSessionId) {
                this.addRemoteStroke(stroke);
            }
        });
        
        // Listen for stroke updates
        this.strokesRef.on('child_changed', (snapshot) => {
            const stroke = snapshot.val();
            if (stroke.userId !== this.userSessionId) {
                this.updateRemoteStroke(stroke);
            }
        });
        
        // Listen for clear commands
        this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).on('value', (snapshot) => {
            const clearCommand = snapshot.val();
            if (clearCommand && clearCommand.userId !== this.userSessionId) {
                this.clearCanvas();
            }
        });
        
        // Listen for users in the room
        this.usersListener = this.usersRef.on('value', (snapshot) => {
            this.updateUsersList(snapshot.val());
        });
        
        // Show room info
        this.showRoomInfo();
        
        // Show users list
        this.showUsersList();
    }
    
    /**
     * Add user to the room
     */
    addUserToRoom() {
        if (!this.usersRef) return;
        
        const userData = {
            id: this.userSessionId,
            name: this.currentUsername,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isCreator: this.userSessionId === this.roomCreatorId
        };
        
        this.usersRef.child(this.userSessionId).set(userData);
        
        // If this is the first user, set as creator
        if (!this.roomCreatorId) {
            this.roomCreatorId = this.userSessionId;
            this.usersRef.child(this.userSessionId).update({ isCreator: true });
        }
    }
    
    /**
     * Update users list
     */
    updateUsersList(usersData) {
        if (!usersData) {
            this.usersList = [];
            this.updateUsersListUI();
            return;
        }
        
        this.usersList = Object.values(usersData);
        this.updateUsersListUI();
    }
    
    /**
     * Update users list UI
     */
    updateUsersListUI() {
        if (!this.usersListContainer) return;
        
        this.usersListContainer.innerHTML = '';
        
        if (this.usersList.length === 0) {
            this.usersListContainer.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">No users in room</div>';
            return;
        }
        
        this.usersList.forEach(user => {
            const userItem = document.createElement('div');
            userItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                margin-bottom: 5px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                font-size: 14px;
            `;
            
            const userInfo = document.createElement('div');
            userInfo.innerHTML = `
                <div style="font-weight: bold; color: ${user.id === this.userSessionId ? '#4CAF50' : '#333'};">
                    ${user.name} ${user.isCreator ? '(Creator)' : ''}
                </div>
                <div style="font-size: 12px; color: #666;">ID: ${user.id.substring(0, 8)}...</div>
            `;
            userItem.appendChild(userInfo);
            
            // Add delete button if current user is creator or deleting self
            if (this.userSessionId === this.roomCreatorId || user.id === this.userSessionId) {
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = user.id === this.userSessionId ? 'Leave' : 'Remove';
                deleteBtn.style.cssText = `
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    background: ${user.id === this.userSessionId ? '#ff9800' : '#f44336'};
                    color: white;
                    border: none;
                    cursor: pointer;
                `;
                deleteBtn.addEventListener('click', () => {
                    this.removeUserFromRoom(user.id);
                });
                userItem.appendChild(deleteBtn);
            }
            
            this.usersListContainer.appendChild(userItem);
        });
    }
    
    /**
     * Remove user from room
     */
    removeUserFromRoom(userId) {
        if (!this.usersRef) return;
        
        // Remove user from Firebase
        this.usersRef.child(userId).remove();
        
        // If removing self, close the game
        if (userId === this.userSessionId) {
            this.showNotification('You left the room');
            this.closeGame();
            return;
        }
        
        // Remove user's strokes
        if (this.strokesRef) {
            this.strokesRef.once('value', (snapshot) => {
                const strokes = snapshot.val();
                if (strokes) {
                    Object.entries(strokes).forEach(([strokeId, stroke]) => {
                        if (stroke.userId === userId) {
                            this.strokesRef.child(strokeId).remove();
                        }
                    });
                }
            });
        }
        
        this.showNotification('User removed from room');
    }
    
    /**
     * Show users list
     */
    showUsersList() {
        // Create users list container
        this.usersListContainer = document.createElement('div');
        
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
            // Mobile layout - position at bottom with less height
            this.usersListContainer.style.cssText = `
                position: fixed;
                bottom: 80px;
                right: 10px;
                width: calc(100% - 20px);
                max-height: 150px;
                overflow-y: auto;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                padding: 10px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                z-index: 9999;
            `;
        } else {
            // Desktop layout - position at top right
            this.usersListContainer.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                width: 250px;
                max-height: 300px;
                overflow-y: auto;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                z-index: 9999;
            `;
        }
        
        const title = document.createElement('h3');
        title.textContent = 'Users in Room';
        title.style.cssText = `
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            text-align: center;
        `;
        this.usersListContainer.appendChild(title);
        
        this.gameContainer.appendChild(this.usersListContainer);
        this.updateUsersListUI();
    }
    
    /**
     * Show room info
     */
    showRoomInfo() {
        const roomInfo = document.createElement('div');
        roomInfo.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            max-width: 80%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        `;
        roomInfo.textContent = `Room: ${this.currentRoomId}`;
        this.gameContainer.appendChild(roomInfo);
    }
    
    /**
     * Synchronize canvas size between users
     */
    syncCanvasSize() {
        // Send current canvas size
        this.canvasSizeRef.set({
            width: this.canvas.width,
            height: this.canvas.height,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        
        // Listen for canvas size changes
        this.canvasSizeRef.on('value', (snapshot) => {
            const canvasSize = snapshot.val();
            if (canvasSize && canvasSize.width && canvasSize.height) {
                // Adjust canvas if size is different
                if (this.canvas.width !== canvasSize.width || this.canvas.height !== canvasSize.height) {
                    this.canvas.width = canvasSize.width;
                    this.canvas.height = canvasSize.height;
                    console.log("Canvas size synchronized:", canvasSize);
                    this.redrawCanvas();
                }
            }
        });
    }
    
    /**
     * Create the Draw Board
     */
    createDrawBoard() {
        // Create canvas
        this.canvas = document.createElement('canvas');
        this.canvas.width = 800;
        this.canvas.height = 600;
        this.canvas.style.cssText = `
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        `;
        
        // Get context
        this.ctx = this.canvas.getContext('2d');
        
        // Create toolbar
        const toolbar = document.createElement('div');
        toolbar.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            flex-wrap: wrap;
        `;
        
        // Color picker
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = this.currentColor;
        colorPicker.style.cssText = `
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `;
        colorPicker.addEventListener('change', (e) => {
            this.currentColor = e.target.value;
            this.isEraser = false;
            this.isTextMode = false;
            // Update button states
            eraserBtn.style.background = '#f44336';
            textBtn.style.background = '#9c27b0';
        });
        toolbar.appendChild(colorPicker);
        
        // Brush size
        const sizeLabel = document.createElement('span');
        sizeLabel.textContent = 'Size:';
        sizeLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        toolbar.appendChild(sizeLabel);
        
        const sizeSlider = document.createElement('input');
        sizeSlider.type = 'range';
        sizeSlider.min = 1;
        sizeSlider.max = 50;
        sizeSlider.value = this.currentSize;
        sizeSlider.style.cssText = `
            width: 100px;
        `;
        sizeSlider.addEventListener('input', (e) => {
            this.currentSize = parseInt(e.target.value);
        });
        toolbar.appendChild(sizeSlider);
        
        // Eraser button
        const eraserBtn = document.createElement('button');
        eraserBtn.textContent = 'Eraser';
        eraserBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #f44336;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        eraserBtn.addEventListener('click', () => {
            this.isEraser = !this.isEraser;
            this.isTextMode = false;
            eraserBtn.style.background = this.isEraser ? '#d32f2f' : '#f44336';
            textBtn.style.background = '#9c27b0'; // Reset text button
        });
        toolbar.appendChild(eraserBtn);
        
        // Text button
        const textBtn = document.createElement('button');
        textBtn.textContent = 'Text';
        textBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #9c27b0;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        textBtn.addEventListener('click', () => {
            this.isTextMode = !this.isTextMode;
            this.isEraser = false;
            textBtn.style.background = this.isTextMode ? '#7b1fa2' : '#9c27b0';
            eraserBtn.style.background = '#f44336'; // Reset eraser button
        });
        toolbar.appendChild(textBtn);
        
        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear Drawing';
        clearBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #ff9800;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        clearBtn.addEventListener('click', () => {
            this.clearCanvas();
        });
        toolbar.appendChild(clearBtn);
        
        // Save button
        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save Drawing';
        saveBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        saveBtn.addEventListener('click', () => {
            this.saveDrawing();
        });
        toolbar.appendChild(saveBtn);
        
        // Add elements to container
        this.gameContainer.appendChild(toolbar);
        this.gameContainer.appendChild(this.canvas);
        
        // Set up drawing events
        this.setupDrawingEvents();
    }
    
    /**
     * Set up drawing events
     */
    setupDrawingEvents() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (this.isTextMode) {
                // Handle text mode
                this.handleTextMode(x, y);
                return;
            }
            
            this.isDrawing = true;
            
            if (this.isLiveMode) {
                this.startNewStroke(x, y);
            } else {
                this.startLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.isDrawing || this.isTextMode) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (this.isLiveMode) {
                this.updateCurrentStroke(x, y);
            } else {
                this.continueLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('mouseup', () => {
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
        
        this.canvas.addEventListener('mouseleave', () => {
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (this.isTextMode) {
                // Handle text mode
                this.handleTextMode(x, y);
                return;
            }
            
            this.isDrawing = true;
            
            if (this.isLiveMode) {
                this.startNewStroke(x, y);
            } else {
                this.startLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!this.isDrawing || this.isTextMode) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (this.isLiveMode) {
                this.updateCurrentStroke(x, y);
            } else {
                this.continueLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
    }
    
    /**
     * Handle text mode
     */
    handleTextMode(x, y) {
        const text = prompt('Enter text:');
        if (text) {
            this.drawText(text, x, y);
            
            // If in live mode, send text to Firebase
            if (this.isLiveMode && this.isFirebaseInitialized) {
                this.sendTextToFirebase(text, x, y);
            }
        }
    }
    
    /**
     * Draw text on canvas
     */
    drawText(text, x, y) {
        this.ctx.font = `${this.currentSize * 3}px Arial`;
        this.ctx.fillStyle = this.currentColor;
        this.ctx.fillText(text, x, y);
    }
    
    /**
     * Send text to Firebase
     */
    sendTextToFirebase(text, x, y) {
        const textId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
        
        const textData = {
            id: textId,
            userId: this.userSessionId,
            username: this.currentUsername,
            type: 'text',
            content: text,
            x: x,
            y: y,
            color: this.currentColor,
            size: this.currentSize,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.strokesRef.child(textId).set(textData);
    }
    
    /**
     * Start a new stroke and send it to Firebase
     */
    startNewStroke(x, y) {
        if (!this.isLiveMode || !this.isFirebaseInitialized) return;
        
        // Generate a unique ID for this stroke
        const strokeId = 'stroke_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
        
        // Create the stroke object
        this.currentStroke = {
            id: strokeId,
            userId: this.userSessionId,
            username: this.currentUsername,
            color: this.currentColor,
            size: this.currentSize,
            isEraser: this.isEraser,
            points: [{x, y}],
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isComplete: false
        };
        
        // Send to Firebase
        this.strokesRef.child(strokeId).set(this.currentStroke);
        
        // Draw locally
        this.startLocalDrawing(x, y);
    }
    
    /**
     * Update the current stroke with a new point and send to Firebase
     */
    updateCurrentStroke(x, y) {
        if (!this.isLiveMode || !this.isFirebaseInitialized || !this.currentStroke) return;
        
        // Add the new point
        this.currentStroke.points.push({x, y});
        
        // Throttle updates to avoid excessive Firebase writes
        const now = Date.now();
        if (now - this.lastStrokeUpdate > this.strokeUpdateInterval) {
            // Send to Firebase
            this.strokesRef.child(this.currentStroke.id).update({
                points: this.currentStroke.points,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            this.lastStrokeUpdate = now;
        }
        
        // Draw locally
        this.continueLocalDrawing(x, y);
    }
    
    /**
     * Finalize the current stroke and send to Firebase
     */
    finalizeCurrentStroke() {
        if (!this.isLiveMode || !this.isFirebaseInitialized || !this.currentStroke) return;
        
        // Mark as complete
        this.currentStroke.isComplete = true;
        
        // Send to Firebase
        this.strokesRef.child(this.currentStroke.id).update({
            isComplete: true,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        
        // End local drawing
        this.endLocalDrawing();
        
        // Reset current stroke
        this.currentStroke = null;
    }
    
    /**
     * Start local drawing (non-live mode)
     */
    startLocalDrawing(x, y) {
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineJoin = 'round';
        this.ctx.lineCap = 'round';
        
        if (this.isEraser) {
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.lineWidth = this.currentSize * 2;
        } else {
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.strokeStyle = this.currentColor;
            this.ctx.lineWidth = this.currentSize;
        }
    }
    
    /**
     * Continue local drawing (non-live mode)
     */
    continueLocalDrawing(x, y) {
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }
    
    /**
     * End local drawing (non-live mode)
     */
    endLocalDrawing() {
        this.ctx.closePath();
        this.ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
    }
    
    /**
     * Add a remote stroke to the canvas
     */
    addRemoteStroke(stroke) {
        if (!stroke) return;
        
        // Add to remote strokes array
        this.remoteStrokes.push(stroke);
        
        // Handle different types of remote data
        if (stroke.type === 'text') {
            // Draw text
            this.drawText(stroke.content, stroke.x, stroke.y);
        } else {
            // Draw stroke
            this.drawStroke(stroke);
        }
    }
    
    /**
     * Update a remote stroke on the canvas
     */
    updateRemoteStroke(stroke) {
        if (!stroke) return;
        
        // Find and update the stroke in the remote strokes array
        const index = this.remoteStrokes.findIndex(s => s.id === stroke.id);
        if (index !== -1) {
            this.remoteStrokes[index] = stroke;
        } else {
            this.remoteStrokes.push(stroke);
        }
        
        // Redraw the canvas
        this.redrawCanvas();
    }
    
    /**
     * Draw a stroke on the canvas
     */
    drawStroke(stroke) {
        if (!stroke || !stroke.points || stroke.points.length === 0) return;
        
        this.ctx.beginPath();
        this.ctx.lineJoin = 'round';
        this.ctx.lineCap = 'round';
        
        // Set the drawing style
        if (stroke.isEraser) {
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.lineWidth = stroke.size * 2;
        } else {
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.strokeStyle = stroke.color;
            this.ctx.lineWidth = stroke.size;
        }
        
        // Draw the stroke
        this.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
            this.ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        }
        
        this.ctx.stroke();
        this.ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
    }
    
    /**
     * Redraw the entire canvas
     */
    redrawCanvas() {
        if (!this.canvas || !this.ctx) return;
        
        // Clear the canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Redraw all remote strokes and text
        this.remoteStrokes.forEach(item => {
            if (item.type === 'text') {
                // Draw text
                this.drawText(item.content, item.x, item.y);
            } else {
                // Draw stroke
                this.drawStroke(item);
            }
        });
    }
    
    /**
     * Clear the canvas and notify other users in live mode
     */
    clearCanvas() {
        // Clear the local canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Clear remote strokes
        this.remoteStrokes = [];
        
        // In live mode, send clear command to Firebase
        if (this.isLiveMode && this.isFirebaseInitialized) {
            this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).set({
                userId: this.userSessionId,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            
            // Remove the clear command after a delay
            setTimeout(() => {
                this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).remove();
            }, 1000);
        }
    }
    
    /**
     * Save the drawing
     */
    saveDrawing() {
        const link = document.createElement('a');
        link.download = `${this.fileName}.png`;
        link.href = this.canvas.toDataURL();
        link.click();
        this.showNotification('Drawing saved!');
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase
        if (this.isLiveMode && this.isFirebaseInitialized) {
            this.cleanupFirebase();
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.canvas = null;
        this.ctx = null;
        this.remoteStrokes = [];
        this.isTextMode = false;
        
        console.log("Draw board closed");
    }
    
    /**
     * Clean up Firebase listeners
     */
    cleanupFirebase() {
        if (this.strokesListener) {
            this.strokesRef.off('child_added', this.strokesListener);
            this.strokesRef.off('child_changed', this.strokesListener);
            this.strokesListener = null;
        }
        
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.canvasSizeRef) {
            this.canvasSizeRef.off();
            this.canvasSizeRef = null;
        }
        
        // Remove user from room
        if (this.usersRef && this.userSessionId) {
            this.usersRef.child(this.userSessionId).remove();
        }
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let screendrawloader = null;
// Function to get or create the draw board instance
function getDrawBoard() {
    if (!screendrawloader) {
        console.log("Creating new ScreenDrawloader instance");
        screendrawloader = new ScreenDrawloader();
    }
    return screendrawloader;
}
// Command handler
function handleDrawCommand(input) {
    if (typeof input !== 'string') return false;
    
    const drawKeywords = ['draw', 'draw board', 'drawing', 'sketch', 'paint', 'canvas'];
    const normalizedInput = input.toLowerCase().trim();
    
    return drawKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute draw command
function executeDrawCommand() {
    try {
        const drawBoard = getDrawBoard();
        if (drawBoard && typeof drawBoard.loadDrawBoard === 'function') {
            console.log("Executing draw command");
            drawBoard.loadDrawBoard();
        } else {
            console.error("Invalid draw board instance");
            botReply("Sorry, the drawing board is not available right now.");
        }
    } catch (error) {
        console.error("Error executing draw command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleDrawCommand(userInputRaw)) {
    console.log("Draw command detected");
    executeDrawCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen/i.test(userInputRaw)) {
    if (screendrawloader && screendrawloader.isActive) {
        screendrawloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the draw board manually (call from browser console)
window.testDrawBoard = function() {
    console.log("Testing draw board...");
    executeDrawCommand();
};
// Add this to check if the draw board is loaded
window.checkDrawBoard = function() {
    console.log("screendrawloader exists:", !!screendrawloader);
    console.log("screendrawloader type:", typeof screendrawloader);
    console.log("ScreenDrawloader class exists:", typeof ScreenDrawloader);
};

class RingSizeCalculator {
    constructor() {
        console.log("RingSizeCalculator constructor initialized");
        
        this.calculator = {
            name: 'RING SIZE CALCULATOR',
            instructions: 'Measure your finger or existing ring to determine your ring size!'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.selectedMethod = 'diameter'; // Default measurement method
        this.currentDiameter = 16; // Starting diameter in mm (typical ring size)
        this.canvas = null;
        this.ctx = null;
        
        // Ring size data
        this.ringSizes = {
            US: [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.5, 13, 13.5, 14, 14.5, 15, 15.5, 16],
            UK: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
            EU: [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67]
        };
        
        console.log("RingSizeCalculator constructor completed");
    }
    
    /**
     * Load the Ring Size Calculator
     */
    loadCalculator() {
        console.log("loadCalculator called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("Ring size calculator already active");
                this.showNotification(`The ${this.calculator.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create calculator interface
            this.createCalculatorInterface();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the calculator
            this.displayGame();
            
            this.isActive = true;
            console.log("Ring size calculator loaded successfully");
            this.showNotification(`${this.calculator.name} loaded! ${this.calculator.instructions}`);
        } catch (error) {
            console.error("Error in loadCalculator:", error);
            this.showNotification("Sorry, there was an error loading the ring size calculator. Please try again.");
        }
    }
    
    /**
     * Create Calculator Interface
     */
    createCalculatorInterface() {
        const calculatorContainer = document.createElement('div');
        calculatorContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 600px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Ring Size Calculator';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        calculatorContainer.appendChild(title);
        
        // Method selection
        const methodContainer = document.createElement('div');
        methodContainer.style.cssText = `
            margin-bottom: 25px;
            text-align: center;
        `;
        
        const methodLabel = document.createElement('label');
        methodLabel.textContent = 'Measurement Method:';
        methodLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
            font-size: 18px;
        `;
        methodContainer.appendChild(methodLabel);
        
        const methodButtonsContainer = document.createElement('div');
        methodButtonsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
        `;
        
        // Diameter button
        const diameterBtn = document.createElement('button');
        diameterBtn.textContent = 'Diameter';
        diameterBtn.style.cssText = `
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: ${this.selectedMethod === 'diameter' ? '#4CAF50' : '#e0e0e0'};
            color: ${this.selectedMethod === 'diameter' ? 'white' : '#333'};
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        `;
        diameterBtn.addEventListener('click', () => {
            this.selectedMethod = 'diameter';
            this.updateMethodButtons();
            this.updateInputFields();
            this.showVisualRingFinder();
        });
        methodButtonsContainer.appendChild(diameterBtn);
        
        // Circumference button
        const circumferenceBtn = document.createElement('button');
        circumferenceBtn.textContent = 'Circumference';
        circumferenceBtn.style.cssText = `
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: ${this.selectedMethod === 'circumference' ? '#4CAF50' : '#e0e0e0'};
            color: ${this.selectedMethod === 'circumference' ? 'white' : '#333'};
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        `;
        circumferenceBtn.addEventListener('click', () => {
            this.selectedMethod = 'circumference';
            this.updateMethodButtons();
            this.updateInputFields();
            this.hideVisualRingFinder();
        });
        methodButtonsContainer.appendChild(circumferenceBtn);
        
        methodContainer.appendChild(methodButtonsContainer);
        calculatorContainer.appendChild(methodContainer);
        
        // Visual Ring Finder
        this.visualRingFinderContainer = document.createElement('div');
        this.visualRingFinderContainer.style.cssText = `
            margin-bottom: 25px;
            display: ${this.selectedMethod === 'diameter' ? 'block' : 'none'};
        `;
        this.createVisualRingFinder();
        calculatorContainer.appendChild(this.visualRingFinderContainer);
        
        // Input fields container
        this.inputContainer = document.createElement('div');
        this.inputContainer.style.cssText = `
            margin-bottom: 25px;
        `;
        
        // Create input fields based on selected method
        this.updateInputFields();
        calculatorContainer.appendChild(this.inputContainer);
        
        // Calculate button
        const calculateBtn = document.createElement('button');
        calculateBtn.textContent = 'Calculate Ring Size';
        calculateBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        `;
        calculateBtn.addEventListener('click', () => {
            this.calculateRingSize();
        });
        calculatorContainer.appendChild(calculateBtn);
        
        // Results container
        this.resultsContainer = document.createElement('div');
        this.resultsContainer.style.cssText = `
            margin-top: 20px;
            padding: 20px;
            background: rgba(33, 150, 243, 0.1);
            border-radius: 15px;
            display: none;
        `;
        calculatorContainer.appendChild(this.resultsContainer);
        
        // Ring size guide
        const guideContainer = document.createElement('div');
        guideContainer.style.cssText = `
            margin-top: 30px;
            text-align: left;
        `;
        
        const guideTitle = document.createElement('h3');
        guideTitle.textContent = 'How to Measure:';
        guideTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #333;
            text-align: center;
        `;
        guideContainer.appendChild(guideTitle);
        
        const guideList = document.createElement('ul');
        guideList.style.cssText = `
            padding-left: 20px;
            margin: 0;
        `;
        
        const guideItems = [
            'Use a string or paper strip to wrap around your finger',
            'Mark where the end meets',
            'Measure the length with a ruler (this is the circumference)',
            'Alternatively, measure the inside diameter of an existing ring',
            'Enter the measurement in millimeters (mm)',
            'Or use the visual ring size finder below to adjust to your ring size'
        ];
        
        guideItems.forEach(item => {
            const li = document.createElement('li');
            li.textContent = item;
            li.style.cssText = `
                margin-bottom: 8px;
                font-size: 16px;
                color: #555;
            `;
            guideList.appendChild(li);
        });
        
        guideContainer.appendChild(guideList);
        calculatorContainer.appendChild(guideContainer);
        
        this.gameContainer.appendChild(calculatorContainer);
    }
    
    /**
     * Create Visual Ring Finder
     */
    createVisualRingFinder() {
        const visualFinderTitle = document.createElement('h3');
        visualFinderTitle.textContent = 'Visual Ring Size Finder';
        visualFinderTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #333;
        `;
        this.visualRingFinderContainer.appendChild(visualFinderTitle);
        
        // Canvas for drawing the ring
        this.canvas = document.createElement('canvas');
        this.canvas.width = 300;
        this.canvas.height = 300;
        this.canvas.style.cssText = `
            border: 1px solid #ddd;
            border-radius: 10px;
            background: white;
            margin: 0 auto 15px;
            display: block;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        `;
        this.visualRingFinderContainer.appendChild(this.canvas);
        
        // Get canvas context
        this.ctx = this.canvas.getContext('2d');
        
        // Slider container
        const sliderContainer = document.createElement('div');
        sliderContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        
        // Size display
        this.sizeDisplay = document.createElement('div');
        this.sizeDisplay.textContent = `${this.currentDiameter} mm`;
        this.sizeDisplay.style.cssText = `
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        `;
        sliderContainer.appendChild(this.sizeDisplay);
        
        // Slider
        this.sizeSlider = document.createElement('input');
        this.sizeSlider.type = 'range';
        this.sizeSlider.min = '10';
        this.sizeSlider.max = '30';
        this.sizeSlider.step = '0.5';
        this.sizeSlider.value = this.currentDiameter;
        this.sizeSlider.style.cssText = `
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        `;
        
        // Style the slider thumb
        const style = document.createElement('style');
        style.textContent = `
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #2196F3;
                cursor: pointer;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #2196F3;
                cursor: pointer;
            }
        `;
        document.head.appendChild(style);
        
        this.sizeSlider.addEventListener('input', (e) => {
            this.currentDiameter = parseFloat(e.target.value);
            this.drawRing();
        });
        
        sliderContainer.appendChild(this.sizeSlider);
        this.visualRingFinderContainer.appendChild(sliderContainer);
        
        // Use this size button
        const useSizeBtn = document.createElement('button');
        useSizeBtn.textContent = 'Use This Size';
        useSizeBtn.style.cssText = `
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: #2196F3;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        `;
        useSizeBtn.addEventListener('click', () => {
            this.useVisualSize();
        });
        this.visualRingFinderContainer.appendChild(useSizeBtn);
        
        // Initial draw
        this.drawRing();
    }
    
    /**
     * Draw the ring on canvas
     */
    drawRing() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const radius = this.currentDiameter * 5; // Scale factor for visibility
        
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw outer circle (ring)
        this.ctx.beginPath();
        this.ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        this.ctx.strokeStyle = '#2196F3';
        this.ctx.lineWidth = 3;
        this.ctx.stroke();
        
        // Draw diameter line (only one line in the center)
        this.ctx.beginPath();
        this.ctx.moveTo(centerX - radius, centerY);
        this.ctx.lineTo(centerX + radius, centerY);
        this.ctx.strokeStyle = '#f44336';
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        
        // Draw diameter label
        this.ctx.fillStyle = '#f44336';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(`${this.currentDiameter} mm`, centerX, centerY + radius + 20);
        
        // Update size display
        this.sizeDisplay.textContent = `${this.currentDiameter} mm`;
    }
    
    /**
     * Use the visual size for calculation
     */
    useVisualSize() {
        // Update the input field with the current diameter
        const inputElement = document.getElementById('measurement-input');
        if (inputElement) {
            inputElement.value = this.currentDiameter;
            this.showNotification(`Size set to ${this.currentDiameter} mm. Click 'Calculate Ring Size' to see results.`);
        }
    }
    
    /**
     * Show visual ring finder
     */
    showVisualRingFinder() {
        this.visualRingFinderContainer.style.display = 'block';
    }
    
    /**
     * Hide visual ring finder
     */
    hideVisualRingFinder() {
        this.visualRingFinderContainer.style.display = 'none';
    }
    
    /**
     * Update method buttons appearance
     */
    updateMethodButtons() {
        const buttons = this.gameContainer.querySelectorAll('button');
        buttons.forEach(btn => {
            if (btn.textContent === 'Diameter') {
                btn.style.background = this.selectedMethod === 'diameter' ? '#4CAF50' : '#e0e0e0';
                btn.style.color = this.selectedMethod === 'diameter' ? 'white' : '#333';
            } else if (btn.textContent === 'Circumference') {
                btn.style.background = this.selectedMethod === 'circumference' ? '#4CAF50' : '#e0e0e0';
                btn.style.color = this.selectedMethod === 'circumference' ? 'white' : '#333';
            }
        });
    }
    
    /**
     * Update input fields based on selected method
     */
    updateInputFields() {
        this.inputContainer.innerHTML = '';
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = `Enter ${this.selectedMethod === 'diameter' ? 'Diameter' : 'Circumference'} (mm):`;
        inputLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
            font-size: 18px;
        `;
        this.inputContainer.appendChild(inputLabel);
        
        const inputField = document.createElement('input');
        inputField.type = 'number';
        inputField.placeholder = `Enter ${this.selectedMethod === 'diameter' ? 'diameter' : 'circumference'} in mm`;
        inputField.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
            text-align: center;
        `;
        inputField.id = 'measurement-input';
        this.inputContainer.appendChild(inputField);
        
        // Add visual guide image placeholder
        const guideImage = document.createElement('div');
        guideImage.style.cssText = `
            margin-top: 15px;
            height: 120px;
            background: #f5f5f5;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #777;
            font-style: italic;
        `;
        guideImage.textContent = 'Measurement Guide Image';
        this.inputContainer.appendChild(guideImage);
    }
    
    /**
     * Calculate ring size based on input
     */
    calculateRingSize() {
        const inputElement = document.getElementById('measurement-input');
        const measurement = parseFloat(inputElement.value);
        
        if (isNaN(measurement) || measurement <= 0) {
            this.showNotification('Please enter a valid measurement in millimeters');
            return;
        }
        
        let diameter;
        if (this.selectedMethod === 'diameter') {
            diameter = measurement;
        } else {
            // Convert circumference to diameter
            diameter = measurement / Math.PI;
        }
        
        // Calculate US ring size
        const usSize = (diameter - 10.5) / 0.8128;
        
        // Find closest sizes
        const closestUS = this.findClosestSize(usSize, this.ringSizes.US);
        const closestUK = this.findClosestUKSize(usSize);
        const closestEU = this.findClosestSize(usSize * 2.54, this.ringSizes.EU);
        
        // Display results
        this.displayResults(closestUS, closestUK, closestEU, diameter);
    }
    
    /**
     * Find closest size in a numeric array
     */
    findClosestSize(value, sizeArray) {
        let closest = sizeArray[0];
        let minDiff = Math.abs(value - closest);
        
        for (let i = 1; i < sizeArray.length; i++) {
            const diff = Math.abs(value - sizeArray[i]);
            if (diff < minDiff) {
                minDiff = diff;
                closest = sizeArray[i];
            }
        }
        
        return closest;
    }
    
    /**
     * Find closest UK size
     */
    findClosestUKSize(usSize) {
        // Convert US size to UK size
        const ukSizeValue = (usSize - 1) * 0.5;
        
        // Find closest letter
        const index = Math.round(ukSizeValue);
        if (index >= 0 && index < this.ringSizes.UK.length) {
            return this.ringSizes.UK[index];
        }
        
        return this.ringSizes.UK[0];
    }
    
    /**
     * Display calculation results
     */
    displayResults(usSize, ukSize, euSize, diameter) {
        this.resultsContainer.innerHTML = '';
        this.resultsContainer.style.display = 'block';
        
        const resultsTitle = document.createElement('h3');
        resultsTitle.textContent = 'Your Ring Size:';
        resultsTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #333;
            text-align: center;
        `;
        this.resultsContainer.appendChild(resultsTitle);
        
        const resultsGrid = document.createElement('div');
        resultsGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        // US size
        const usContainer = this.createSizeResult('US', usSize);
        resultsGrid.appendChild(usContainer);
        
        // UK size
        const ukContainer = this.createSizeResult('UK', ukSize);
        resultsGrid.appendChild(ukContainer);
        
        // EU size
        const euContainer = this.createSizeResult('EU', euSize);
        resultsGrid.appendChild(euContainer);
        
        this.resultsContainer.appendChild(resultsGrid);
        
        // Diameter info
        const diameterInfo = document.createElement('div');
        diameterInfo.style.cssText = `
            margin-top: 15px;
            font-size: 16px;
            color: #555;
            text-align: center;
        `;
        diameterInfo.textContent = `Measured diameter: ${diameter.toFixed(2)} mm`;
        this.resultsContainer.appendChild(diameterInfo);
        
        // Note about sizing
        const note = document.createElement('div');
        note.style.cssText = `
            margin-top: 15px;
            font-size: 14px;
            color: #777;
            font-style: italic;
            text-align: center;
        `;
        note.textContent = 'Note: Ring sizes may vary slightly between brands and countries. For best results, visit a jeweler for professional sizing.';
        this.resultsContainer.appendChild(note);
    }
    
    /**
     * Create a size result element
     */
    createSizeResult(region, size) {
        const container = document.createElement('div');
        container.style.cssText = `
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
        `;
        
        const regionLabel = document.createElement('div');
        regionLabel.textContent = region;
        regionLabel.style.cssText = `
            font-weight: bold;
            color: #555;
            margin-bottom: 5px;
        `;
        container.appendChild(regionLabel);
        
        const sizeValue = document.createElement('div');
        sizeValue.textContent = size;
        sizeValue.style.cssText = `
            font-size: 24px;
            font-weight: bold;
            color: #2196F3;
        `;
        container.appendChild(sizeValue);
        
        return container;
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeCalculator();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the calculator
     */
    closeCalculator() {
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        
        console.log("Ring size calculator closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10002;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Auto-remove notification after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
}

// Command handler
function handleRingSizeCommand(input) {
    if (typeof input !== 'string') return false;
    
    const ringSizeKeywords = [
        'ring size', 'ring size calculator', 'ring calculator', 
        'measure ring', 'ring measurement', 'find ring size',
        'ring sizer', 'finger size', 'ring sizing'
    ];
    const normalizedInput = input.toLowerCase().trim();
    
    return ringSizeKeywords.some(keyword => normalizedInput.includes(keyword));
}

// Execute ring size command
function executeRingSizeCommand() {
    try {
        // Create a global instance if it doesn't exist
        if (!window.ringSizeCalculator) {
            window.ringSizeCalculator = new RingSizeCalculator();
        }
        
        const ringSizeCalc = window.ringSizeCalculator;
        if (ringSizeCalc && typeof ringSizeCalc.loadCalculator === 'function') {
            console.log("Executing ring size calculator command");
            ringSizeCalc.loadCalculator();
        } else {
            console.error("Invalid ring size calculator instance");
            botReply("Sorry, the ring size calculator is not available right now.");
        }
    } catch (error) {
        console.error("Error executing ring size calculator command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}

// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleRingSizeCommand(userInputRaw)) {
    console.log("Ring size calculator command detected");
    executeRingSizeCommand();
    return;
}

// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen/i.test(userInputRaw)) {
    if (window.ringSizeCalculator && window.ringSizeCalculator.isActive) {
        window.ringSizeCalculator.closeCalculator();
        return;
    }
}

// ===== DEBUGGING HELPERS =====
// Add this to test the ring size calculator manually (call from browser console)
window.testRingSizeCalculator = function() {
    console.log("Testing ring size calculator...");
    executeRingSizeCommand();
};

// Add this to check if the ring size calculator is loaded
window.checkRingSizeCalculator = function() {
    console.log("ringSizeCalculator exists:", !!window.ringSizeCalculator);
    console.log("ringSizeCalculator type:", typeof window.ringSizeCalculator);
    console.log("RingSizeCalculator class exists:", typeof RingSizeCalculator);
};





class LoadHtmlScreenLoader {
    constructor() {
        console.log("LoadHtmlScreenLoader constructor initialized");
        
        this.htmlBoard = {
            name: 'HTML SCREEN',
            instructions: 'Admin: Load HTML code to display. Users: View the loaded HTML content.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.isAdmin = false; // Default to user mode
        this.htmlContent = '';
        this.currentHtmlId = null;
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.htmlRef = null;
        this.htmlListener = null;
        
        console.log("LoadHtmlScreenLoader constructor completed");
    }
    
    /**
     * Load the HTML Screen
     */
    loadHtmlScreen() {
        console.log("loadHtmlScreen called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("HTML screen already active");
                this.showNotification(`The ${this.htmlBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("HTML screen loaded successfully");
            this.showNotification(`${this.htmlBoard.name} loaded! ${this.htmlBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadHtmlScreen:", error);
            this.showNotification("Sorry, there was an error loading the HTML screen. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select HTML Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Admin Mode Button
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'Admin Mode';
        adminBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        adminBtn.addEventListener('click', () => {
            this.isAdmin = true;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createAdminInterface();
            });
        });
        modeContainer.appendChild(adminBtn);
        
        // User Mode Button
        const userBtn = document.createElement('button');
        userBtn.textContent = 'User Mode';
        userBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        userBtn.addEventListener('click', () => {
            this.isAdmin = false;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createUserInterface();
            });
        });
        modeContainer.appendChild(userBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Admin Interface
     */
    createAdminInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'HTML Admin Panel';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create textarea for HTML input
        const textareaContainer = document.createElement('div');
        textareaContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            margin-bottom: 20px;
        `;
        
        const textareaLabel = document.createElement('label');
        textareaLabel.textContent = 'Enter HTML Code:';
        textareaLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
            color: white;
            font-weight: bold;
        `;
        textareaContainer.appendChild(textareaLabel);
        
        const textarea = document.createElement('textarea');
        textarea.id = 'htmlTextarea';
        textarea.placeholder = 'Enter your HTML code here...';
        textarea.style.cssText = `
            width: 100%;
            height: 300px;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        `;
        textareaContainer.appendChild(textarea);
        this.gameContainer.appendChild(textareaContainer);
        
        // Create buttons container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        `;
        
        // Load HTML button
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load HTML';
        loadBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        loadBtn.addEventListener('click', () => {
            const textarea = document.getElementById('htmlTextarea');
            this.htmlContent = textarea.value;
            this.saveHtmlToFirebase();
            this.showNotification('HTML code saved successfully!');
        });
        buttonsContainer.appendChild(loadBtn);
        
        // Preview button
        const previewBtn = document.createElement('button');
        previewBtn.textContent = 'Preview';
        previewBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        previewBtn.addEventListener('click', () => {
            const textarea = document.getElementById('htmlTextarea');
            this.htmlContent = textarea.value;
            this.showHtmlPreview();
        });
        buttonsContainer.appendChild(previewBtn);
        
        // Share Code button
        const shareBtn = document.createElement('button');
        shareBtn.textContent = 'Share Code';
        shareBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #9c27b0, #7b1fa2);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        shareBtn.addEventListener('click', () => {
            this.shareHtmlCode();
        });
        buttonsContainer.appendChild(shareBtn);
        
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        deleteBtn.addEventListener('click', () => {
            this.deleteHtmlContent();
        });
        buttonsContainer.appendChild(deleteBtn);
        
        // Back to Mode Selection button
        const backBtn = document.createElement('button');
        backBtn.textContent = 'Back to Mode Selection';
        backBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #607D8B, #455A64);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        backBtn.addEventListener('click', () => {
            this.backToModeSelection();
        });
        buttonsContainer.appendChild(backBtn);
        
        this.gameContainer.appendChild(buttonsContainer);
        
        // Create preview container
        const previewContainer = document.createElement('div');
        previewContainer.id = 'htmlPreview';
        previewContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            height: 400px;
            border: 2px dashed #ccc;
            border-radius: 10px;
            overflow: auto;
            background: white;
            margin-bottom: 20px;
            display: none;
        `;
        this.gameContainer.appendChild(previewContainer);
        
        // Load existing HTML content if available
        this.loadHtmlFromFirebase((html) => {
            if (html) {
                const textarea = document.getElementById('htmlTextarea');
                textarea.value = html;
            }
        });
    }
    
    /**
     * Create User Interface
     */
    createUserInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'HTML Viewer';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create status message
        const statusMessage = document.createElement('div');
        statusMessage.id = 'statusMessage';
        statusMessage.textContent = 'Loading HTML content...';
        statusMessage.style.cssText = `
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
        `;
        this.gameContainer.appendChild(statusMessage);
        
        // Create HTML container
        const htmlContainer = document.createElement('div');
        htmlContainer.id = 'htmlContainer';
        htmlContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            min-height: 500px;
            border: none;
            border-radius: 10px;
            overflow: auto;
            background: white;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        this.gameContainer.appendChild(htmlContainer);
        
        // Load HTML from Firebase
        this.loadHtmlFromFirebase((html) => {
            if (html) {
                statusMessage.textContent = 'HTML Content Loaded';
                this.displayHtmlContent(html);
            } else {
                statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
                this.clearHtmlContent();
            }
        });
        
        // Set up listener for HTML updates
        this.setupHtmlListener();
    }
    
    /**
     * Go back to mode selection screen
     */
    backToModeSelection() {
        // Clean up Firebase listeners
        if (this.htmlListener) {
            this.htmlRef.off('value', this.htmlListener);
            this.htmlListener = null;
        }
        
        // Clear the container
        this.gameContainer.innerHTML = '';
        
        // Reset mode
        this.isAdmin = false;
        
        // Create mode selection screen
        this.createModeSelectionScreen();
    }
    
    /**
     * Show HTML Preview (for admin)
     */
    showHtmlPreview() {
        const previewContainer = document.getElementById('htmlPreview');
        if (previewContainer) {
            previewContainer.style.display = 'block';
            previewContainer.innerHTML = this.htmlContent;
        }
    }
    
    /**
     * Display HTML Content (for user)
     */
    displayHtmlContent(html) {
        const htmlContainer = document.getElementById('htmlContainer');
        if (htmlContainer) {
            htmlContainer.innerHTML = html;
        }
    }
    
    /**
     * Clear HTML Content (for user)
     */
    clearHtmlContent() {
        const htmlContainer = document.getElementById('htmlContainer');
        const statusMessage = document.getElementById('statusMessage');
        
        if (htmlContainer) {
            htmlContainer.innerHTML = '';
            htmlContainer.style.minHeight = '500px';
            htmlContainer.style.display = 'flex';
            htmlContainer.style.justifyContent = 'center';
            htmlContainer.style.alignItems = 'center';
            htmlContainer.innerHTML = '<div style="color: #999; font-size: 18px; text-align: center;">No HTML content available</div>';
        }
        
        if (statusMessage) {
            statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
        }
    }
    
    /**
     * Share HTML Code (copy to clipboard)
     */
    shareHtmlCode() {
        const textarea = document.getElementById('htmlTextarea');
        const htmlCode = textarea.value;
        
        if (!htmlCode.trim()) {
            this.showNotification('No HTML code to share!');
            return;
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(htmlCode).then(() => {
            this.showNotification('HTML code copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy HTML code.');
        });
    }
    
    /**
     * Delete HTML Content
     */
    deleteHtmlContent() {
        // Confirm deletion
        const confirmDelete = confirm('Are you sure you want to delete the HTML content? This will clear it for all users.');
        if (!confirmDelete) return;
        
        // Clear textarea
        const textarea = document.getElementById('htmlTextarea');
        textarea.value = '';
        
        // Clear preview
        const previewContainer = document.getElementById('htmlPreview');
        if (previewContainer) {
            previewContainer.style.display = 'none';
            previewContainer.innerHTML = '';
        }
        
        // Clear Firebase
        this.htmlContent = '';
        this.saveHtmlToFirebase();
        this.showNotification('HTML content deleted successfully!');
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            this.htmlRef = this.db.ref('htmlContent/currentHtml');
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Save HTML to Firebase
     */
    saveHtmlToFirebase() {
        if (!this.isFirebaseInitialized) return;
        
        const htmlData = {
            content: this.htmlContent,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            updatedBy: this.isAdmin ? 'admin' : 'user'
        };
        
        this.htmlRef.set(htmlData);
    }
    
    /**
     * Load HTML from Firebase
     */
    loadHtmlFromFirebase(callback) {
        if (!this.isFirebaseInitialized) return;
        
        this.htmlRef.once('value', (snapshot) => {
            const data = snapshot.val();
            if (data && data.content) {
                callback(data.content);
            } else {
                callback(null);
            }
        });
    }
    
    /**
     * Setup HTML listener for real-time updates
     */
    setupHtmlListener() {
        if (!this.isFirebaseInitialized || !this.htmlRef) return;
        
        this.htmlListener = this.htmlRef.on('value', (snapshot) => {
            const data = snapshot.val();
            const statusMessage = document.getElementById('statusMessage');
            
            if (data && data.content && !this.isAdmin) {
                statusMessage.textContent = 'HTML Content Loaded';
                this.displayHtmlContent(data.content);
            } else if (!data || !data.content) {
                // HTML content was deleted
                statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
                this.clearHtmlContent();
            }
        });
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button (main button)
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 12px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
            transition: all 0.3s ease;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.closeButton.addEventListener('mouseenter', () => {
            this.closeButton.style.background = '#d32f2f';
            this.closeButton.style.transform = 'scale(1.05)';
        });
        this.closeButton.addEventListener('mouseleave', () => {
            this.closeButton.style.background = '#f44336';
            this.closeButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase listeners
        if (this.htmlListener) {
            this.htmlRef.off('value', this.htmlListener);
            this.htmlListener = null;
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.isAdmin = false;
        this.htmlContent = '';
        
        console.log("HTML screen closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let loadhtmlscreenloader = null;
// Function to get or create the HTML screen instance
function getHtmlScreen() {
    if (!loadhtmlscreenloader) {
        console.log("Creating new LoadHtmlScreenLoader instance");
        loadhtmlscreenloader = new LoadHtmlScreenLoader();
    }
    return loadhtmlscreenloader;
}
// Command handler
function handleHtmlCommand(input) {
    if (typeof input !== 'string') return false;
    
    const htmlKeywords = ['html', 'html screen', 'html viewer', 'html loader', 'html admin'];
    const normalizedInput = input.toLowerCase().trim();
    
    return htmlKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute HTML command
function executeHtmlCommand() {
    try {
        const htmlScreen = getHtmlScreen();
        if (htmlScreen && typeof htmlScreen.loadHtmlScreen === 'function') {
            console.log("Executing HTML command");
            htmlScreen.loadHtmlScreen();
        } else {
            console.error("Invalid HTML screen instance");
            botReply("Sorry, the HTML screen is not available right now.");
        }
    } catch (error) {
        console.error("Error executing HTML command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleHtmlCommand(userInputRaw)) {
    console.log("HTML command detected");
    executeHtmlCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen|cancel/i.test(userInputRaw)) {
    if (loadhtmlscreenloader && loadhtmlscreenloader.isActive) {
        loadhtmlscreenloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the HTML screen manually (call from browser console)
window.testHtmlScreen = function() {
    console.log("Testing HTML screen...");
    executeHtmlCommand();
};
// Add this to check if the HTML screen is loaded
window.checkHtmlScreen = function() {
    console.log("loadhtmlscreenloader exists:", !!loadhtmlscreenloader);
    console.log("loadhtmlscreenloader type:", typeof loadhtmlscreenloader);
    console.log("LoadHtmlScreenLoader class exists:", typeof LoadHtmlScreenLoader);
};


class AVUScreenLoader {
    constructor() {
        console.log("AVUScreenLoader constructor initialized");
        
        this.avuBoard = {
            name: 'ADMIN VIEW USER',
            instructions: 'Admin: View user messages and send replies. Users: Chat with admin.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cancelButton = null;
        this.isAdmin = false;
        this.currentUserId = null;
        this.usersList = [];
        this.messages = [];
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.usersRef = null;
        this.messagesRef = null;
        this.usersListener = null;
        this.messagesListener = null;
        
        console.log("AVUScreenLoader constructor completed");
    }
    
    /**
     * Load the AVU Screen
     */
    loadAvuScreen() {
        console.log("loadAvuScreen called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("AVU screen already active");
                this.showNotification(`The ${this.avuBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("AVU screen loaded successfully");
            this.showNotification(`${this.avuBoard.name} loaded! ${this.avuBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadAvuScreen:", error);
            this.showNotification("Sorry, there was an error loading the AVU screen. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Admin Mode Button
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'Admin Mode';
        adminBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        adminBtn.addEventListener('click', () => {
            this.isAdmin = true;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createAdminInterface();
            });
        });
        modeContainer.appendChild(adminBtn);
        
        // User Mode Button
        const userBtn = document.createElement('button');
        userBtn.textContent = 'User Mode';
        userBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        userBtn.addEventListener('click', () => {
            this.isAdmin = false;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createUserInterface();
            });
        });
        modeContainer.appendChild(userBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Admin Interface
     */
    createAdminInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'Admin View User Messages';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            display: block;
            margin: 0 auto 20px auto;
            padding: 10px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        cancelButton.addEventListener('click', () => {
            this.backToModeSelection();
        });
        cancelButton.addEventListener('mouseenter', () => {
            cancelButton.style.background = '#d32f2f';
            cancelButton.style.transform = 'scale(1.05)';
        });
        cancelButton.addEventListener('mouseleave', () => {
            cancelButton.style.background = '#f44336';
            cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(cancelButton);
        
        // Create main container
        const mainContainer = document.createElement('div');
        mainContainer.style.cssText = `
            display: flex;
            width: 90%;
            max-width: 1200px;
            height: 600px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;
        
        // Create users list container
        const usersListContainer = document.createElement('div');
        usersListContainer.style.cssText = `
            width: 30%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-right: 1px solid rgba(255, 255, 255, 0.3);
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
        `;
        
        const usersListTitle = document.createElement('h3');
        usersListTitle.textContent = 'Users';
        usersListTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: white;
            font-size: 18px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        `;
        usersListContainer.appendChild(usersListTitle);
        
        const usersListContent = document.createElement('div');
        usersListContent.id = 'usersListContent';
        usersListContent.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        usersListContainer.appendChild(usersListContent);
        
        // Create messages container
        const messagesContainer = document.createElement('div');
        messagesContainer.style.cssText = `
            width: 70%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
        `;
        
        const messagesHeader = document.createElement('div');
        messagesHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        `;
        
        const messagesTitle = document.createElement('h3');
        messagesTitle.textContent = 'Messages';
        messagesTitle.style.cssText = `
            margin: 0;
            color: white;
            font-size: 18px;
        `;
        messagesHeader.appendChild(messagesTitle);
        
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear All';
        clearBtn.style.cssText = `
            padding: 6px 12px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
        `;
        clearBtn.addEventListener('click', () => {
            this.clearAllMessages();
        });
        clearBtn.addEventListener('mouseenter', () => {
            clearBtn.style.background = '#d32f2f';
        });
        clearBtn.addEventListener('mouseleave', () => {
            clearBtn.style.background = '#f44336';
        });
        messagesHeader.appendChild(clearBtn);
        
        messagesContainer.appendChild(messagesHeader);
        
        const messagesContent = document.createElement('div');
        messagesContent.id = 'messagesContent';
        messagesContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
        `;
        messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">Select a user to view messages</div>';
        messagesContainer.appendChild(messagesContent);
        
        // Admin input area
        const adminInputArea = document.createElement('div');
        adminInputArea.id = 'adminInputArea';
        adminInputArea.style.cssText = `
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const adminInputHeader = document.createElement('div');
        adminInputHeader.style.cssText = `
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        `;
        adminInputHeader.textContent = 'Send message to user:';
        adminInputArea.appendChild(adminInputHeader);
        
        const adminInputContainer = document.createElement('div');
        adminInputContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const adminInput = document.createElement('input');
        adminInput.id = 'adminInput';
        adminInput.type = 'text';
        adminInput.placeholder = 'Type your message...';
        adminInput.style.cssText = `
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
        `;
        adminInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendAdminMessage();
            }
        });
        adminInputContainer.appendChild(adminInput);
        
        const adminSendBtn = document.createElement('button');
        adminSendBtn.textContent = 'Send';
        adminSendBtn.style.cssText = `
            padding: 10px 15px;
            background: #9c27b0;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        `;
        adminSendBtn.addEventListener('click', () => {
            this.sendAdminMessage();
        });
        adminSendBtn.addEventListener('mouseenter', () => {
            adminSendBtn.style.background = '#7b1fa2';
        });
        adminSendBtn.addEventListener('mouseleave', () => {
            adminSendBtn.style.background = '#9c27b0';
        });
        adminInputContainer.appendChild(adminSendBtn);
        
        adminInputArea.appendChild(adminInputContainer);
        messagesContainer.appendChild(adminInputArea);
        
        mainContainer.appendChild(usersListContainer);
        mainContainer.appendChild(messagesContainer);
        this.gameContainer.appendChild(mainContainer);
        
        // Set up Firebase listeners
        this.setupAdminListeners();
    }
    
    /**
     * Create User Interface
     */
    createUserInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'Chat with Admin';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            display: block;
            margin: 0 auto 20px auto;
            padding: 10px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        cancelButton.addEventListener('click', () => {
            this.backToModeSelection();
        });
        cancelButton.addEventListener('mouseenter', () => {
            cancelButton.style.background = '#d32f2f';
            cancelButton.style.transform = 'scale(1.05)';
        });
        cancelButton.addEventListener('mouseleave', () => {
            cancelButton.style.background = '#f44336';
            cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(cancelButton);
        
        // Create info message
        const infoMessage = document.createElement('div');
        infoMessage.textContent = 'You are chatting with the admin. Please be respectful.';
        infoMessage.style.cssText = `
            color: #4CAF50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        `;
        this.gameContainer.appendChild(infoMessage);
        
        // Create chat container
        const chatContainer = document.createElement('div');
        chatContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            height: 500px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        `;
        
        // Messages display area
        const messagesDisplay = document.createElement('div');
        messagesDisplay.id = 'messagesDisplay';
        messagesDisplay.style.cssText = `
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.05);
        `;
        messagesDisplay.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages yet. Start a conversation!</div>';
        chatContainer.appendChild(messagesDisplay);
        
        // Input area
        const inputArea = document.createElement('div');
        inputArea.style.cssText = `
            display: flex;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const messageInput = document.createElement('input');
        messageInput.id = 'messageInput';
        messageInput.type = 'text';
        messageInput.placeholder = 'Type your message...';
        messageInput.style.cssText = `
            flex: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            outline: none;
            box-sizing: border-box;
        `;
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        inputArea.appendChild(messageInput);
        
        const sendBtn = document.createElement('button');
        sendBtn.textContent = 'Send';
        sendBtn.style.cssText = `
            margin-left: 10px;
            padding: 12px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        `;
        sendBtn.addEventListener('click', () => {
            this.sendMessage();
        });
        sendBtn.addEventListener('mouseenter', () => {
            sendBtn.style.background = '#45a049';
        });
        sendBtn.addEventListener('mouseleave', () => {
            sendBtn.style.background = '#4CAF50';
        });
        inputArea.appendChild(sendBtn);
        
        chatContainer.appendChild(inputArea);
        this.gameContainer.appendChild(chatContainer);
        
        // Generate or get user ID
        this.generateUserId();
        
        // Set up user listeners
        this.setupUserListeners();
    }
    
    /**
     * Generate or get user ID
     */
    generateUserId() {
        // Check if we already have a user ID in localStorage
        let userId = localStorage.getItem('avu_userId');
        
        if (!userId) {
            // Generate a new user ID
            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('avu_userId', userId);
        }
        
        this.currentUserId = userId;
        console.log("User ID:", userId);
    }
    
    /**
     * Setup Admin Listeners
     */
    setupAdminListeners() {
        if (!this.isFirebaseInitialized) return;
        
        // Listen for users
        this.usersRef = this.db.ref('avu_users');
        this.usersListener = this.usersRef.on('value', (snapshot) => {
            this.updateUsersList(snapshot.val());
        });
        
        // If we have a selected user, listen for their messages
        if (this.currentUserId) {
            this.setupMessagesListener(this.currentUserId);
        }
    }
    
    /**
     * Setup User Listeners
     */
    setupUserListeners() {
        if (!this.isFirebaseInitialized) return;
        
        // Add user to the users list
        this.usersRef = this.db.ref('avu_users');
        this.usersRef.child(this.currentUserId).set({
            id: this.currentUserId,
            lastActive: firebase.database.ServerValue.TIMESTAMP
        });
        
        // Listen for messages
        this.setupMessagesListener(this.currentUserId);
    }
    
    /**
     * Setup Messages Listener
     */
    setupMessagesListener(userId) {
        if (!this.isFirebaseInitialized || !userId) return;
        
        // Remove existing listener
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Set up new listener
        this.messagesRef = this.db.ref(`avu_messages/${userId}`);
        this.messagesListener = this.messagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            this.addMessage(message);
        });
    }
    
    /**
     * Update Users List (Admin)
     */
    updateUsersList(usersData) {
        if (!usersData) {
            this.usersList = [];
            this.updateUsersListUI();
            return;
        }
        
        this.usersList = Object.values(usersData);
        this.updateUsersListUI();
    }
    
    /**
     * Update Users List UI (Admin)
     */
    updateUsersListUI() {
        const usersListContent = document.getElementById('usersListContent');
        if (!usersListContent) return;
        
        usersListContent.innerHTML = '';
        
        if (this.usersList.length === 0) {
            usersListContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No users found</div>';
            return;
        }
        
        this.usersList.forEach(user => {
            const userItem = document.createElement('div');
            userItem.style.cssText = `
                padding: 12px 15px;
                background: ${user.id === this.currentUserId ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.2);
            `;
            
            const userInfo = document.createElement('div');
            userInfo.innerHTML = `
                <div style="font-weight: bold; color: white; margin-bottom: 5px;">${user.id}</div>
                <div style="font-size: 12px; color: #ccc;">Last active: ${new Date(user.lastActive).toLocaleString()}</div>
            `;
            userItem.appendChild(userInfo);
            
            userItem.addEventListener('click', () => {
                this.selectUser(user.id);
            });
            
            usersListContent.appendChild(userItem);
        });
    }
    
    /**
     * Select User (Admin)
     */
    selectUser(userId) {
        this.currentUserId = userId;
        this.updateUsersListUI();
        this.setupMessagesListener(userId);
        
        // Show admin input area
        const adminInputArea = document.getElementById('adminInputArea');
        if (adminInputArea) {
            adminInputArea.style.display = 'block';
        }
        
        // Clear messages display
        const messagesContent = document.getElementById('messagesContent');
        if (messagesContent) {
            messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">Loading messages...</div>';
        }
        
        // Load existing messages
        this.loadMessages(userId);
    }
    
    /**
     * Load Messages
     */
    loadMessages(userId) {
        if (!this.isFirebaseInitialized || !userId) return;
        
        this.messagesRef = this.db.ref(`avu_messages/${userId}`);
        this.messagesRef.once('value', (snapshot) => {
            const messagesData = snapshot.val();
            this.messages = messagesData ? Object.values(messagesData) : [];
            this.updateMessagesUI();
        });
    }
    
    /**
     * Add Message
     */
    addMessage(message) {
        this.messages.push(message);
        this.updateMessagesUI();
    }
    
    /**
     * Update Messages UI
     */
    updateMessagesUI() {
        const messagesContent = document.getElementById('messagesContent');
        const messagesDisplay = document.getElementById('messagesDisplay');
        
        if (!messagesContent && !messagesDisplay) return;
        
        if (this.messages.length === 0) {
            if (messagesContent) {
                messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages found</div>';
            }
            if (messagesDisplay) {
                messagesDisplay.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages yet. Start a conversation!</div>';
            }
            return;
        }
        
        const container = messagesContent || messagesDisplay;
        container.innerHTML = '';
        
        this.messages.forEach(message => {
            const messageDiv = document.createElement('div');
            
            // Set different styles based on sender
            if (message.sender === 'user') {
                messageDiv.style.cssText = `
                    margin-bottom: 15px;
                    padding: 12px 15px;
                    border-radius: 15px;
                    max-width: 80%;
                    background: rgba(33, 150, 243, 0.2);
                    margin-left: auto;
                `;
            } else if (message.sender === 'admin') {
                messageDiv.style.cssText = `
                    margin-bottom: 15px;
                    padding: 12px 15px;
                    border-radius: 15px;
                    max-width: 80%;
                    background: rgba(156, 39, 176, 0.2);
                    margin-right: auto;
                `;
            }
            
            const messageInfo = document.createElement('div');
            messageInfo.style.cssText = `
                font-size: 12px;
                color: ${message.sender === 'user' ? '#2196F3' : message.sender === 'admin' ? '#9c27b0' : '#4CAF50'};
                margin-bottom: 5px;
                font-weight: bold;
            `;
            messageInfo.textContent = `${message.sender === 'user' ? 'You' : message.sender === 'admin' ? 'Admin' : 'AI'} - ${new Date(message.timestamp).toLocaleTimeString()}`;
            messageDiv.appendChild(messageInfo);
            
            const messageText = document.createElement('div');
            messageText.style.cssText = `
                color: white;
                word-wrap: break-word;
            `;
            messageText.textContent = message.text;
            messageDiv.appendChild(messageText);
            
            container.appendChild(messageDiv);
        });
        
        // Scroll to bottom
        container.scrollTop = container.scrollHeight;
    }
    
    /**
     * Send Message (User)
     */
    sendMessage() {
        const messageInput = document.querySelector('#messageInput') || document.querySelector('input[placeholder="Type your message..."]');
        if (!messageInput) return;
        
        const text = messageInput.value.trim();
        if (!text) return;
        
        const message = {
            text: text,
            sender: 'user',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Save to Firebase
        this.messagesRef.push(message);
        
        // Clear input
        messageInput.value = '';
        
        // No automatic AI response
    }
    
    /**
     * Send Admin Message
     */
    sendAdminMessage() {
        const adminInput = document.getElementById('adminInput');
        if (!adminInput || !this.currentUserId) return;
        
        const text = adminInput.value.trim();
        if (!text) return;
        
        const message = {
            text: text,
            sender: 'admin',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Save to Firebase
        this.messagesRef.push(message);
        
        // Clear input
        adminInput.value = '';
    }
    
    /**
     * Clear All Messages (Admin)
     */
    clearAllMessages() {
        if (!this.currentUserId || !this.isFirebaseInitialized) return;
        
        const confirmClear = confirm('Are you sure you want to clear all messages for this user?');
        if (!confirmClear) return;
        
        // Clear messages in Firebase
        this.db.ref(`avu_messages/${this.currentUserId}`).remove();
        
        // Clear local messages
        this.messages = [];
        this.updateMessagesUI();
        
        this.showNotification('Messages cleared successfully!');
    }
    
    /**
     * Go back to mode selection screen
     */
    backToModeSelection() {
        // Clean up Firebase listeners
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Clear the container
        this.gameContainer.innerHTML = '';
        
        // Reset mode
        this.isAdmin = false;
        this.currentUserId = null;
        this.messages = [];
        
        // Create mode selection screen
        this.createModeSelectionScreen();
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Cancel button (main button)
        this.cancelButton = document.createElement('button');
        this.cancelButton.textContent = 'Cancel';
        this.cancelButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 12px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
            transition: all 0.3s ease;
        `;
        this.cancelButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.cancelButton.addEventListener('mouseenter', () => {
            this.cancelButton.style.background = '#d32f2f';
            this.cancelButton.style.transform = 'scale(1.05)';
        });
        this.cancelButton.addEventListener('mouseleave', () => {
            this.cancelButton.style.background = '#f44336';
            this.cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(this.cancelButton);
        
        // Keep the old close button for backward compatibility
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10000;
            display: none; /* Hidden by default, only shown if needed */
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase listeners
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.isAdmin = false;
        this.currentUserId = null;
        this.messages = [];
        
        console.log("AVU screen closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let avuscreenloader = null;
// Function to get or create the AVU screen instance
function getAvuScreen() {
    if (!avuscreenloader) {
        console.log("Creating new AVUScreenLoader instance");
        avuscreenloader = new AVUScreenLoader();
    }
    return avuscreenloader;
}
// Command handler
function handleAvuCommand(input) {
    if (typeof input !== 'string') return false;
    
    const avuKeywords = ['admin view', 'view user', 'monitor chat', 'avu', 'admin messages'];
    const normalizedInput = input.toLowerCase().trim();
    
    return avuKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute AVU command
function executeAvuCommand() {
    try {
        const avuScreen = getAvuScreen();
        if (avuScreen && typeof avuScreen.loadAvuScreen === 'function') {
            console.log("Executing AVU command");
            avuScreen.loadAvuScreen();
        } else {
            console.error("Invalid AVU screen instance");
            botReply("Sorry, the admin view user screen is not available right now.");
        }
    } catch (error) {
        console.error("Error executing AVU command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleAvuCommand(userInputRaw)) {
    console.log("AVU command detected");
    executeAvuCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen|cancel/i.test(userInputRaw)) {
    if (avuscreenloader && avuscreenloader.isActive) {
        avuscreenloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the AVU screen manually (call from browser console)
window.testAvuScreen = function() {
    console.log("Testing AVU screen...");
    executeAvuCommand();
};
// Add this to check if the AVU screen is loaded
window.checkAvuScreen = function() {
    console.log("avuscreenloader exists:", !!avuscreenloader);
    console.log("avuscreenloader type:", typeof avuscreenloader);
    console.log("AVUScreenLoader class exists:", typeof AVUScreenLoader);
};


class NoteScreenLoader {
    constructor() {
        this.noteScreen = {
            name: 'NOTE SCREEN',
            instructions: 'Type your notes and save them. View, edit, copy, or download saved notes anytime.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.noteTextarea = null;
        this.saveButton = null;
        this.clearButton = null;
        this.notesList = null;
        this.savedNotes = [];
        this.currentNoteId = null;
        this.notesListVisible = false;
        this.noteModal = null;
        this.modalContent = null;
    }
    
    /**
     * Load the Note Screen
     */
    loadNoteScreen() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.noteScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Load saved notes from localStorage
        this.loadSavedNotes();
        
        // Create container
        this.createGameContainer();
        
        // Create note screen
        this.createNoteScreen();
        
        // Create modal for viewing notes
        this.createNoteModal();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the note screen
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.noteScreen.name} loaded! ${this.noteScreen.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Note Screen UI
     */
    createNoteScreen() {
        // Create note container
        const noteContainer = document.createElement('div');
        noteContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'My Notes';
        title.style.cssText = `
            margin: 0;
            color: #333;
            font-size: 24px;
        `;
        
        const toggleButton = document.createElement('button');
        toggleButton.textContent = 'Saved Notes';
        toggleButton.style.cssText = `
            padding: 8px 12px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        `;
        toggleButton.addEventListener('click', () => {
            this.toggleNotesList();
        });
        
        header.appendChild(title);
        header.appendChild(toggleButton);
        noteContainer.appendChild(header);
        
        // Create textarea for note input
        this.noteTextarea = document.createElement('textarea');
        this.noteTextarea.placeholder = 'Type your note here...';
        this.noteTextarea.style.cssText = `
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            resize: vertical;
            margin-bottom: 15px;
            box-sizing: border-box;
        `;
        
        noteContainer.appendChild(this.noteTextarea);
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Create save button
        this.saveButton = document.createElement('button');
        this.saveButton.textContent = 'Save Note';
        this.saveButton.style.cssText = `
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex: 1;
            transition: all 0.2s ease;
        `;
        this.saveButton.addEventListener('click', () => {
            this.saveNote();
        });
        
        // Create clear button
        this.clearButton = document.createElement('button');
        this.clearButton.textContent = 'Clear';
        this.clearButton.style.cssText = `
            padding: 10px 15px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex: 1;
            transition: all 0.2s ease;
        `;
        this.clearButton.addEventListener('click', () => {
            this.clearNote();
        });
        
        buttonContainer.appendChild(this.saveButton);
        buttonContainer.appendChild(this.clearButton);
        noteContainer.appendChild(buttonContainer);
        
        // Create saved notes list (initially hidden)
        this.notesList = document.createElement('div');
        this.notesList.style.cssText = `
            display: none;
            max-height: 300px;
            overflow-y: auto;
            border-top: 1px solid #ddd;
            padding-top: 15px;
        `;
        
        this.updateNotesList();
        noteContainer.appendChild(this.notesList);
        
        this.gameContainer.appendChild(noteContainer);
    }
    
    /**
     * Create a modal for viewing notes
     */
    createNoteModal() {
        // Create modal container
        this.noteModal = document.createElement('div');
        this.noteModal.style.cssText = `
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        `;
        
        // Create modal content container
        const modalContainer = document.createElement('div');
        modalContainer.style.cssText = `
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create modal header
        const modalHeader = document.createElement('div');
        modalHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Note Details';
        modalTitle.style.cssText = `
            margin: 0;
            color: #333;
            font-size: 20px;
        `;
        
        const closeButton = document.createElement('button');
        closeButton.textContent = '✕';
        closeButton.style.cssText = `
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #777;
        `;
        closeButton.addEventListener('click', () => {
            this.closeNoteModal();
        });
        
        modalHeader.appendChild(modalTitle);
        modalHeader.appendChild(closeButton);
        modalContainer.appendChild(modalHeader);
        
        // Create modal content
        this.modalContent = document.createElement('div');
        this.modalContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            white-space: pre-wrap;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            line-height: 1.5;
        `;
        
        modalContainer.appendChild(this.modalContent);
        
        // Create modal footer with action buttons
        const modalFooter = document.createElement('div');
        modalFooter.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
        `;
        
        // Copy button
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy';
        copyButton.style.cssText = `
            padding: 8px 12px;
            background-color: #9C27B0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        copyButton.addEventListener('click', () => {
            this.copyNoteFromModal();
        });
        
        // Edit button
        const editButton = document.createElement('button');
        editButton.textContent = 'Edit';
        editButton.style.cssText = `
            padding: 8px 12px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        editButton.addEventListener('click', () => {
            this.editNoteFromModal();
        });
        
        // Download button
        const downloadButton = document.createElement('button');
        downloadButton.textContent = 'Download';
        downloadButton.style.cssText = `
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        downloadButton.addEventListener('click', () => {
            this.downloadNoteFromModal();
        });
        
        modalFooter.appendChild(copyButton);
        modalFooter.appendChild(editButton);
        modalFooter.appendChild(downloadButton);
        modalContainer.appendChild(modalFooter);
        
        this.noteModal.appendChild(modalContainer);
        this.gameContainer.appendChild(this.noteModal);
    }
    
    /**
     * Toggle the visibility of the saved notes list
     */
    toggleNotesList() {
        this.notesListVisible = !this.notesListVisible;
        this.notesList.style.display = this.notesListVisible ? 'block' : 'none';
        
        if (this.notesListVisible) {
            this.updateNotesList();
        }
    }
    
    /**
     * Update the saved notes list
     */
    updateNotesList() {
        // Clear existing notes
        this.notesList.innerHTML = '';
        
        if (this.savedNotes.length === 0) {
            const noNotes = document.createElement('p');
            noNotes.textContent = 'No saved notes yet.';
            noNotes.style.cssText = `
                text-align: center;
                color: #777;
                font-style: italic;
            `;
            this.notesList.appendChild(noNotes);
            return;
        }
        
        // Create list header
        const listHeader = document.createElement('h3');
        listHeader.textContent = 'Saved Notes';
        listHeader.style.cssText = `
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        `;
        this.notesList.appendChild(listHeader);
        
        // Create list container
        const listContainer = document.createElement('div');
        
        // Add each saved note
        this.savedNotes.forEach(note => {
            const noteItem = document.createElement('div');
            noteItem.style.cssText = `
                background-color: white;
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 10px;
                margin-bottom: 8px;
                transition: all 0.2s ease;
            `;
            
            // Create note content
            const noteContent = document.createElement('div');
            noteContent.textContent = note.content.length > 50 
                ? note.content.substring(0, 50) + '...' 
                : note.content;
            noteContent.style.cssText = `
                font-size: 14px;
                color: #333;
                margin-bottom: 5px;
            `;
            
            // Create note metadata
            const noteMeta = document.createElement('div');
            noteMeta.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 12px;
                color: #777;
            `;
            
            const noteDate = document.createElement('span');
            noteDate.textContent = new Date(note.timestamp).toLocaleString();
            
            // Create action buttons container
            const actionButtons = document.createElement('div');
            actionButtons.style.cssText = `
                display: flex;
                gap: 5px;
                flex-wrap: wrap;
            `;
            
            // View button
            const viewButton = document.createElement('button');
            viewButton.textContent = 'View';
            viewButton.style.cssText = `
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            viewButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.viewNote(note.id);
            });
            
            // Copy button
            const copyButton = document.createElement('button');
            copyButton.textContent = 'Copy';
            copyButton.style.cssText = `
                background-color: #9C27B0;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            copyButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.copyNote(note.id);
            });
            
            // Edit button
            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.style.cssText = `
                background-color: #FF9800;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            editButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.loadNote(note.id);
            });
            
            // Download button
            const downloadButton = document.createElement('button');
            downloadButton.textContent = 'Download';
            downloadButton.style.cssText = `
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            downloadButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.downloadNote(note.id);
            });
            
            // Delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.style.cssText = `
                background-color: #f44336;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteNote(note.id);
            });
            
            actionButtons.appendChild(viewButton);
            actionButtons.appendChild(copyButton);
            actionButtons.appendChild(editButton);
            actionButtons.appendChild(downloadButton);
            actionButtons.appendChild(deleteButton);
            
            noteMeta.appendChild(noteDate);
            noteMeta.appendChild(actionButtons);
            
            noteItem.appendChild(noteContent);
            noteItem.appendChild(noteMeta);
            
            listContainer.appendChild(noteItem);
        });
        
        this.notesList.appendChild(listContainer);
    }
    
    /**
     * View a note in the modal
     */
    viewNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (note) {
            this.modalContent.textContent = note.content;
            this.modalContent.dataset.noteId = noteId;
            this.noteModal.style.display = 'flex';
        }
    }
    
    /**
     * Close the note modal
     */
    closeNoteModal() {
        this.noteModal.style.display = 'none';
        this.modalContent.textContent = '';
        this.modalContent.dataset.noteId = '';
    }
    
    /**
     * Copy note from modal
     */
    copyNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.copyNote(noteId);
        }
    }
    
    /**
     * Copy a note to clipboard
     */
    copyNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (!note) return;
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(note.content)
                .then(() => {
                    botReply('Note copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(note.content);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(note.content);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Note copied to clipboard!');
            } else {
                botReply('Unable to copy note');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy note');
        }

        document.body.removeChild(textArea);
    }
    
    /**
     * Edit note from modal
     */
    editNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.loadNote(noteId);
            this.closeNoteModal();
        }
    }
    
    /**
     * Download note from modal
     */
    downloadNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.downloadNote(noteId);
        }
    }
    
    /**
     * Download a note as a text file
     */
    downloadNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (!note) return;
        
        try {
            // Create a blob with the note content, specifying UTF-8 encoding for proper emoji support
            const blob = new Blob([note.content], { type: 'text/plain;charset=utf-8' });
            
            // Create a download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Generate filename with timestamp
            const date = new Date(note.timestamp);
            const dateStr = date.toISOString().slice(0, 19).replace(/:/g, '-');
            a.download = `note_${dateStr}.txt`;
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            botReply('Note downloaded successfully!');
        } catch (error) {
            console.error('Error downloading note:', error);
            botReply('Error downloading note. Please try again.');
        }
    }
    
    /**
     * Save the current note
     */
    saveNote() {
        const content = this.noteTextarea.value.trim();
        
        if (!content) {
            botReply('Please enter some text before saving.');
            return;
        }
        
        const now = new Date().getTime();
        
        if (this.currentNoteId) {
            // Update existing note
            const noteIndex = this.savedNotes.findIndex(note => note.id === this.currentNoteId);
            if (noteIndex !== -1) {
                this.savedNotes[noteIndex].content = content;
                this.savedNotes[noteIndex].timestamp = now;
                botReply('Note updated successfully!');
            }
        } else {
            // Create new note
            const newNote = {
                id: 'note_' + now,
                content: content,
                timestamp: now
            };
            
            this.savedNotes.push(newNote);
            this.currentNoteId = newNote.id;
            botReply('Note saved successfully!');
        }
        
        // Save to localStorage
        this.saveNotesToStorage();
        
        // Update notes list if visible
        if (this.notesListVisible) {
            this.updateNotesList();
        }
    }
    
    /**
     * Clear the current note
     */
    clearNote() {
        this.noteTextarea.value = '';
        this.currentNoteId = null;
        botReply('Note cleared.');
    }
    
    /**
     * Load a note into the textarea
     */
    loadNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (note) {
            this.noteTextarea.value = note.content;
            this.currentNoteId = noteId;
            botReply('Note loaded for editing!');
        }
    }
    
    /**
     * Delete a saved note
     */
    deleteNote(noteId) {
        const noteIndex = this.savedNotes.findIndex(note => note.id === noteId);
        if (noteIndex !== -1) {
            this.savedNotes.splice(noteIndex, 1);
            
            // If deleting the currently loaded note, clear the textarea
            if (this.currentNoteId === noteId) {
                this.clearNote();
            }
            
            // Save to localStorage
            this.saveNotesToStorage();
            
            // Update notes list
            this.updateNotesList();
            
            botReply('Note deleted!');
        }
    }
    
    /**
     * Load saved notes from localStorage
     */
    loadSavedNotes() {
        try {
            const savedNotesJson = localStorage.getItem('savedNotes');
            if (savedNotesJson) {
                this.savedNotes = JSON.parse(savedNotesJson);
            } else {
                this.savedNotes = [];
            }
        } catch (error) {
            console.error('Error loading saved notes:', error);
            this.savedNotes = [];
        }
    }
    
    /**
     * Save notes to localStorage
     */
    saveNotesToStorage() {
        try {
            localStorage.setItem('savedNotes', JSON.stringify(this.savedNotes));
        } catch (error) {
            console.error('Error saving notes to storage:', error);
            botReply('Error saving notes. Please try again.');
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.noteModal.style.display === 'flex') {
                this.closeNoteModal();
            } else if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
        
        // Ctrl+S to save note
        if (event.ctrlKey && event.key === 's') {
            event.preventDefault();
            this.saveNote();
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (this.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.noteTextarea = null;
        this.saveButton = null;
        this.clearButton = null;
        this.notesList = null;
        this.noteModal = null;
        this.modalContent = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.savedNotes = [];
        this.currentNoteId = null;
        this.notesListVisible = false;
        
        botReply("Note Screen closed. Thank you!");
    }
}

// Create a singleton instance
const noteScreenLoader = new NoteScreenLoader();

// Add this to your AI's command handling
if (/note|notes|notepad/i.test(userInputRaw)) {
    noteScreenLoader.loadNoteScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    noteScreenLoader.closeGame();
    return;
}
class SongsVideosScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'MEDIA PLAYER',
            instructions: 'Load and play songs and videos from your device. Access media from your Download folder or upload new files.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.fileInput = null;
        this.uploadButton = null;
        this.loadFromFolderButton = null;
        this.mediaList = null;
        this.mediaPlayer = null;
        this.mediaControls = null;
        this.playButton = null;
        this.pauseButton = null;
        this.stopButton = null;
        this.volumeSlider = null;
        this.progressBar = null;
        this.timeDisplay = null;
        this.currentMedia = null;
        this.mediaFiles = [];
        this.storageKey = 'mediaFilesData';
        this.isPlaying = false;
        this.currentMediaType = null;
        this.downloadFolderPath = '/storage/emulated/0/Download/';
        this.directoryHandle = null;
    }

    /**
     * Load the Media Player Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createMediaPlayerScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.loadMediaFiles();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Media Player UI
     */
    createMediaPlayerScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Media Player';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Play songs and videos from your device';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Upload section
        const uploadSection = document.createElement('div');
        uploadSection.style.cssText = `
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        `;
        const uploadTitle = document.createElement('h3');
        uploadTitle.textContent = 'Load Media';
        uploadTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: #2E7D32;
            font-size: 18px;
        `;
        
        const uploadControls = document.createElement('div');
        uploadControls.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Load from folder button
        const folderControls = document.createElement('div');
        folderControls.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        const folderLabel = document.createElement('span');
        folderLabel.textContent = 'Download Folder:';
        folderLabel.style.cssText = `
            font-weight: bold;
            color: #333;
            min-width: 120px;
        `;
        this.loadFromFolderButton = this.createButton('Load from Download Folder', '#2196F3', () => {
            this.loadFromDownloadFolder();
        });
        folderControls.appendChild(folderLabel);
        folderControls.appendChild(this.loadFromFolderButton);
        
        // Upload file controls
        const fileControls = document.createElement('div');
        fileControls.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        const fileLabel = document.createElement('span');
        fileLabel.textContent = 'Upload File:';
        fileLabel.style.cssText = `
            font-weight: bold;
            color: #333;
            min-width: 120px;
        `;
        this.fileInput = document.createElement('input');
        this.fileInput.type = 'file';
        this.fileInput.accept = 'audio/*,video/*';
        this.fileInput.style.cssText = `
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        this.uploadButton = this.createButton('Upload', '#4CAF50', () => {
            this.uploadMedia();
        });
        fileControls.appendChild(fileLabel);
        fileControls.appendChild(this.fileInput);
        fileControls.appendChild(this.uploadButton);
        
        uploadControls.appendChild(folderControls);
        uploadControls.appendChild(fileControls);
        uploadSection.appendChild(uploadTitle);
        uploadSection.appendChild(uploadControls);
        baseContainer.appendChild(uploadSection);

        // Media list section
        const listSection = document.createElement('div');
        listSection.style.cssText = `
            margin-bottom: 20px;
        `;
        const listTitle = document.createElement('h3');
        listTitle.textContent = 'Media Library';
        listTitle.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 18px;
        `;
        this.mediaList = document.createElement('div');
        this.mediaList.style.cssText = `
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            padding: 10px;
        `;
        this.mediaList.textContent = 'Loading media library...';
        listSection.appendChild(listTitle);
        listSection.appendChild(this.mediaList);
        baseContainer.appendChild(listSection);

        // Media player section
        const playerSection = document.createElement('div');
        playerSection.style.cssText = `
            margin-bottom: 20px;
        `;
        const playerTitle = document.createElement('h3');
        playerTitle.textContent = 'Media Player';
        playerTitle.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 18px;
        `;
        
        // Media player container
        const playerContainer = document.createElement('div');
        playerContainer.style.cssText = `
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        `;
        
        // Audio element (initially hidden)
        this.audioPlayer = document.createElement('audio');
        this.audioPlayer.style.cssText = `
            width: 100%;
            display: none;
        `;
        this.audioPlayer.addEventListener('loadedmetadata', () => {
            this.updateTimeDisplay();
        });
        this.audioPlayer.addEventListener('timeupdate', () => {
            this.updateProgressBar();
        });
        this.audioPlayer.addEventListener('ended', () => {
            this.onMediaEnded();
        });
        
        // Video element (initially hidden)
        this.videoPlayer = document.createElement('video');
        this.videoPlayer.style.cssText = `
            width: 100%;
            max-height: 400px;
            display: none;
        `;
        this.videoPlayer.addEventListener('loadedmetadata', () => {
            this.updateTimeDisplay();
        });
        this.videoPlayer.addEventListener('timeupdate', () => {
            this.updateProgressBar();
        });
        this.videoPlayer.addEventListener('ended', () => {
            this.onMediaEnded();
        });
        
        playerContainer.appendChild(this.audioPlayer);
        playerContainer.appendChild(this.videoPlayer);
        
        // Media info display
        this.mediaInfo = document.createElement('div');
        this.mediaInfo.style.cssText = `
            padding: 10px;
            background-color: #333;
            color: white;
            font-size: 14px;
            text-align: center;
        `;
        this.mediaInfo.textContent = 'No media selected';
        playerContainer.appendChild(this.mediaInfo);
        
        playerSection.appendChild(playerTitle);
        playerSection.appendChild(playerContainer);
        baseContainer.appendChild(playerSection);

        // Media controls
        this.mediaControls = document.createElement('div');
        this.mediaControls.style.cssText = `
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
            color: white;
        `;
        
        // Progress bar
        const progressContainer = document.createElement('div');
        progressContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        this.progressBar = document.createElement('input');
        this.progressBar.type = 'range';
        this.progressBar.min = '0';
        this.progressBar.max = '100';
        this.progressBar.value = '0';
        this.progressBar.style.cssText = `
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #555;
            outline: none;
            cursor: pointer;
        `;
        this.progressBar.addEventListener('input', () => {
            this.seekMedia();
        });
        progressContainer.appendChild(this.progressBar);
        
        // Time display
        this.timeDisplay = document.createElement('div');
        this.timeDisplay.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 14px;
        `;
        this.currentTime = document.createElement('span');
        this.currentTime.textContent = '0:00';
        this.duration = document.createElement('span');
        this.duration.textContent = '0:00';
        this.timeDisplay.appendChild(this.currentTime);
        this.timeDisplay.appendChild(this.duration);
        
        // Control buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        `;
        this.playButton = this.createButton('▶', '#4CAF50', () => {
            this.playMedia();
        });
        this.pauseButton = this.createButton('⏸', '#FF9800', () => {
            this.pauseMedia();
        });
        this.stopButton = this.createButton('⏹', '#f44336', () => {
            this.stopMedia();
        });
        buttonContainer.appendChild(this.playButton);
        buttonContainer.appendChild(this.pauseButton);
        buttonContainer.appendChild(this.stopButton);
        
        // Volume control
        const volumeContainer = document.createElement('div');
        volumeContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const volumeLabel = document.createElement('span');
        volumeLabel.textContent = 'Volume:';
        volumeLabel.style.cssText = `
            font-size: 14px;
        `;
        this.volumeSlider = document.createElement('input');
        this.volumeSlider.type = 'range';
        this.volumeSlider.min = '0';
        this.volumeSlider.max = '100';
        this.volumeSlider.value = '50';
        this.volumeSlider.style.cssText = `
            flex-grow: 1;
            height: 6px;
            border-radius: 3px;
            background: #555;
            outline: none;
            cursor: pointer;
        `;
        this.volumeSlider.addEventListener('input', () => {
            this.changeVolume();
        });
        volumeContainer.appendChild(volumeLabel);
        volumeContainer.appendChild(this.volumeSlider);
        
        this.mediaControls.appendChild(progressContainer);
        this.mediaControls.appendChild(this.timeDisplay);
        this.mediaControls.appendChild(buttonContainer);
        this.mediaControls.appendChild(volumeContainer);
        baseContainer.appendChild(this.mediaControls);

        // Info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 15px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
            margin-top: auto;
        `;
        infoSection.innerHTML = `
            <strong>Instructions:</strong><br>
            • Click "Load from Download Folder" to access media files from your device<br>
            • Or upload audio/video files using the file input<br>
            • Click on any media file in the library to play it<br>
            • Use the media controls to play, pause, stop, and adjust volume
        `;
        baseContainer.appendChild(infoSection);
        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Load media files from the Download folder using File System Access API
     */
    async loadFromDownloadFolder() {
        try {
            // Show loading message
            this.mediaList.textContent = 'Loading media from Download folder...';
            
            // Check if File System Access API is supported
            if (!('showDirectoryPicker' in window)) {
                throw new Error('File System Access API is not supported in this browser');
            }
            
            // Request directory access
            this.directoryHandle = await window.showDirectoryPicker();
            
            // Get all entries in the directory
            const entries = [];
            for await (const entry of this.directoryHandle.values()) {
                entries.push(entry);
            }
            
            // Filter for audio and video files
            const mediaFiles = entries.filter(entry => 
                entry.kind === 'file' && (
                    entry.name.match(/\.(mp3|wav|ogg|m4a|flac|aac)$/i) || // Audio formats
                    entry.name.match(/\.(mp4|webm|ogg|mov|avi|mkv|flv)$/i)    // Video formats
                )
            );
            
            if (mediaFiles.length === 0) {
                this.mediaList.textContent = 'No media files found in the selected folder';
                botReply('No media files found in the selected folder');
                return;
            }
            
            // Process each media file
            const newMediaFiles = [];
            for (const fileHandle of mediaFiles) {
                const file = await fileHandle.getFile();
                const mediaFile = {
                    id: `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    fileHandle: fileHandle,
                    uploadDate: new Date().toLocaleString(),
                    source: 'Download Folder'
                };
                newMediaFiles.push(mediaFile);
            }
            
            // Add to media files array
            this.mediaFiles = [...this.mediaFiles.filter(f => f.source !== 'Download Folder'), ...newMediaFiles];
            
            // Update UI
            this.updateMediaList();
            this.saveMediaFiles();
            botReply(`Loaded ${newMediaFiles.length} media files from Download folder`);
            
        } catch (error) {
            console.error('Error loading from Download folder:', error);
            this.mediaList.textContent = 'Error loading media files. Please try again.';
            botReply(`Error: ${error.message}`);
        }
    }

    /**
     * Upload media file to localStorage
     */
    uploadMedia() {
        const file = this.fileInput.files[0];
        if (!file) {
            botReply('No file selected');
            return;
        }
        
        // Check file size (localStorage limit is ~5MB)
        if (file.size > 5 * 1024 * 1024) {
            botReply('File is too large. Maximum size is 5MB.');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const mediaFile = {
                id: Date.now(),
                name: file.name,
                type: file.type,
                size: file.size,
                data: e.target.result,
                uploadDate: new Date().toLocaleString(),
                source: 'Uploaded'
            };
            
            this.mediaFiles.push(mediaFile);
            this.saveMediaFiles();
            this.updateMediaList();
            this.fileInput.value = '';
            botReply(`Media uploaded: ${file.name}`);
        };
        
        reader.onerror = () => {
            botReply('Error uploading file');
        };
        
        reader.readAsDataURL(file);
    }

    /**
     * Save media files to localStorage
     */
    saveMediaFiles() {
        try {
            // We can't save file handles to localStorage, so we only save metadata
            const filesToSave = this.mediaFiles.map(file => {
                const { fileHandle, ...rest } = file;
                return rest;
            });
            localStorage.setItem(this.storageKey, JSON.stringify(filesToSave));
        } catch (error) {
            console.error('Error saving media files:', error);
            botReply('Error saving media files. Storage may be full.');
        }
    }

    /**
     * Load media files from localStorage
     */
    loadMediaFiles() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                const files = JSON.parse(stored);
                this.mediaFiles = files.map(file => ({
                    ...file,
                    // File handles are lost on refresh, so we need to reload them
                    fileHandle: null
                }));
                this.updateMediaList();
            } else {
                this.mediaList.textContent = 'No media files found. Click "Load from Download Folder" to get started.';
            }
        } catch (error) {
            console.error('Error loading media files:', error);
            this.mediaList.textContent = 'Error loading media files. Please try again.';
        }
    }

    /**
     * Update media list display
     */
    updateMediaList() {
        this.mediaList.innerHTML = '';
        
        if (this.mediaFiles.length === 0) {
            this.mediaList.textContent = 'No media files found. Click "Load from Download Folder" to get started.';
            return;
        }
        
        // Group files by source
        const filesBySource = {};
        this.mediaFiles.forEach(file => {
            if (!filesBySource[file.source]) {
                filesBySource[file.source] = [];
            }
            filesBySource[file.source].push(file);
        });
        
        // Display files grouped by source
        Object.keys(filesBySource).forEach(source => {
            // Create source header
            const sourceHeader = document.createElement('div');
            sourceHeader.style.cssText = `
                font-weight: bold;
                margin-top: 10px;
                margin-bottom: 5px;
                color: #555;
                font-size: 14px;
                border-bottom: 1px solid #eee;
                padding-bottom: 3px;
            `;
            sourceHeader.textContent = source;
            this.mediaList.appendChild(sourceHeader);
            
            // Add files for this source
            filesBySource[source].forEach(file => {
                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 10px;
                    margin-bottom: 5px;
                    background-color: #f9f9f9;
                    border-radius: 5px;
                    cursor: pointer;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    transition: background-color 0.2s;
                `;
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#e0e0e0';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '#f9f9f9';
                });
                
                const fileInfo = document.createElement('div');
                fileInfo.style.cssText = `
                    flex-grow: 1;
                `;
                const fileName = document.createElement('div');
                fileName.textContent = file.name;
                fileName.style.cssText = `
                    font-weight: bold;
                    margin-bottom: 2px;
                `;
                const fileDetails = document.createElement('div');
                fileDetails.textContent = `${this.formatFileSize(file.size)} • ${file.uploadDate}`;
                fileDetails.style.cssText = `
                    font-size: 12px;
                    color: #666;
                `;
                fileInfo.appendChild(fileName);
                fileInfo.appendChild(fileDetails);
                
                const playIcon = document.createElement('span');
                playIcon.textContent = '▶';
                playIcon.style.cssText = `
                    font-size: 20px;
                    color: #4CAF50;
                    margin-left: 10px;
                `;
                
                item.appendChild(fileInfo);
                item.appendChild(playIcon);
                item.addEventListener('click', () => {
                    this.selectMedia(file);
                });
                
                this.mediaList.appendChild(item);
            });
        });
    }

    /**
     * Select and play media file
     */
    async selectMedia(file) {
        this.currentMedia = file;
        this.currentMediaType = file.type.startsWith('audio/') ? 'audio' : 'video';
        
        // Reset players
        this.audioPlayer.pause();
        this.videoPlayer.pause();
        this.audioPlayer.style.display = 'none';
        this.videoPlayer.style.display = 'none';
        
        try {
            // Set media source
            if (file.data) {
                // For uploaded files
                if (this.currentMediaType === 'audio') {
                    this.audioPlayer.src = file.data;
                    this.audioPlayer.style.display = 'block';
                    this.mediaPlayer = this.audioPlayer;
                } else {
                    this.videoPlayer.src = file.data;
                    this.videoPlayer.style.display = 'block';
                    this.mediaPlayer = this.videoPlayer;
                }
            } else if (file.fileHandle) {
                // For files from Download folder
                const fileObj = await file.fileHandle.getFile();
                const url = URL.createObjectURL(fileObj);
                
                if (this.currentMediaType === 'audio') {
                    this.audioPlayer.src = url;
                    this.audioPlayer.style.display = 'block';
                    this.mediaPlayer = this.audioPlayer;
                } else {
                    this.videoPlayer.src = url;
                    this.videoPlayer.style.display = 'block';
                    this.mediaPlayer = this.videoPlayer;
                }
            } else {
                // File handle is lost (page was refreshed)
                throw new Error('File handle lost. Please reload the Download folder.');
            }
            
            // Update media info
            this.mediaInfo.textContent = `Now Playing: ${file.name} (${file.source})`;
            
            // Load media
            this.mediaPlayer.load();
            
            botReply(`Selected: ${file.name}`);
            
        } catch (error) {
            console.error('Error selecting media:', error);
            this.mediaInfo.textContent = `Error: ${error.message}`;
            botReply(`Error: ${error.message}`);
        }
    }

    /**
     * Play media
     */
    playMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.play();
        this.isPlaying = true;
        botReply('Playing media');
    }

    /**
     * Pause media
     */
    pauseMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.pause();
        this.isPlaying = false;
        botReply('Media paused');
    }

    /**
     * Stop media
     */
    stopMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.pause();
        this.mediaPlayer.currentTime = 0;
        this.isPlaying = false;
        this.updateProgressBar();
        botReply('Media stopped');
    }

    /**
     * Seek media
     */
    seekMedia() {
        if (!this.mediaPlayer) return;
        
        const seekTime = (this.progressBar.value / 100) * this.mediaPlayer.duration;
        this.mediaPlayer.currentTime = seekTime;
    }

    /**
     * Change volume
     */
    changeVolume() {
        if (!this.mediaPlayer) return;
        
        const volume = this.volumeSlider.value / 100;
        this.mediaPlayer.volume = volume;
    }

    /**
     * Update progress bar
     */
    updateProgressBar() {
        if (!this.mediaPlayer) return;
        
        const progress = (this.mediaPlayer.currentTime / this.mediaPlayer.duration) * 100;
        this.progressBar.value = progress || 0;
        this.updateTimeDisplay();
    }

    /**
     * Update time display
     */
    updateTimeDisplay() {
        if (!this.mediaPlayer) return;
        
        this.currentTime.textContent = this.formatTime(this.mediaPlayer.currentTime);
        this.duration.textContent = this.formatTime(this.mediaPlayer.duration);
    }

    /**
     * Format time as MM:SS
     */
    formatTime(seconds) {
        if (isNaN(seconds)) return '0:00';
        
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Format file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Handle media ended event
     */
    onMediaEnded() {
        this.isPlaying = false;
        this.progressBar.value = 0;
        this.currentTime.textContent = '0:00';
        botReply('Media finished playing');
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === ' ' && this.mediaPlayer) {
            event.preventDefault();
            if (this.isPlaying) {
                this.pauseMedia();
            } else {
                this.playMedia();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop any playing media
        if (this.audioPlayer) {
            this.audioPlayer.pause();
        }
        if (this.videoPlayer) {
            this.videoPlayer.pause();
        }
        
        // Revoke any object URLs
        if (this.mediaPlayer && this.mediaPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(this.mediaPlayer.src);
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.fileInput = null;
        this.uploadButton = null;
        this.loadFromFolderButton = null;
        this.mediaList = null;
        this.audioPlayer = null;
        this.videoPlayer = null;
        this.mediaControls = null;
        this.playButton = null;
        this.pauseButton = null;
        this.stopButton = null;
        this.volumeSlider = null;
        this.progressBar = null;
        this.timeDisplay = null;
        this.currentMedia = null;
        this.mediaFiles = [];
        this.directoryHandle = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Media Player closed. Thank you!");
    }
}

// Create a singleton instance
const songsVideosScreenLoader = new SongsVideosScreenLoader();

// Add this to your AI's command handling
if (/media player|music player|video player|play songs|play videos/i.test(userInputRaw)) {
    songsVideosScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    songsVideosScreenLoader.closeGame();
    return;
}

class CaptureScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'CODE CAPTURE',
            instructions: 'Capture, edit, and analyze code from developer tools. Supports syntax highlighting and code analysis.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.codeInput = null;
        this.codeDisplay = null;
        this.languageSelect = null;
        this.captureButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.analyzeButton = null;
        this.outputDiv = null;
        this.currentCode = '';
        this.currentLanguage = 'javascript';
        this.capturedSnippets = [];
        this.storageKey = 'capturedCodeSnippets';
    }

    /**
     * Load the Code Capture Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createCaptureScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.loadCapturedSnippets();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Code Capture UI
     */
    createCaptureScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #1e1e1e;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
            color: #d4d4d4;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Code Capture Tool';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #ffffff;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Capture and analyze code from developer tools (F12)';
        subtitle.style.cssText = `
            margin: 0;
            color: #cccccc;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Instructions section
        const instructionsSection = document.createElement('div');
        instructionsSection.style.cssText = `
            background-color: #2d2d30;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #007acc;
        `;
        instructionsSection.innerHTML = `
            <strong style="color: #ffffff;">How to capture code:</strong><br>
            1. Open developer tools (F12) in your browser<br>
            2. Copy the code you want to capture<br>
            3. Paste it in the input area below<br>
            4. Select the programming language<br>
            5. Click "Capture Code" to format and analyze
        `;
        baseContainer.appendChild(instructionsSection);

        // Language selection
        const languageSection = document.createElement('div');
        languageSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const languageLabel = document.createElement('label');
        languageLabel.textContent = 'Programming Language:';
        languageLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.languageSelect = document.createElement('select');
        this.languageSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            box-sizing: border-box;
        `;
        const languages = [
            { value: 'javascript', text: 'JavaScript' },
            { value: 'html', text: 'HTML' },
            { value: 'css', text: 'CSS' },
            { value: 'python', text: 'Python' },
            { value: 'java', text: 'Java' },
            { value: 'cpp', text: 'C++' },
            { value: 'csharp', text: 'C#' },
            { value: 'php', text: 'PHP' },
            { value: 'ruby', text: 'Ruby' },
            { value: 'go', text: 'Go' },
            { value: 'rust', text: 'Rust' },
            { value: 'typescript', text: 'TypeScript' },
            { value: 'json', text: 'JSON' },
            { value: 'xml', text: 'XML' },
            { value: 'sql', text: 'SQL' },
            { value: 'bash', text: 'Bash' },
            { value: 'markdown', text: 'Markdown' }
        ];
        languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang.value;
            option.textContent = lang.text;
            this.languageSelect.appendChild(option);
        });
        this.languageSelect.addEventListener('change', (e) => {
            this.currentLanguage = e.target.value;
        });
        languageSection.appendChild(languageLabel);
        languageSection.appendChild(this.languageSelect);
        baseContainer.appendChild(languageSection);

        // Code input area
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Paste Your Code Here:';
        inputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.codeInput = document.createElement('textarea');
        this.codeInput.style.cssText = `
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            resize: vertical;
            box-sizing: border-box;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        `;
        this.codeInput.placeholder = `// Paste your code here
// For example:
function helloWorld() {
    console.log("Hello, World!");
}`;
        this.codeInput.addEventListener('input', () => {
            this.currentCode = this.codeInput.value;
        });
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.codeInput);
        baseContainer.appendChild(inputSection);

        // Action buttons
        const buttonSection = document.createElement('div');
        buttonSection.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        `;
        this.captureButton = this.createButton('Capture Code', '#007acc', () => {
            this.captureCode();
        });
        this.clearButton = this.createButton('Clear', '#dc3545', () => {
            this.clearCode();
        });
        this.copyButton = this.createButton('Copy', '#28a745', () => {
            this.copyCode();
        });
        this.analyzeButton = this.createButton('Analyze', '#ffc107', () => {
            this.analyzeCode();
        });
        buttonSection.appendChild(this.captureButton);
        buttonSection.appendChild(this.clearButton);
        buttonSection.appendChild(this.copyButton);
        buttonSection.appendChild(this.analyzeButton);
        baseContainer.appendChild(buttonSection);

        // Code display area
        const displaySection = document.createElement('div');
        displaySection.style.cssText = `
            margin-bottom: 20px;
        `;
        const displayLabel = document.createElement('label');
        displayLabel.textContent = 'Formatted Code:';
        displayLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.codeDisplay = document.createElement('pre');
        this.codeDisplay.style.cssText = `
            width: 100%;
            min-height: 150px;
            max-height: 300px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        `;
        this.codeDisplay.textContent = '// Your formatted code will appear here';
        displaySection.appendChild(displayLabel);
        displaySection.appendChild(this.codeDisplay);
        baseContainer.appendChild(displaySection);

        // Output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Analysis Output:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.outputDiv = document.createElement('div');
        this.outputDiv.style.cssText = `
            width: 100%;
            min-height: 100px;
            max-height: 200px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        `;
        this.outputDiv.textContent = '// Code analysis results will appear here';
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputDiv);
        baseContainer.appendChild(outputSection);

        // Captured snippets section
        const snippetsSection = document.createElement('div');
        snippetsSection.style.cssText = `
            margin-top: auto;
        `;
        const snippetsLabel = document.createElement('label');
        snippetsLabel.textContent = 'Captured Snippets:';
        snippetsLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.snippetsList = document.createElement('div');
        this.snippetsList.style.cssText = `
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #2d2d30;
            padding: 10px;
        `;
        this.snippetsList.textContent = 'No captured snippets yet';
        snippetsSection.appendChild(snippetsLabel);
        snippetsSection.appendChild(this.snippetsList);
        baseContainer.appendChild(snippetsSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Capture and format the code
     */
    captureCode() {
        if (!this.currentCode.trim()) {
            this.outputDiv.textContent = '// Error: No code to capture';
            return;
        }

        // Format the code with syntax highlighting
        const formattedCode = this.formatCode(this.currentCode, this.currentLanguage);
        this.codeDisplay.innerHTML = formattedCode;

        // Save to captured snippets
        const snippet = {
            id: Date.now(),
            code: this.currentCode,
            language: this.currentLanguage,
            timestamp: new Date().toLocaleString(),
            lines: this.currentCode.split('\n').length
        };
        this.capturedSnippets.push(snippet);
        this.saveCapturedSnippets();
        this.updateSnippetsList();

        // Basic analysis
        this.analyzeCode();

        botReply(`Code captured successfully (${snippet.lines} lines of ${this.currentLanguage})`);
    }

    /**
     * Format code with syntax highlighting
     */
    formatCode(code, language) {
        let formatted = code
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');

        // Apply language-specific highlighting
        switch (language) {
            case 'javascript':
            case 'typescript':
                formatted = this.highlightJavaScript(formatted);
                break;
            case 'html':
                formatted = this.highlightHTML(formatted);
                break;
            case 'css':
                formatted = this.highlightCSS(formatted);
                break;
            case 'python':
                formatted = this.highlightPython(formatted);
                break;
            case 'json':
                formatted = this.highlightJSON(formatted);
                break;
            case 'sql':
                formatted = this.highlightSQL(formatted);
                break;
            default:
                // Generic highlighting for other languages
                formatted = this.highlightGeneric(formatted);
        }

        return formatted;
    }

    /**
     * Highlight JavaScript/TypeScript code
     */
    highlightJavaScript(code) {
        // Keywords
        const keywords = /\b(function|var|let|const|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|class|extends|import|export|default|async|await|new|this|super|typeof|instanceof|in|of|delete|void|yield|debugger)\b/g;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /(['"`])((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*|0x[0-9a-fA-F]+)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        // Functions
        const functions = /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        code = code.replace(functions, '<span style="color: #dcdcaa;">$1</span>(');

        return code;
    }

    /**
     * Highlight HTML code
     */
    highlightHTML(code) {
        // Tags
        const tags = /(&lt;\/?[a-zA-Z0-9]+&gt;)/g;
        code = code.replace(tags, '<span style="color: #569cd6;">$&</span>');

        // Attributes
        const attributes = /\b([a-zA-Z-]+)=["'][^"']*["']/g;
        code = code.replace(attributes, '<span style="color: #9cdcfe;">$1</span>=');

        // Strings in attributes
        const attrStrings = /=["']([^"']*)["']/g;
        code = code.replace(attrStrings, '=<span style="color: #ce9178;">"$1"</span>');

        // Comments
        const comments = /(&lt;!--[\s\S]*?--&gt;)/g;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Highlight CSS code
     */
    highlightCSS(code) {
        // Selectors
        const selectors = /([^{]+)\{/g;
        code = code.replace(selectors, '<span style="color: #d7ba7d;">$1</span>{');

        // Properties
        const properties = /\b([a-zA-Z-]+)\s*:/g;
        code = code.replace(properties, '<span style="color: #9cdcfe;">$1</span>:');

        // Values
        const values = /:\s*([^;]+);/g;
        code = code.replace(values, ': <span style="color: #ce9178;">$1</span>;');

        // Numbers in values
        const numbers = /\b(\d+\.?\d*)(px|em|rem|%|vh|vw|pt|pc|in|cm|mm)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$1$2</span>');

        // Colors
        const colors = /#[0-9a-fA-F]{3,6}\b/g;
        code = code.replace(colors, '<span style="color: #ce9178;">$&</span>');

        // Comments
        const comments = /\/\*[\s\S]*?\*\//g;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Highlight Python code
     */
    highlightPython(code) {
        // Keywords
        const keywords = /\b(def|class|if|elif|else|for|while|try|except|finally|with|as|import|from|return|yield|raise|assert|del|pass|break|continue|and|or|not|in|is|lambda|global|nonlocal)\b/g;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /('''|"""|'|"")((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(#.*$)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        // Functions
        const functions = /\bdef\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        code = code.replace(functions, 'def <span style="color: #dcdcaa;">$1</span>');

        return code;
    }

    /**
     * Highlight JSON code
     */
    highlightJSON(code) {
        // Strings
        const strings = /"([^"]*)":/g;
        code = code.replace(strings, '<span style="color: #9cdcfe;">"$1"</span>:');

        // String values
        const values = /:\s*"([^"]*)"/g;
        code = code.replace(values, ': <span style="color: #ce9178;">"$1"</span>');

        // Numbers
        const numbers = /:\s*(\d+\.?\d*)/g;
        code = code.replace(numbers, ': <span style="color: #b5cea8;">$1</span>');

        // Booleans
        const booleans = /:\s*(true|false|null)/g;
        code = code.replace(booleans, ': <span style="color: #569cd6;">$1</span>');

        return code;
    }

    /**
     * Highlight SQL code
     */
    highlightSQL(code) {
        // Keywords
        const keywords = /\b(SELECT|FROM|WHERE|INSERT|INTO|VALUES|UPDATE|SET|DELETE|CREATE|TABLE|DROP|ALTER|JOIN|INNER|LEFT|RIGHT|FULL|OUTER|ON|GROUP|BY|ORDER|HAVING|LIMIT|OFFSET|UNION|ALL|DISTINCT|AS|AND|OR|NOT|IN|EXISTS|BETWEEN|LIKE|IS|NULL)\b/gi;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /'[^']*'/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$&</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(--.*$|\/\*[\s\S]*?\*\/)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Generic highlighting for other languages
     */
    highlightGeneric(code) {
        // Strings
        const strings = /(['"`])((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments (// style)
        const lineComments = /\/\/.*$/gm;
        code = code.replace(lineComments, '<span style="color: #6a9955;">$&</span>');

        // Comments (/* */ style)
        const blockComments = /\/\*[\s\S]*?\*\//g;
        code = code.replace(blockComments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Analyze the captured code
     */
    analyzeCode() {
        if (!this.currentCode.trim()) {
            this.outputDiv.textContent = '// Error: No code to analyze';
            return;
        }

        let analysis = `// Code Analysis Results\n`;
        analysis += `// Language: ${this.currentLanguage.toUpperCase()}\n`;
        analysis += `// Lines: ${this.currentCode.split('\n').length}\n`;
        analysis += `// Characters: ${this.currentCode.length}\n\n`;

        // Basic analysis based on language
        switch (this.currentLanguage) {
            case 'javascript':
            case 'typescript':
                analysis += this.analyzeJavaScript();
                break;
            case 'html':
                analysis += this.analyzeHTML();
                break;
            case 'css':
                analysis += this.analyzeCSS();
                break;
            case 'python':
                analysis += this.analyzePython();
                break;
            case 'json':
                analysis += this.analyzeJSON();
                break;
            case 'sql':
                analysis += this.analyzeSQL();
                break;
            default:
                analysis += '// Basic analysis completed\n';
        }

        this.outputDiv.textContent = analysis;
    }

    /**
     * Analyze JavaScript code
     */
    analyzeJavaScript() {
        let analysis = '// JavaScript Analysis:\n';
        
        // Count functions
        const functionCount = (this.currentCode.match(/\bfunction\b/g) || []).length;
        analysis += `// Functions: ${functionCount}\n`;
        
        // Count variables
        const varCount = (this.currentCode.match(/\b(var|let|const)\b/g) || []).length;
        analysis += `// Variables: ${varCount}\n`;
        
        // Check for async/await
        const hasAsync = /async/.test(this.currentCode);
        analysis += `// Uses async/await: ${hasAsync ? 'Yes' : 'No'}\n`;
        
        // Check for promises
        const hasPromises = /Promise/.test(this.currentCode);
        analysis += `// Uses Promises: ${hasPromises ? 'Yes' : 'No'}\n`;
        
        // Check for arrow functions
        const arrowCount = (this.currentCode.match(/=>/g) || []).length;
        analysis += `// Arrow functions: ${arrowCount}\n`;
        
        return analysis;
    }

    /**
     * Analyze HTML code
     */
    analyzeHTML() {
        let analysis = '// HTML Analysis:\n';
        
        // Count tags
        const tagCount = (this.currentCode.match(/&lt;\/?[a-zA-Z0-9]+&gt;/g) || []).length;
        analysis += `// HTML tags: ${tagCount}\n`;
        
        // Check for common tags
        const hasDiv = /&lt;div/i.test(this.currentCode);
        analysis += `// Contains div elements: ${hasDiv ? 'Yes' : 'No'}\n`;
        
        const hasForm = /&lt;form/i.test(this.currentCode);
        analysis += `// Contains forms: ${hasForm ? 'Yes' : 'No'}\n`;
        
        const hasScript = /&lt;script/i.test(this.currentCode);
        analysis += `// Contains scripts: ${hasScript ? 'Yes' : 'No'}\n`;
        
        const hasStyle = /&lt;style/i.test(this.currentCode);
        analysis += `// Contains styles: ${hasStyle ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze CSS code
     */
    analyzeCSS() {
        let analysis = '// CSS Analysis:\n';
        
        // Count selectors
        const selectorCount = (this.currentCode.match(/[^{]+(?=\{)/g) || []).length;
        analysis += `// CSS selectors: ${selectorCount}\n`;
        
        // Count properties
        const propertyCount = (this.currentCode.match(/[a-zA-Z-]+(?=:)/g) || []).length;
        analysis += `// CSS properties: ${propertyCount}\n`;
        
        // Check for media queries
        const hasMediaQueries = /@media/.test(this.currentCode);
        analysis += `// Contains media queries: ${hasMediaQueries ? 'Yes' : 'No'}\n`;
        
        // Check for animations
        const hasAnimations = /@keyframes|animation/.test(this.currentCode);
        analysis += `// Contains animations: ${hasAnimations ? 'Yes' : 'No'}\n`;
        
        // Check for flexbox
        const hasFlexbox = /display:\s*flex/i.test(this.currentCode);
        analysis += `// Uses flexbox: ${hasFlexbox ? 'Yes' : 'No'}\n`;
        
        // Check for grid
        const hasGrid = /display:\s*grid/i.test(this.currentCode);
        analysis += `// Uses grid: ${hasGrid ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze Python code
     */
    analyzePython() {
        let analysis = '// Python Analysis:\n';
        
        // Count functions
        const functionCount = (this.currentCode.match(/\bdef\b/g) || []).length;
        analysis += `// Functions: ${functionCount}\n`;
        
        // Count classes
        const classCount = (this.currentCode.match(/\bclass\b/g) || []).length;
        analysis += `// Classes: ${classCount}\n`;
        
        // Check for imports
        const importCount = (this.currentCode.match(/\bimport\b/g) || []).length;
        analysis += `// Import statements: ${importCount}\n`;
        
        // Check for loops
        const forCount = (this.currentCode.match(/\bfor\b/g) || []).length;
        const whileCount = (this.currentCode.match(/\bwhile\b/g) || []).length;
        analysis += `// For loops: ${forCount}\n`;
        analysis += `// While loops: ${whileCount}\n`;
        
        // Check for comprehensions
        const hasComprehensions = /\[.*for.*in.*\]/.test(this.currentCode);
        analysis += `// Uses comprehensions: ${hasComprehensions ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze JSON code
     */
    analyzeJSON() {
        let analysis = '// JSON Analysis:\n';
        
        try {
            const parsed = JSON.parse(this.currentCode);
            
            // Check if it's an object or array
            if (Array.isArray(parsed)) {
                analysis += `// Type: Array\n`;
                analysis += `// Elements: ${parsed.length}\n`;
            } else if (typeof parsed === 'object' && parsed !== null) {
                analysis += `// Type: Object\n`;
                analysis += `// Properties: ${Object.keys(parsed).length}\n`;
            }
            
            // Check for nested structures
            const hasNested = JSON.stringify(parsed).includes('{');
            analysis += `// Has nested structures: ${hasNested ? 'Yes' : 'No'}\n`;
            
        } catch (error) {
            analysis += `// Invalid JSON: ${error.message}\n`;
        }
        
        return analysis;
    }

    /**
     * Analyze SQL code
     */
    analyzeSQL() {
        let analysis = '// SQL Analysis:\n';
        
        // Check for SELECT statements
        const hasSelect = /SELECT/i.test(this.currentCode);
        analysis += `// Contains SELECT: ${hasSelect ? 'Yes' : 'No'}\n`;
        
        // Check for JOINs
        const joinCount = (this.currentCode.match(/JOIN/gi) || []).length;
        analysis += `// JOINs: ${joinCount}\n`;
        
        // Check for subqueries
        const hasSubqueries = /\(.*SELECT/i.test(this.currentCode);
        analysis += `// Contains subqueries: ${hasSubqueries ? 'Yes' : 'No'}\n`;
        
        // Check for aggregations
        const hasAggregations = /(COUNT|SUM|AVG|MIN|MAX)/i.test(this.currentCode);
        analysis += `// Uses aggregations: ${hasAggregations ? 'Yes' : 'No'}\n`;
        
        // Check for GROUP BY
        const hasGroupBy = /GROUP BY/i.test(this.currentCode);
        analysis += `// Uses GROUP BY: ${hasGroupBy ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Clear the code input and display
     */
    clearCode() {
        this.currentCode = '';
        this.codeInput.value = '';
        this.codeDisplay.textContent = '// Your formatted code will appear here';
        this.outputDiv.textContent = '// Code analysis results will appear here';
        botReply('Code cleared');
    }

    /**
     * Copy the formatted code to clipboard
     */
    copyCode() {
        if (!this.currentCode.trim()) {
            botReply('No code to copy');
            return;
        }

        if (navigator.clipboard) {
            navigator.clipboard.writeText(this.currentCode)
                .then(() => {
                    botReply('Code copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(this.currentCode);
                });
        } else {
            this.fallbackCopyTextToClipboard(this.currentCode);
        }
    }

    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Code copied to clipboard!');
            } else {
                botReply('Unable to copy code');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy code');
        }
        document.body.removeChild(textArea);
    }

    /**
     * Save captured snippets to localStorage
     */
    saveCapturedSnippets() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.capturedSnippets));
        } catch (error) {
            console.error('Error saving captured snippets:', error);
        }
    }

    /**
     * Load captured snippets from localStorage
     */
    loadCapturedSnippets() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                this.capturedSnippets = JSON.parse(stored);
                this.updateSnippetsList();
            }
        } catch (error) {
            console.error('Error loading captured snippets:', error);
        }
    }

    /**
     * Update the snippets list display
     */
    updateSnippetsList() {
        this.snippetsList.innerHTML = '';
        
        if (this.capturedSnippets.length === 0) {
            this.snippetsList.textContent = 'No captured snippets yet';
            return;
        }
        
        this.capturedSnippets.forEach(snippet => {
            const item = document.createElement('div');
            item.style.cssText = `
                padding: 8px;
                margin-bottom: 5px;
                background-color: #1e1e1e;
                border-radius: 5px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background-color 0.2s;
            `;
            item.addEventListener('mouseenter', () => {
                item.style.backgroundColor = '#2d2d30';
            });
            item.addEventListener('mouseleave', () => {
                item.style.backgroundColor = '#1e1e1e';
            });
            
            const snippetInfo = document.createElement('div');
            snippetInfo.style.cssText = `
                flex-grow: 1;
            `;
            const snippetTitle = document.createElement('div');
            snippetTitle.textContent = `${snippet.language.toUpperCase()} - ${snippet.lines} lines`;
            snippetTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 2px;
                color: #ffffff;
            `;
            const snippetDetails = document.createElement('div');
            snippetDetails.textContent = snippet.timestamp;
            snippetDetails.style.cssText = `
                font-size: 12px;
                color: #999999;
            `;
            snippetInfo.appendChild(snippetTitle);
            snippetInfo.appendChild(snippetDetails);
            
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load';
            loadButton.style.cssText = `
                padding: 4px 8px;
                background-color: #007acc;
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
                font-size: 12px;
            `;
            loadButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.loadSnippet(snippet);
            });
            
            item.appendChild(snippetInfo);
            item.appendChild(loadButton);
            this.snippetsList.appendChild(item);
        });
    }

    /**
     * Load a captured snippet
     */
    loadSnippet(snippet) {
        this.currentCode = snippet.code;
        this.currentLanguage = snippet.language;
        this.codeInput.value = snippet.code;
        this.languageSelect.value = snippet.language;
        botReply(`Loaded snippet: ${snippet.language.toUpperCase()} - ${snippet.lines} lines`);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.ctrlKey && event.key === 'Enter') {
            event.preventDefault();
            this.captureCode();
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.codeInput = null;
        this.codeDisplay = null;
        this.languageSelect = null;
        this.captureButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.analyzeButton = null;
        this.outputDiv = null;
        this.snippetsList = null;
        this.currentCode = '';
        this.currentLanguage = 'javascript';
        this.capturedSnippets = [];
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Code Capture Tool closed. Thank you!");
    }
}

// Create a singleton instance
const captureScreenLoader = new CaptureScreenLoader();

// Add this to your AI's command handling
if (/code capture|capture code|f12 capture|developer tools/i.test(userInputRaw)) {
    captureScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    captureScreenLoader.closeGame();
    return;
}





class FileConverter {
constructor() {
this.baseScreen = {
name: 'FILE CONVERTER',
instructions: 'Convert images, text, or create Excel/DOCX files. Supports multiple formats.'
};

this.gameContainer = null;
this.isActive = false;
this.isFullscreen = false;
this.fullscreenButton = null;
this.closeButton = null;
this.fileInput = null;
this.textInput = null;
this.convertButton = null;
this.clearButton = null;
this.downloadButton = null;
this.imagePreview = null;
this.outputDiv = null;
this.selectedFiles = [];
this.conversionMode = 'image'; // 'image', 'text', 'excel', 'docx'
this.fileBlob = null;
}

/**
* Load the File Converter
*/
loadBaseScreen() {
if (this.isActive) {
botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
return;
}

this.createGameContainer();
this.createConverterScreen();
this.setupActionButtons();
this.displayGame();

this.isActive = true;
botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
}

/**
* Create the game container
*/
createGameContainer() {
const existingContainer = document.getElementById('screen-container');
if (existingContainer) {
existingContainer.remove();
}

this.gameContainer = document.createElement('div');
this.gameContainer.id = 'screen-container';
this.gameContainer.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 9999;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
`;
}

/**
* Create the Converter UI
*/
createConverterScreen() {
const baseContainer = document.createElement('div');
baseContainer.style.cssText = `
background-color: #f5f5f5;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
padding: 20px;
width: 700px;
max-width: 90vw;
max-height: 80vh;
display: flex;
flex-direction: column;
`;

// Header
const header = document.createElement('div');
header.style.cssText = `
text-align: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid #ddd;
`;

const title = document.createElement('h2');
title.textContent = 'File Converter';
title.style.cssText = `
margin: 0 0 10px 0;
color: #333;
font-size: 24px;
`;

const subtitle = document.createElement('p');
subtitle.textContent = 'Convert files to PDF, Excel, or DOCX format';
subtitle.style.cssText = `
margin: 0;
color: #666;
font-size: 16px;
`;

header.appendChild(title);
header.appendChild(subtitle);
baseContainer.appendChild(header);

// Conversion mode selector
const modeSection = document.createElement('div');
modeSection.style.cssText = `
margin-bottom: 15px;
display: flex;
justify-content: center;
gap: 15px;
flex-wrap: wrap;
`;

// Image mode
const imageModeLabel = this.createModeLabel('Image to PDF', 'image', true);
modeSection.appendChild(imageModeLabel);

// Text mode
const textModeLabel = this.createModeLabel('Text to PDF', 'text', false);
modeSection.appendChild(textModeLabel);

// Excel mode
const excelModeLabel = this.createModeLabel('Create Excel', 'excel', false);
modeSection.appendChild(excelModeLabel);

// DOCX mode
const docxModeLabel = this.createModeLabel('Create DOCX', 'docx', false);
modeSection.appendChild(docxModeLabel);

baseContainer.appendChild(modeSection);

// Image input section (initially visible)
this.imageSection = document.createElement('div');
this.imageSection.id = 'imageSection';

const uploadLabel = document.createElement('label');
uploadLabel.textContent = 'Select Images:';
uploadLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.fileInput = document.createElement('input');
this.fileInput.type = 'file';
this.fileInput.multiple = true;
this.fileInput.accept = 'image/*';
this.fileInput.style.cssText = `
width: 100%;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
margin-bottom: 10px;
`;

this.fileInput.addEventListener('change', (e) => {
this.handleFileSelect(e);
});

this.imageSection.appendChild(uploadLabel);
this.imageSection.appendChild(this.fileInput);
baseContainer.appendChild(this.imageSection);

// Text input section (initially hidden)
this.textSection = document.createElement('div');
this.textSection.id = 'textSection';
this.textSection.style.display = 'none';

const textLabel = document.createElement('label');
textLabel.textContent = 'Enter Text:';
textLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.textInput = document.createElement('textarea');
this.textInput.placeholder = 'Enter text to convert to PDF...';
this.textInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.textSection.appendChild(textLabel);
this.textSection.appendChild(this.textInput);
baseContainer.appendChild(this.textSection);

// Excel input section (initially hidden)
this.excelSection = document.createElement('div');
this.excelSection.id = 'excelSection';
this.excelSection.style.display = 'none';

const excelLabel = document.createElement('label');
excelLabel.textContent = 'Excel Data (CSV format):';
excelLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.excelInput = document.createElement('textarea');
this.excelInput.placeholder = 'Enter data in CSV format:\nName,Age,City\nJohn,25,New York\nJane,30,Los Angeles';
this.excelInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.excelSection.appendChild(excelLabel);
this.excelSection.appendChild(this.excelInput);
baseContainer.appendChild(this.excelSection);

// DOCX input section (initially hidden)
this.docxSection = document.createElement('div');
this.docxSection.id = 'docxSection';
this.docxSection.style.display = 'none';

const docxLabel = document.createElement('label');
docxLabel.textContent = 'Document Content:';
docxLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.docxInput = document.createElement('textarea');
this.docxInput.placeholder = 'Enter document content...';
this.docxInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.docxSection.appendChild(docxLabel);
this.docxSection.appendChild(this.docxInput);
baseContainer.appendChild(this.docxSection);

// Preview area (for images)
this.imagePreview = document.createElement('div');
this.imagePreview.style.cssText = `
width: 100%;
min-height: 120px;
max-height: 200px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow-y: auto;
margin-bottom: 15px;
display: flex;
flex-wrap: wrap;
gap: 10px;
`;

this.imagePreview.textContent = 'No images selected';
baseContainer.appendChild(this.imagePreview);

// Button grid
const buttonGrid = document.createElement('div');
buttonGrid.style.cssText = `
display: grid;
grid-template-columns: repeat(3, 1fr);
grid-gap: 10px;
margin-bottom: 15px;
`;

// Convert button
this.convertButton = this.createButton('Convert to PDF', '#4CAF50', () => {
this.convertFile();
});

// Clear button
this.clearButton = this.createButton('Clear', '#f44336', () => {
this.clearFields();
});

// Download button (initially disabled)
this.downloadButton = this.createButton('Download File', '#2196F3', () => {
this.downloadFile();
});
this.downloadButton.disabled = true;
this.downloadButton.style.opacity = '0.5';
this.downloadButton.style.cursor = 'not-allowed';

buttonGrid.appendChild(this.convertButton);
buttonGrid.appendChild(this.clearButton);
buttonGrid.appendChild(this.downloadButton);

baseContainer.appendChild(buttonGrid);

// Output section
const outputSection = document.createElement('div');
outputSection.style.cssText = `
margin-bottom: 15px;
`;

const outputLabel = document.createElement('label');
outputLabel.textContent = 'Status:';
outputLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.outputDiv = document.createElement('div');
this.outputDiv.style.cssText = `
width: 100%;
min-height: 80px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
`;

this.outputDiv.textContent = 'Ready to convert files';

outputSection.appendChild(outputLabel);
outputSection.appendChild(this.outputDiv);
baseContainer.appendChild(outputSection);

// Info section
const infoSection = document.createElement('div');
infoSection.style.cssText = `
background-color: #e3f2fd;
border-radius: 5px;
padding: 10px;
font-size: 14px;
color: #1976d2;
border-left: 4px solid #2196F3;
`;

infoSection.innerHTML = `
<strong>Instructions:</strong><br>
            • Select conversion mode: Image, Text, Excel, or DOCX<br>
            • For images: Select one or more images<br>
            • For text: Enter your text in the text area<br>
            • For Excel: Enter data in CSV format<br>
            • For DOCX: Enter document content<br>
            • Click "Convert" to process and "Download" to save
        `;

        baseContainer.appendChild(infoSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Create a mode label with radio button
     */
    createModeLabel(text, value, isChecked) {
        const label = document.createElement('label');
        label.style.cssText = `
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;

        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'conversionMode';
        radio.value = value;
        radio.checked = isChecked;
        radio.style.marginRight = '5px';

        radio.addEventListener('change', () => {
            this.setConversionMode(value);
        });

        label.appendChild(radio);
        label.appendChild(document.createTextNode(text));

        return label;
    }

    /**
     * Set conversion mode
     */
    setConversionMode(mode) {
        this.conversionMode = mode;

        // Hide all sections
        this.imageSection.style.display = 'none';
        this.textSection.style.display = 'none';
        this.excelSection.style.display = 'none';
        this.docxSection.style.display = 'none';
        this.imagePreview.style.display = 'none';

        // Show appropriate section and update UI
        switch (mode) {
            case 'image':
                this.imageSection.style.display = 'block';
                this.imagePreview.style.display = 'flex';
                this.convertButton.textContent = 'Convert to PDF';
                this.outputDiv.textContent = 'Ready to convert images to PDF';
                break;
            case 'text':
                this.textSection.style.display = 'block';
                this.convertButton.textContent = 'Convert to PDF';
                this.outputDiv.textContent = 'Ready to convert text to PDF';
                break;
            case 'excel':
                this.excelSection.style.display = 'block';
                this.convertButton.textContent = 'Create Excel File';
                this.outputDiv.textContent = 'Ready to create Excel file';
                break;
            case 'docx':
                this.docxSection.style.display = 'block';
                this.convertButton.textContent = 'Create DOCX File';
                this.outputDiv.textContent = 'Ready to create DOCX file';
                break;
        }

        // Reset download button
        this.downloadButton.disabled = true;
        this.downloadButton.style.opacity = '0.5';
        this.downloadButton.style.cursor = 'not-allowed';
        this.fileBlob = null;
    }

    /**
     * Handle file selection
     */
    handleFileSelect(event) {
        this.selectedFiles = Array.from(event.target.files);
        this.updateImagePreview();

        if (this.selectedFiles.length > 0) {
            this.outputDiv.textContent = `${this.selectedFiles.length} image(s) selected. Ready to convert.`;
        } else {
            this.outputDiv.textContent = 'No images selected.';
        }
    }

    /**
     * Update the image preview area
     */
    updateImagePreview() {
        this.imagePreview.innerHTML = '';

        if (this.selectedFiles.length === 0) {
            this.imagePreview.textContent = 'No images selected';
            return;
        }

        this.selectedFiles.forEach((file, index) => {
            const reader = new FileReader();

            reader.onload = (e) => {
                const imgContainer = document.createElement('div');
                imgContainer.style.cssText = `
                    position: relative;
                    width: 100px;
                    height: 100px;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    overflow: hidden;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                const img = document.createElement('img');
                img.src = e.target.result;
                img.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                `;

                const imgLabel = document.createElement('div');
                imgLabel.textContent = file.name;
                imgLabel.style.cssText = `
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    font-size: 10px;
                    padding: 2px;
                    text-align: center;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;

                imgContainer.appendChild(img);
                imgContainer.appendChild(imgLabel);
                this.imagePreview.appendChild(imgContainer);
            };

            reader.readAsDataURL(file);
        });
    }

    /**
     * Convert file based on selected mode
     */
    convertFile() {
        switch (this.conversionMode) {
            case 'image':
                this.convertImagesToPdf();
                break;
            case 'text':
                this.convertTextToPdf();
                break;
            case 'excel':
                this.convertToExcel();
                break;
            case 'docx':
                this.convertToDocx();
                break;
        }
    }

    /**
     * Convert images to PDF
     */
    convertImagesToPdf() {
        if (this.selectedFiles.length === 0) {
            botReply('Please select at least one image to convert.');
            return;
        }

        this.outputDiv.textContent = 'Converting images to PDF...';

        if (typeof window.jsPDF === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', () => {
                this.processImagesToPdf();
            });
        } else {
            this.processImagesToPdf();
        }
    }

    /**
     * Convert text to PDF
     */
    convertTextToPdf() {
        const text = this.textInput.value.trim();
        if (!text) {
            botReply('Please enter some text to convert.');
            return;
        }

        this.outputDiv.textContent = 'Converting text to PDF...';

        if (typeof window.jsPDF === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', () => {
                this.processTextToPdf(text);
            });
        } else {
            this.processTextToPdf(text);
        }
    }

    /**
     * Convert to Excel
     */
    convertToExcel() {
        const csvData = this.excelInput.value.trim();
        if (!csvData) {
            botReply('Please enter some data to convert to Excel.');
            return;
        }

        this.outputDiv.textContent = 'Creating Excel file...';

        if (typeof window.XLSX === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js', () => {
                this.processToExcel(csvData);
            });
        } else {
            this.processToExcel(csvData);
        }
    }

    /**
     * Convert to DOCX
     */
    convertToDocx() {
        const docContent = this.docxInput.value.trim();
        if (!docContent) {
            botReply('Please enter some content to create a DOCX file.');
            return;
        }

        this.outputDiv.textContent = 'Creating DOCX file...';

        if (typeof window.docx === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js', () => {
                this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js', () => {
                    this.processToDocx(docContent);
                });
            });
        } else {
            this.processToDocx(docContent);
        }
    }

    /**
     * Process images to create PDF
     */
    processImagesToPdf() {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();

        let processedImages = 0;
        const totalImages = this.selectedFiles.length;

        this.selectedFiles.forEach((file, index) => {
            const reader = new FileReader();

            reader.onload = (e) => {
                const imgData = e.target.result;
                const imgProps = pdf.getImageProperties(imgData);
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

                if (index > 0) {
                    pdf.addPage();
                }

                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);

                processedImages++;
                this.outputDiv.textContent = `Processing image ${processedImages} of ${totalImages}...`;

                if (processedImages === totalImages) {
                    this.fileBlob = pdf.output('blob');
                    this.outputDiv.textContent = `PDF created successfully with ${totalImages} image(s).`;

                    this.downloadButton.disabled = false;
                    this.downloadButton.style.opacity = '1';
                    this.downloadButton.style.cursor = 'pointer';

                    botReply('Images converted to PDF successfully!');
                }
            };

            reader.readAsDataURL(file);
        });
    }

    /**
     * Process text to create PDF
     */
    processTextToPdf(text) {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 15;
        const maxWidth = pageWidth - 2 * margin;

        const lines = pdf.splitTextToSize(text, maxWidth);
        pdf.text(lines, margin, margin);

        this.fileBlob = pdf.output('blob');
        this.outputDiv.textContent = 'PDF created successfully from text.';

        this.downloadButton.disabled = false;
        this.downloadButton.style.opacity = '1';
        this.downloadButton.style.cursor = 'pointer';

        botReply('Text converted to PDF successfully!');
    }

    /**
     * Process CSV data to create Excel file
     */
    processToExcel(csvData) {
        // Parse CSV data
        const lines = csvData.split('\n');
        const data = [];

        lines.forEach(line => {
            const values = line.split(',');
            data.push(values);
        });

        // Create workbook
        const workbook = XLSX.utils.book_new();
        const worksheet = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');

        // Generate Excel file
        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        this.fileBlob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

        this.outputDiv.textContent = 'Excel file created successfully.';

        this.downloadButton.disabled = false;
        this.downloadButton.style.opacity = '1';
        this.downloadButton.style.cursor = 'pointer';

        botReply('Excel file created successfully!');
    }

    /**
     * Process text to create DOCX file
     */
    processToDocx(docContent) {
        // Create document
        const doc = new docx.Document({
            sections: [{
                properties: {},
                children: [
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun(docContent)
                        ],
                    }),
                ],
            }],
        });

        // Generate DOCX file
        docx.Packer.toBlob(doc).then(blob => {
            this.fileBlob = blob;

            this.outputDiv.textContent = 'DOCX file created successfully.';

            this.downloadButton.disabled = false;
            this.downloadButton.style.opacity = '1';
            this.downloadButton.style.cursor = 'pointer';

            botReply('DOCX file created successfully!');
        });
    }

    /**
     * Download the generated file
     */
    downloadFile() {
        if (!this.fileBlob) {
            botReply('No file available for download. Please convert files first.');
            return;
        }

        let fileName = 'converted-file';
        let fileExtension = '.pdf';

        switch (this.conversionMode) {
            case 'image':
                fileName = 'converted-images';
                fileExtension = '.pdf';
                break;
            case 'text':
                fileName = 'converted-text';
                fileExtension = '.pdf';
                break;
            case 'excel':
                fileName = 'converted-data';
                fileExtension = '.xlsx';
                break;
            case 'docx':
                fileName = 'converted-document';
                fileExtension = '.docx';
                break;
        }

        const url = URL.createObjectURL(this.fileBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName + fileExtension;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        botReply('File downloaded successfully!');
    }

    /**
     * Clear all fields and selections
     */
    clearFields() {
        this.fileInput.value = '';
        this.textInput.value = '';
        this.excelInput.value = '';
        this.docxInput.value = '';
        this.selectedFiles = [];
        this.imagePreview.innerHTML = '';
        this.imagePreview.textContent = 'No images selected';
        this.outputDiv.textContent = `Ready to convert ${this.conversionMode}`;
        this.fileBlob = null;

        this.downloadButton.disabled = true;
        this.downloadButton.style.opacity = '0.5';
        this.downloadButton.style.cursor = 'not-allowed';

        botReply('Fields cleared.');
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;

        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });

        button.addEventListener('click', clickHandler);

        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;

        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };

        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };

        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };

        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;

        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };

        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };

        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };

        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);

        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);

        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;

        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;

        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;

        if (this.isFullscreen) {
            this.exitFullscreen();
        }

        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);

        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }

        this.gameContainer = null;
        this.fileInput = null;
        this.textInput = null;
        this.excelInput = null;
        this.docxInput = null;
        this.convertButton = null;
        this.clearButton = null;
        this.downloadButton = null;
        this.imagePreview = null;
        this.outputDiv = null;
        this.selectedFiles = [];
        this.fileBlob = null;
        this.conversionMode = 'image';
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;

        botReply("File Converter closed. Thank you!");
    }
}

// Create a singleton instance
const fileConverter = new FileConverter();

// Add this to your AI's command handling
if (/file converter|pdf convert|convert file|image to pdf|text to pdf|excel|docx|create excel|create docx/i.test(userInputRaw)) {
    fileConverter.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    fileConverter.closeGame();
    return;
}



class AllDocMount {
constructor() {
this.baseScreen = {
name: 'DOCUMENT MANAGER',
instructions: 'Upload, view, edit, download, and copy documents. Supports PDF, DOCX, TXT, and image files.'
};

this.gameContainer = null;
this.isActive = false;
this.isFullscreen = false;
this.fullscreenButton = null;
this.closeButton = null;
this.fileInput = null;
this.viewButton = null;
this.editButton = null;
this.copyButton = null;
this.downloadButton = null;
this.clearButton = null;
this.previewArea = null;
this.editorArea = null;
this.outputDiv = null;
this.currentFile = null;
this.fileContent = null;
this.fileType = null;
this.fileName = null;
this.isEditing = false;
}

/**
* Load the Document Manager
*/
loadBaseScreen() {
if (this.isActive) {
botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
return;
}

this.createGameContainer();
this.createDocManagerScreen();
this.setupActionButtons();
this.displayGame();

this.isActive = true;
botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
}

/**
* Create the game container
*/
createGameContainer() {
const existingContainer = document.getElementById('screen-container');
if (existingContainer) {
existingContainer.remove();
}

this.gameContainer = document.createElement('div');
this.gameContainer.id = 'screen-container';
this.gameContainer.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 9999;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
`;
}

/**
* Create the Document Manager UI
*/
createDocManagerScreen() {
const baseContainer = document.createElement('div');
baseContainer.style.cssText = `
background-color: #f5f5f5;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
padding: 20px;
width: 800px;
max-width: 90vw;
max-height: 80vh;
display: flex;
flex-direction: column;
`;

// Header
const header = document.createElement('div');
header.style.cssText = `
text-align: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid #ddd;
`;

const title = document.createElement('h2');
title.textContent = 'Document Manager';
title.style.cssText = `
margin: 0 0 10px 0;
color: #333;
font-size: 24px;
`;

const subtitle = document.createElement('p');
subtitle.textContent = 'Upload, view, edit, download, and copy documents';
subtitle.style.cssText = `
margin: 0;
color: #666;
font-size: 16px;
`;

header.appendChild(title);
header.appendChild(subtitle);
baseContainer.appendChild(header);

// Upload section
const uploadSection = document.createElement('div');
uploadSection.style.cssText = `
margin-bottom: 15px;
`;

const uploadLabel = document.createElement('label');
uploadLabel.textContent = 'Upload Document:';
uploadLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.fileInput = document.createElement('input');
this.fileInput.type = 'file';
this.fileInput.accept = '.pdf,.docx,.txt,.jpg,.jpeg,.png,.gif,.csv,.json,.html,.xml';
this.fileInput.style.cssText = `
width: 100%;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
margin-bottom: 10px;
`;

this.fileInput.addEventListener('change', (e) => {
this.handleFileUpload(e);
});

uploadSection.appendChild(uploadLabel);
uploadSection.appendChild(this.fileInput);
baseContainer.appendChild(uploadSection);

// Button grid
const buttonGrid = document.createElement('div');
buttonGrid.style.cssText = `
display: grid;
grid-template-columns: repeat(5, 1fr);
grid-gap: 10px;
margin-bottom: 15px;
`;

// View button
this.viewButton = this.createButton('View', '#4CAF50', () => {
this.viewDocument();
});
this.viewButton.disabled = true;

// Edit button
this.editButton = this.createButton('Edit', '#2196F3', () => {
this.editDocument();
});
this.editButton.disabled = true;

// Copy button
this.copyButton = this.createButton('Copy', '#FF9800', () => {
this.copyDocument();
});
this.copyButton.disabled = true;

// Download button
this.downloadButton = this.createButton('Download', '#9C27B0', () => {
this.downloadDocument();
});
this.downloadButton.disabled = true;

// Clear button
this.clearButton = this.createButton('Clear', '#f44336', () => {
this.clearDocument();
});

buttonGrid.appendChild(this.viewButton);
buttonGrid.appendChild(this.editButton);
buttonGrid.appendChild(this.copyButton);
buttonGrid.appendChild(this.downloadButton);
buttonGrid.appendChild(this.clearButton);

baseContainer.appendChild(buttonGrid);

// Preview area
this.previewArea = document.createElement('div');
this.previewArea.style.cssText = `
width: 100%;
height: 300px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow: auto;
margin-bottom: 15px;
display: flex;
align-items: center;
justify-content: center;
`;

this.previewArea.textContent = 'No document uploaded';
baseContainer.appendChild(this.previewArea);

// Editor area (initially hidden)
this.editorArea = document.createElement('div');
this.editorArea.style.cssText = `
width: 100%;
height: 300px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow: auto;
margin-bottom: 15px;
display: none;
`;

const editorLabel = document.createElement('label');
editorLabel.textContent = 'Edit Document:';
editorLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.editorTextarea = document.createElement('textarea');
this.editorTextarea.style.cssText = `
width: 100%;
height: 250px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.editorArea.appendChild(editorLabel);
this.editorArea.appendChild(this.editorTextarea);
baseContainer.appendChild(this.editorArea);

// Output section
const outputSection = document.createElement('div');
outputSection.style.cssText = `
margin-bottom: 15px;
`;

const outputLabel = document.createElement('label');
outputLabel.textContent = 'Status:';
outputLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.outputDiv = document.createElement('div');
this.outputDiv.style.cssText = `
width: 100%;
min-height: 50px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
`;

this.outputDiv.textContent = 'Ready to upload a document';

outputSection.appendChild(outputLabel);
outputSection.appendChild(this.outputDiv);
baseContainer.appendChild(outputSection);

// Info section
const infoSection = document.createElement('div');
infoSection.style.cssText = `
background-color: #e3f2fd;
border-radius: 5px;
padding: 10px;
font-size: 14px;
color: #1976d2;
border-left: 4px solid #2196F3;
`;

infoSection.innerHTML = `
<strong>Instructions:</strong><br>
            • Upload a document using the file input<br>
            • View: Display the document in the preview area<br>
            • Edit: Edit text-based documents in the editor<br>
            • Copy: Copy document content to clipboard<br>
            • Download: Save the document to your device<br>
            • Clear: Reset the document manager
        `;

        baseContainer.appendChild(infoSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Handle file upload
     */
    handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) {
            this.outputDiv.textContent = 'No file selected';
            return;
        }

        this.currentFile = file;
        this.fileName = file.name;
        this.fileType = file.type;
        this.isEditing = false;

        // Show file info
        this.outputDiv.textContent = `File uploaded: ${this.fileName} (${this.formatFileSize(file.size)})`;

        // Enable buttons
        this.viewButton.disabled = false;
        this.downloadButton.disabled = false;
        this.clearButton.disabled = false;

        // Determine if file can be edited or copied
        const editableTypes = [
            'text/plain',
            'text/csv',
            'application/json',
            'text/html',
            'text/xml',
            'application/xml'
        ];

        if (editableTypes.includes(this.fileType) ||
            this.fileName.endsWith('.txt') ||
            this.fileName.endsWith('.csv') ||
            this.fileName.endsWith('.json') ||
            this.fileName.endsWith('.html') ||
            this.fileName.endsWith('.xml')) {
            this.editButton.disabled = false;
            this.copyButton.disabled = false;
        } else {
            this.editButton.disabled = true;
            this.copyButton.disabled = true;
        }

        // Read file content
        this.readFileContent(file);
    }

    /**
     * Read file content
     */
    readFileContent(file) {
        const reader = new FileReader();

        reader.onload = (e) => {
            this.fileContent = e.target.result;
            this.previewArea.innerHTML = '';

            // Display file based on type
            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = e.target.result;
                img.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                `;
                this.previewArea.appendChild(img);
            } else if (file.type === 'application/pdf') {
                const iframe = document.createElement('iframe');
                iframe.src = e.target.result;
                iframe.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                `;
                this.previewArea.appendChild(iframe);
            } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                // For DOCX files, we can't display directly, so show a message
                const message = document.createElement('div');
                message.textContent = 'DOCX file uploaded. Use Download to save or Edit if supported.';
                message.style.cssText = `
                    text-align: center;
                    color: #666;
                `;
                this.previewArea.appendChild(message);
            } else {
                // For text files, show a preview
                const pre = document.createElement('pre');
                pre.textContent = e.target.result;
                pre.style.cssText = `
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                `;
                this.previewArea.appendChild(pre);
            }
        };

        reader.onerror = () => {
            this.outputDiv.textContent = 'Error reading file';
        };

        // Read file based on type
        if (file.type.startsWith('image/') || file.type === 'application/pdf') {
            reader.readAsDataURL(file);
        } else {
            reader.readAsText(file);
        }
    }

    /**
     * View document
     */
    viewDocument() {
        if (!this.currentFile) {
            botReply('No document to view');
            return;
        }

        // Show preview area, hide editor
        this.previewArea.style.display = 'flex';
        this.editorArea.style.display = 'none';
        this.isEditing = false;

        botReply(`Viewing document: ${this.fileName}`);
    }

    /**
     * Edit document
     */
    editDocument() {
        if (!this.currentFile) {
            botReply('No document to edit');
            return;
        }

        if (this.editButton.disabled) {
            botReply('This document type cannot be edited');
            return;
        }

        // Show editor area, hide preview
        this.previewArea.style.display = 'none';
        this.editorArea.style.display = 'block';

        // Set editor content
        this.editorTextarea.value = this.fileContent;
        this.isEditing = true;

        botReply(`Editing document: ${this.fileName}`);
    }

    /**
     * Copy document content
     */
    copyDocument() {
        if (!this.currentFile) {
            botReply('No document to copy');
            return;
        }

        if (this.copyButton.disabled) {
            botReply('This document type cannot be copied');
            return;
        }

        // Get content to copy
        let contentToCopy = this.fileContent;
        if (this.isEditing) {
            contentToCopy = this.editorTextarea.value;
        }

        // Copy to clipboard
        if (navigator.clipboard) {
            navigator.clipboard.writeText(contentToCopy)
                .then(() => {
                    botReply('Document content copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(contentToCopy);
                });
        } else {
            this.fallbackCopyTextToClipboard(contentToCopy);
        }
    }

    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;

        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Document content copied to clipboard!');
            } else {
                botReply('Unable to copy document content');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy document content');
        }

        document.body.removeChild(textArea);
    }

    /**
     * Download document
     */
    downloadDocument() {
        if (!this.currentFile) {
            botReply('No document to download');
            return;
        }

        // Create download link
        const url = URL.createObjectURL(this.currentFile);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        botReply(`Document downloaded: ${this.fileName}`);
    }

    /**
     * Clear document
     */
    clearDocument() {
        this.currentFile = null;
        this.fileContent = null;
        this.fileType = null;
        this.fileName = null;
        this.isEditing = false;

        // Reset UI
        this.fileInput.value = '';
        this.previewArea.innerHTML = '';
        this.previewArea.textContent = 'No document uploaded';
        this.previewArea.style.display = 'flex';
        this.editorArea.style.display = 'none';
        this.editorTextarea.value = '';

        // Disable buttons
        this.viewButton.disabled = true;
        this.editButton.disabled = true;
        this.copyButton.disabled = true;
        this.downloadButton.disabled = true;

        this.outputDiv.textContent = 'Document cleared. Ready to upload a new document';

        botReply('Document cleared');
    }

    /**
     * Format file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';

        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;

        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });

        button.addEventListener('click', clickHandler);

        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;

        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };

        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };

        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };

        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;

        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };

        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };

        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };

        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);

        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);

        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;

        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;

        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;

        if (this.isFullscreen) {
            this.exitFullscreen();
        }

        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);

        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }

        this.gameContainer = null;
        this.fileInput = null;
        this.viewButton = null;
        this.editButton = null;
        this.copyButton = null;
        this.downloadButton = null;
        this.clearButton = null;
        this.previewArea = null;
        this.editorArea = null;
        this.outputDiv = null;
        this.currentFile = null;
        this.fileContent = null;
        this.fileType = null;
        this.fileName = null;
        this.isEditing = false;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;

        botReply("Document Manager closed. Thank you!");
    }
}

// Create a singleton instance
const allDocMount = new AllDocMount();

// Add this to your AI's command handling
if (/document manager|doc manager|file manager|upload document|view document|edit document/i.test(userInputRaw)) {
    allDocMount.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    allDocMount.closeGame();
    return;
}

class AdvancedCalendar {
    constructor() {
        this.baseScreen = {
            name: 'ADVANCED CALENDAR',
            instructions: 'Manage your schedule with events, reminders, and recurring tasks. All data is saved locally.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        
        // Calendar state
        this.currentDate = new Date();
        this.currentView = 'month'; // month, week, day, agenda
        this.events = [];
        this.reminders = [];
        this.selectedDate = null;
        this.selectedEvent = null;
        this.selectedReminder = null;
        
        // UI elements
        this.calendarGrid = null;
        this.monthYearDisplay = null;
        this.viewButtons = {};
        this.eventForm = null;
        this.eventsList = null;
        this.reminderForm = null;
        this.remindersList = null;
        this.searchInput = null;
        this.categoryFilter = null;
        this.eventDetailsModal = null;
        this.reminderDetailsModal = null;
        
        // Event categories with colors
        this.categories = [
            { id: 'work', name: 'Work', color: '#4285F4' },
            { id: 'personal', name: 'Personal', color: '#34A853' },
            { id: 'health', name: 'Health', color: '#FBBC05' },
            { id: 'social', name: 'Social', color: '#EA4335' },
            { id: 'other', name: 'Other', color: '#9C27B0' }
        ];
        
        // Load data from localStorage on initialization
        this.loadDataFromStorage();
    }

    /**
     * Load data from localStorage
     */
    loadDataFromStorage() {
        try {
            // Load events
            const eventsData = localStorage.getItem('advancedCalendar_events');
            if (eventsData) {
                const parsedEvents = JSON.parse(eventsData);
                // Convert date strings back to Date objects
                this.events = parsedEvents.map(event => ({
                    ...event,
                    date: new Date(event.date)
                }));
            }
            
            // Load reminders
            const remindersData = localStorage.getItem('advancedCalendar_reminders');
            if (remindersData) {
                const parsedReminders = JSON.parse(remindersData);
                // Convert date strings back to Date objects
                this.reminders = parsedReminders.map(reminder => ({
                    ...reminder,
                    date: new Date(reminder.date)
                }));
            }
        } catch (error) {
            console.error('Error loading data from localStorage:', error);
            // If there's an error, start with empty arrays
            this.events = [];
            this.reminders = [];
        }
    }

    /**
     * Save data to localStorage
     */
    saveDataToStorage() {
        try {
            // Save events
            localStorage.setItem('advancedCalendar_events', JSON.stringify(this.events));
            
            // Save reminders
            localStorage.setItem('advancedCalendar_reminders', JSON.stringify(this.reminders));
        } catch (error) {
            console.error('Error saving data to localStorage:', error);
            botReply('Error saving your data. Your browser may be in private mode or have storage disabled.');
        }
    }

    /**
     * Load the Advanced Calendar
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createCalendarScreen();
        this.setupActionButtons();
        this.renderCalendar();
        this.displayGame();
        this.isActive = true;
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) existingContainer.remove();
        
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }

    /**
     * Create the Advanced Calendar UI
     */
    createCalendarScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 1200px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Advanced Calendar';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 28px;
        `;
        header.appendChild(title);
        baseContainer.appendChild(header);

        // Top controls
        const topControls = document.createElement('div');
        topControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        `;

        // Navigation buttons
        const navButtons = document.createElement('div');
        navButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const todayButton = this.createButton('Today', '#4CAF50', () => {
            this.goToToday();
        });
        
        const prevButton = this.createButton('◀', '#2196F3', () => {
            this.navigatePrevious();
        });
        
        const nextButton = this.createButton('▶', '#2196F3', () => {
            this.navigateNext();
        });
        
        navButtons.appendChild(todayButton);
        navButtons.appendChild(prevButton);
        navButtons.appendChild(nextButton);
        topControls.appendChild(navButtons);

        // Month and year display
        this.monthYearDisplay = document.createElement('div');
        this.monthYearDisplay.style.cssText = `
            font-size: 24px;
            font-weight: bold;
            color: #333;
        `;
        topControls.appendChild(this.monthYearDisplay);

        // View buttons
        const viewButtonsContainer = document.createElement('div');
        viewButtonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        this.viewButtons.month = this.createButton('Month', '#FF9800', () => {
            this.setView('month');
        });
        this.viewButtons.month.classList.add('active');
        
        this.viewButtons.week = this.createButton('Week', '#FF9800', () => {
            this.setView('week');
        });
        
        this.viewButtons.day = this.createButton('Day', '#FF9800', () => {
            this.setView('day');
        });
        
        this.viewButtons.agenda = this.createButton('Agenda', '#FF9800', () => {
            this.setView('agenda');
        });
        
        viewButtonsContainer.appendChild(this.viewButtons.month);
        viewButtonsContainer.appendChild(this.viewButtons.week);
        viewButtonsContainer.appendChild(this.viewButtons.day);
        viewButtonsContainer.appendChild(this.viewButtons.agenda);
        topControls.appendChild(viewButtonsContainer);

        baseContainer.appendChild(topControls);

        // Search and filter
        const searchFilterContainer = document.createElement('div');
        searchFilterContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        `;
        
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search events...';
        this.searchInput.style.cssText = `
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        this.searchInput.addEventListener('input', () => {
            this.filterEvents();
        });
        searchFilterContainer.appendChild(this.searchInput);
        
        this.categoryFilter = document.createElement('select');
        this.categoryFilter.style.cssText = `
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = 'All Categories';
        this.categoryFilter.appendChild(allOption);
        
        this.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            this.categoryFilter.appendChild(option);
        });
        
        this.categoryFilter.addEventListener('change', () => {
            this.filterEvents();
        });
        searchFilterContainer.appendChild(this.categoryFilter);
        
        const addEventButton = this.createButton('Add Event', '#4CAF50', () => {
            this.showEventForm();
        });
        searchFilterContainer.appendChild(addEventButton);
        
        const addReminderButton = this.createButton('Add Reminder', '#9C27B0', () => {
            this.showReminderForm();
        });
        searchFilterContainer.appendChild(addReminderButton);
        
        // Add export/import buttons
        const exportButton = this.createButton('Export', '#607D8B', () => {
            this.exportData();
        });
        searchFilterContainer.appendChild(exportButton);
        
        const importButton = this.createButton('Import', '#607D8B', () => {
            this.importData();
        });
        searchFilterContainer.appendChild(importButton);
        
        baseContainer.appendChild(searchFilterContainer);

        // Main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-grow: 1;
            gap: 20px;
            overflow: hidden;
        `;

        // Calendar grid
        const calendarContainer = document.createElement('div');
        calendarContainer.style.cssText = `
            flex: 3;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        this.calendarGrid = document.createElement('div');
        this.calendarGrid.style.cssText = `
            width: 100%;
            overflow: auto;
            flex-grow: 1;
        `;
        calendarContainer.appendChild(this.calendarGrid);
        mainContent.appendChild(calendarContainer);

        // Sidebar
        const sidebar = document.createElement('div');
        sidebar.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: auto;
        `;
        
        // Events list
        const eventsSection = document.createElement('div');
        eventsSection.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        `;
        
        const eventsTitle = document.createElement('h3');
        eventsTitle.textContent = 'Upcoming Events';
        eventsTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        `;
        eventsSection.appendChild(eventsTitle);
        
        this.eventsList = document.createElement('div');
        this.eventsList.style.cssText = `
            max-height: 300px;
            overflow-y: auto;
        `;
        eventsSection.appendChild(this.eventsList);
        sidebar.appendChild(eventsSection);
        
        // Reminders list
        const remindersSection = document.createElement('div');
        remindersSection.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        `;
        
        const remindersTitle = document.createElement('h3');
        remindersTitle.textContent = 'Reminders';
        remindersTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        `;
        remindersSection.appendChild(remindersTitle);
        
        this.remindersList = document.createElement('div');
        this.remindersList.style.cssText = `
            max-height: 300px;
            overflow-y: auto;
        `;
        remindersSection.appendChild(this.remindersList);
        sidebar.appendChild(remindersSection);
        
        // Storage info
        const storageSection = document.createElement('div');
        storageSection.style.cssText = `
            background-color: #e8f5e9;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
            color: #2e7d32;
        `;
        
        const storageTitle = document.createElement('h3');
        storageTitle.textContent = 'Storage Info';
        storageTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 10px;
            color: #2e7d32;
            font-size: 16px;
        `;
        storageSection.appendChild(storageTitle);
        
        const storageInfo = document.createElement('p');
        storageInfo.textContent = 'All your events and reminders are automatically saved in your browser\'s local storage.';
        storageInfo.style.cssText = `
            margin: 0 0 10px 0;
        `;
        storageSection.appendChild(storageInfo);
        
        const clearButton = this.createButton('Clear All Data', '#f44336', () => {
            this.clearAllData();
        });
        clearButton.style.cssText = `
            padding: 8px 12px;
            font-size: 12px;
            margin-top: 10px;
        `;
        storageSection.appendChild(clearButton);
        
        sidebar.appendChild(storageSection);
        
        mainContent.appendChild(sidebar);
        baseContainer.appendChild(mainContent);

        // Event form (initially hidden)
        this.eventForm = this.createEventForm();
        baseContainer.appendChild(this.eventForm);
        
        // Reminder form (initially hidden)
        this.reminderForm = this.createReminderForm();
        baseContainer.appendChild(this.reminderForm);
        
        // Event details modal (initially hidden)
        this.eventDetailsModal = this.createEventDetailsModal();
        baseContainer.appendChild(this.eventDetailsModal);
        
        // Reminder details modal (initially hidden)
        this.reminderDetailsModal = this.createReminderDetailsModal();
        baseContainer.appendChild(this.reminderDetailsModal);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Create event form
     */
    createEventForm() {
        const form = document.createElement('div');
        form.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const formTitle = document.createElement('h3');
        formTitle.textContent = 'Add Event';
        formTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        form.appendChild(formTitle);
        
        // Title input
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('label');
        titleLabel.textContent = 'Event Title:';
        titleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        titleContainer.appendChild(titleLabel);
        
        const titleInput = document.createElement('input');
        titleInput.type = 'text';
        titleInput.placeholder = 'Enter event title';
        titleInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        titleContainer.appendChild(titleInput);
        form.appendChild(titleContainer);
        
        // Date and time inputs
        const dateTimeContainer = document.createElement('div');
        dateTimeContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        const dateContainer = document.createElement('div');
        dateContainer.style.cssText = `
            flex: 1;
        `;
        const dateLabel = document.createElement('label');
        dateLabel.textContent = 'Date:';
        dateLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        dateContainer.appendChild(dateLabel);
        
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        dateContainer.appendChild(dateInput);
        dateTimeContainer.appendChild(dateContainer);
        
        const timeContainer = document.createElement('div');
        timeContainer.style.cssText = `
            flex: 1;
        `;
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Time:';
        timeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        timeContainer.appendChild(timeLabel);
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        timeContainer.appendChild(timeInput);
        dateTimeContainer.appendChild(timeContainer);
        form.appendChild(dateTimeContainer);
        
        // Category selection
        const categoryContainer = document.createElement('div');
        categoryContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const categoryLabel = document.createElement('label');
        categoryLabel.textContent = 'Category:';
        categoryLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        categoryContainer.appendChild(categoryLabel);
        
        const categorySelect = document.createElement('select');
        categorySelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        this.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            categorySelect.appendChild(option);
        });
        categoryContainer.appendChild(categorySelect);
        form.appendChild(categoryContainer);
        
        // Recurring options
        const recurringContainer = document.createElement('div');
        recurringContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const recurringLabel = document.createElement('label');
        recurringLabel.textContent = 'Recurring:';
        recurringLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        recurringContainer.appendChild(recurringLabel);
        
        const recurringSelect = document.createElement('select');
        recurringSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const recurringOptions = [
            { value: 'none', text: 'Does not repeat' },
            { value: 'daily', text: 'Daily' },
            { value: 'weekly', text: 'Weekly' },
            { value: 'monthly', text: 'Monthly' },
            { value: 'yearly', text: 'Yearly' }
        ];
        
        recurringOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            recurringSelect.appendChild(opt);
        });
        recurringContainer.appendChild(recurringSelect);
        form.appendChild(recurringContainer);
        
        // Description textarea
        const descContainer = document.createElement('div');
        descContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        const descLabel = document.createElement('label');
        descLabel.textContent = 'Description:';
        descLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        descContainer.appendChild(descLabel);
        
        const descTextarea = document.createElement('textarea');
        descTextarea.placeholder = 'Enter event description (optional)';
        descTextarea.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
            resize: vertical;
            min-height: 80px;
        `;
        descContainer.appendChild(descTextarea);
        form.appendChild(descContainer);
        
        // Form buttons
        const formButtons = document.createElement('div');
        formButtons.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        `;
        
        const saveButton = this.createButton('Save', '#4CAF50', () => {
            this.saveEvent(
                titleInput.value,
                dateInput.value,
                timeInput.value,
                categorySelect.value,
                recurringSelect.value,
                descTextarea.value
            );
            form.style.display = 'none';
        });
        
        const cancelButton = this.createButton('Cancel', '#f44336', () => {
            form.style.display = 'none';
        });
        
        formButtons.appendChild(saveButton);
        formButtons.appendChild(cancelButton);
        form.appendChild(formButtons);
        
        return form;
    }

    /**
     * Create reminder form
     */
    createReminderForm() {
        const form = document.createElement('div');
        form.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const formTitle = document.createElement('h3');
        formTitle.textContent = 'Add Reminder';
        formTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        form.appendChild(formTitle);
        
        // Title input
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('label');
        titleLabel.textContent = 'Reminder Title:';
        titleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        titleContainer.appendChild(titleLabel);
        
        const titleInput = document.createElement('input');
        titleInput.type = 'text';
        titleInput.placeholder = 'Enter reminder title';
        titleInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        titleContainer.appendChild(titleInput);
        form.appendChild(titleContainer);
        
        // Date and time inputs
        const dateTimeContainer = document.createElement('div');
        dateTimeContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        const dateContainer = document.createElement('div');
        dateContainer.style.cssText = `
            flex: 1;
        `;
        const dateLabel = document.createElement('label');
        dateLabel.textContent = 'Date:';
        dateLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        dateContainer.appendChild(dateLabel);
        
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        dateContainer.appendChild(dateInput);
        dateTimeContainer.appendChild(dateContainer);
        
        const timeContainer = document.createElement('div');
        timeContainer.style.cssText = `
            flex: 1;
        `;
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Time:';
        timeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        timeContainer.appendChild(timeLabel);
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        timeContainer.appendChild(timeInput);
        dateTimeContainer.appendChild(timeContainer);
        form.appendChild(dateTimeContainer);
        
        // Repeat options
        const repeatContainer = document.createElement('div');
        repeatContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const repeatLabel = document.createElement('label');
        repeatLabel.textContent = 'Repeat:';
        repeatLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        repeatContainer.appendChild(repeatLabel);
        
        const repeatSelect = document.createElement('select');
        repeatSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const repeatOptions = [
            { value: 'none', text: 'Does not repeat' },
            { value: 'daily', text: 'Daily' },
            { value: 'weekly', text: 'Weekly' },
            { value: 'monthly', text: 'Monthly' },
            { value: 'yearly', text: 'Yearly' }
        ];
        
        repeatOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            repeatSelect.appendChild(opt);
        });
        repeatContainer.appendChild(repeatSelect);
        form.appendChild(repeatContainer);
        
        // Notification options
        const notifyContainer = document.createElement('div');
        notifyContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        const notifyLabel = document.createElement('label');
        notifyLabel.textContent = 'Notify me:';
        notifyLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        notifyContainer.appendChild(notifyLabel);
        
        const notifySelect = document.createElement('select');
        notifySelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const notifyOptions = [
            { value: '0', text: 'At time of event' },
            { value: '5', text: '5 minutes before' },
            { value: '15', text: '15 minutes before' },
            { value: '30', text: '30 minutes before' },
            { value: '60', text: '1 hour before' },
            { value: '1440', text: '1 day before' }
        ];
        
        notifyOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            notifySelect.appendChild(opt);
        });
        notifyContainer.appendChild(notifySelect);
        form.appendChild(notifyContainer);
        
        // Form buttons
        const formButtons = document.createElement('div');
        formButtons.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        `;
        
        const saveButton = this.createButton('Save', '#9C27B0', () => {
            this.saveReminder(
                titleInput.value,
                dateInput.value,
                timeInput.value,
                repeatSelect.value,
                notifySelect.value
            );
            form.style.display = 'none';
        });
        
        const cancelButton = this.createButton('Cancel', '#f44336', () => {
            form.style.display = 'none';
        });
        
        formButtons.appendChild(saveButton);
        formButtons.appendChild(cancelButton);
        form.appendChild(formButtons);
        
        return form;
    }

    /**
     * Create event details modal
     */
    createEventDetailsModal() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Event Details';
        modalTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        modal.appendChild(modalTitle);
        
        // Event details container
        const detailsContainer = document.createElement('div');
        detailsContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        // Title
        const titleRow = document.createElement('div');
        titleRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('span');
        titleLabel.textContent = 'Title: ';
        titleLabel.style.cssText = `
            font-weight: bold;
        `;
        const titleValue = document.createElement('span');
        titleValue.id = 'event-details-title';
        titleRow.appendChild(titleLabel);
        titleRow.appendChild(titleValue);
        detailsContainer.appendChild(titleRow);
        
        // Date and time
        const dateTimeRow = document.createElement('div');
        dateTimeRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const dateTimeLabel = document.createElement('span');
        dateTimeLabel.textContent = 'Date & Time: ';
        dateTimeLabel.style.cssText = `
            font-weight: bold;
        `;
        const dateTimeValue = document.createElement('span');
        dateTimeValue.id = 'event-details-datetime';
        dateTimeRow.appendChild(dateTimeLabel);
        dateTimeRow.appendChild(dateTimeValue);
        detailsContainer.appendChild(dateTimeRow);
        
        // Category
        const categoryRow = document.createElement('div');
        categoryRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const categoryLabel = document.createElement('span');
        categoryLabel.textContent = 'Category: ';
        categoryLabel.style.cssText = `
            font-weight: bold;
        `;
        const categoryValue = document.createElement('span');
        categoryValue.id = 'event-details-category';
        categoryRow.appendChild(categoryLabel);
        categoryRow.appendChild(categoryValue);
        detailsContainer.appendChild(categoryRow);
        
        // Recurring
        const recurringRow = document.createElement('div');
        recurringRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const recurringLabel = document.createElement('span');
        recurringLabel.textContent = 'Recurring: ';
        recurringLabel.style.cssText = `
            font-weight: bold;
        `;
        const recurringValue = document.createElement('span');
        recurringValue.id = 'event-details-recurring';
        recurringRow.appendChild(recurringLabel);
        recurringRow.appendChild(recurringValue);
        detailsContainer.appendChild(recurringRow);
        
        // Description
        const descriptionRow = document.createElement('div');
        descriptionRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const descriptionLabel = document.createElement('span');
        descriptionLabel.textContent = 'Description: ';
        descriptionLabel.style.cssText = `
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        `;
        const descriptionValue = document.createElement('div');
        descriptionValue.id = 'event-details-description';
        descriptionValue.style.cssText = `
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            min-height: 60px;
        `;
        descriptionRow.appendChild(descriptionLabel);
        descriptionRow.appendChild(descriptionValue);
        detailsContainer.appendChild(descriptionRow);
        
        modal.appendChild(detailsContainer);
        
        // Modal buttons
        const modalButtons = document.createElement('div');
        modalButtons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 10px;
        `;
        
        const deleteButton = this.createButton('Delete', '#f44336', () => {
            if (this.selectedEvent) {
                this.deleteEvent(this.selectedEvent.id);
                modal.style.display = 'none';
            }
        });
        
        const closeButton = this.createButton('Close', '#2196F3', () => {
            modal.style.display = 'none';
        });
        
        modalButtons.appendChild(deleteButton);
        modalButtons.appendChild(closeButton);
        modal.appendChild(modalButtons);
        
        return modal;
    }

    /**
     * Create reminder details modal
     */
    createReminderDetailsModal() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Reminder Details';
        modalTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        modal.appendChild(modalTitle);
        
        // Reminder details container
        const detailsContainer = document.createElement('div');
        detailsContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        // Title
        const titleRow = document.createElement('div');
        titleRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('span');
        titleLabel.textContent = 'Title: ';
        titleLabel.style.cssText = `
            font-weight: bold;
        `;
        const titleValue = document.createElement('span');
        titleValue.id = 'reminder-details-title';
        titleRow.appendChild(titleLabel);
        titleRow.appendChild(titleValue);
        detailsContainer.appendChild(titleRow);
        
        // Date and time
        const dateTimeRow = document.createElement('div');
        dateTimeRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const dateTimeLabel = document.createElement('span');
        dateTimeLabel.textContent = 'Date & Time: ';
        dateTimeLabel.style.cssText = `
            font-weight: bold;
        `;
        const dateTimeValue = document.createElement('span');
        dateTimeValue.id = 'reminder-details-datetime';
        dateTimeRow.appendChild(dateTimeLabel);
        dateTimeRow.appendChild(dateTimeValue);
        detailsContainer.appendChild(dateTimeRow);
        
        // Repeat
        const repeatRow = document.createElement('div');
        repeatRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const repeatLabel = document.createElement('span');
        repeatLabel.textContent = 'Repeat: ';
        repeatLabel.style.cssText = `
            font-weight: bold;
        `;
        const repeatValue = document.createElement('span');
        repeatValue.id = 'reminder-details-repeat';
        repeatRow.appendChild(repeatLabel);
        repeatRow.appendChild(repeatValue);
        detailsContainer.appendChild(repeatRow);
        
        // Notification
        const notifyRow = document.createElement('div');
        notifyRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const notifyLabel = document.createElement('span');
        notifyLabel.textContent = 'Notify: ';
        notifyLabel.style.cssText = `
            font-weight: bold;
        `;
        const notifyValue = document.createElement('span');
        notifyValue.id = 'reminder-details-notify';
        notifyRow.appendChild(notifyLabel);
        notifyRow.appendChild(notifyValue);
        detailsContainer.appendChild(notifyRow);
        
        modal.appendChild(detailsContainer);
        
        // Modal buttons
        const modalButtons = document.createElement('div');
        modalButtons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 10px;
        `;
        
        const deleteButton = this.createButton('Delete', '#f44336', () => {
            if (this.selectedReminder) {
                this.deleteReminder(this.selectedReminder.id);
                modal.style.display = 'none';
            }
        });
        
        const closeButton = this.createButton('Close', '#2196F3', () => {
            modal.style.display = 'none';
        });
        
        modalButtons.appendChild(deleteButton);
        modalButtons.appendChild(closeButton);
        modal.appendChild(modalButtons);
        
        return modal;
    }

    /**
     * Render calendar based on current view
     */
    renderCalendar() {
        // Update month/year display
        this.updateMonthYearDisplay();
        
        // Clear calendar grid
        this.calendarGrid.innerHTML = '';
        
        // Render based on current view
        switch (this.currentView) {
            case 'month':
                this.renderMonthView();
                break;
            case 'week':
                this.renderWeekView();
                break;
            case 'day':
                this.renderDayView();
                break;
            case 'agenda':
                this.renderAgendaView();
                break;
        }
        
        // Update events and reminders lists
        this.updateEventsList();
        this.updateRemindersList();
    }

    /**
     * Render month view
     */
    renderMonthView() {
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        
        // Create month header with day names
        const monthHeader = document.createElement('div');
        monthHeader.style.cssText = `
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            margin-bottom: 1px;
        `;
        
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        dayNames.forEach(day => {
            const dayHeader = document.createElement('div');
            dayHeader.textContent = day;
            dayHeader.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: center;
                font-weight: bold;
            `;
            monthHeader.appendChild(dayHeader);
        });
        
        this.calendarGrid.appendChild(monthHeader);
        
        // Get first day of month and number of days
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        // Create month grid
        const monthGrid = document.createElement('div');
        monthGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add empty cells for days before the first day of the month
        for (let i = 0; i < firstDay; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.style.cssText = `
                background-color: #fff;
                min-height: 100px;
            `;
            monthGrid.appendChild(emptyDay);
        }
        
        // Add cells for each day of the month
        for (let day = 1; day <= daysInMonth; day++) {
            const dayCell = document.createElement('div');
            dayCell.style.cssText = `
                background-color: #fff;
                min-height: 100px;
                padding: 5px;
                position: relative;
                cursor: pointer;
            `;
            
            // Highlight today
            const today = new Date();
            if (year === today.getFullYear() && month === today.getMonth() && day === today.getDate()) {
                dayCell.style.backgroundColor = '#e3f2fd';
            }
            
            // Add day number
            const dayNumber = document.createElement('div');
            dayNumber.textContent = day;
            dayNumber.style.cssText = `
                font-weight: bold;
                margin-bottom: 5px;
            `;
            dayCell.appendChild(dayNumber);
            
            // Add events for this day
            const date = new Date(year, month, day);
            const dayEvents = this.getEventsForDate(date);
            
            const eventsContainer = document.createElement('div');
            eventsContainer.style.cssText = `
                font-size: 12px;
                overflow: hidden;
            `;
            
            dayEvents.slice(0, 3).forEach(event => {
                const eventElement = document.createElement('div');
                eventElement.textContent = event.title;
                eventElement.style.cssText = `
                    background-color: ${event.color};
                    color: white;
                    padding: 2px 5px;
                    margin-bottom: 2px;
                    border-radius: 3px;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;
                eventsContainer.appendChild(eventElement);
            });
            
            if (dayEvents.length > 3) {
                const moreElement = document.createElement('div');
                moreElement.textContent = `+${dayEvents.length - 3} more`;
                moreElement.style.cssText = `
                    font-style: italic;
                    color: #666;
                `;
                eventsContainer.appendChild(moreElement);
            }
            
            dayCell.appendChild(eventsContainer);
            
            // Add click event to show event form
            dayCell.addEventListener('click', () => {
                this.selectedDate = new Date(year, month, day);
                this.showEventForm();
            });
            
            monthGrid.appendChild(dayCell);
        }
        
        this.calendarGrid.appendChild(monthGrid);
    }

    /**
     * Render week view
     */
    renderWeekView() {
        const today = new Date();
        const currentDay = this.currentDate.getDay();
        const startDate = new Date(this.currentDate);
        startDate.setDate(this.currentDate.getDate() - currentDay);
        
        // Create week header with day names
        const weekHeader = document.createElement('div');
        weekHeader.style.cssText = `
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            margin-bottom: 1px;
        `;
        
        // Empty cell for time column
        const emptyHeader = document.createElement('div');
        emptyHeader.style.cssText = `
            background-color: #f0f0f0;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        `;
        weekHeader.appendChild(emptyHeader);
        
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        for (let i = 0; i < 7; i++) {
            const date = new Date(startDate);
            date.setDate(startDate.getDate() + i);
            
            const dayHeader = document.createElement('div');
            dayHeader.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: center;
                font-weight: bold;
            `;
            
            // Highlight today
            if (date.toDateString() === today.toDateString()) {
                dayHeader.style.backgroundColor = '#e3f2fd';
            }
            
            dayHeader.innerHTML = `${dayNames[i]}<br>${date.getDate()}`;
            weekHeader.appendChild(dayHeader);
        }
        
        this.calendarGrid.appendChild(weekHeader);
        
        // Create time grid
        const timeGrid = document.createElement('div');
        timeGrid.style.cssText = `
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add time slots
        for (let hour = 0; hour < 24; hour++) {
            // Time label
            const timeLabel = document.createElement('div');
            timeLabel.textContent = `${hour === 0 ? '12' : hour > 12 ? hour - 12 : hour}:00 ${hour < 12 ? 'AM' : 'PM'}`;
            timeLabel.style.cssText = `
                background-color: #f0f0f0;
                padding: 5px;
                text-align: right;
                font-size: 12px;
            `;
            timeGrid.appendChild(timeLabel);
            
            // Add cells for each day
            for (let day = 0; day < 7; day++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + day);
                date.setHours(hour, 0, 0, 0);
                
                const hourCell = document.createElement('div');
                hourCell.style.cssText = `
                    background-color: #fff;
                    min-height: 50px;
                    position: relative;
                    cursor: pointer;
                `;
                
                // Highlight today's hour
                if (date.toDateString() === today.toDateString() && hour === today.getHours()) {
                    hourCell.style.backgroundColor = '#e3f2fd';
                }
                
                // Add events for this hour
                const hourEvents = this.getEventsForDateTime(date);
                
                hourEvents.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.textContent = event.title;
                    eventElement.style.cssText = `
                        background-color: ${event.color};
                        color: white;
                        padding: 2px 5px;
                        margin-bottom: 2px;
                        border-radius: 3px;
                        font-size: 12px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    `;
                    hourCell.appendChild(eventElement);
                });
                
                // Add click event to show event form
                hourCell.addEventListener('click', () => {
                    this.selectedDate = new Date(date);
                    this.showEventForm();
                });
                
                timeGrid.appendChild(hourCell);
            }
        }
        
        this.calendarGrid.appendChild(timeGrid);
    }

    /**
     * Render day view
     */
    renderDayView() {
        const date = new Date(this.currentDate);
        const today = new Date();
        
        // Create day header
        const dayHeader = document.createElement('div');
        dayHeader.style.cssText = `
            display: flex;
            background-color: #f0f0f0;
            padding: 15px;
            margin-bottom: 1px;
            align-items: center;
            justify-content: space-between;
        `;
        
        const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
        const monthName = date.toLocaleDateString('en-US', { month: 'long' });
        const dayNumber = date.getDate();
        const year = date.getFullYear();
        
        const dateDisplay = document.createElement('div');
        dateDisplay.textContent = `${dayName}, ${monthName} ${dayNumber}, ${year}`;
        dateDisplay.style.cssText = `
            font-size: 18px;
            font-weight: bold;
        `;
        
        // Highlight today
        if (date.toDateString() === today.toDateString()) {
            dateDisplay.style.color = '#2196F3';
        }
        
        dayHeader.appendChild(dateDisplay);
        
        const addButton = this.createButton('Add Event', '#4CAF50', () => {
            this.selectedDate = new Date(date);
            this.showEventForm();
        });
        dayHeader.appendChild(addButton);
        
        this.calendarGrid.appendChild(dayHeader);
        
        // Create time grid
        const timeGrid = document.createElement('div');
        timeGrid.style.cssText = `
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add time slots
        for (let hour = 0; hour < 24; hour++) {
            // Time label
            const timeLabel = document.createElement('div');
            timeLabel.textContent = `${hour === 0 ? '12' : hour > 12 ? hour - 12 : hour}:00 ${hour < 12 ? 'AM' : 'PM'}`;
            timeLabel.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: right;
                font-size: 14px;
            `;
            timeGrid.appendChild(timeLabel);
            
            // Hour cell
            const hourCell = document.createElement('div');
            hourCell.style.cssText = `
                background-color: #fff;
                min-height: 60px;
                position: relative;
                cursor: pointer;
                padding: 5px;
            `;
            
            // Highlight current hour
            if (date.toDateString() === today.toDateString() && hour === today.getHours()) {
                hourCell.style.backgroundColor = '#e3f2fd';
            }
            
            // Add events for this hour
            const hourDate = new Date(date);
            hourDate.setHours(hour, 0, 0, 0);
            const hourEvents = this.getEventsForDateTime(hourDate);
            
            hourEvents.forEach(event => {
                const eventElement = document.createElement('div');
                eventElement.style.cssText = `
                    background-color: ${event.color};
                    color: white;
                    padding: 8px;
                    margin-bottom: 5px;
                    border-radius: 5px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                `;
                
                const eventTitle = document.createElement('div');
                eventTitle.textContent = event.title;
                eventTitle.style.cssText = `
                    font-weight: bold;
                    margin-bottom: 3px;
                `;
                
                const eventTime = document.createElement('div');
                eventTime.textContent = event.time;
                eventTime.style.cssText = `
                    font-size: 12px;
                `;
                
                eventElement.appendChild(eventTitle);
                eventElement.appendChild(eventTime);
                hourCell.appendChild(eventElement);
            });
            
            // Add click event to show event form
            hourCell.addEventListener('click', () => {
                this.selectedDate = new Date(hourDate);
                this.showEventForm();
            });
            
            timeGrid.appendChild(hourCell);
        }
        
        this.calendarGrid.appendChild(timeGrid);
    }

    /**
     * Render agenda view
     */
    renderAgendaView() {
        const agendaContainer = document.createElement('div');
        agendaContainer.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            flex-grow: 1;
            overflow: auto;
        `;
        
        const agendaTitle = document.createElement('h3');
        agendaTitle.textContent = 'Agenda';
        agendaTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
        `;
        agendaContainer.appendChild(agendaTitle);
        
        // Get events for the next 7 days
        const events = [];
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const dayEvents = this.getEventsForDate(date);
            
            if (dayEvents.length > 0) {
                events.push({
                    date: new Date(date),
                    events: dayEvents
                });
            }
        }
        
        if (events.length === 0) {
            const noEvents = document.createElement('p');
            noEvents.textContent = 'No upcoming events in the next 7 days.';
            noEvents.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            agendaContainer.appendChild(noEvents);
        } else {
            events.forEach(day => {
                const dayContainer = document.createElement('div');
                dayContainer.style.cssText = `
                    margin-bottom: 20px;
                `;
                
                const dayHeader = document.createElement('h4');
                dayHeader.textContent = day.date.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric' 
                });
                dayHeader.style.cssText = `
                    margin-top: 0;
                    margin-bottom: 10px;
                    color: #333;
                    border-bottom: 1px solid #eee;
                    padding-bottom: 5px;
                `;
                dayContainer.appendChild(dayHeader);
                
                day.events.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.style.cssText = `
                        display: flex;
                        align-items: center;
                        padding: 10px;
                        margin-bottom: 8px;
                        border-radius: 5px;
                        background-color: #f9f9f9;
                        border-left: 4px solid ${event.color};
                        cursor: pointer;
                    `;
                    
                    const eventTime = document.createElement('div');
                    eventTime.textContent = event.time;
                    eventTime.style.cssText = `
                        min-width: 70px;
                        font-weight: bold;
                        color: #555;
                    `;
                    
                    const eventDetails = document.createElement('div');
                    eventDetails.style.cssText = `
                        margin-left: 15px;
                    `;
                    
                    const eventTitle = document.createElement('div');
                    eventTitle.textContent = event.title;
                    eventTitle.style.cssText = `
                        font-weight: bold;
                        margin-bottom: 3px;
                    `;
                    
                    const eventCategory = document.createElement('div');
                    eventCategory.textContent = event.categoryName;
                    eventCategory.style.cssText = `
                        font-size: 12px;
                        color: #666;
                    `;
                    
                    eventDetails.appendChild(eventTitle);
                    eventDetails.appendChild(eventCategory);
                    
                    eventElement.appendChild(eventTime);
                    eventElement.appendChild(eventDetails);
                    
                    eventElement.addEventListener('click', () => {
                        this.selectedEvent = event;
                        this.showEventDetails(event);
                    });
                    
                    dayContainer.appendChild(eventElement);
                });
                
                agendaContainer.appendChild(dayContainer);
            });
        }
        
        this.calendarGrid.appendChild(agendaContainer);
    }

    /**
     * Update month/year display
     */
    updateMonthYearDisplay() {
        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        
        const month = monthNames[this.currentDate.getMonth()];
        const year = this.currentDate.getFullYear();
        
        this.monthYearDisplay.textContent = `${month} ${year}`;
    }

    /**
     * Set calendar view
     */
    setView(view) {
        this.currentView = view;
        
        // Update active button
        Object.keys(this.viewButtons).forEach(key => {
            if (key === view) {
                this.viewButtons[key].classList.add('active');
            } else {
                this.viewButtons[key].classList.remove('active');
            }
        });
        
        this.renderCalendar();
    }

    /**
     * Navigate to previous period
     */
    navigatePrevious() {
        switch (this.currentView) {
            case 'month':
                this.currentDate.setMonth(this.currentDate.getMonth() - 1);
                break;
            case 'week':
                this.currentDate.setDate(this.currentDate.getDate() - 7);
                break;
            case 'day':
                this.currentDate.setDate(this.currentDate.getDate() - 1);
                break;
            case 'agenda':
                this.currentDate.setDate(this.currentDate.getDate() - 7);
                break;
        }
        this.renderCalendar();
    }

    /**
     * Navigate to next period
     */
    navigateNext() {
        switch (this.currentView) {
            case 'month':
                this.currentDate.setMonth(this.currentDate.getMonth() + 1);
                break;
            case 'week':
                this.currentDate.setDate(this.currentDate.getDate() + 7);
                break;
            case 'day':
                this.currentDate.setDate(this.currentDate.getDate() + 1);
                break;
            case 'agenda':
                this.currentDate.setDate(this.currentDate.getDate() + 7);
                break;
        }
        this.renderCalendar();
    }

    /**
     * Go to today
     */
    goToToday() {
        this.currentDate = new Date();
        this.renderCalendar();
    }

    /**
     * Show event form
     */
    showEventForm() {
        this.eventForm.style.display = 'block';
        
        // Set default date to selected date or today
        const dateInput = this.eventForm.querySelector('input[type="date"]');
        if (this.selectedDate) {
            dateInput.value = this.formatDateForInput(this.selectedDate);
        } else {
            dateInput.value = this.formatDateForInput(new Date());
        }
    }

    /**
     * Show reminder form
     */
    showReminderForm() {
        this.reminderForm.style.display = 'block';
        
        // Set default date to today
        const dateInput = this.reminderForm.querySelector('input[type="date"]');
        dateInput.value = this.formatDateForInput(new Date());
    }

    /**
     * Show event details modal
     */
    showEventDetails(event) {
        this.selectedEvent = event;
        
        // Populate modal with event details
        document.getElementById('event-details-title').textContent = event.title;
        document.getElementById('event-details-datetime').textContent = 
            `${event.date.toLocaleDateString()} at ${event.time}`;
        document.getElementById('event-details-category').textContent = event.categoryName;
        document.getElementById('event-details-recurring').textContent = 
            event.recurring === 'none' ? 'Does not repeat' : 
            event.recurring.charAt(0).toUpperCase() + event.recurring.slice(1);
        document.getElementById('event-details-description').textContent = 
            event.description || 'No description';
        
        // Show modal
        this.eventDetailsModal.style.display = 'block';
    }

    /**
     * Show reminder details modal
     */
    showReminderDetails(reminder) {
        this.selectedReminder = reminder;
        
        // Populate modal with reminder details
        document.getElementById('reminder-details-title').textContent = reminder.title;
        document.getElementById('reminder-details-datetime').textContent = 
            `${reminder.date.toLocaleDateString()} at ${reminder.time}`;
        document.getElementById('reminder-details-repeat').textContent = 
            reminder.repeat === 'none' ? 'Does not repeat' : 
            reminder.repeat.charAt(0).toUpperCase() + reminder.repeat.slice(1);
        
        // Format notification time
        let notifyText = 'At time of reminder';
        if (reminder.notifyBefore > 0) {
            if (reminder.notifyBefore < 60) {
                notifyText = `${reminder.notifyBefore} minutes before`;
            } else if (reminder.notifyBefore === 60) {
                notifyText = '1 hour before';
            } else if (reminder.notifyBefore === 1440) {
                notifyText = '1 day before';
            }
        }
        document.getElementById('reminder-details-notify').textContent = notifyText;
        
        // Show modal
        this.reminderDetailsModal.style.display = 'block';
    }

    /**
     * Save event
     */
    saveEvent(title, date, time, category, recurring, description) {
        if (!title || !date) {
            botReply('Please fill in the required fields (title and date).');
            return;
        }
        
        const eventDate = new Date(date);
        const event = {
            id: Date.now(),
            title,
            date: eventDate,
            time: time || 'All day',
            category,
            categoryName: this.categories.find(c => c.id === category).name,
            color: this.categories.find(c => c.id === category).color,
            recurring,
            description
        };
        
        this.events.push(event);
        this.saveDataToStorage(); // Save to localStorage
        this.renderCalendar();
        botReply(`Event "${title}" has been added to your calendar and saved.`);
    }

    /**
     * Save reminder
     */
    saveReminder(title, date, time, repeat, notifyBefore) {
        if (!title || !date) {
            botReply('Please fill in the required fields (title and date).');
            return;
        }
        
        const reminderDate = new Date(date);
        const reminder = {
            id: Date.now(),
            title,
            date: reminderDate,
            time: time || 'All day',
            repeat,
            notifyBefore: parseInt(notifyBefore)
        };
        
        this.reminders.push(reminder);
        this.saveDataToStorage(); // Save to localStorage
        this.renderCalendar();
        botReply(`Reminder "${title}" has been added to your calendar and saved.`);
    }

    /**
     * Delete event
     */
    deleteEvent(eventId) {
        if (confirm('Are you sure you want to delete this event?')) {
            this.events = this.events.filter(event => event.id !== eventId);
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('Event has been deleted.');
        }
    }

    /**
     * Delete reminder
     */
    deleteReminder(reminderId) {
        if (confirm('Are you sure you want to delete this reminder?')) {
            this.reminders = this.reminders.filter(reminder => reminder.id !== reminderId);
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('Reminder has been deleted.');
        }
    }

    /**
     * Get events for a specific date
     */
    getEventsForDate(date) {
        const dateStr = date.toDateString();
        return this.events.filter(event => {
            const eventDateStr = event.date.toDateString();
            return eventDateStr === dateStr;
        });
    }

    /**
     * Get events for a specific date and hour
     */
    getEventsForDateTime(dateTime) {
        const dateStr = dateTime.toDateString();
        const hour = dateTime.getHours();
        
        return this.events.filter(event => {
            const eventDateStr = event.date.toDateString();
            if (eventDateStr !== dateStr) return false;
            
            if (event.time === 'All day') return true;
            
            const eventHour = parseInt(event.time.split(':')[0]);
            const eventAmPm = event.time.includes('AM') ? 'AM' : 'PM';
            
            // Convert to 24-hour format for comparison
            let eventHour24 = eventHour;
            if (eventAmPm === 'PM' && eventHour !== 12) {
                eventHour24 += 12;
            } else if (eventAmPm === 'AM' && eventHour === 12) {
                eventHour24 = 0;
            }
            
            return eventHour24 === hour;
        });
    }

    /**
     * Update events list in sidebar
     */
    updateEventsList() {
        this.eventsList.innerHTML = '';
        
        // Get upcoming events (next 7 days)
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const nextWeek = new Date(today);
        nextWeek.setDate(today.getDate() + 7);
        
        const upcomingEvents = this.events.filter(event => {
            return event.date >= today && event.date <= nextWeek;
        });
        
        if (upcomingEvents.length === 0) {
            const noEvents = document.createElement('p');
            noEvents.textContent = 'No upcoming events.';
            noEvents.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            this.eventsList.appendChild(noEvents);
            return;
        }
        
        // Sort events by date and time
        upcomingEvents.sort((a, b) => {
            if (a.date < b.date) return -1;
            if (a.date > b.date) return 1;
            
            if (a.time === 'All day') return -1;
            if (b.time === 'All day') return 1;
            
            return a.time.localeCompare(b.time);
        });
        
        upcomingEvents.forEach(event => {
            const eventElement = document.createElement('div');
            eventElement.style.cssText = `
                padding: 10px;
                margin-bottom: 8px;
                border-radius: 5px;
                background-color: #f9f9f9;
                border-left: 4px solid ${event.color};
                cursor: pointer;
                position: relative;
            `;
            
            const eventTitle = document.createElement('div');
            eventTitle.textContent = event.title;
            eventTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 3px;
            `;
            
            const eventDate = document.createElement('div');
            eventDate.textContent = `${event.date.toLocaleDateString()} at ${event.time}`;
            eventDate.style.cssText = `
                font-size: 12px;
                color: #666;
            `;
            
            eventElement.appendChild(eventTitle);
            eventElement.appendChild(eventDate);
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '✕';
            deleteButton.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: #f44336;
                font-size: 16px;
                cursor: pointer;
                padding: 0;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteEvent(event.id);
            });
            eventElement.appendChild(deleteButton);
            
            eventElement.addEventListener('click', () => {
                this.selectedEvent = event;
                this.showEventDetails(event);
            });
            
            this.eventsList.appendChild(eventElement);
        });
    }

    /**
     * Update reminders list in sidebar
     */
    updateRemindersList() {
        this.remindersList.innerHTML = '';
        
        // Get active reminders
        const today = new Date();
        const activeReminders = this.reminders.filter(reminder => {
            return reminder.date >= today;
        });
        
        if (activeReminders.length === 0) {
            const noReminders = document.createElement('p');
            noReminders.textContent = 'No active reminders.';
            noReminders.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            this.remindersList.appendChild(noReminders);
            return;
        }
        
        // Sort reminders by date and time
        activeReminders.sort((a, b) => {
            if (a.date < b.date) return -1;
            if (a.date > b.date) return 1;
            
            if (a.time === 'All day') return -1;
            if (b.time === 'All day') return 1;
            
            return a.time.localeCompare(b.time);
        });
        
        activeReminders.forEach(reminder => {
            const reminderElement = document.createElement('div');
            reminderElement.style.cssText = `
                padding: 10px;
                margin-bottom: 8px;
                border-radius: 5px;
                background-color: #f9f9f9;
                border-left: 4px solid #9C27B0;
                cursor: pointer;
                position: relative;
            `;
            
            const reminderTitle = document.createElement('div');
            reminderTitle.textContent = reminder.title;
            reminderTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 3px;
            `;
            
            const reminderDate = document.createElement('div');
            reminderDate.textContent = `${reminder.date.toLocaleDateString()} at ${reminder.time}`;
            reminderDate.style.cssText = `
                font-size: 12px;
                color: #666;
            `;
            
            reminderElement.appendChild(reminderTitle);
            reminderElement.appendChild(reminderDate);
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '✕';
            deleteButton.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: #f44336;
                font-size: 16px;
                cursor: pointer;
                padding: 0;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteReminder(reminder.id);
            });
            reminderElement.appendChild(deleteButton);
            
            reminderElement.addEventListener('click', () => {
                this.selectedReminder = reminder;
                this.showReminderDetails(reminder);
            });
            
            this.remindersList.appendChild(reminderElement);
        });
    }

    /**
     * Filter events based on search and category
     */
    filterEvents() {
        const searchTerm = this.searchInput.value.toLowerCase();
        const selectedCategory = this.categoryFilter.value;
        
        // Implementation for filtering events
        // This would update the calendar view to show only matching events
        botReply(`Filtering events by: "${searchTerm}" and category: ${selectedCategory}`);
    }

    /**
     * Export data to JSON file
     */
    exportData() {
        const data = {
            events: this.events,
            reminders: this.reminders,
            exportDate: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `calendar-data-${new Date().toISOString().split('T')[0]}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        botReply('Calendar data exported successfully!');
    }

    /**
     * Import data from JSON file
     */
    importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            
            reader.onload = event => {
                try {
                    const data = JSON.parse(event.target.result);
                    
                    if (data.events && Array.isArray(data.events)) {
                        this.events = data.events.map(event => ({
                            ...event,
                            date: new Date(event.date)
                        }));
                    }
                    
                    if (data.reminders && Array.isArray(data.reminders)) {
                        this.reminders = data.reminders.map(reminder => ({
                            ...reminder,
                            date: new Date(reminder.date)
                        }));
                    }
                    
                    this.saveDataToStorage();
                    this.renderCalendar();
                    botReply('Calendar data imported successfully!');
                } catch (error) {
                    console.error('Error importing data:', error);
                    botReply('Error importing data. Please make sure the file is a valid calendar export.');
                }
            };
            
            reader.readAsText(file);
        };
        
        input.click();
    }

    /**
     * Clear all data
     */
    clearAllData() {
        if (confirm('Are you sure you want to clear all calendar data? This action cannot be undone.')) {
            this.events = [];
            this.reminders = [];
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('All calendar data has been cleared.');
        }
    }

    /**
     * Format date for input field
     */
    formatDateForInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            // Close any open modals first
            if (this.eventDetailsModal && this.eventDetailsModal.style.display === 'block') {
                this.eventDetailsModal.style.display = 'none';
                return;
            }
            
            if (this.reminderDetailsModal && this.reminderDetailsModal.style.display === 'block') {
                this.reminderDetailsModal.style.display = 'none';
                return;
            }
            
            if (this.eventForm && this.eventForm.style.display === 'block') {
                this.eventForm.style.display = 'none';
                return;
            }
            
            if (this.reminderForm && this.reminderForm.style.display === 'block') {
                this.reminderForm.style.display = 'none';
                return;
            }
            
            // Then handle fullscreen or close
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.calendarGrid = null;
        this.monthYearDisplay = null;
        this.viewButtons = {};
        this.eventForm = null;
        this.eventsList = null;
        this.reminderForm = null;
        this.remindersList = null;
        this.searchInput = null;
        this.categoryFilter = null;
        this.eventDetailsModal = null;
        this.reminderDetailsModal = null;
        this.currentDate = new Date();
        this.currentView = 'month';
        this.selectedDate = null;
        this.selectedEvent = null;
        this.selectedReminder = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Advanced Calendar closed. Your data has been saved locally.");
    }
}

// Create a singleton instance
const advancedCalendar = new AdvancedCalendar();

// Add this to your AI's command handling
if (/calendar|schedule|agenda|planner/i.test(userInputRaw)) {
    advancedCalendar.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    advancedCalendar.closeGame();
    return;
}

class CameraTextReader {
    constructor() {
        this.appName = 'CAMERA TEXT READER';
        this.instructions = 'Use your camera to capture and read text from images.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.textArea = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.textHistory = [];
        this.isCapturing = false;
        this.animationId = null;
        this.tesseractLoaded = false;
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasTextRecognition = 'TextDetector' in window || 
                                  (window.TextRecognition || window.webkitTextRecognition || 
                                   window.mozTextRecognition || window.msTextRecognition);
    }
    
    /**
     * Load the Camera Text Reader
     */
    loadCameraTextReader() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Preload Tesseract.js for better performance
        this.preloadTesseract();
        
        this.createAppContainer();
        this.createCameraTextReaderUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Preload Tesseract.js for better performance
     */
    preloadTesseract() {
        if (typeof Tesseract === 'undefined') {
            this.loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js')
                .then(() => {
                    this.tesseractLoaded = true;
                    console.log('Tesseract.js loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load Tesseract.js:', err);
                });
        } else {
            this.tesseractLoaded = true;
        }
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Please try a different browser.');
            return false;
        }
        
        if (!this.hasTextRecognition) {
            botReply('Your browser does not support text recognition. Using alternative method.');
            // We'll use a canvas-based approach as fallback
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
    }
    
    /**
     * Create the Camera Text Reader UI
     */
    createCameraTextReaderUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 900px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '📷';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // Camera container
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 50%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            display: none;
        `;
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '📸';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid white;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.captureAndReadText());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Image enhancement options
        const enhancementLabel = document.createElement('div');
        enhancementLabel.textContent = 'Image Enhancement:';
        enhancementLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const enhancementOptions = document.createElement('div');
        enhancementOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const autoEnhance = this.createToggleOption('Auto-Enhance', true);
        const highContrast = this.createToggleOption('High Contrast', false);
        const grayscale = this.createToggleOption('Grayscale', false);
        
        enhancementOptions.appendChild(autoEnhance);
        enhancementOptions.appendChild(highContrast);
        enhancementOptions.appendChild(grayscale);
        
        settingsPanel.appendChild(enhancementLabel);
        settingsPanel.appendChild(enhancementOptions);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Extracted Text';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copyText());
        
        const retryButton = document.createElement('button');
        retryButton.textContent = 'Retry';
        retryButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(255, 152, 0, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        retryButton.addEventListener('click', () => this.retryWithDifferentSettings());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearText());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(retryButton);
        actionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(actionButtons);
        
        // Text area for displaying extracted text
        this.textArea = document.createElement('textarea');
        this.textArea.placeholder = 'Captured text will appear here...';
        this.textArea.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            resize: none;
            outline: none;
            margin-bottom: 15px;
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Click the capture button to extract text from the camera';
        
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.textArea);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Initialize camera
        this.initializeCamera();
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `option-${label.replace(/\s+/g, '-').toLowerCase()}`;
        checkbox.checked = defaultValue;
        checkbox.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = checkbox.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(checkbox);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1920 }, // Higher resolution for better OCR
                    height: { ideal: 1080 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Point at text and click capture.');
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message);
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Capture image and extract text
     */
    async captureAndReadText() {
        if (this.isCapturing) {
            return;
        }
        
        this.isCapturing = true;
        this.updateStatus('Capturing image...');
        
        try {
            // Draw current video frame to canvas
            const context = this.canvasElement.getContext('2d');
            context.drawImage(this.videoElement, 0, 0, this.canvasElement.width, this.canvasElement.height);
            
            // Get image data
            const imageData = this.canvasElement.toDataURL('image/png');
            
            // Extract text from image
            await this.extractTextFromImage(imageData);
            
        } catch (error) {
            console.error('Error capturing image:', error);
            this.updateStatus('Error capturing image: ' + error.message);
        } finally {
            this.isCapturing = false;
        }
    }
    
    /**
     * Extract text from image using multiple methods
     */
    async extractTextFromImage(imageData) {
        this.updateStatus('Extracting text...');
        
        try {
            // Get enhancement options
            const autoEnhance = document.getElementById('option-auto-enhance').checked;
            const highContrast = document.getElementById('option-high-contrast').checked;
            const grayscale = document.getElementById('option-grayscale').checked;
            
            // Preprocess the image for better OCR results
            const processedImageData = await this.preprocessImage(imageData, {
                autoEnhance,
                highContrast,
                grayscale
            });
            
            // Method 1: Try using Tesseract.js (most reliable)
            if (this.tesseractLoaded) {
                const text = await this.extractWithTesseract(processedImageData);
                if (text && this.isValidText(text)) {
                    this.displayExtractedText(text);
                    return;
                }
            } else {
                // Try to load Tesseract if not already loaded
                await this.loadTesseractAndExtract(processedImageData);
                return;
            }
            
            // Method 2: Try using TextDetector API if available
            if ('TextDetector' in window) {
                const text = await this.extractWithTextDetector();
                if (text && this.isValidText(text)) {
                    this.displayExtractedText(text);
                    return;
                }
            }
            
            // Method 3: Fallback to server-side OCR
            const textFromServer = await this.extractWithServerOCR(processedImageData);
            if (textFromServer && this.isValidText(textFromServer)) {
                this.displayExtractedText(textFromServer);
                return;
            }
            
            this.updateStatus('Could not extract readable text. Please try again with better lighting or focus.');
            
        } catch (error) {
            console.error('Error extracting text:', error);
            this.updateStatus('Error extracting text: ' + error.message);
        }
    }
    
    /**
     * Preprocess image for better OCR results
     */
    async preprocessImage(imageData, options) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = img.width;
                canvas.height = img.height;
                
                // Draw the original image
                ctx.drawImage(img, 0, 0);
                
                // Get image data
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                let data = imageData.data;
                
                // Apply grayscale if selected
                if (options.grayscale) {
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = avg;     // red
                        data[i + 1] = avg; // green
                        data[i + 2] = avg; // blue
                    }
                }
                
                // Apply high contrast if selected
                if (options.highContrast) {
                    const threshold = 128;
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        const value = avg > threshold ? 255 : 0;
                        data[i] = value;     // red
                        data[i + 1] = value; // green
                        data[i + 2] = value; // blue
                    }
                }
                
                // Apply auto-enhance if selected
                if (options.autoEnhance) {
                    // Simple contrast enhancement
                    const factor = 1.5;
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * factor);     // red
                        data[i + 1] = Math.min(255, data[i + 1] * factor); // green
                        data[i + 2] = Math.min(255, data[i + 2] * factor); // blue
                    }
                }
                
                // Put the modified image data back
                ctx.putImageData(imageData, 0, 0);
                
                // Return the processed image as data URL
                resolve(canvas.toDataURL('image/png'));
            };
            
            img.src = imageData;
        });
    }
    
    /**
     * Load Tesseract and extract text
     */
    async loadTesseractAndExtract(imageData) {
        try {
            this.updateStatus('Loading text recognition engine...');
            
            // Load Tesseract.js if not already loaded
            if (!this.tesseractLoaded) {
                await this.loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js');
                this.tesseractLoaded = true;
            }
            
            // Extract text
            const text = await this.extractWithTesseract(imageData);
            if (text && this.isValidText(text)) {
                this.displayExtractedText(text);
            } else {
                this.updateStatus('Could not extract readable text. Please try again with better lighting or focus.');
            }
        } catch (error) {
            console.error('Error loading Tesseract:', error);
            this.updateStatus('Error loading text recognition engine. Please try again.');
        }
    }
    
    /**
     * Extract text using Tesseract.js with improved settings
     */
    async extractWithTesseract(imageData) {
        try {
            this.updateStatus('Extracting text with advanced recognition...');
            
            // Create a worker with improved settings
            const worker = await Tesseract.createWorker({
                logger: m => {
                    if (m.status === 'recognizing text') {
                        const progress = Math.round(m.progress * 100);
                        this.updateStatus(`Extracting text: ${progress}%`);
                    }
                },
            });
            
            // Initialize with English language
            await worker.loadLanguage('eng');
            await worker.initialize('eng');
            
            // Set parameters for better accuracy
            await worker.setParameters({
                tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
            });
            
            // Recognize text
            const result = await worker.recognize(imageData);
            
            // Terminate worker
            await worker.terminate();
            
            // Post-process the text to clean it up
            const cleanedText = this.cleanExtractedText(result.data.text);
            
            return cleanedText.trim() || null;
        } catch (error) {
            console.error('Tesseract error:', error);
            return null;
        }
    }
    
    /**
     * Clean up extracted text
     */
    cleanExtractedText(text) {
        if (!text) return '';
        
        // Replace common OCR errors
        let cleaned = text
            // Replace common misrecognized characters
            .replace(/ﬁ/g, 'fi')
            .replace(/ﬂ/g, 'fl')
            .replace(/ﬀ/g, 'ff')
            .replace(/ﬃ/g, 'ffi')
            .replace(/ﬄ/g, 'ffl')
            // Replace quotes and apostrophes
            .replace(/[""]/g, '"')
            .replace(/['']/g, "'")
            .replace(/['']/g, "'")
            // Replace dashes
            .replace(/[—–]/g, '-')
            // Remove extra spaces
            .replace(/\s+/g, ' ')
            // Remove empty lines
            .replace(/\n\s*\n/g, '\n\n')
            .replace(/^\s+|\s+$/g, '');
        
        return cleaned;
    }
    
    /**
     * Check if extracted text is valid
     */
    isValidText(text) {
        if (!text || text.trim() === '') {
            return false;
        }
        
        // Remove whitespace and check length
        const trimmed = text.trim();
        if (trimmed.length < 3) {
            return false;
        }
        
        // Check if text contains mostly special characters (likely not real text)
        const specialCharCount = (trimmed.match(/[^\w\s]/g) || []).length;
        const specialCharRatio = specialCharCount / trimmed.length;
        
        if (specialCharRatio > 0.7) {
            return false;
        }
        
        // Check if text contains at least some letters
        const letterCount = (trimmed.match(/[a-zA-Z]/g) || []).length;
        if (letterCount < 2) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Extract text using TextDetector API
     */
    async extractWithTextDetector() {
        try {
            // Create a TextDetector
            const textDetector = new TextDetector();
            
            // Detect text blocks
            const textBlocks = await textDetector.detect(this.videoElement);
            
            // Extract text from blocks
            let extractedText = '';
            textBlocks.forEach(block => {
                extractedText += block.rawValue + '\n';
            });
            
            return this.cleanExtractedText(extractedText).trim() || null;
        } catch (error) {
            console.error('TextDetector error:', error);
            return null;
        }
    }
    
    /**
     * Extract text using server-side OCR (simulated)
     */
    async extractWithServerOCR(imageData) {
        try {
            this.updateStatus('Using advanced text recognition...');
            
            // In a real implementation, you would send the image to a server
            // For this example, we'll simulate a response after a delay
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Simulate extracted text
                    // In a real implementation, this would be the actual text extracted from the image
                    const simulatedText = "This is a simulated text extraction result. In a real implementation, this would be the actual text extracted from the image using server-side OCR APIs like Google Vision, AWS Textract, or similar services.";
                    resolve(this.cleanExtractedText(simulatedText));
                }, 2000);
            });
        } catch (error) {
            console.error('Server OCR error:', error);
            return null;
        }
    }
    
    /**
     * Retry with different settings
     */
    async retryWithDifferentSettings() {
        if (!this.currentImage) {
            this.updateStatus('No image to retry with');
            return;
        }
        
        this.updateStatus('Retrying with different settings...');
        
        // Toggle enhancement options
        const autoEnhance = document.getElementById('option-auto-enhance');
        const highContrast = document.getElementById('option-high-contrast');
        const grayscale = document.getElementById('option-grayscale');
        
        // Try different combinations
        if (!autoEnhance.checked && !highContrast.checked && !grayscale.checked) {
            // First try: enable auto-enhance
            autoEnhance.checked = true;
        } else if (autoEnhance.checked && !highContrast.checked && !grayscale.checked) {
            // Second try: enable high contrast
            highContrast.checked = true;
        } else if (autoEnhance.checked && highContrast.checked && !grayscale.checked) {
            // Third try: enable grayscale
            grayscale.checked = true;
        } else {
            // Reset all options
            autoEnhance.checked = false;
            highContrast.checked = false;
            grayscale.checked = false;
        }
        
        // Try extraction again with new settings
        await this.extractTextFromImage(this.currentImage);
    }
    
    /**
     * Display extracted text
     */
    displayExtractedText(text) {
        if (!text || text.trim() === '') {
            this.updateStatus('No text found in the image. Please try again.');
            return;
        }
        
        // Store current image for potential retry
        this.currentImage = this.canvasElement.toDataURL('image/png');
        
        // Add to text area
        this.textArea.value = text;
        
        // Add to history
        this.textHistory.unshift({
            text: text,
            timestamp: new Date()
        });
        
        // Keep only last 10 items
        if (this.textHistory.length > 10) {
            this.textHistory = this.textHistory.slice(0, 10);
        }
        
        this.updateStatus('Text extracted successfully!');
        
        // Auto-scroll to bottom of text area
        this.textArea.scrollTop = this.textArea.scrollHeight;
    }
    
    /**
     * Copy text to clipboard
     */
    copyText() {
        const text = this.textArea.value;
        
        if (!text || text.trim() === '') {
            this.updateStatus('No text to copy');
            return;
        }
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.updateStatus('Text copied to clipboard!');
                })
                .catch(err => {
                    console.error('Clipboard API error:', err);
                    this.fallbackCopyTextToClipboard(text);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(text);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            document.execCommand('copy');
            this.updateStatus('Text copied to clipboard!');
        } catch (err) {
            console.error('Fallback copy error:', err);
            this.updateStatus('Failed to copy text');
        }
        
        document.body.removeChild(textArea);
    }
    
    /**
     * Clear text area
     */
    clearText() {
        this.textArea.value = '';
        this.currentImage = null;
        this.updateStatus('Text cleared');
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        this.resultDisplay.textContent = message;
    }
    
    /**
     * Load external script dynamically
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0f3460, #16213e);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.fullscreenButton.addEventListener('mouseover', () => {
            this.fullscreenButton.style.transform = 'scale(1.1)';
        });
        
        this.fullscreenButton.addEventListener('mouseout', () => {
            this.fullscreenButton.style.transform = 'scale(1)';
        });
        
        this.fullscreenButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        });
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '✕';
        this.closeButton.style.cssText = `
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, #e53935, #c62828);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.closeButton.addEventListener('mouseover', () => {
            this.closeButton.style.transform = 'scale(1.1)';
        });
        
        this.closeButton.addEventListener('mouseout', () => {
            this.closeButton.style.transform = 'scale(1)';
        });
        
        this.closeButton.addEventListener('click', (e) => {
            e.stopPropagation();
            this.closeApp();
        });
        
        floatingButtons.appendChild(this.closeButton);
        
        this.appContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.appContainer) return;
        
        if (this.appContainer.requestFullscreen) {
            this.appContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.appContainer.webkitRequestFullscreen) {
            this.appContainer.webkitRequestFullscreen();
        } else if (this.appContainer.msRequestFullscreen) {
            this.appContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        switch (event.key) {
            case 'Escape':
                if (this.isFullscreen) {
                    this.exitFullscreen();
                } else {
                    this.closeApp();
                }
                break;
            case 'Enter':
                // Capture image when Enter is pressed
                if (!this.isCapturing) {
                    this.captureAndReadText();
                }
                break;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        if (!this.isActive) return;
        
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Cancel any ongoing animations
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        // Reset variables
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.textArea = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment';
        this.flashMode = 'off';
        this.textHistory = [];
        this.isCapturing = false;
        this.animationId = null;
        this.tesseractLoaded = false;
        this.currentImage = null;
        
        botReply("Camera Text Reader closed. Thank you!");
    }
}

// Create a singleton instance
const cameraTextReader = new CameraTextReader();

// Add this to your AI's command handling
if (/camera text reader|text scanner|ocr|scan text/i.test(userInputRaw)) {
    cameraTextReader.loadCameraTextReader();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    cameraTextReader.closeApp();
    return;
}
class CameraObjectUnderstanding {
    constructor() {
        this.appName = 'CAMERA OBJECT UNDERSTANDING';
        this.instructions = 'Use your camera or upload an image to identify and understand objects.';
        
        this.appContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cameraContainer = null;
        this.videoElement = null;
        this.canvasElement = null;
        this.captureButton = null;
        this.resultDisplay = null;
        this.objectInfoDisplay = null;
        this.switchCameraButton = null;
        this.flashButton = null;
        this.currentStream = null;
        this.facingMode = 'environment'; // Start with back camera
        this.flashMode = 'off'; // off, on, auto
        this.objectHistory = [];
        this.isDetecting = false;
        this.animationId = null;
        this.detectedObjects = [];
        this.modelLoaded = false;
        this.continuousDetectionId = null;
        this.model = null; // Store the loaded model
        
        // Initialize tracking variables
        this.lastDetectedObjects = null;
        this.lastStatusUpdate = 0;
        this.lastErrorUpdate = 0;
        
        // Check if required APIs are available
        this.hasMediaDevices = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        this.hasObjectDetection = 'IntersectionObserver' in window || 
                                 (window.OffscreenCanvas && window.createImageBitmap);
    }
    
    /**
     * Load the Camera Object Understanding
     */
    loadCameraObjectUnderstanding() {
        if (this.isActive) {
            botReply(`The ${this.appName} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check for browser support
        if (!this.checkBrowserSupport()) {
            return;
        }
        
        // Preload ML model for better performance
        this.preloadModel();
        
        this.createAppContainer();
        this.createObjectUnderstandingUI();
        this.setupActionButtons();
        this.displayApp();
        
        this.isActive = true;
        botReply(`${this.appName} loaded! ${this.instructions}`);
    }
    
    /**
     * Preload ML model for better performance
     */
    preloadModel() {
        // Try to load TensorFlow.js and Coco-SSD model
        if (typeof tf === 'undefined') {
            this.updateStatus('Loading TensorFlow.js...');
            this.loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js')
                .then(() => {
                    this.updateStatus('Loading COCO-SSD model...');
                    return this.loadScript('Model.js');
                })
                .then(() => {
                    // Load the actual model
                    return cocoSsd.load();
                })
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        } else if (typeof cocoSsd !== 'undefined') {
            // If TensorFlow is already loaded, just load the model
            cocoSsd.load()
                .then(model => {
                    this.model = model;
                    this.modelLoaded = true;
                    console.log('Object detection model loaded successfully');
                    this.updateStatus('Object detection model loaded successfully');
                })
                .catch(err => {
                    console.error('Failed to load object detection model:', err);
                    this.updateStatus('Failed to load object detection model. Using simulation mode.');
                });
        }
    }
    
    /**
     * Dynamically load a script
     */
    loadScript(src) {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }
    
    /**
     * Check if browser supports required features
     */
    checkBrowserSupport() {
        if (!this.hasMediaDevices) {
            botReply('Your browser does not support camera access. Image upload will still work.');
            // We don't return false here, as the app can still function with image upload
        }
        
        if (!this.hasObjectDetection) {
            botReply('Your browser has limited support for object detection. Using alternative method.');
        }
        
        return true;
    }
    
    /**
     * Create the app container
     */
    createAppContainer() {
        const existingContainer = document.getElementById('app-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        this.appContainer = document.createElement('div');
        this.appContainer.id = 'app-container';
        this.appContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        // Add CSS for animations
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            .tab-button.active {
                background-color: rgba(33, 150, 243, 0.7);
                color: white;
            }
        `;
        document.head.appendChild(styleElement);
    }
    
    /**
     * Create the Camera Object Understanding UI
     */
    createObjectUnderstandingUI() {
        // Main card container
        const cardContainer = document.createElement('div');
        cardContainer.style.cssText = `
            background-color: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 90vw;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            background: linear-gradient(90deg, #0f3460, #16213e);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const titleIcon = document.createElement('div');
        titleIcon.textContent = '🔍';
        titleIcon.style.cssText = `
            font-size: 28px;
        `;
        
        const title = document.createElement('div');
        title.textContent = this.appName;
        title.style.cssText = `
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
        `;
        
        titleContainer.appendChild(titleIcon);
        titleContainer.appendChild(title);
        header.appendChild(titleContainer);
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = '⛶';
        this.fullscreenButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;
        
        this.fullscreenButton.addEventListener('click', () => this.toggleFullscreen());
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = '✕';
        this.closeButton.style.cssText = `
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s;
            margin-left: 10px;
        `;
        
        this.closeButton.addEventListener('click', () => this.closeApp());
        
        header.appendChild(this.fullscreenButton);
        header.appendChild(this.closeButton);
        cardContainer.appendChild(header);
        
        // Create main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 20px;
        `;
        
        // --- NEW: Tab Navigation ---
        const tabNavigation = document.createElement('div');
        tabNavigation.style.cssText = `
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const cameraTab = this.createTabButton('Camera', true, () => this.switchTab('camera'));
        const uploadTab = this.createTabButton('Upload Image', false, () => this.switchTab('upload'));
        
        tabNavigation.appendChild(cameraTab);
        tabNavigation.appendChild(uploadTab);
        
        // --- MODIFIED: Camera Container (now part of a tab content area) ---
        this.cameraContainer = document.createElement('div');
        this.cameraContainer.id = 'camera-content';
        this.cameraContainer.style.cssText = `
            position: relative;
            width: 100%;
            height: 60%;
            border-radius: 16px;
            overflow: hidden;
            background-color: #000;
            margin-bottom: 20px;
            display: block; // Initially visible
        `;
        
        // Video element for camera feed
        this.videoElement = document.createElement('video');
        this.videoElement.style.cssText = `
            width: 100%;
            height: 100%;
            object-fit: cover;
        `;
        this.videoElement.autoplay = true;
        this.videoElement.playsInline = true;
        
        // Canvas element for image capture and object detection
        this.canvasElement = document.createElement('canvas');
        this.canvasElement.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        `;
        
        // Camera controls
        const cameraControls = document.createElement('div');
        cameraControls.style.cssText = `
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        `;
        
        // Capture button
        this.captureButton = document.createElement('button');
        this.captureButton.innerHTML = '📸';
        this.captureButton.style.cssText = `
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 3px solid white;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        this.captureButton.addEventListener('click', () => this.detectObjects());
        
        // Switch camera button
        this.switchCameraButton = document.createElement('button');
        this.switchCameraButton.innerHTML = '🔄';
        this.switchCameraButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.switchCameraButton.addEventListener('click', () => this.switchCamera());
        
        // Flash button
        this.flashButton = document.createElement('button');
        this.flashButton.innerHTML = '⚡';
        this.flashButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        this.flashButton.addEventListener('click', () => this.toggleFlash());
        
        cameraControls.appendChild(this.switchCameraButton);
        cameraControls.appendChild(this.captureButton);
        cameraControls.appendChild(this.flashButton);
        
        this.cameraContainer.appendChild(this.videoElement);
        this.cameraContainer.appendChild(this.canvasElement);
        this.cameraContainer.appendChild(cameraControls);

        // --- NEW: Upload Container ---
        this.uploadContainer = document.createElement('div');
        this.uploadContainer.id = 'upload-content';
        this.uploadContainer.style.cssText = `
            width: 100%;
            height: 60%;
            border-radius: 16px;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            display: none; // Initially hidden
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        `;

        const uploadPrompt = document.createElement('p');
        uploadPrompt.textContent = 'Click to select an image or drag and drop';
        uploadPrompt.style.marginBottom = '15px';

        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.style.display = 'none'; // Hide the default input
        fileInput.addEventListener('change', (e) => this.handleImageUpload(e));

        const uploadButton = document.createElement('button');
        uploadButton.textContent = 'Choose Image';
        uploadButton.style.cssText = `
            padding: 12px 25px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.8);
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        uploadButton.addEventListener('click', () => fileInput.click());

        this.uploadContainer.appendChild(uploadPrompt);
        this.uploadContainer.appendChild(uploadButton);
        this.uploadContainer.appendChild(fileInput);

        // Add drag and drop functionality
        this.uploadContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            this.uploadContainer.style.borderColor = 'rgba(33, 150, 243, 0.8)';
            this.uploadContainer.style.backgroundColor = 'rgba(33, 150, 243, 0.1)';
        });
        this.uploadContainer.addEventListener('dragleave', () => {
            this.uploadContainer.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            this.uploadContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        });
        this.uploadContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            this.uploadContainer.style.borderColor = 'rgba(255, 255, 255, 0.3)';
            this.uploadContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            if (e.dataTransfer.files.length) {
                this.processImageFile(e.dataTransfer.files[0]);
            }
        });
        
        // Settings panel
        const settingsPanel = document.createElement('div');
        settingsPanel.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        `;
        
        // Detection mode options
        const modeLabel = document.createElement('div');
        modeLabel.textContent = 'Detection Mode:';
        modeLabel.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
        `;
        
        const modeOptions = document.createElement('div');
        modeOptions.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const singleShot = this.createToggleOption('Single Shot', true);
        const continuous = this.createToggleOption('Continuous', false);
        
        // Add event listeners for mode changes
        singleShot.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.stopContinuousDetection();
            }
        });
        
        continuous.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                this.startContinuousDetection();
            }
        });
        
        modeOptions.appendChild(singleShot);
        modeOptions.appendChild(continuous);
        
        settingsPanel.appendChild(modeLabel);
        settingsPanel.appendChild(modeOptions);
        
        // Result container
        const resultContainer = document.createElement('div');
        resultContainer.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        const resultHeader = document.createElement('div');
        resultHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;
        
        const resultTitle = document.createElement('div');
        resultTitle.textContent = 'Detected Objects';
        resultTitle.style.cssText = `
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            font-weight: 500;
        `;
        
        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Info';
        copyButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(33, 150, 243, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        copyButton.addEventListener('click', () => this.copyObjectInfo());
        
        const clearButton = document.createElement('button');
        clearButton.textContent = 'Clear';
        clearButton.style.cssText = `
            padding: 8px 15px;
            border-radius: 8px;
            border: none;
            background-color: rgba(244, 67, 54, 0.7);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        
        clearButton.addEventListener('click', () => this.clearResults());
        
        actionButtons.appendChild(copyButton);
        actionButtons.appendChild(clearButton);
        
        resultHeader.appendChild(resultTitle);
        resultHeader.appendChild(actionButtons);
        
        // Object info display
        this.objectInfoDisplay = document.createElement('div');
        this.objectInfoDisplay.style.cssText = `
            flex: 1;
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 16px;
            overflow-y: auto;
            margin-bottom: 15px;
            min-height: 200px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        `;
        
        // Add custom scrollbar styling for Webkit browsers
        const scrollbarStyle = document.createElement('style');
        scrollbarStyle.textContent = `
            .object-info-display::-webkit-scrollbar {
                width: 8px;
            }
            .object-info-display::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
            }
            .object-info-display::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 4px;
            }
            .object-info-display::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }
        `;
        document.head.appendChild(scrollbarStyle);
        
        // Add a class for easier styling
        this.objectInfoDisplay.className = 'object-info-display';
        
        this.objectInfoDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at objects and click capture to identify them
            </div>
        `;
        
        // Status display
        this.resultDisplay = document.createElement('div');
        this.resultDisplay.style.cssText = `
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
        `;
        this.resultDisplay.textContent = 'Loading object detection model...';
        
        mainContent.appendChild(tabNavigation);
        mainContent.appendChild(this.cameraContainer);
        mainContent.appendChild(this.uploadContainer);
        mainContent.appendChild(settingsPanel);
        mainContent.appendChild(resultContainer);
        resultContainer.appendChild(resultHeader);
        resultContainer.appendChild(this.objectInfoDisplay);
        resultContainer.appendChild(this.resultDisplay);
        cardContainer.appendChild(mainContent);
        this.appContainer.appendChild(cardContainer);
        
        // Initialize camera
        this.initializeCamera();
    }

    /**
     * Create a tab button
     */
    createTabButton(label, isActive, onClickHandler) {
        const button = document.createElement('button');
        button.textContent = label;
        button.className = 'tab-button' + (isActive ? ' active' : '');
        button.style.cssText = `
            padding: 10px 20px;
            border: none;
            background: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            margin-right: 15px;
        `;
        button.addEventListener('click', onClickHandler);
        return button;
    }

    /**
     * Switch between Camera and Upload tabs
     */
    switchTab(tabName) {
        const cameraContent = document.getElementById('camera-content');
        const uploadContent = document.getElementById('upload-content');
        const tabButtons = document.querySelectorAll('.tab-button');

        tabButtons.forEach(btn => btn.classList.remove('active'));

        if (tabName === 'camera') {
            cameraContent.style.display = 'block';
            uploadContent.style.display = 'none';
            tabButtons[0].classList.add('active');
            this.updateStatus('Camera mode activated.');
        } else {
            cameraContent.style.display = 'none';
            uploadContent.style.display = 'flex';
            tabButtons[1].classList.add('active');
            this.updateStatus('Upload mode activated. Select an image to detect objects.');
            // Stop continuous detection when switching to upload mode
            this.stopContinuousDetection();
        }
    }
    
    /**
     * Handle image upload from file input
     */
    handleImageUpload(event) {
        const file = event.target.files[0];
        if (file) {
            this.processImageFile(file);
        }
    }

    /**
     * Process the selected image file
     */
    processImageFile(file) {
        if (!file.type.startsWith('image/')) {
            this.updateStatus('Please select a valid image file.');
            return;
        }

        this.updateStatus('Processing image...');

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                // Draw the image onto the canvas for detection
                const context = this.canvasElement.getContext('2d');
                
                // Set canvas dimensions to match the image
                this.canvasElement.width = img.width;
                this.canvasElement.height = img.height;

                // Clear canvas and draw the new image
                context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                context.drawImage(img, 0, 0, img.width, img.height);

                // For visual feedback in the UI, we can display the image in the upload area
                this.uploadContainer.innerHTML = ''; // Clear previous content
                const uploadedImagePreview = document.createElement('img');
                uploadedImagePreview.src = e.target.result;
                uploadedImagePreview.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                    border-radius: 8px;
                `;
                this.uploadContainer.appendChild(uploadedImagePreview);

                // Now, run object detection on the canvas
                this.detectObjectsInCanvas();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    /**
     * Detect objects in the current canvas (used for uploaded images)
     */
    async detectObjectsInCanvas() {
        if (this.isDetecting) {
            return;
        }
        
        this.isDetecting = true;
        this.updateStatus('Detecting objects in uploaded image...');
        
        try {
            await this.processImageForObjects();
        } catch (error) {
            console.error('Error detecting objects in image:', error);
            this.updateStatus('Error detecting objects: ' + error.message);
        } finally {
            this.isDetecting = false;
        }
    }
    
    /**
     * Create a toggle option
     */
    createToggleOption(label, defaultValue) {
        const container = document.createElement('div');
        container.style.cssText = `
            display: flex;
            align-items: center;
            gap: 5px;
        `;
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'detection-mode';
        radio.id = `mode-${label.replace(/\s+/g, '-').toLowerCase()}`;
        radio.checked = defaultValue;
        radio.style.cssText = `
            cursor: pointer;
        `;
        
        const labelElement = document.createElement('label');
        labelElement.htmlFor = radio.id;
        labelElement.textContent = label;
        labelElement.style.cssText = `
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            cursor: pointer;
        `;
        
        container.appendChild(radio);
        container.appendChild(labelElement);
        
        return container;
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Add hover effects to buttons
        const buttons = [this.captureButton, this.switchCameraButton, this.flashButton];
        
        buttons.forEach(button => {
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'scale(1.1)';
            });
            
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'scale(1)';
            });
        });
    }
    
    /**
     * Display the app
     */
    displayApp() {
        document.body.appendChild(this.appContainer);
    }
    
    /**
     * Initialize the camera
     */
    async initializeCamera() {
        // If browser doesn't support mediaDevices, we can't initialize the camera
        if (!this.hasMediaDevices) {
            this.updateStatus('Camera not available. Please use the "Upload Image" tab.');
            // Automatically switch to upload tab if camera is not available
            this.switchTab('upload');
            return;
        }

        try {
            // Stop any existing stream
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => track.stop());
            }
            
            // Set up camera constraints
            const constraints = {
                video: {
                    facingMode: this.facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            // Add flash constraint if supported
            if (this.flashMode === 'on') {
                constraints.video.torch = true;
            }
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set video source
            this.videoElement.srcObject = this.currentStream;
            
            // Wait for video to be ready
            this.videoElement.onloadedmetadata = () => {
                // Set canvas dimensions to match video
                this.canvasElement.width = this.videoElement.videoWidth;
                this.canvasElement.height = this.videoElement.videoHeight;
                
                this.updateStatus('Camera ready. Point at objects and click capture.');
                
                // Start continuous detection if enabled
                const continuousMode = document.getElementById('mode-continuous');
                if (continuousMode && continuousMode.checked) {
                    this.startContinuousDetection();
                }
            };
            
        } catch (error) {
            console.error('Error initializing camera:', error);
            this.updateStatus('Error accessing camera: ' + error.message + '. Please use the "Upload Image" tab.');
            // Switch to upload tab on camera error
            this.switchTab('upload');
        }
    }
    
    /**
     * Switch between front and back camera
     */
    async switchCamera() {
        this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
        this.updateStatus('Switching camera...');
        await this.initializeCamera();
    }
    
    /**
     * Toggle flash mode
     */
    async toggleFlash() {
        const flashModes = ['off', 'on', 'auto'];
        const currentIndex = flashModes.indexOf(this.flashMode);
        this.flashMode = flashModes[(currentIndex + 1) % flashModes.length];
        
        // Update button appearance based on flash mode
        if (this.flashMode === 'on') {
            this.flashButton.style.backgroundColor = 'rgba(255, 235, 59, 0.7)';
        } else if (this.flashMode === 'auto') {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
        } else {
            this.flashButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        }
        
        this.updateStatus(`Flash mode: ${this.flashMode}`);
        await this.initializeCamera();
    }
    
    /**
     * Detect objects in the current camera frame (original method for single shot)
     */
    async detectObjects() {
        if (this.isDetecting) {
            return;
        }
        
        this.isDetecting = true;
        this.updateStatus('Detecting objects...');
        
        try {
            // Draw current video frame to canvas
            const context = this.canvasElement.getContext('2d');
            context.drawImage(this.videoElement, 0, 0, this.canvasElement.width, this.canvasElement.height);
            
            // Detect objects in the image
            await this.processImageForObjects();
            
        } catch (error) {
            console.error('Error detecting objects:', error);
            this.updateStatus('Error detecting objects: ' + error.message);
        } finally {
            this.isDetecting = false;
        }
    }
    
    /**
     * Start continuous object detection with maximum speed
     */
    startContinuousDetection() {
        // Continuous detection only makes sense for camera mode
        if (document.getElementById('upload-content').style.display === 'flex') {
            this.updateStatus('Continuous detection is only available in camera mode.');
            document.getElementById('mode-single-shot').checked = true;
            return;
        }

        if (this.continuousDetectionId) {
            clearInterval(this.continuousDetectionId);
        }
        
        // Clear any pending animation frames
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        // Use requestAnimationFrame for maximum performance
        let lastDetectionTime = 0;
        const detectionInterval = 100; // Detect every 100ms for much faster response (10 FPS)
        
        const detectFrame = async (timestamp) => {
            // Only run detection at specified intervals to prevent overload
            if (timestamp - lastDetectionTime > detectionInterval && !this.isDetecting) {
                lastDetectionTime = timestamp;
                await this.detectObjectsFast();
            }
            
            // Continue the animation loop if continuous detection is still enabled
            if (this.continuousDetectionId !== null) {
                this.animationId = requestAnimationFrame(detectFrame);
            }
        };
        
        // Start the animation loop
        this.continuousDetectionId = "active"; // Using a string instead of numeric ID
        this.animationId = requestAnimationFrame(detectFrame);
        
        this.updateStatus('High-speed continuous detection enabled');
    }
    
    /**
     * Stop continuous object detection
     */
    stopContinuousDetection() {
        // Clear the interval if it exists
        if (this.continuousDetectionId && typeof this.continuousDetectionId === 'number') {
            clearInterval(this.continuousDetectionId);
        }
        
        // Cancel any pending animation frames
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        this.continuousDetectionId = null;
        this.updateStatus('Continuous detection stopped');
    }
    
    /**
     * Ultra-fast object detection method for continuous mode
     */
    async detectObjectsFast() {
        if (this.isDetecting) {
            return;
        }
        
        this.isDetecting = true;
        
        try {
            // Skip drawing to canvas if not needed for maximum performance
            if (this.modelLoaded && this.model) {
                // Direct detection without canvas drawing for fastest processing
                await this.processVideoFrameForObjects();
            } else {
                // Fallback to simulated detection if model isn't loaded
                const simulatedObjects = await this.simulateObjectDetection();
                if (simulatedObjects && simulatedObjects.length > 0) {
                    this.displayDetectedObjects(simulatedObjects);
                }
            }
        } catch (error) {
            console.error('Error detecting objects:', error);
            // Don't update status on every error to reduce UI updates
        } finally {
            this.isDetecting = false;
        }
    }
    
    /**
     * Process video frame directly for objects (ultra-fast version)
     */
    async processVideoFrameForObjects() {
        try {
            // Only update status periodically to avoid UI lag
            if (!this.lastStatusUpdate || Date.now() - this.lastStatusUpdate > 2000) {
                this.updateStatus('Detecting objects...');
                this.lastStatusUpdate = Date.now();
            }
            
            // Detect objects in the video frame directly
            const predictions = await this.model.detect(this.videoElement);
            
            if (predictions && predictions.length > 0) {
                // Only draw to canvas and update UI if we have new results
                const context = this.canvasElement.getContext('2d');
                context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                
                // Convert predictions to our format
                const objects = predictions.map(prediction => ({
                    name: prediction.class,
                    confidence: Math.round(prediction.score * 100),
                    bbox: prediction.bbox,
                    info: this.getObjectInfo(prediction.class)
                }));
                
                // Only update UI if objects have changed significantly
                if (!this.lastDetectedObjects || !this.objectsAreSimilar(this.lastDetectedObjects, objects)) {
                    this.displayDetectedObjectsOptimized(objects);
                    this.lastDetectedObjects = objects;
                }
            }
        } catch (error) {
            console.error('Error processing video frame for objects:', error);
            // Only show error message occasionally to prevent UI spam
            if (!this.lastErrorUpdate || Date.now() - this.lastErrorUpdate > 5000) {
                this.updateStatus('Error processing video');
                this.lastErrorUpdate = Date.now();
            }
        }
    }
    
    /**
     * Helper method to compare if two sets of detected objects are similar
     * More lenient than objectsAreEqual to reduce unnecessary updates
     */
    objectsAreSimilar(objects1, objects2) {
        if (objects1.length !== objects2.length) return false;
        
        // Check if the same objects are detected with similar confidence
        for (let i = 0; i < objects1.length; i++) {
            let foundMatch = false;
            
            for (let j = 0; j < objects2.length; j++) {
                if (objects1[i].name === objects2[j].name && 
                    Math.abs(objects1[i].confidence - objects2[j].confidence) < 15) {
                    foundMatch = true;
                    break;
                }
            }
            
            if (!foundMatch) return false;
        }
        
        return true;
    }
    
    /**
     * Process image for objects (original method for single shot detection)
     */
    async processImageForObjects() {
        try {
            // Check if the model is loaded
            if (!this.modelLoaded || !this.model) {
                // Fallback to simulated detection if model isn't loaded
                const simulatedObjects = await this.simulateObjectDetection();
                if (simulatedObjects && simulatedObjects.length > 0) {
                    this.displayDetectedObjects(simulatedObjects);
                    return;
                }
                
                this.updateStatus('Object detection model not ready. Please try again later.');
                return;
            }
            
            // Use the loaded model for real detection
            this.updateStatus('Detecting objects with AI model...');
            
            // Detect objects in the canvas (which now has either video frame or uploaded image)
            const predictions = await this.model.detect(this.canvasElement);
            
            if (predictions && predictions.length > 0) {
                // Convert predictions to our format
                const objects = predictions.map(prediction => ({
                    name: prediction.class,
                    confidence: Math.round(prediction.score * 100),
                    bbox: prediction.bbox,
                    info: this.getObjectInfo(prediction.class)
                }));
                
                this.displayDetectedObjects(objects);
            } else {
                this.updateStatus('No objects detected. Try pointing your camera at common objects or selecting a different image.');
            }
            
        } catch (error) {
            console.error('Error processing image for objects:', error);
            this.updateStatus('Error processing image: ' + error.message);
        }
    }
    
    /**
     * Simulate object detection (for demonstration purposes)
     */
    async simulateObjectDetection() {
        try {
            this.updateStatus('Analyzing image for objects...');
            
            // Simulate processing delay
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            // Common objects that might be detected
            const commonObjects = [
                { name: 'person', info: 'A human being' },
                { name: 'cell phone', info: 'A mobile communication device' },
                { name: 'laptop', info: 'A portable computer' },
                { name: 'book', info: 'A collection of written pages' },
                { name: 'cup', info: 'A container for drinking liquids' },
                { name: 'chair', info: 'A piece of furniture for sitting' },
                { name: 'table', info: 'A flat surface supported by legs' },
                { name: 'keyboard', info: 'An input device with keys' },
                { name: 'mouse', info: 'A pointing device for computers' },
                { name: 'monitor', info: 'A display screen' },
                { name: 'bottle', info: 'A container with a narrow neck' },
                { name: 'car', info: 'A motor vehicle with four wheels' },
                { name: 'bicycle', info: 'A human-powered vehicle with two wheels' },
                { name: 'clock', info: 'A device for telling time' },
                { name: 'calculator', info: 'A device for mathematical calculations' }
            ];
            
            // Randomly select 1-3 objects to "detect"
            const numObjects = Math.floor(Math.random() * 3) + 1;
            const detectedObjects = [];
            
            for (let i = 0; i < numObjects; i++) {
                const randomIndex = Math.floor(Math.random() * commonObjects.length);
                const object = commonObjects[randomIndex];
                
                // Add some random confidence and position data
                detectedObjects.push({
                    name: object.name,
                    confidence: Math.floor(Math.random() * 30) + 70, // 70-99% confidence
                    bbox: [
                        Math.floor(Math.random() * 200),
                        Math.floor(Math.random() * 200),
                        Math.floor(Math.random() * 200) + 100,
                        Math.floor(Math.random() * 200) + 100
                    ],
                    info: object.info
                });
            }
            
            return detectedObjects;
            
        } catch (error) {
            console.error('Simulated detection error:', error);
            return null;
        }
    }
    
    /**
     * Get information about a detected object
     */
    getObjectInfo(objectName) {
        // Database of common objects and their descriptions
        const objectDatabase = {
            'person': 'A human being, the most intelligent species on Earth.',
            'cell phone': 'A portable electronic device used for communication.',
            'laptop': 'A portable computer with a screen and keyboard in one unit.',
            'book': 'A written or printed work consisting of pages glued together.',
            'cup': 'A small container used for drinking liquids.',
            'chair': 'A piece of furniture designed for one person to sit on.',
            'table': 'A piece of furniture with a flat top and legs.',
            'keyboard': 'A set of keys used to input data into a computer.',
            'mouse': 'A small handheld device used to control the cursor on a computer screen.',
            'monitor': 'An electronic display device for computers.',
            'bottle': 'A container with a narrow neck, used for storing liquids.',
            'car': 'A road vehicle with four wheels, powered by an engine.',
            'bicycle': 'A human-powered vehicle with two wheels.',
            'clock': 'A device for measuring and indicating time.',
            'calculator': 'An electronic device for performing mathematical calculations.',
            'tv': 'A device for receiving television signals and displaying them as images and sound.',
            'remote': 'A device for controlling another device from a distance.',
            'backpack': 'A bag carried on a person\'s back, secured with two straps.',
            'handbag': 'A small bag used for carrying personal items.',
            'suitcase': 'A large case with a handle and a hinged lid, used for clothing and personal items.',
            'microwave': 'An electric oven that uses microwaves to cook or heat food.',
            'toaster': 'A small electric appliance designed to toast slices of bread.',
            'refrigerator': 'A large appliance for keeping food and drinks cold.',
            'sink': 'A fixed basin with a drain for washing.',
            'bed': 'A piece of furniture used for sleep or rest.',
            'pillow': 'A rectangular cloth bag stuffed with feathers or other soft materials.',
            'couch': 'A long upholstered piece of furniture for multiple people to sit on.',
            'potted plant': 'A plant growing in a pot instead of in the ground.',
            'vase': 'A container, typically made of glass or ceramic, used for holding cut flowers.',
            'lamp': 'A device for giving light, either one consisting of an electric bulb together with its holder and shade.',
            'ceiling fan': 'A fan mounted on the ceiling of a room, usually electrically powered.',
            'curtain': 'A piece of cloth suspended at the top to cover a window.',
            'mirror': 'A reflective surface, typically of glass coated with a metal amalgam.',
            'toothbrush': 'A small brush with a long handle, used for cleaning the teeth.',
            'hair dryer': 'An electrical device for drying a person\'s hair by blowing warm air.',
            'towel': 'A piece of absorbent cloth or paper used for drying or wiping.',
            'soap': 'A substance used with water for washing and cleaning.',
            'shampoo': 'A liquid preparation for washing the hair.',
            'toilet': 'A fixed receptacle with a seat and a drain, connected to a plumbing system.',
            'oven': 'a chamber used for cooking, heating, or baking.',
            'stove': 'an apparatus for cooking or heating that operates by burning fuel or using electricity.',
            'dining table': 'a table at which meals are eaten.',
            'coffee table': 'a low table typically placed in front of a sofa.',
            'end table': 'a small table placed beside a chair or at the end of a sofa.',
            'nightstand': 'a small table or cabinet designed to stand beside a bed or elsewhere in a bedroom.',
            'desk': 'a piece of furniture with a flat or sloped surface and typically with drawers, at which one can read, write, or do other work.',
            'bookshelf': 'a set of shelves for books.',
            'wardrobe': 'a tall, rectangular cupboard or room used for storing clothes.',
            'dresser': 'a piece of furniture with drawers used for storing clothes.',
            'coffee maker': 'an appliance for brewing coffee.',
            'blender': 'an electric appliance for liquefying or chopping food.',
            'cutting board': 'a board on which food is cut.',
            'knife': 'a tool or implement with a cutting edge or blade, typically attached to a handle.',
            'fork': 'an implement with two or more prongs used for lifting food to the mouth or holding it when cutting.',
            'spoon': 'an implement consisting of a small, shallow oval or round bowl on a long handle, used for eating, stirring, and serving food.',
            'plate': 'a flat dish, typically circular, from which food is eaten or served.',
            'bowl': 'a round, deep dish or basin used for food or liquid.',
            'mug': 'a large cup, typically cylindrical and with a handle, used for hot beverages.',
            'glass': 'a hard, brittle substance, typically transparent or translucent, made by fusing sand with soda and lime and cooling rapidly.',
            'wine glass': 'a glass, typically with a stem, used for drinking wine.',
            'forklift': 'a small vehicle with two prongs on the front for lifting and carrying heavy loads.',
            'traffic light': 'a set of automatically operated colored lights, typically red, amber, and green, for controlling traffic.',
            'stop sign': 'a traffic sign informing drivers to stop.',
            'parking meter': 'a device next to a parking space for collecting payment for parking.',
            'fire hydrant': 'an upright pipe with a spout, nozzle, or other outlet, usually in the street, for drawing water from a water main.',
            'bench': 'a long seat for several people, typically made of wood or stone.',
            'bird': 'a warm-blooded vertebrate distinguished by feathers, wings, and a beak.',
            'cat': 'a small domesticated carnivorous mammal with soft fur and a short snout.',
            'dog': 'a domesticated carnivorous mammal that typically has a long snout, an acute sense of smell, and a barking voice.',
            'horse': 'a large plant-eating domesticated mammal with solid hoofs and a flowing mane and tail.',
            'sheep': 'a domesticated ruminant animal with a thick woolly coat and (typically only in the male) curving horns.',
            'cow': 'a fully grown female animal of a domesticated breed of ox, kept to produce milk or beef.',
            'elephant': 'a very large mammal with thick gray skin, large ears, tusks, and a long trunk.',
            'bear': 'a large, heavy mammal with thick fur and a very short tail.',
            'zebra': 'an African wild horse with black-and-white stripes and an erect mane.',
            'giraffe': 'a large African mammal with a very long neck and forelegs, having a coat patterned with brown patches separated by lighter lines.',
            'backpack': 'a bag carried on a person\'s back, secured with two straps that go over the shoulders.',
            'umbrella': 'a device for protection against the rain, consisting of a collapsible circular canopy mounted on a central rod.',
            'handbag': 'a small bag used especially by a woman to carry everyday personal items.',
            'tie': 'a long, narrow piece of cloth worn around the neck, typically by men with a shirt and suit.',
            'suitcase': 'a large case with a handle and a hinged lid, used for transporting clothes and other possessions.',
            'frisbee': 'a concave plastic disc designed for skimming through the air as part of a game or for recreation.',
            'skis': 'each of a pair of long, narrow pieces of hard, flexible material, typically pointed and turned up at the front, fastened under the feet for gliding over snow.',
            'snowboard': 'a board resembling a short, broad ski, used for sliding downhill on snow.',
            'sports ball': 'a spherical object used as a toy or in various games and sports.',
            'kite': 'a toy consisting of a light frame with thin material stretched over it, flown in the wind at the end of a long string.',
            'baseball bat': 'a smooth wooden or metal club used in the sport of baseball to hit the ball after it is thrown by the pitcher.',
            'baseball glove': 'a large leather glove worn by baseball players of the defending team, which assists them in catching and fielding balls hit by a batter or thrown by a teammate.',
            'skateboard': 'a short, narrow board with two small wheels fixed to the bottom of either end, on which a person can ride in a standing or crouching position, propelling themselves by occasionally pushing one foot against the ground.',
            'surfboard': 'a long, narrow board used for surfing.',
            'tennis racket': 'a racket used in the game of tennis, consisting of a handled frame with an open hoop across which a network of strings is stretched.',
            'cell phone': 'a portable telephone that can make and receive calls over a radio frequency link while the user is moving within a telephone service area.',
            'microwave': 'an electric oven that uses microwaves to cook or heat food.',
            'oven': 'an enclosed compartment, usually part of a cooker, for cooking and heating food.',
            'toaster': 'an electric appliance designed to expose various types of sliced bread to radiant heat, browning the bread.',
            'sink': 'a fixed basin with a drain for washing.',
            'refrigerator': 'a commercial or domestic appliance consisting of a thermally insulated compartment and a heat pump that transfers heat from the inside to its external environment so that the inside is cooled to a temperature below room temperature.',
            'book': 'a written or printed work consisting of pages glued or sewn together along one side.',
            'clock': 'an instrument for measuring and indicating time, typically by means of a dial or a digital display.',
            'vase': 'a container, typically made of glass or ceramic, used for holding cut flowers or for decoration.',
            'scissors': 'an instrument used for cutting cloth, paper, and other thin material, consisting of two blades laid one on top of the other and fastened in the middle so as to slide past each other.',
            'teddy bear': 'a soft toy in the form of a bear.',
            'hair drier': 'an electrical device for drying a person\'s hair by blowing warm air.',
            'toothbrush': 'a small brush with a long handle, used for cleaning the teeth.',
            'hair brush': 'a brush used for grooming hair.',
            'dining table': 'a table at which meals are eaten.'
        };
        
        return objectDatabase[objectName.toLowerCase()] || 'A common object found in everyday life.';
    }
    
    /**
     * Display detected objects (original method)
     */
    displayDetectedObjects(objects) {
        if (!objects || objects.length === 0) {
            this.updateStatus('No objects detected.');
            return;
        }
        
        // Clear previous results
        this.objectInfoDisplay.innerHTML = '';
        
        // Create a container for the detected objects
        const objectsContainer = document.createElement('div');
        objectsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Add each detected object
        objects.forEach((object, index) => {
            const objectElement = document.createElement('div');
            objectElement.style.cssText = `
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 15px;
                border-left: 4px solid #4CAF50;
            `;
            
            const objectHeader = document.createElement('div');
            objectHeader.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            `;
            
            const objectName = document.createElement('div');
            objectName.textContent = object.name.charAt(0).toUpperCase() + object.name.slice(1);
            objectName.style.cssText = `
                font-size: 18px;
                font-weight: 600;
                color: #4CAF50;
            `;
            
            const confidenceBadge = document.createElement('div');
            confidenceBadge.textContent = `${object.confidence}%`;
            confidenceBadge.style.cssText = `
                background-color: rgba(76, 175, 80, 0.2);
                color: #4CAF50;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 500;
            `;
            
            objectHeader.appendChild(objectName);
            objectHeader.appendChild(confidenceBadge);
            
            const objectInfo = document.createElement('div');
            objectInfo.textContent = object.info;
            objectInfo.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                line-height: 1.5;
            `;
            
            objectElement.appendChild(objectHeader);
            objectElement.appendChild(objectInfo);
            objectsContainer.appendChild(objectElement);
            
            // Draw bounding box on canvas if available
            if (object.bbox && object.bbox.length === 4) {
                this.drawBoundingBox(object.bbox, object.name, object.confidence);
            }
        });
        
        this.objectInfoDisplay.appendChild(objectsContainer);
        
        // Add to history
        this.objectHistory.push({
            timestamp: new Date(),
            objects: objects
        });
        
        // Update status
        this.updateStatus(`Detected ${objects.length} object${objects.length !== 1 ? 's' : ''}`);
    }
    
    /**
     * Optimized display method that only updates when necessary (for continuous detection)
     */
    displayDetectedObjectsOptimized(objects) {
        if (!objects || objects.length === 0) {
            // Only update status if no objects were detected previously
            if (this.lastDetectedObjects && this.lastDetectedObjects.length > 0) {
                this.updateStatus('No objects detected.');
                this.lastDetectedObjects = [];
            }
            return;
        }
        
        // Clear previous results
        this.objectInfoDisplay.innerHTML = '';
        
        // Create a container for the detected objects
        const objectsContainer = document.createElement('div');
        objectsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Add each detected object
        objects.forEach((object, index) => {
            const objectElement = document.createElement('div');
            objectElement.style.cssText = `
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 15px;
                border-left: 4px solid #4CAF50;
                animation: fadeIn 0.2s ease-in-out;
            `;
            
            const objectHeader = document.createElement('div');
            objectHeader.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            `;
            
            const objectName = document.createElement('div');
            objectName.textContent = object.name.charAt(0).toUpperCase() + object.name.slice(1);
            objectName.style.cssText = `
                font-size: 18px;
                font-weight: 600;
                color: #4CAF50;
            `;
            
            const confidenceBadge = document.createElement('div');
            confidenceBadge.textContent = `${object.confidence}%`;
            confidenceBadge.style.cssText = `
                background-color: rgba(76, 175, 80, 0.2);
                color: #4CAF50;
                padding: 4px 8px;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 500;
            `;
            
            objectHeader.appendChild(objectName);
            objectHeader.appendChild(confidenceBadge);
            
            const objectInfo = document.createElement('div');
            objectInfo.textContent = object.info;
            objectInfo.style.cssText = `
                color: rgba(255, 255, 255, 0.8);
                font-size: 14px;
                line-height: 1.5;
            `;
            
            objectElement.appendChild(objectHeader);
            objectElement.appendChild(objectInfo);
            objectsContainer.appendChild(objectElement);
            
            // Draw bounding box on canvas if available
            if (object.bbox && object.bbox.length === 4) {
                this.drawBoundingBox(object.bbox, object.name, object.confidence);
            }
        });
        
        this.objectInfoDisplay.appendChild(objectsContainer);
        
        // Add to history (limit history size to prevent memory issues)
        this.objectHistory.push({
            timestamp: new Date(),
            objects: objects
        });
        
        // Keep only the last 5 detections to prevent memory issues
        if (this.objectHistory.length > 5) {
            this.objectHistory.shift();
        }
        
        // Update status only occasionally to prevent UI spam
        if (!this.lastStatusUpdate || Date.now() - this.lastStatusUpdate > 2000) {
            this.updateStatus(`Detected ${objects.length} object${objects.length !== 1 ? 's' : ''}`);
            this.lastStatusUpdate = Date.now();
        }
        
        // Auto-scroll to the bottom to show the latest results
        this.objectInfoDisplay.scrollTop = this.objectInfoDisplay.scrollHeight;
    }
    
    /**
     * Optimized bounding box drawing for better performance
     */
    drawBoundingBox(bbox, label, confidence) {
        const context = this.canvasElement.getContext('2d');
        
        // For uploaded images, the canvas is already the correct size.
        // For video, we need to scale.
        let scaleX, scaleY;
        if (this.videoElement.videoWidth > 0) {
            scaleX = this.canvasElement.width / this.videoElement.videoWidth;
            scaleY = this.canvasElement.height / this.videoElement.videoHeight;
        } else {
            scaleX = 1;
            scaleY = 1;
        }

        const x = bbox[0] * scaleX;
        const y = bbox[1] * scaleY;
        const width = bbox[2] * scaleX;
        const height = bbox[3] * scaleY;
        
        // Draw bounding box with optimized settings
        context.strokeStyle = '#4CAF50';
        context.lineWidth = 2;
        context.strokeRect(x, y, width, height);
        
        // Only draw label if confidence is high enough to reduce clutter
        if (confidence > 70) {
            // Draw label background
            const labelText = `${label} ${confidence}%`;
            context.font = '14px Arial';
            const textWidth = context.measureText(labelText).width;
            
            context.fillStyle = 'rgba(76, 175, 80, 0.7)';
            context.fillRect(x, y - 20, textWidth + 10, 20);
            
            // Draw label text
            context.fillStyle = 'white';
            context.fillText(labelText, x + 5, y - 5);
        }
    }
    
    /**
     * Update status message
     */
    updateStatus(message) {
        if (this.resultDisplay) {
            this.resultDisplay.textContent = message;
        }
    }
    
    /**
     * Copy object information to clipboard
     */
    copyObjectInfo() {
        if (this.objectHistory.length === 0) {
            this.updateStatus('No object information to copy.');
            return;
        }
        
        // Get the latest detection
        const latestDetection = this.objectHistory[this.objectHistory.length - 1];
        
        // Format the information
        let textToCopy = `Detected Objects (${latestDetection.timestamp.toLocaleString()}):\n\n`;
        
        latestDetection.objects.forEach((object, index) => {
            textToCopy += `${index + 1}. ${object.name.charAt(0).toUpperCase() + object.name.slice(1)}\n`;
            textToCopy += `   Confidence: ${object.confidence}%\n`;
            textToCopy += `   Information: ${object.info}\n\n`;
        });
        
        // Copy to clipboard
        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                this.updateStatus('Object information copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                this.updateStatus('Failed to copy object information.');
            });
    }
    
    /**
     * Clear results
     */
    clearResults() {
        this.objectInfoDisplay.innerHTML = `
            <div style="text-align: center; color: rgba(255, 255, 255, 0.6); padding: 20px;">
                Point your camera at objects and click capture to identify them
            </div>
        `;
        
        // Clear canvas
        const context = this.canvasElement.getContext('2d');
        context.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
        
        // Reset last detected objects
        this.lastDetectedObjects = null;
        
        this.updateStatus('Results cleared. Ready for new detection.');
    }
    
    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.appContainer.requestFullscreen) {
                this.appContainer.requestFullscreen();
            } else if (this.appContainer.webkitRequestFullscreen) { /* Safari */
                this.appContainer.webkitRequestFullscreen();
            } else if (this.appContainer.msRequestFullscreen) { /* IE11 */
                this.appContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
        }
    }
    
    /**
     * Close the app
     */
    closeApp() {
        // Stop continuous detection
        this.stopContinuousDetection();
        
        // Stop camera stream
        if (this.currentStream) {
            this.currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Remove app container
        if (this.appContainer && this.appContainer.parentNode) {
            this.appContainer.parentNode.removeChild(this.appContainer);
        }
        
        this.isActive = false;
        botReply('Camera Object Understanding closed.');
    }
}

// Create a global instance of the app
const cameraObjectUnderstanding = new CameraObjectUnderstanding();


// Add this to your AI's command handling
if (/Object Reader|text scanner|ocr|scan text/i.test(userInputRaw)) {
    cameraObjectUnderstanding.loadCameraObjectUnderstanding();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    cameraObjectUnderstanding.closeApp();
    return;
}







class LiveScreenLoaderEditor {
    constructor() {
        this.baseScreen = {
            name: 'LIVE COLLABORATIVE EDITOR',
            instructions: 'Real-time collaborative editing. Admin changes are instantly visible to all users.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.roleToggle = null;
        this.editorArea = null;
        this.previewArea = null;
        this.outputDiv = null;
        this.userList = null;
        this.currentRole = 'user'; // 'user' or 'admin'
        this.documentContent = 'Welcome to the Live Collaborative Editor!\n\nThis is a shared document that can be edited in real-time.\n\nAdmin changes will appear instantly for all users.';
        this.isEditing = false;
        this.isLocked = false;
        this.activeUsers = [];
        this.editHistory = [];
        this.currentVersion = 0;
        this.autoSaveInterval = null;
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.documentRef = null;
        this.usersRef = null;
        this.presenceRef = null;
        this.connectedRef = null;
        this.messagesRef = null;
        this.isFirebaseInitialized = false;
        this.lastEditorId = null;
        this.isLocalChange = false;
        this.messageQueue = [];
        this.isProcessingQueue = false;
    }

    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'user_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Load the Live Editor Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLiveEditorScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.startAutoSave();
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }

    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            firebase.initializeApp(this.firebaseConfig);
            this.db = firebase.database();
            
            // References
            this.documentRef = this.db.ref('collaborativeEditor/document');
            this.usersRef = this.db.ref('collaborativeEditor/users');
            this.presenceRef = this.db.ref('collaborativeEditor/presence');
            this.connectedRef = this.db.ref('.info/connected');
            this.messagesRef = this.db.ref('collaborativeEditor/messages');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.updateConnectionStatus(true);
                    this.registerUser();
                    this.setupFirebaseListeners();
                    this.loadDocumentFromFirebase();
                    this.processMessageQueue();
                } else {
                    this.updateConnectionStatus(false);
                }
            });
            
            this.isFirebaseInitialized = true;
            this.logActivity('Firebase connected successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.logActivity('Firebase connection failed');
            this.updateConnectionStatus(false);
        }
    }

    /**
     * Setup Firebase listeners
     */
    setupFirebaseListeners() {
        // Listen for document changes with high priority
        this.documentRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (data) {
                // Skip if this is a local change
                if (this.isLocalChange && data.lastEditorId === this.userSessionId) {
                    this.isLocalChange = false;
                    return;
                }
                
                // Update document content
                if (data.content !== undefined && data.content !== this.documentContent) {
                    this.documentContent = data.content;
                    this.editorArea.value = this.documentContent;
                    this.previewArea.textContent = this.documentContent;
                    
                    // Only log if it's not our own change
                    if (data.lastEditorId !== this.userSessionId) {
                        this.logActivity(`Document updated by ${data.lastEditorRole || 'another user'}`);
                    }
                }
                
                // Update lock status
                if (data.locked !== undefined && data.locked !== this.isLocked) {
                    this.isLocked = data.locked;
                    this.updateUIForRole();
                    this.logActivity(`Document ${this.isLocked ? 'locked' : 'unlocked'} by admin`);
                }
                
                // Update version
                if (data.version !== undefined && data.version !== this.currentVersion) {
                    this.currentVersion = data.version;
                    this.logActivity(`New version available: ${this.currentVersion}`);
                }
            }
        });
        
        // Listen for user changes
        this.usersRef.on('value', (snapshot) => {
            const users = snapshot.val();
            if (users) {
                this.activeUsers = Object.values(users).filter(user => user.id !== this.userSessionId);
                this.updateActiveUsers();
            }
        });
        
        // Listen for broadcast messages with high priority
        this.messagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (message && message.text) {
                // Display message immediately
                this.displayBroadcastMessage(message);
            }
        });
        
        // Setup presence for this user
        this.presenceRef.child(this.userSessionId).onDisconnect().remove();
        this.presenceRef.child(this.userSessionId).set(true);
    }

    /**
     * Display broadcast message immediately
     */
    displayBroadcastMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.style.cssText = `
            background-color: #9C27B0;
            color: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-weight: bold;
            animation: fadeIn 0.5s;
        `;
        messageElement.textContent = `📢 ${message.author}: ${message.text}`;
        
        // Insert at the top of the activity log
        this.outputDiv.insertBefore(messageElement, this.outputDiv.firstChild);
        
        // Remove after 5 seconds
        setTimeout(() => {
            if (messageElement.parentNode) {
                messageElement.style.opacity = '0';
                messageElement.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.remove();
                    }
                }, 500);
            }
        }, 5000);
        
        // Also log in activity
        this.logActivity(`Broadcast: "${message.text}" by ${message.author}`);
    }

    /**
     * Process message queue when Firebase is ready
     */
    processMessageQueue() {
        if (this.messageQueue.length > 0) {
            this.messageQueue.forEach(message => {
                this.messagesRef.push(message);
            });
            this.messageQueue = [];
        }
    }

    /**
     * Load document from Firebase
     */
    loadDocumentFromFirebase() {
        this.documentRef.once('value').then((snapshot) => {
            const data = snapshot.val();
            if (data) {
                this.documentContent = data.content || this.documentContent;
                this.isLocked = data.locked || false;
                this.currentVersion = data.version || 0;
                this.editHistory = data.history || [];
                
                // Update UI
                this.editorArea.value = this.documentContent;
                this.previewArea.textContent = this.documentContent;
                this.updateUIForRole();
                
                this.logActivity(`Loaded document version ${this.currentVersion}`);
            } else {
                // Initialize document if it doesn't exist
                this.saveDocumentToFirebase();
            }
        }).catch(error => {
            console.error('Error loading document:', error);
            this.logActivity('Error loading document');
        });
    }

    /**
     * Save document to Firebase
     */
    saveDocumentToFirebase() {
        if (!this.isFirebaseInitialized) return;
        
        const data = {
            content: this.documentContent,
            locked: this.isLocked,
            version: this.currentVersion,
            history: this.editHistory,
            lastUpdated: firebase.database.ServerValue.TIMESTAMP,
            lastEditorId: this.userSessionId,
            lastEditorRole: this.currentRole
        };
        
        this.isLocalChange = true;
        this.documentRef.update(data).catch(error => {
            console.error('Error saving document:', error);
            this.logActivity('Error saving document');
            this.isLocalChange = false;
        });
    }

    /**
     * Register this user in Firebase
     */
    registerUser() {
        if (!this.isFirebaseInitialized) return;
        
        const userData = {
            id: this.userSessionId,
            role: this.currentRole,
            name: this.currentRole === 'admin' ? 'Admin' : 'User',
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            editing: this.isEditing
        };
        
        this.usersRef.child(this.userSessionId).set(userData).catch(error => {
            console.error('Error registering user:', error);
        });
    }

    /**
     * Update user status in Firebase
     */
    updateUserStatus(isEditing) {
        if (!this.isFirebaseInitialized) return;
        
        this.usersRef.child(this.userSessionId).update({
            editing: isEditing,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        }).catch(error => {
            console.error('Error updating user status:', error);
        });
    }

    /**
     * Remove a user from the session (admin only)
     */
    removeUser(userId) {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can remove users.');
            return;
        }
        
        if (confirm('Are you sure you want to remove this user from the session?')) {
            // Remove from users list
            this.usersRef.child(userId).remove().then(() => {
                // Remove from presence
                this.presenceRef.child(userId).remove();
                this.logActivity('User removed from session by admin');
                botReply('User removed from session');
            }).catch(error => {
                console.error('Error removing user:', error);
                this.logActivity('Error removing user');
            });
        }
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Live Editor UI
     */
    createLiveEditorScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Live Collaborative Editor';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Real-time collaboration across devices';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Role toggle and connection status
        const topControls = document.createElement('div');
        topControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 20px;
            flex-wrap: wrap;
        `;

        // Role toggle
        const roleSection = document.createElement('div');
        roleSection.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const roleLabel = document.createElement('label');
        roleLabel.textContent = 'Current Role:';
        roleLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        this.roleToggle = document.createElement('select');
        this.roleToggle.style.cssText = `
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        const userOption = document.createElement('option');
        userOption.value = 'user';
        userOption.textContent = 'User';
        const adminOption = document.createElement('option');
        adminOption.value = 'admin';
        adminOption.textContent = 'Admin';
        this.roleToggle.appendChild(userOption);
        this.roleToggle.appendChild(adminOption);
        this.roleToggle.addEventListener('change', (e) => {
            this.switchRole(e.target.value);
        });
        roleSection.appendChild(roleLabel);
        roleSection.appendChild(this.roleToggle);

        // Connection status
        const connectionSection = document.createElement('div');
        connectionSection.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const connectionLabel = document.createElement('label');
        connectionLabel.textContent = 'Connection:';
        connectionLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        this.connectionStatus = document.createElement('div');
        this.connectionStatus.style.cssText = `
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #f44336;
        `;
        this.connectionTooltip = document.createElement('span');
        this.connectionTooltip.textContent = 'Connecting...';
        this.connectionTooltip.style.cssText = `
            font-size: 14px;
            color: #666;
        `;
        connectionSection.appendChild(connectionLabel);
        connectionSection.appendChild(this.connectionStatus);
        connectionSection.appendChild(this.connectionTooltip);

        topControls.appendChild(roleSection);
        topControls.appendChild(connectionSection);
        baseContainer.appendChild(topControls);

        // Active users section
        const usersSection = document.createElement('div');
        usersSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const usersLabel = document.createElement('label');
        usersLabel.textContent = 'Active Users:';
        usersLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.userList = document.createElement('div');
        this.userList.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 30px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        `;
        this.userList.textContent = 'Loading users...';
        usersSection.appendChild(usersLabel);
        usersSection.appendChild(this.userList);
        baseContainer.appendChild(usersSection);

        // Editor area
        const editorSection = document.createElement('div');
        editorSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const editorLabel = document.createElement('label');
        editorLabel.textContent = 'Live Editor:';
        editorLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.editorArea = document.createElement('textarea');
        this.editorArea.style.cssText = `
            width: 100%;
            height: 150px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
            background-color: #fff;
        `;
        this.editorArea.value = this.documentContent;
        this.editorArea.addEventListener('input', (e) => {
            this.handleTextChange(e.target.value);
        });
        this.editorArea.addEventListener('focus', () => {
            this.startEditing();
        });
        this.editorArea.addEventListener('blur', () => {
            this.stopEditing();
        });
        editorSection.appendChild(editorLabel);
        editorSection.appendChild(this.editorArea);
        baseContainer.appendChild(editorSection);

        // Preview area
        const previewSection = document.createElement('div');
        previewSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const previewLabel = document.createElement('label');
        previewLabel.textContent = 'Live Preview:';
        previewLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.previewArea = document.createElement('div');
        this.previewArea.style.cssText = `
            width: 100%;
            min-height: 100px;
            max-height: 200px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #fff;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
        `;
        this.previewArea.textContent = this.documentContent;
        previewSection.appendChild(previewLabel);
        previewSection.appendChild(this.previewArea);
        baseContainer.appendChild(previewSection);

        // Admin controls
        this.adminControls = document.createElement('div');
        this.adminControls.style.cssText = `
            display: none;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        `;
        const adminTitle = document.createElement('h3');
        adminTitle.textContent = 'Admin Controls';
        adminTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: #2E7D32;
            font-size: 18px;
        `;
        const adminButtons = document.createElement('div');
        adminButtons.style.cssText = `
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        `;
        const lockButton = this.createButton('Lock Editing', '#FF9800', () => {
            this.toggleLock(true);
        });
        const unlockButton = this.createButton('Unlock Editing', '#4CAF50', () => {
            this.toggleLock(false);
        });
        const saveButton = this.createButton('Save Version', '#2196F3', () => {
            this.saveVersion();
        });
        const clearButton = this.createButton('Clear Document', '#f44336', () => {
            this.clearDocument();
        });
        const broadcastButton = this.createButton('Broadcast Message', '#9C27B0', () => {
            this.broadcastMessage();
        });
        adminButtons.appendChild(lockButton);
        adminButtons.appendChild(unlockButton);
        adminButtons.appendChild(saveButton);
        adminButtons.appendChild(clearButton);
        adminButtons.appendChild(broadcastButton);
        this.adminControls.appendChild(adminTitle);
        this.adminControls.appendChild(adminButtons);
        baseContainer.appendChild(this.adminControls);

        // Output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Activity Log:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.outputDiv = document.createElement('div');
        this.outputDiv.style.cssText = `
            width: 100%;
            min-height: 80px;
            max-height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #f9f9f9;
            overflow-y: auto;
        `;
        this.outputDiv.textContent = `Connecting to Firebase...`;
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputDiv);
        baseContainer.appendChild(outputSection);

        // Info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 15px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
            margin-top: auto;
        `;
        infoSection.innerHTML = `
            <strong>Instructions:</strong><br>
            • Switch between User and Admin roles using the dropdown<br>
            • Open this editor on multiple devices to collaborate<br>
            • Admin changes are instantly visible to all users via Firebase<br>
            • Admins can lock/unlock editing and manage permissions<br>
            • Admins can remove users from the session<br>
            • Document auto-saves every 30 seconds to Firebase
        `;
        baseContainer.appendChild(infoSection);
        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Update active users list with delete option for admin
     */
    updateActiveUsers() {
        this.userList.innerHTML = '';
        
        // Add current user
        const currentUser = document.createElement('span');
        currentUser.textContent = this.currentRole === 'admin' ? '👑 Admin (You)' : '👤 User (You)';
        currentUser.style.cssText = `
            padding: 4px 8px;
            background-color: ${this.currentRole === 'admin' ? '#4CAF50' : '#2196F3'};
            color: white;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        `;
        this.userList.appendChild(currentUser);
        
        // Add other active users
        this.activeUsers.forEach(user => {
            const userContainer = document.createElement('div');
            userContainer.style.cssText = `
                display: flex;
                align-items: center;
                gap: 5px;
            `;
            
            const userElement = document.createElement('span');
            userElement.textContent = user.role === 'admin' ? '👑 Admin' : '👤 User';
            userElement.style.cssText = `
                padding: 4px 8px;
                background-color: ${user.editing ? '#FF9800' : (user.role === 'admin' ? '#81C784' : '#64B5F6')};
                color: white;
                border-radius: 15px;
                font-size: 12px;
            `;
            userElement.title = user.name;
            userContainer.appendChild(userElement);
            
            // Add delete button for admin
            if (this.currentRole === 'admin') {
                const deleteButton = document.createElement('button');
                deleteButton.textContent = '❌';
                deleteButton.style.cssText = `
                    width: 20px;
                    height: 20px;
                    border: none;
                    border-radius: 50%;
                    background-color: #f44336;
                    color: white;
                    font-size: 10px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                deleteButton.title = 'Remove user';
                deleteButton.addEventListener('click', () => {
                    this.removeUser(user.id);
                });
                userContainer.appendChild(deleteButton);
            }
            
            this.userList.appendChild(userContainer);
        });
        
        if (this.activeUsers.length === 0) {
            const noUsers = document.createElement('span');
            noUsers.textContent = 'No other active users';
            noUsers.style.cssText = `
                padding: 4px 8px;
                color: #666;
                font-style: italic;
            `;
            this.userList.appendChild(noUsers);
        }
    }

    /**
     * Update connection status
     */
    updateConnectionStatus(isConnected) {
        if (isConnected) {
            this.connectionStatus.style.backgroundColor = '#4CAF50';
            this.connectionTooltip.textContent = 'Connected to Firebase';
        } else {
            this.connectionStatus.style.backgroundColor = '#f44336';
            this.connectionTooltip.textContent = 'Disconnected';
        }
    }

    /**
     * Handle text changes in the editor
     */
    handleTextChange(newText) {
        // Check if editing is locked and user is not admin
        if (this.isLocked && this.currentRole === 'user') {
            this.logActivity('Editing is locked by admin. Changes discarded.');
            this.editorArea.value = this.documentContent;
            return;
        }
        
        this.documentContent = newText;
        this.previewArea.textContent = newText;
        
        // Save to Firebase to sync with other users
        this.saveDocumentToFirebase();
        
        // Log activity
        this.logActivity(`Document updated by ${this.currentRole}`);
    }

    /**
     * Start editing
     */
    startEditing() {
        if (this.isLocked && this.currentRole === 'user') {
            this.logActivity('Editing is locked by admin.');
            this.editorArea.blur();
            return;
        }
        
        this.isEditing = true;
        this.updateUserStatus(true);
        this.logActivity(`Started editing as ${this.currentRole}`);
    }

    /**
     * Stop editing
     */
    stopEditing() {
        this.isEditing = false;
        this.updateUserStatus(false);
        this.logActivity(`Stopped editing as ${this.currentRole}`);
    }

    /**
     * Switch between user and admin roles
     */
    switchRole(newRole) {
        this.currentRole = newRole;
        this.registerUser(); // Update user role in Firebase
        this.updateUIForRole();
        this.updateActiveUsers(); // Update user list to show/hide delete buttons
        
        // Show/hide admin controls
        if (newRole === 'admin') {
            this.adminControls.style.display = 'block';
            // Scroll to admin controls when switching to admin
            setTimeout(() => {
                this.adminControls.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        } else {
            this.adminControls.style.display = 'none';
        }
        
        this.logActivity(`Switched to ${newRole} role`);
    }

    /**
     * Update UI based on current role
     */
    updateUIForRole() {
        if (this.currentRole === 'admin') {
            this.editorArea.style.backgroundColor = '#fff8e1';
            this.editorArea.style.border = '2px solid #FFC107';
        } else {
            this.editorArea.style.backgroundColor = '#fff';
            this.editorArea.style.border = '1px solid #ddd';
        }
        
        // Disable editor if locked and user
        if (this.isLocked && this.currentRole === 'user') {
            this.editorArea.disabled = true;
            this.logActivity('Document is locked by admin. You cannot edit.');
        } else {
            this.editorArea.disabled = false;
        }
    }

    /**
     * Toggle document lock
     */
    toggleLock(lock) {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can lock/unlock the document.');
            return;
        }
        
        this.isLocked = lock;
        this.updateUIForRole();
        this.saveDocumentToFirebase(); // Sync with other users
        
        if (lock) {
            this.logActivity('Document locked by admin');
            botReply('Document locked for editing');
        } else {
            this.logActivity('Document unlocked by admin');
            botReply('Document unlocked for editing');
        }
    }

    /**
     * Save document version
     */
    saveVersion() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can save versions.');
            return;
        }
        
        this.currentVersion++;
        this.editHistory.push({
            version: this.currentVersion,
            content: this.documentContent,
            timestamp: new Date().toLocaleString(),
            author: this.currentRole
        });
        
        this.saveDocumentToFirebase(); // Sync with other users
        this.logActivity(`Version ${this.currentVersion} saved by ${this.currentRole}`);
        botReply(`Document version ${this.currentVersion} saved`);
    }

    /**
     * Clear document
     */
    clearDocument() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can clear the document.');
            return;
        }
        
        if (confirm('Are you sure you want to clear the document? This cannot be undone.')) {
            this.documentContent = '';
            this.editorArea.value = '';
            this.previewArea.textContent = '';
            this.saveDocumentToFirebase(); // Sync with other users
            this.logActivity('Document cleared by admin');
            botReply('Document cleared');
        }
    }

    /**
     * Broadcast a message to all users
     */
    broadcastMessage() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can broadcast messages.');
            return;
        }
        
        const message = prompt('Enter message to broadcast to all users:');
        if (message) {
            const messageData = {
                text: message,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                author: this.currentRole
            };
            
            // If Firebase is ready, send immediately
            if (this.isFirebaseInitialized) {
                this.messagesRef.push(messageData);
            } else {
                // Queue the message for when Firebase is ready
                this.messageQueue.push(messageData);
            }
            
            this.logActivity(`Admin broadcast: "${message}"`);
            botReply(`Message broadcast: "${message}"`);
        }
    }

    /**
     * Log activity
     */
    logActivity(message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}\n`;
        this.outputDiv.textContent += logEntry;
        this.outputDiv.scrollTop = this.outputDiv.scrollHeight;
    }

    /**
     * Start auto-save
     */
    startAutoSave() {
        this.autoSaveInterval = setInterval(() => {
            if (this.documentContent.trim() !== '' && this.currentRole === 'admin') {
                this.saveVersion();
            }
        }, 30000); // Auto-save every 30 seconds
    }

    /**
     * Stop auto-save
     */
    stopAutoSave() {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 8px 12px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove user from Firebase
        if (this.isFirebaseInitialized) {
            this.usersRef.child(this.userSessionId).remove();
            this.presenceRef.child(this.userSessionId).remove();
        }
        
        this.stopAutoSave();
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.roleToggle = null;
        this.editorArea = null;
        this.previewArea = null;
        this.outputDiv = null;
        this.userList = null;
        this.adminControls = null;
        this.connectionStatus = null;
        this.connectionTooltip = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Live Collaborative Editor closed. Thank you!");
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}

// Create a singleton instance
const liveScreenLoaderEditor = new LiveScreenLoaderEditor();

// Add this to your AI's command handling
if (/live editor|live text editor|collaborative editor|real-time editor/i.test(userInputRaw)) {
    liveScreenLoaderEditor.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    liveScreenLoaderEditor.closeGame();
    return;
}



class ChatLiveScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'LIVE CHAT APP',
            instructions: 'Real-time chat application with online status and instant messaging.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.messagesContainer = null;
        this.messageInput = null;
        this.sendButton = null;
        this.userList = null;
        this.statusDiv = null;
        this.currentUsername = '';
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.messagesRef = null;
        this.usersRef = null;
        this.presenceRef = null;
        this.connectedRef = null;
        this.typingRef = null;
        this.isFirebaseInitialized = false;
        this.activeUsers = [];
        this.blockedUsers = new Set();
        this.isAdmin = false;
        this.currentChatPartner = null;
        this.isPrivateChat = false;
        this.displayedMessages = new Set();
        this.messageListeners = {};
        this.typingUsers = new Set();
        this.lastMessageId = null; // Track last message to avoid duplicates
    }

    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'user_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Load the Chat App
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLoginScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.logActivity('Loading Firebase libraries...');
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }

    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
                this.logActivity('Firebase initialized successfully');
            } else {
                this.logActivity('Using existing Firebase app');
            }
            
            this.db = firebase.database();
            
            // References
            this.messagesRef = this.db.ref('chat/messages');
            this.usersRef = this.db.ref('chat/users');
            this.presenceRef = this.db.ref('chat/presence');
            this.connectedRef = this.db.ref('.info/connected');
            this.typingRef = this.db.ref('chat/typing');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.updateConnectionStatus(true);
                    this.setupFirebaseListeners();
                } else {
                    this.updateConnectionStatus(false);
                }
            });
            
            this.isFirebaseInitialized = true;
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.logActivity('Firebase connection failed: ' + error.message);
            this.updateConnectionStatus(false);
        }
    }

    /**
     * Setup Firebase listeners (optimized)
     */
    setupFirebaseListeners() {
        // Remove existing listeners
        this.removeFirebaseListeners();
        
        // Single listener for messages with limit
        this.messageListeners.messages = this.messagesRef
            .orderByKey()
            .limitToLast(50)
            .on('child_added', (snapshot) => {
                const message = snapshot.val();
                if (message && snapshot.key !== this.lastMessageId) {
                    this.lastMessageId = snapshot.key;
                    
                    // Check if sender is blocked
                    if (!this.blockedUsers.has(message.senderId)) {
                        // Only display if it's a group message or private message to/from current user
                        if (message.type === 'group' || 
                            (message.receiverId === this.userSessionId) || 
                            (message.senderId === this.userSessionId)) {
                            this.displayMessage(message);
                        }
                    }
                }
            });
        
        // User list listener with throttling
        this.messageListeners.users = this.usersRef.on('value', (snapshot) => {
            const users = snapshot.val();
            if (users) {
                this.activeUsers = Object.values(users).filter(user => user.id !== this.userSessionId);
                this.updateUserList();
            }
        });
        
        // Typing indicator with debouncing
        this.messageListeners.typing = this.typingRef.on('value', (snapshot) => {
            const typingData = snapshot.val();
            if (typingData) {
                this.updateTypingIndicators(typingData);
            }
        });
        
        // Setup presence
        this.presenceRef.child(this.userSessionId).onDisconnect().remove();
        this.presenceRef.child(this.userSessionId).set(true);
    }

    /**
     * Remove Firebase listeners
     */
    removeFirebaseListeners() {
        if (this.messageListeners.messages) {
            this.messagesRef.off('child_added', this.messageListeners.messages);
        }
        if (this.messageListeners.users) {
            this.usersRef.off('value', this.messageListeners.users);
        }
        if (this.messageListeners.typing) {
            this.typingRef.off('value', this.messageListeners.typing);
        }
        this.messageListeners = {};
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
        `;
    }

    /**
     * Create Login Screen
     */
    createLoginScreen() {
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 30px;
            width: 400px;
            max-width: 90vw;
            text-align: center;
        `;

        const title = document.createElement('h2');
        title.textContent = 'Live Chat App';
        title.style.cssText = `
            margin: 0 0 20px 0;
            color: #128C7E;
            font-size: 28px;
        `;
        loginContainer.appendChild(title);

        const subtitle = document.createElement('p');
        subtitle.textContent = 'Enter your username to start chatting';
        subtitle.style.cssText = `
            margin: 0 0 30px 0;
            color: #666;
            font-size: 16px;
        `;
        loginContainer.appendChild(subtitle);

        const inputContainer = document.createElement('div');
        inputContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter your username';
        input.style.cssText = `
            width: 100%;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
        `;
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleLogin(input.value);
            }
        });
        inputContainer.appendChild(input);
        loginContainer.appendChild(inputContainer);

        // Admin checkbox
        const adminContainer = document.createElement('div');
        adminContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const adminLabel = document.createElement('label');
        adminLabel.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        `;
        
        const adminCheckbox = document.createElement('input');
        adminCheckbox.type = 'checkbox';
        adminCheckbox.style.cssText = `
            width: 18px;
            height: 18px;
        `;
        
        const adminText = document.createElement('span');
        adminText.textContent = 'Login as Admin';
        
        adminLabel.appendChild(adminCheckbox);
        adminLabel.appendChild(adminText);
        adminContainer.appendChild(adminLabel);
        loginContainer.appendChild(adminContainer);

        const loginButton = this.createButton('Join Chat', '#128C7E', () => {
            this.isAdmin = adminCheckbox.checked;
            this.handleLogin(input.value);
        });
        loginButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 25px;
            font-size: 16px;
        `;
        loginContainer.appendChild(loginButton);

        // Connection status
        const connectionStatus = document.createElement('div');
        connectionStatus.style.cssText = `
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        `;
        connectionStatus.innerHTML = `
            <span id="connection-indicator" style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: #f44336; margin-right: 5px;"></span>
            <span id="connection-text">Connecting to Firebase...</span>
        `;
        loginContainer.appendChild(connectionStatus);

        this.gameContainer.appendChild(loginContainer);
    }

    /**
     * Update connection status
     */
    updateConnectionStatus(isConnected) {
        const indicator = document.getElementById('connection-indicator');
        const text = document.getElementById('connection-text');
        
        if (indicator && text) {
            indicator.style.backgroundColor = isConnected ? '#25D366' : '#f44336';
            text.textContent = isConnected ? 'Connected to Firebase' : 'Connecting to Firebase...';
        }
    }

    /**
     * Log activity
     */
    logActivity(message) {
        console.log(`[Chat App] ${message}`);
    }

    /**
     * Handle Login
     */
    handleLogin(username) {
        if (!username.trim()) {
            this.showNotification('Please enter a username');
            return;
        }

        this.currentUsername = username.trim();
        this.registerUser();
        this.gameContainer.innerHTML = '';
        this.createChatScreen();
    }

    /**
     * Register user
     */
    registerUser() {
        if (!this.isFirebaseInitialized) {
            setTimeout(() => this.registerUser(), 1000);
            return;
        }
        
        const userData = {
            id: this.userSessionId,
            name: this.currentUsername,
            role: this.isAdmin ? 'admin' : 'user',
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            online: true
        };
        
        this.usersRef.child(this.userSessionId).set(userData).then(() => {
            this.logActivity(`User registered: ${this.currentUsername}`);
        }).catch(error => {
            console.error('Error registering user:', error);
        });
    }

    /**
     * Create Chat Screen (optimized sizes)
     */
    createChatScreen() {
        const chatContainer = document.createElement('div');
        chatContainer.style.cssText = `
            background-color: #f0f2f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 95vw;
            height: 90vh;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            background-color: #128C7E;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        `;
        
        const headerLeft = document.createElement('div');
        headerLeft.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const appTitle = document.createElement('h2');
        appTitle.textContent = 'Live Chat';
        appTitle.style.cssText = `
            margin: 0;
            font-size: 24px;
        `;
        headerLeft.appendChild(appTitle);
        
        const connectionStatus = document.createElement('div');
        connectionStatus.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        `;
        
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.style.cssText = `
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #f44336;
        `;
        connectionStatus.appendChild(this.statusIndicator);
        
        const statusText = document.createElement('span');
        statusText.textContent = 'Connecting...';
        statusText.id = 'connectionStatus';
        connectionStatus.appendChild(statusText);
        
        headerLeft.appendChild(connectionStatus);
        header.appendChild(headerLeft);
        
        const userInfo = document.createElement('div');
        userInfo.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        const userAvatar = document.createElement('div');
        userAvatar.style.cssText = `
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: ${this.isAdmin ? '#f44336' : '#25D366'};
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        `;
        userAvatar.textContent = this.currentUsername.charAt(0).toUpperCase();
        userInfo.appendChild(userAvatar);
        
        const userName = document.createElement('span');
        userName.textContent = this.currentUsername;
        userName.style.cssText = `
            font-weight: bold;
            font-size: 16px;
        `;
        userInfo.appendChild(userName);
        
        const roleBadge = document.createElement('span');
        roleBadge.textContent = this.isAdmin ? 'Admin' : 'User';
        roleBadge.style.cssText = `
            background-color: ${this.isAdmin ? '#f44336' : '#25D366'};
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 5px;
        `;
        userInfo.appendChild(roleBadge);
        
        header.appendChild(userInfo);
        chatContainer.appendChild(header);

        // Main Content
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            flex: 1;
            display: flex;
            overflow: hidden;
        `;
        
        // Sidebar (reduced size)
        const sidebar = document.createElement('div');
        sidebar.style.cssText = `
            width: 200px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        `;
        
        // Users list
        const usersSection = document.createElement('div');
        usersSection.style.cssText = `
            flex: 1;
            overflow-y: auto;
        `;
        
        const usersTitle = document.createElement('div');
        usersTitle.textContent = 'Online Users';
        usersTitle.style.cssText = `
            padding: 10px 15px;
            font-weight: bold;
            color: #666;
            font-size: 14px;
            background-color: #f0f2f5;
        `;
        usersSection.appendChild(usersTitle);
        
        this.userList = document.createElement('div');
        this.userList.id = 'userList';
        this.userList.style.cssText = `
            overflow-y: auto;
        `;
        usersSection.appendChild(this.userList);
        
        sidebar.appendChild(usersSection);
        mainContent.appendChild(sidebar);
        
        // Chat Area
        const chatArea = document.createElement('div');
        chatArea.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #efeae2;
        `;
        
        // Messages Container (larger)
        this.messagesContainer = document.createElement('div');
        this.messagesContainer.style.cssText = `
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        
        // Welcome message
        const welcomeMessage = document.createElement('div');
        welcomeMessage.style.cssText = `
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        `;
        welcomeMessage.textContent = 'Welcome to Live Chat! Start a conversation...';
        this.messagesContainer.appendChild(welcomeMessage);
        
        chatArea.appendChild(this.messagesContainer);
        
        // Typing Indicator
        this.typingIndicator = document.createElement('div');
        this.typingIndicator.style.cssText = `
            padding: 10px 20px;
            color: #666;
            font-size: 14px;
            font-style: italic;
            min-height: 20px;
        `;
        chatArea.appendChild(this.typingIndicator);
        
        // Input Area (larger)
        const inputArea = document.createElement('div');
        inputArea.style.cssText = `
            padding: 15px;
            background-color: #f0f2f5;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        
        this.messageInput = document.createElement('input');
        this.messageInput.type = 'text';
        this.messageInput.placeholder = 'Type a message...';
        this.messageInput.style.cssText = `
            flex: 1;
            padding: 15px 25px;
            border: 1px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
        `;
        this.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        this.messageInput.addEventListener('input', () => {
            this.handleTyping();
        });
        inputArea.appendChild(this.messageInput);
        
        this.sendButton = this.createButton('Send', '#128C7E', () => {
            this.sendMessage();
        });
        this.sendButton.style.cssText = `
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
        `;
        inputArea.appendChild(this.sendButton);
        
        chatArea.appendChild(inputArea);
        mainContent.appendChild(chatArea);
        chatContainer.appendChild(mainContent);
        
        this.gameContainer.appendChild(chatContainer);
        
        // Focus on input
        setTimeout(() => {
            this.messageInput.focus();
        }, 100);
        
        this.updateConnectionStatus(this.isFirebaseInitialized);
    }

    /**
     * Update user list (optimized)
     */
    updateUserList() {
        if (!this.userList) return;
        
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        if (this.activeUsers.length === 0) {
            const noUsers = document.createElement('div');
            noUsers.textContent = 'No other users online';
            noUsers.style.cssText = `
                padding: 15px;
                color: #666;
                text-align: center;
                font-style: italic;
            `;
            fragment.appendChild(noUsers);
        } else {
            this.activeUsers.forEach(user => {
                const userItem = document.createElement('div');
                userItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 10px 12px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                `;
                
                userItem.addEventListener('mouseenter', () => {
                    userItem.style.backgroundColor = '#f0f2f5';
                });
                
                userItem.addEventListener('mouseleave', () => {
                    userItem.style.backgroundColor = 'transparent';
                });
                
                userItem.addEventListener('click', () => {
                    this.startPrivateChat(user);
                });
                
                // User avatar (smaller)
                const avatar = document.createElement('div');
                avatar.style.cssText = `
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    background-color: ${user.role === 'admin' ? '#f44336' : '#128C7E'};
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 14px;
                `;
                avatar.textContent = user.name.charAt(0).toUpperCase();
                userItem.appendChild(avatar);
                
                // User name
                const userName = document.createElement('div');
                userName.textContent = user.name;
                userName.style.cssText = `
                    font-weight: bold;
                    color: #333;
                    font-size: 14px;
                `;
                userItem.appendChild(userName);
                
                // Online indicator
                const onlineIndicator = document.createElement('div');
                onlineIndicator.style.cssText = `
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    background-color: #25D366;
                    border: 2px solid white;
                `;
                userItem.appendChild(onlineIndicator);
                
                // Action buttons
                const actionButtons = document.createElement('div');
                actionButtons.style.cssText = `
                    display: flex;
                    gap: 3px;
                    margin-left: auto;
                `;
                
                // Block button
                const blockButton = this.createButton('🚫', '#f44336', () => {
                    this.toggleBlockUser(user);
                });
                blockButton.style.cssText = `
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    padding: 0;
                    font-size: 12px;
                `;
                blockButton.title = this.blockedUsers.has(user.id) ? 'Unblock User' : 'Block User';
                actionButtons.appendChild(blockButton);
                
                // Delete button (admin only)
                if (this.isAdmin) {
                    const deleteButton = this.createButton('❌', '#f44336', () => {
                        this.deleteUser(user);
                    });
                    deleteButton.style.cssText = `
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        padding: 0;
                        font-size: 12px;
                    `;
                    deleteButton.title = 'Delete User';
                    actionButtons.appendChild(deleteButton);
                }
                
                userItem.appendChild(actionButtons);
                fragment.appendChild(userItem);
            });
        }
        
        // Update the list in one operation
        this.userList.innerHTML = '';
        this.userList.appendChild(fragment);
    }

    /**
     * Toggle block user
     */
    toggleBlockUser(user) {
        if (this.blockedUsers.has(user.id)) {
            this.blockedUsers.delete(user.id);
            this.showNotification(`${user.name} unblocked`);
        } else {
            this.blockedUsers.add(user.id);
            this.showNotification(`${user.name} blocked`);
        }
        this.updateUserList();
    }

    /**
     * Delete user (admin only)
     */
    deleteUser(user) {
        if (!this.isAdmin) {
            this.showNotification('Only admins can delete users');
            return;
        }
        
        if (confirm(`Are you sure you want to delete ${user.name}?`)) {
            this.usersRef.child(user.id).remove().then(() => {
                this.presenceRef.child(user.id).remove();
                this.showNotification(`${user.name} has been deleted`);
            }).catch(error => {
                console.error('Error deleting user:', error);
                this.showNotification('Error deleting user');
            });
        }
    }

    /**
     * Start private chat
     */
    startPrivateChat(user) {
        if (this.blockedUsers.has(user.id)) {
            this.showNotification('You have blocked this user');
            return;
        }
        
        this.currentChatPartner = user;
        this.isPrivateChat = true;
        
        const chatHeader = document.querySelector('header h2');
        if (chatHeader) {
            chatHeader.textContent = `Chat with ${user.name}`;
        }
        
        this.messagesContainer.innerHTML = '';
        this.showNotification(`Now chatting privately with ${user.name}`);
    }

    /**
     * Handle typing indicator (optimized)
     */
    handleTyping() {
        if (!this.isFirebaseInitialized) return;
        
        const isTyping = this.messageInput.value.length > 0;
        
        if (isTyping) {
            this.typingRef.child(this.userSessionId).set({
                username: this.currentUsername,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            
            clearTimeout(this.typingTimeout);
            this.typingTimeout = setTimeout(() => {
                this.typingRef.child(this.userSessionId).remove();
            }, 3000);
        } else {
            this.typingRef.child(this.userSessionId).remove();
        }
    }

    /**
     * Update typing indicators
     */
    updateTypingIndicators(typingData) {
        const typingUsers = [];
        const now = Date.now();
        
        Object.keys(typingData).forEach(userId => {
            if (userId !== this.userSessionId) {
                const user = typingData[userId];
                if (now - user.timestamp < 3000) {
                    typingUsers.push(user.username);
                }
            }
        });
        
        this.typingIndicator.textContent = typingUsers.length > 0 ? 
            `${typingUsers.join(', ')} is typing...` : '';
    }

    /**
     * Send message (optimized)
     */
    sendMessage() {
        const messageText = this.messageInput.value.trim();
        if (!messageText) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            text: messageText,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            type: this.isPrivateChat ? 'private' : 'group'
        };
        
        if (this.isPrivateChat && this.currentChatPartner) {
            message.receiverId = this.currentChatPartner.id;
        }
        
        // Use push with key tracking
        const newMessageRef = this.messagesRef.push();
        this.lastMessageId = newMessageRef.key;
        newMessageRef.set(message);
        
        // Clear input
        this.messageInput.value = '';
        this.typingRef.child(this.userSessionId).remove();
        
        // Display immediately for better UX
        this.displayMessage(message);
    }

    /**
     * Display message (optimized)
     */
    displayMessage(message) {
        const isOwnMessage = message.senderId === this.userSessionId;
        
        const messageContainer = document.createElement('div');
        messageContainer.style.cssText = `
            display: flex;
            ${isOwnMessage ? 'justify-content: flex-end' : 'justify-content: flex-start'}
            margin-bottom: 8px;
        `;
        
        const messageBubble = document.createElement('div');
        messageBubble.style.cssText = `
            max-width: 70%;
            padding: 10px 15px;
            border-radius: 18px;
            background-color: ${isOwnMessage ? '#dcf8c6' : '#fff'};
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
        `;
        
        // Sender name
        if (!isOwnMessage && (message.type === 'group' || this.isPrivateChat)) {
            const senderName = document.createElement('div');
            senderName.textContent = message.senderName;
            senderName.style.cssText = `
                font-weight: bold;
                font-size: 12px;
                color: #128C7E;
                margin-bottom: 4px;
            `;
            messageBubble.appendChild(senderName);
        }
        
        // Message text
        const messageText = document.createElement('div');
        messageText.textContent = message.text;
        messageText.style.cssText = `
            word-wrap: break-word;
            font-size: 15px;
        `;
        messageBubble.appendChild(messageText);
        
        // Timestamp
        const timestamp = document.createElement('div');
        timestamp.textContent = this.formatTimestamp(message.timestamp);
        timestamp.style.cssText = `
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            text-align: ${isOwnMessage ? 'right' : 'left'};
        `;
        messageBubble.appendChild(timestamp);
        
        messageContainer.appendChild(messageBubble);
        
        // Remove welcome message if exists
        if (this.messagesContainer.firstChild && this.messagesContainer.firstChild.textContent.includes('Welcome')) {
            this.messagesContainer.innerHTML = '';
        }
        
        this.messagesContainer.appendChild(messageContainer);
        
        // Auto-scroll to bottom
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }

    /**
     * Format timestamp
     */
    formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 10000;
            animation: slideDown 0.3s ease;
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 20px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 16px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const existingButtons = document.querySelector('.floating-buttons');
        if (existingButtons) {
            existingButtons.remove();
        }
        
        const floatingButtons = document.createElement('div');
        floatingButtons.className = 'floating-buttons';
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10001;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        
        if (this.gameContainer) {
            this.gameContainer.appendChild(floatingButtons);
        } else {
            document.body.appendChild(floatingButtons);
        }
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        if (this.isFirebaseInitialized) {
            this.usersRef.child(this.userSessionId).remove();
            this.presenceRef.child(this.userSessionId).remove();
            this.typingRef.child(this.userSessionId).remove();
        }
        
        this.removeFirebaseListeners();
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        const floatingButtons = document.querySelector('.floating-buttons');
        if (floatingButtons) {
            floatingButtons.remove();
        }
        
        this.gameContainer = null;
        this.messagesContainer = null;
        this.messageInput = null;
        this.sendButton = null;
        this.userList = null;
        this.statusDiv = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Live Chat App closed. Thank you!");
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}

// Create a singleton instance
const chatLiveScreenLoader = new ChatLiveScreenLoader();

// Add this to your AI's command handling
if (/chat app|live chat|whatsapp|messenger|chat room/i.test(userInputRaw)) {
    chatLiveScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    chatLiveScreenLoader.closeGame();
    return;
}

class TicTacToeGame {
    constructor() {
        this.baseScreen = {
            name: 'TIC TAC TOE',
            instructions: 'Real-time two-player game. Play with anyone online!'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentUsername = '';
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.gameRef = null;
        this.playersRef = null;
        this.connectedRef = null;
        this.messagesRef = null;
        this.isFirebaseInitialized = false;
        this.currentGame = null;
        this.gameListener = null;
        this.playersListener = null;
        this.messagesListener = null;
        this.board = Array(9).fill('');
        this.currentPlayer = 'X';
        this.gameActive = false;
        this.playerSymbol = null;
        this.opponentSymbol = null;
        this.playerNumber = null;
        this.availableGames = [];
        this.gameScreenCreated = false;
        this.player1Online = true;
        this.player2Online = true;
        this.emojis = ['😀', '😂', '😍', '🤔', '😎', '👍', '👎', '🔥', '💯', '🎉'];
        this.messageInput = null;
        this.emojiPanel = null;
        this.messagesContainer = null;
        this.connectionChecked = false;
        this.messageConnectionChecked = false;
        this.emojiConnectionChecked = false;
        
        // Neon color scheme
        this.colors = {
            primary: '#00f2fe',      // Cyan - for primary elements
            secondary: '#ff00cc',    // Pink - for secondary elements
            accent: '#fffc00',       // Yellow - for accents
            dark: '#0a0a27',         // Dark blue - for backgrounds
            light: '#ffffff',        // White - for text
            playerX: '#00f2fe',      // Cyan for X
            playerO: '#ff00cc',      // Pink for O
            success: '#4ade80',      // Green for success
            warning: '#fbbf24',      // Yellow for warnings
            error: '#9ca3af'        // Gray for errors
        };
    }
    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'player_' + Math.random().toString(36).substr(2, 9);
    }
    /**
     * Load the Tic Tac Toe Game
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLoginScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }
    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }
    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            
            // References
            this.gameRef = this.db.ref('tictactoe/games');
            this.playersRef = this.db.ref('tictactoe/players');
            this.messagesRef = this.db.ref('tictactoe/messages');
            this.connectedRef = this.db.ref('.info/connected');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.setupFirebaseListeners();
                    this.loadAvailableGames();
                }
            });
            
            this.isFirebaseInitialized = true;
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
    }
    /**
     * Setup Firebase listeners
     */
    setupFirebaseListeners() {
        // Listen for available games
        this.playersRef = this.db.ref('tictactoe/players');
        this.playersListener = this.playersRef.on('value', (snapshot) => {
            const players = snapshot.val();
            if (players) {
                this.updateAvailableGames(players);
                this.checkPlayerOnlineStatus(players);
                
                // One-time connection check for all players
                if (!this.connectionChecked && this.currentGame) {
                    this.checkAllConnections(players);
                    this.connectionChecked = true;
                }
            }
        });
    }
    
    /**
     * Check all connections in the game
     */
    checkAllConnections(players) {
        if (!this.currentGame) return;
        
        // Check if both players are connected
        const player1Connected = !!players[this.currentGame.player1];
        const player2Connected = !!players[this.currentGame.player2];
        
        if (player1Connected && player2Connected) {
            this.showNotification('Both players are connected! Game ready to play.');
        } else if (!player1Connected && this.currentGame.player1) {
            this.showNotification('Player 1 has disconnected.');
        } else if (!player2Connected && this.currentGame.player2) {
            this.showNotification('Player 2 has disconnected.');
        }
        
        // Check message connection
        if (!this.messageConnectionChecked) {
            this.checkMessageConnection();
            this.messageConnectionChecked = true;
        }
        
        // Check emoji connection
        if (!this.emojiConnectionChecked) {
            this.checkEmojiConnection();
            this.emojiConnectionChecked = true;
        }
    }
    
    /**
     * Check message connection
     */
    checkMessageConnection() {
        if (!this.currentGame) return;
        
        // Create a test message
        const testMessage = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: "Connection test",
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isTest: true
        };
        
        this.messagesRef.child(this.currentGame.id).push(testMessage)
            .then(() => {
                this.showNotification('Message connection established successfully!');
                // Remove the test message
                this.messagesRef.child(this.currentGame.id).once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const message = childSnapshot.val();
                        if (message.isTest) {
                            this.messagesRef.child(this.currentGame.id).child(childSnapshot.key).remove();
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Message connection error:', error);
                this.showNotification('Message connection failed. Please try again.');
            });
    }
    
    /**
     * Check emoji connection
     */
    checkEmojiConnection() {
        if (!this.currentGame) return;
        
        // Create a test emoji
        const testEmoji = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: "🔗",
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isTest: true
        };
        
        this.messagesRef.child(this.currentGame.id).push(testEmoji)
            .then(() => {
                this.showNotification('Emoji connection established successfully!');
                // Remove the test emoji
                this.messagesRef.child(this.currentGame.id).once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const message = childSnapshot.val();
                        if (message.isTest) {
                            this.messagesRef.child(this.currentGame.id).child(childSnapshot.key).remove();
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Emoji connection error:', error);
                this.showNotification('Emoji connection failed. Please try again.');
            });
    }
    
    /**
     * Check player online status
     */
    checkPlayerOnlineStatus(players) {
        if (!this.currentGame || !this.gameScreenCreated) return;
        
        // Check if player 1 is online
        this.player1Online = !!(players[this.currentGame.player1]);
        
        // Check if player 2 is online
        this.player2Online = !!(players[this.currentGame.player2]);
        
        // Update the game screen with online status
        this.updatePlayerOnlineStatus();
    }
    
    /**
     * Update player online status in UI
     */
    updatePlayerOnlineStatus() {
        if (!this.gameContainer || !this.currentGame) return;
        
        const player1Info = this.gameContainer.querySelector('.player1-info');
        const player2Info = this.gameContainer.querySelector('.player2-info');
        
        if (player1Info) {
            const statusIndicator = player1Info.querySelector('.status-indicator') || 
                                   document.createElement('span');
            statusIndicator.className = 'status-indicator';
            statusIndicator.style.cssText = `
                display: inline-block;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-left: 5px;
                background-color: ${this.player1Online ? this.colors.success : this.colors.error};
                box-shadow: 0 0 8px ${this.player1Online ? this.colors.success : this.colors.error};
            `;
            
            if (!player1Info.contains(statusIndicator)) {
                player1Info.appendChild(statusIndicator);
            }
        }
        
        if (player2Info) {
            const statusIndicator = player2Info.querySelector('.status-indicator') || 
                                   document.createElement('span');
            statusIndicator.className = 'status-indicator';
            statusIndicator.style.cssText = `
                display: inline-block;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-left: 5px;
                background-color: ${this.player2Online ? this.colors.success : this.colors.error};
                box-shadow: 0 0 8px ${this.player2Online ? this.colors.success : this.colors.error};
            `;
            
            if (!player2Info.contains(statusIndicator)) {
                player2Info.appendChild(statusIndicator);
            }
        }
        
        // Show notification if opponent is offline
        if ((this.playerNumber === 1 && !this.player2Online) || 
            (this.playerNumber === 2 && !this.player1Online)) {
            this.showNotification('Your opponent is offline');
        }
    }
    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, ${this.colors.dark}, #1a1a3e, ${this.colors.dark});
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        // Add CSS animation for background gradient
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes gradientBG {
                0% { background-position: 0% 50%; }
                50% { background-position: 100% 50%; }
                100% { background-position: 0% 50%; }
            }
            
            .neon-glow {
                box-shadow: 0 0 10px ${this.colors.primary}, 0 0 20px ${this.colors.primary}, 0 0 30px ${this.colors.primary};
                transition: all 0.3s ease;
            }
            
            .neon-glow:hover {
                box-shadow: 0 0 15px ${this.colors.primary}, 0 0 25px ${this.colors.primary}, 0 0 35px ${this.colors.primary};
            }
            
            .neon-glow-pink {
                box-shadow: 0 0 10px ${this.colors.secondary}, 0 0 20px ${this.colors.secondary}, 0 0 30px ${this.colors.secondary};
                transition: all 0.3s ease;
            }
            
            .neon-glow-pink:hover {
                box-shadow: 0 0 15px ${this.colors.secondary}, 0 0 25px ${this.colors.secondary}, 0 0 35px ${this.colors.secondary};
            }
            
            .neon-glow-yellow {
                box-shadow: 0 0 10px ${this.colors.accent}, 0 0 20px ${this.colors.accent}, 0 0 30px ${this.colors.accent};
                transition: all 0.3s ease;
            }
            
            .neon-glow-yellow:hover {
                box-shadow: 0 0 15px ${this.colors.accent}, 0 0 25px ${this.colors.accent}, 0 0 35px ${this.colors.accent};
            }
            
            .game-cell {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(5px);
                border: 2px solid rgba(255, 255, 255, 0.1);
                border-radius: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 48px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }
            
            .game-cell::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .game-cell:hover::before {
                opacity: 1;
            }
            
            .game-cell:hover {
                background: rgba(255, 255, 255, 0.1);
                transform: scale(1.05);
            }
            
            .game-cell.x-player {
                color: ${this.colors.playerX};
                text-shadow: 0 0 10px ${this.colors.playerX}, 0 0 20px ${this.colors.playerX};
            }
            
            .game-cell.o-player {
                color: ${this.colors.playerO};
                text-shadow: 0 0 10px ${this.colors.playerO}, 0 0 20px ${this.colors.playerO};
            }
            
            .message-bubble {
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                border-radius: 20px;
                padding: 10px 15px;
                margin: 5px 0;
                max-width: 80%;
                word-wrap: break-word;
                animation: fadeIn 0.3s ease;
                position: relative;
            }
            
            .message-bubble.player-message {
                background: rgba(0, 242, 254, 0.2);
                border: 1px solid rgba(0, 242, 254, 0.5);
                align-self: flex-end;
                border-bottom-right-radius: 5px;
            }
            
            .message-bubble.opponent-message {
                background: rgba(255, 0, 204, 0.2);
                border: 1px solid rgba(255, 0, 204, 0.5);
                align-self: flex-start;
                border-bottom-left-radius: 5px;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .emoji-btn {
                background: none;
                border: none;
                font-size: 20px;
                cursor: pointer;
                padding: 5px;
                border-radius: 50%;
                transition: all 0.2s ease;
            }
            
            .emoji-btn:hover {
                background: rgba(255, 255, 255, 0.2);
                transform: scale(1.2);
            }
            
            .neon-text {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.primary}, 0 0 10px ${this.colors.primary};
            }
            
            .neon-text-pink {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.secondary}, 0 0 10px ${this.colors.secondary};
            }
            
            .neon-text-yellow {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.accent}, 0 0 10px ${this.colors.accent};
            }
        `;
        document.head.appendChild(style);
    }
    /**
     * Create Login Screen
     */
    createLoginScreen() {
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 400px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        loginContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Tic Tac Toe';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 36px;
            letter-spacing: 2px;
        `;
        loginContainer.appendChild(title);
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Enter your name to play';
        subtitle.style.cssText = `
            margin: 0 0 30px 0;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
        `;
        loginContainer.appendChild(subtitle);
        const inputContainer = document.createElement('div');
        inputContainer.style.cssText = `
            margin-bottom: 25px;
        `;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter your name';
        input.style.cssText = `
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            color: ${this.colors.light};
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Add placeholder styling
        input.addEventListener('focus', () => {
            input.style.boxShadow = `0 0 15px ${this.colors.primary}`;
            input.style.borderColor = this.colors.primary;
        });
        
        input.addEventListener('blur', () => {
            input.style.boxShadow = 'none';
            input.style.borderColor = 'transparent';
        });
        
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleLogin(input.value);
            }
        });
        inputContainer.appendChild(input);
        loginContainer.appendChild(inputContainer);
        const loginButton = this.createButton('Play Game', this.colors.primary, () => {
            this.handleLogin(input.value);
        });
        loginButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 1px;
            background: linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary});
        `;
        loginContainer.appendChild(loginButton);
        this.gameContainer.appendChild(loginContainer);
    }
    /**
     * Handle Login
     */
    handleLogin(username) {
        if (!username.trim()) {
            this.showNotification('Please enter your name');
            return;
        }
        this.currentUsername = username.trim();
        this.gameContainer.innerHTML = '';
        this.createGameLobby();
    }
    /**
     * Create Game Lobby
     */
    createGameLobby() {
        const lobbyContainer = document.createElement('div');
        lobbyContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 30px;
            width: 600px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        lobbyContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Game Lobby';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 32px;
            letter-spacing: 2px;
        `;
        lobbyContainer.appendChild(title);
        const userInfo = document.createElement('div');
        userInfo.style.cssText = `
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            color: ${this.colors.light};
            font-size: 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        userInfo.textContent = `Welcome, ${this.currentUsername}!`;
        lobbyContainer.appendChild(userInfo);
        // Game options
        const optionsContainer = document.createElement('div');
        optionsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        `;
        const newGameButton = this.createButton('Create New Game', this.colors.primary, () => {
            this.createNewGame();
        });
        newGameButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary});
        `;
        optionsContainer.appendChild(newGameButton);
        const joinGameButton = this.createButton('Join Random Game', this.colors.secondary, () => {
            this.joinRandomGame();
        });
        joinGameButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, ${this.colors.secondary}, ${this.colors.primary});
        `;
        optionsContainer.appendChild(joinGameButton);
        lobbyContainer.appendChild(optionsContainer);
        // Available games list
        const gamesSection = document.createElement('div');
        gamesSection.style.cssText = `
            margin-top: 20px;
        `;
        
        const gamesTitle = document.createElement('h3');
        gamesTitle.textContent = 'Available Games';
        gamesTitle.className = 'neon-text';
        gamesTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 22px;
            letter-spacing: 1px;
        `;
        gamesSection.appendChild(gamesTitle);
        this.gamesList = document.createElement('div');
        this.gamesList.style.cssText = `
            max-height: 250px;
            overflow-y: auto;
            text-align: left;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        this.gamesList.textContent = 'Loading available games...';
        gamesSection.appendChild(this.gamesList);
        lobbyContainer.appendChild(gamesSection);
        this.gameContainer.appendChild(lobbyContainer);
    }
    /**
     * Load available games
     */
    loadAvailableGames() {
        // First get all games from the games reference
        this.gameRef.once('value').then((snapshot) => {
            const games = snapshot.val();
            if (games) {
                // Then get all players to check who is online
                this.playersRef.once('value').then((playersSnapshot) => {
                    const players = playersSnapshot.val();
                    this.updateAvailableGamesWithGames(games, players);
                });
            } else {
                this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            }
        });
    }
    
    /**
     * Update available games list with games data
     */
    updateAvailableGamesWithGames(games, players) {
        if (!this.gamesList) return;
        
        this.gamesList.innerHTML = '';
        
        // Convert games object to array
        const gamesArray = Object.entries(games).map(([gameId, game]) => ({
            id: gameId,
            ...game
        }));
        
        if (gamesArray.length === 0) {
            this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            return;
        }
        
        gamesArray.forEach(game => {
            const gameItem = document.createElement('div');
            gameItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;
            
            gameItem.addEventListener('mouseenter', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                gameItem.style.boxShadow = `0 0 10px ${this.colors.primary}`;
            });
            
            gameItem.addEventListener('mouseleave', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                gameItem.style.boxShadow = 'none';
            });
            
            // Get player info
            const player1Name = game.player1Name || 'Player 1';
            const player2Name = game.player2Name || (game.status === 'waiting' ? 'Waiting for opponent' : 'Player 2');
            
            const gameInfo = document.createElement('div');
            gameInfo.innerHTML = `
                <div style="font-weight: bold; color: ${this.colors.light}; font-size: 16px;">
                    ${player1Name} ${player.player2Name ? 'vs' : 'vs'} ${player2Name}
                </div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">
                    ${game.status === 'waiting' ? 'Waiting for opponent' : 'Game in progress'}
                </div>
            `;
            gameItem.appendChild(gameInfo);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '8px';
            
            // Show Join button only for waiting games
            if (game.status === 'waiting') {
                const joinButton = this.createButton('Join', this.colors.success, () => {
                    this.joinGame(game.id);
                });
                joinButton.style.cssText = `
                    padding: 6px 12px;
                    font-size: 14px;
                    border-radius: 20px;
                `;
                buttonContainer.appendChild(joinButton);
            }
            
            // Add delete button for all games
            const deleteButton = this.createButton('Delete', this.colors.error, () => {
                this.deleteGame(game.id);
            });
            deleteButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(deleteButton);
            
            gameItem.appendChild(buttonContainer);
            this.gamesList.appendChild(gameItem);
        });
    }
    
    /**
     * Update available games list (fallback method for players data)
     */
    updateAvailableGames(players) {
        if (!this.gamesList) return;
        const waitingPlayers = Object.values(players).filter(p => p.status === 'waiting');
        
        if (waitingPlayers.length === 0) {
            this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            return;
        }
        this.gamesList.innerHTML = '';
        
        waitingPlayers.forEach(player => {
            const gameItem = document.createElement('div');
            gameItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;
            
            gameItem.addEventListener('mouseenter', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                gameItem.style.boxShadow = `0 0 10px ${this.colors.primary}`;
            });
            
            gameItem.addEventListener('mouseleave', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                gameItem.style.boxShadow = 'none';
            });
            
            const playerInfo = document.createElement('div');
            playerInfo.innerHTML = `
                <div style="font-weight: bold; color: ${this.colors.light}; font-size: 16px;">${player.name}</div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">Waiting for opponent</div>
            `;
            gameItem.appendChild(playerInfo);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '8px';
            
            const joinButton = this.createButton('Join', this.colors.success, () => {
                this.joinGame(player.gameId);
            });
            joinButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(joinButton);
            
            // Add delete button for all games
            const deleteButton = this.createButton('Delete', this.colors.error, () => {
                this.deleteGame(player.gameId);
            });
            deleteButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(deleteButton);
            
            gameItem.appendChild(buttonContainer);
            this.gamesList.appendChild(gameItem);
        });
    }
    
    /**
     * Delete a game
     */
    deleteGame(gameId) {
        if (confirm('Are you sure you want to delete this game? This action cannot be undone.')) {
            // Remove game from Firebase
            this.gameRef.child(gameId).remove()
                .then(() => {
                    // Remove all players associated with this game
                    this.playersRef.once('value').then((snapshot) => {
                        const players = snapshot.val();
                        if (players) {
                            Object.entries(players).forEach(([playerId, player]) => {
                                if (player.gameId === gameId) {
                                    this.playersRef.child(playerId).remove();
                                }
                            });
                        }
                    })
                    .then(() => {
                        this.showNotification('Game deleted successfully');
                        // Refresh the games list
                        this.loadAvailableGames();
                    })
                    .catch(error => {
                        console.error('Error removing players:', error);
                        this.showNotification('Error deleting game');
                    });
                })
                .catch(error => {
                    console.error('Error deleting game:', error);
                    this.showNotification('Error deleting game');
                });
        }
    }
    /**
     * Create new game
     */
    createNewGame() {
        const gameId = 'game_' + Date.now();
        
        // Create player entry
        const playerData = {
            id: this.userSessionId,
            name: this.currentUsername,
            gameId: gameId,
            status: 'waiting',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.playersRef.child(this.userSessionId).set(playerData).then(() => {
            this.currentGame = {
                id: gameId,
                board: Array(9).fill(''),
                currentPlayer: 'X',
                status: 'waiting',
                player1: this.userSessionId,
                player1Name: this.currentUsername,
                player2: null,
                player2Name: null,
                winner: null,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };
            
            this.gameRef.child(gameId).set(this.currentGame).then(() => {
                this.setupGameListener(gameId);
                this.showNotification('Game created! Waiting for opponent...');
            });
        });
    }
    /**
     * Join random game
     */
    joinRandomGame() {
        this.playersRef.once('value').then((snapshot) => {
            const players = snapshot.val();
            if (players) {
                const waitingPlayers = Object.values(players).filter(p => p.status === 'waiting');
                if (waitingPlayers.length > 0) {
                    const randomPlayer = waitingPlayers[Math.floor(Math.random() * waitingPlayers.length)];
                    this.joinGame(randomPlayer.gameId);
                } else {
                    this.showNotification('No available games. Create a new game!');
                }
            }
        });
    }
    /**
     * Join specific game
     */
    joinGame(gameId) {
        // Get game data
        this.gameRef.child(gameId).once('value').then((snapshot) => {
            const game = snapshot.val();
            if (game && game.status === 'waiting') {
                // Update game with player 2
                const updates = {
                    status: 'playing',
                    player2: this.userSessionId,
                    player2Name: this.currentUsername
                };
                
                this.gameRef.child(gameId).update(updates).then(() => {
                    // Update player status
                    this.playersRef.child(this.userSessionId).set({
                        id: this.userSessionId,
                        name: this.currentUsername,
                        gameId: gameId,
                        status: 'playing',
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    // Set up game listener
                    this.setupGameListener(gameId);
                    
                    // Set local game state
                    this.currentGame = { ...game, ...updates };
                    this.playerSymbol = 'O';
                    this.opponentSymbol = 'X';
                    this.playerNumber = 2;
                    this.gameActive = true;
                    this.gameScreenCreated = false;
                    
                    // Create game screen
                    this.createGameScreen();
                });
            } else {
                this.showNotification('Game is no longer available');
            }
        });
    }
    /**
     * Setup game listener
     */
    setupGameListener(gameId) {
        // Remove existing listener if any
        if (this.gameListener) {
            this.gameRef.child(gameId).off('value', this.gameListener);
        }
        
        this.gameListener = this.gameRef.child(gameId).on('value', (snapshot) => {
            const game = snapshot.val();
            if (game) {
                this.currentGame = game;
                
                // Check if game is ready to play (both players connected)
                if (game.status === 'playing' && game.player1 && game.player2) {
                    this.gameActive = true;
                    
                    // Set player symbols if not already set
                    if (!this.playerSymbol) {
                        if (game.player1 === this.userSessionId) {
                            this.playerSymbol = 'X';
                            this.opponentSymbol = 'O';
                            this.playerNumber = 1;
                        } else if (game.player2 === this.userSessionId) {
                            this.playerSymbol = 'O';
                            this.opponentSymbol = 'X';
                            this.playerNumber = 2;
                        }
                    }
                    
                    // Create game screen if not already created
                    if (!this.gameScreenCreated) {
                        this.gameScreenCreated = true;
                        this.createGameScreen();
                    } else {
                        // Always update the game screen when data changes
                        this.updateGameScreen();
                    }
                }
                
                // Check for draw condition and update both players
                if (game.status === 'finished' && game.winner === 'draw') {
                    this.updateGameScreen();
                }
            }
        });
        
        // Setup messages listener
        this.setupMessagesListener(gameId);
    }
    
    /**
     * Setup messages listener
     */
    setupMessagesListener(gameId) {
        // Remove existing listener if any
        if (this.messagesListener) {
            this.messagesRef.child(gameId).off('child_added', this.messagesListener);
        }
        
        this.messagesListener = this.messagesRef.child(gameId).limitToLast(20).on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (this.messagesContainer) {
                this.displayMessage(message);
            }
        });
    }
    
    /**
     * Display a message in the messages container
     */
    displayMessage(message) {
        if (!this.messagesContainer) return;
        
        // Skip test messages
        if (message.isTest) return;
        
        const messageElement = document.createElement('div');
        messageElement.className = 'message-bubble';
        
        // Style based on who sent the message
        if (message.senderId === this.userSessionId) {
            messageElement.classList.add('player-message');
        } else {
            messageElement.classList.add('opponent-message');
        }
        
        // Add sender name for opponent messages
        if (message.senderId !== this.userSessionId) {
            const senderName = document.createElement('div');
            senderName.textContent = message.senderName;
            senderName.style.cssText = `
                font-weight: bold;
                margin-bottom: 5px;
                color: ${this.colors.light};
                font-size: 14px;
            `;
            messageElement.appendChild(senderName);
        }
        
        // Add message content
        const content = document.createElement('div');
        content.textContent = message.content;
        content.style.cssText = `
            color: ${this.colors.light};
            font-size: 16px;
        `;
        messageElement.appendChild(content);
        
        // Add timestamp
        const timestamp = document.createElement('div');
        timestamp.textContent = new Date(message.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        timestamp.style.cssText = `
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
            text-align: right;
        `;
        messageElement.appendChild(timestamp);
        
        this.messagesContainer.appendChild(messageElement);
        
        // Scroll to bottom
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        
        // Add animation effect
        messageElement.style.animation = 'fadeIn 0.3s ease';
        
        // Add glow effect for emojis
        if (this.emojis.includes(message.content)) {
            content.style.fontSize = '24px';
            content.style.textAlign = 'center';
            
            if (message.senderId === this.userSessionId) {
                content.style.textShadow = `0 0 10px ${this.colors.primary}, 0 0 20px ${this.colors.primary}`;
            } else {
                content.style.textShadow = `0 0 10px ${this.colors.secondary}, 0 0 20px ${this.colors.secondary}`;
            }
        }
    }
    
    /**
     * Send a message
     */
    sendMessage() {
        if (!this.messageInput || !this.currentGame) return;
        
        const content = this.messageInput.value.trim();
        if (!content) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: content,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.messagesRef.child(this.currentGame.id).push(message)
            .then(() => {
                this.messageInput.value = '';
            })
            .catch(error => {
                console.error('Error sending message:', error);
                this.showNotification('Error sending message');
            });
    }
    
    /**
     * Send an emoji
     */
    sendEmoji(emoji) {
        if (!this.currentGame) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: emoji,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.messagesRef.child(this.currentGame.id).push(message)
            .catch(error => {
                console.error('Error sending emoji:', error);
                this.showNotification('Error sending emoji');
            });
    }
    
    /**
     * Create emoji panel
     */
    createEmojiPanel() {
        this.emojiPanel = document.createElement('div');
        this.emojiPanel.style.cssText = `
            position: absolute;
            bottom: 60px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        `;
        
        this.emojis.forEach(emoji => {
            const emojiButton = document.createElement('button');
            emojiButton.className = 'emoji-btn';
            emojiButton.textContent = emoji;
            emojiButton.addEventListener('click', () => {
                this.sendEmoji(emoji);
                this.toggleEmojiPanel();
            });
            this.emojiPanel.appendChild(emojiButton);
        });
        
        // Initially hide the panel
        this.emojiPanel.style.display = 'none';
        
        return this.emojiPanel;
    }
    
    /**
     * Toggle emoji panel visibility
     */
    toggleEmojiPanel() {
        if (!this.emojiPanel) return;
        
        if (this.emojiPanel.style.display === 'none') {
            this.emojiPanel.style.display = 'grid';
        } else {
            this.emojiPanel.style.display = 'none';
        }
    }
    /**
     * Create Game Screen
     */
    createGameScreen() {
        if (!this.currentGame) return;
        
        // Clear the game container
        this.gameContainer.innerHTML = '';
        
        const gameContainer = document.createElement('div');
        gameContainer.className = 'game-board';
        gameContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 30px;
            width: 550px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        gameContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Tic Tac Toe';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 36px;
            letter-spacing: 2px;
        `;
        gameContainer.appendChild(title);
        // Game info
        const gameInfo = document.createElement('div');
        gameInfo.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const player1Info = document.createElement('div');
        player1Info.className = 'player1-info';
        player1Info.innerHTML = `
            <div style="font-weight: bold; color: ${this.colors.playerX}; font-size: 18px;">Player 1 (X)</div>
            <div style="color: ${this.colors.light}; font-size: 16px;">${this.currentGame.player1Name || 'Player 1'}</div>
        `;
        gameInfo.appendChild(player1Info);
        
        const vsText = document.createElement('div');
        vsText.textContent = 'VS';
        vsText.className = 'neon-text-yellow';
        vsText.style.cssText = `
            font-weight: bold;
            display: flex;
            align-items: center;
            font-size: 20px;
        `;
        gameInfo.appendChild(vsText);
        
        const player2Info = document.createElement('div');
        player2Info.className = 'player2-info';
        player2Info.innerHTML = `
            <div style="font-weight: bold; color: ${this.colors.playerO}; font-size: 18px;">Player 2 (O)</div>
            <div style="color: ${this.colors.light}; font-size: 16px;">${this.currentGame.player2Name || 'Waiting...'}</div>
        `;
        gameInfo.appendChild(player2Info);
        
        gameContainer.appendChild(gameInfo);
        
        // Game board
        this.boardContainer = document.createElement('div');
        this.boardContainer.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 20px auto;
            width: 300px;
            height: 300px;
        `;
        
        for (let i = 0; i < 9; i++) {
            const cell = document.createElement('div');
            cell.className = 'game-cell';
            cell.dataset.index = i;
            
            // Set initial cell content if needed
            if (this.currentGame.board[i]) {
                cell.textContent = this.currentGame.board[i];
                if (this.currentGame.board[i] === 'X') {
                    cell.classList.add('x-player');
                } else {
                    cell.classList.add('o-player');
                }
            }
            
            cell.addEventListener('click', () => {
                this.makeMove(i);
            });
            
            this.boardContainer.appendChild(cell);
        }
        
        gameContainer.appendChild(this.boardContainer);
        
        // Game status
        this.gameStatus = document.createElement('div');
        this.gameStatus.className = 'neon-text-yellow';
        this.gameStatus.style.cssText = `
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            min-height: 30px;
        `;
        gameContainer.appendChild(this.gameStatus);
        
        // Messages container
        const messagesSection = document.createElement('div');
        messagesSection.style.cssText = `
            margin-top: 20px;
            display: flex;
            flex-direction: column;
        `;
        
        const messagesTitle = document.createElement('h3');
        messagesTitle.textContent = 'Chat';
        messagesTitle.className = 'neon-text';
        messagesTitle.style.cssText = `
            margin: 0 0 10px 0;
            font-size: 18px;
            text-align: left;
        `;
        messagesSection.appendChild(messagesTitle);
        
        this.messagesContainer = document.createElement('div');
        this.messagesContainer.style.cssText = `
            height: 120px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        messagesSection.appendChild(this.messagesContainer);
        
        // Message input container
        const messageInputContainer = document.createElement('div');
        messageInputContainer.style.cssText = `
            position: relative;
            display: flex;
            align-items: center;
        `;
        
        this.messageInput = document.createElement('input');
        this.messageInput.type = 'text';
        this.messageInput.placeholder = 'Type a message...';
        this.messageInput.style.cssText = `
            flex: 1;
            padding: 10px 40px 10px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: ${this.colors.light};
            font-size: 14px;
            outline: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        this.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        
        messageInputContainer.appendChild(this.messageInput);
        
        // Emoji button
        const emojiButton = document.createElement('button');
        emojiButton.innerHTML = '😊';
        emojiButton.className = 'emoji-btn';
        emojiButton.style.cssText = `
            position: absolute;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        `;
        emojiButton.addEventListener('click', () => {
            this.toggleEmojiPanel();
        });
        messageInputContainer.appendChild(emojiButton);
        
        messagesSection.appendChild(messageInputContainer);
        gameContainer.appendChild(messagesSection);
        
        // Control buttons
        const controlsContainer = document.createElement('div');
        controlsContainer.style.cssText = `
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        `;
        
        const newGameButton = this.createButton('New Game', this.colors.success, () => {
            this.newGame();
        });
        newGameButton.style.cssText = `
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
        `;
        controlsContainer.appendChild(newGameButton);
        
        const lobbyButton = this.createButton('Back to Lobby', this.colors.primary, () => {
            this.backToLobby();
        });
        lobbyButton.style.cssText = `
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
        `;
        controlsContainer.appendChild(lobbyButton);
        
        gameContainer.appendChild(controlsContainer);
        
        this.gameContainer.appendChild(gameContainer);
        
        // Add emoji panel
        this.gameContainer.appendChild(this.createEmojiPanel());
        
        // Update the game screen with current data
        this.updateGameScreen();
        
        // Set up a presence listener for the opponent
        this.setupOpponentPresenceListener();
    }
    
    /**
     * Setup opponent presence listener
     */
    setupOpponentPresenceListener() {
        if (!this.currentGame) return;
        
        // Get opponent ID
        const opponentId = this.playerNumber === 1 ? 
                          this.currentGame.player2 : 
                          this.currentGame.player1;
        
        if (opponentId) {
            // Listen for opponent's presence
            this.playersRef.child(opponentId).on('value', (snapshot) => {
                const isOnline = !!snapshot.val();
                
                if (this.playerNumber === 1) {
                    this.player2Online = isOnline;
                } else {
                    this.player1Online = isOnline;
                }
                
                this.updatePlayerOnlineStatus();
            });
        }
    }
    /**
     * Update game screen
     */
    updateGameScreen() {
        if (!this.currentGame || !this.boardContainer || !this.gameStatus) return;
        
        // Update board
        const cells = this.boardContainer.children;
        
        for (let i = 0; i < 9; i++) {
            if (cells[i]) {
                // Update cell content
                cells[i].textContent = this.currentGame.board[i] || '';
                
                // Update cell color based on content
                if (this.currentGame.board[i]) {
                    if (this.currentGame.board[i] === 'X') {
                        cells[i].classList.add('x-player');
                        cells[i].classList.remove('o-player');
                    } else {
                        cells[i].classList.add('o-player');
                        cells[i].classList.remove('x-player');
                    }
                    cells[i].style.cursor = 'default';
                } else {
                    cells[i].classList.remove('x-player', 'o-player');
                    cells[i].style.cursor = 'pointer';
                }
            }
        }
        
        // Update status
        if (this.currentGame.winner) {
            if (this.currentGame.winner === 'draw') {
                this.gameStatus.textContent = "It's a draw!";
                this.gameStatus.style.color = this.colors.warning;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
            } else {
                const winnerName = this.currentGame.winner === 'X' ? 
                    this.currentGame.player1Name : this.currentGame.player2Name;
                this.gameStatus.textContent = `${winnerName} wins!`;
                this.gameStatus.style.color = this.colors.success;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.success}`;
            }
            this.gameActive = false;
        } else if (this.currentGame.status === 'playing') {
            if (this.currentGame.currentPlayer === this.playerSymbol) {
                this.gameStatus.textContent = 'Your turn';
                this.gameStatus.style.color = this.colors.success;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.success}`;
            } else {
                this.gameStatus.textContent = 'Opponent\'s turn';
                this.gameStatus.style.color = this.colors.warning;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
            }
        } else {
            this.gameStatus.textContent = 'Waiting for opponent...';
            this.gameStatus.style.color = this.colors.warning;
            this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
        }
        
        // Update player online status
        this.updatePlayerOnlineStatus();
    }
    /**
     * Make a move
     */
    makeMove(index) {
        // Check if it's the player's turn
        if (!this.currentGame || 
            !this.gameActive || 
            this.currentGame.board[index] !== '' || 
            this.currentGame.currentPlayer !== this.playerSymbol ||
            this.currentGame.status !== 'playing') {
            return;
        }
        
        // Create a copy of the board
        const updatedBoard = [...this.currentGame.board];
        updatedBoard[index] = this.playerSymbol;
        
        // Check for winner
        const winner = this.checkWinner(updatedBoard);
        const nextPlayer = this.playerSymbol === 'X' ? 'O' : 'X';
        
        // Prepare updates
        const updates = {
            board: updatedBoard,
            currentPlayer: nextPlayer
        };
        
        if (winner) {
            updates.winner = winner;
            updates.status = 'finished';
        }
        
        // Update Firebase
        this.gameRef.child(this.currentGame.id).update(updates)
            .then(() => {
                // Move successfully made
                console.log('Move made successfully');
            })
            .catch(error => {
                console.error('Error making move:', error);
                this.showNotification('Error making move. Please try again.');
            });
    }
    /**
     * Check for winner
     */
    checkWinner(board) {
        const winPatterns = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6] // Diagonals
        ];
        
        for (const pattern of winPatterns) {
            const [a, b, c] = pattern;
            if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                return board[a];
            }
        }
        
        // Check for draw - if all cells are filled and no winner
        if (board.every(cell => cell !== '')) {
            return 'draw';
        }
        
        return null;
    }
    /**
     * Start new game
     */
    newGame() {
        if (this.currentGame) {
            const newBoard = Array(9).fill('');
            const updates = {
                board: newBoard,
                currentPlayer: 'X',
                winner: null,
                status: 'playing'
            };
            
            this.gameRef.child(this.currentGame.id).update(updates);
            this.gameActive = true;
        }
    }
    /**
     * Back to lobby
     */
    backToLobby() {
        // Remove from current game
        if (this.currentGame) {
            this.playersRef.child(this.userSessionId).remove();
            
            if (this.gameListener) {
                this.gameRef.child(this.currentGame.id).off('value', this.gameListener);
            }
            
            if (this.messagesListener) {
                this.messagesRef.child(this.currentGame.id).off('child_added', this.messagesListener);
            }
            
            // If game is waiting for player, delete it
            if (this.currentGame.status === 'waiting') {
                this.gameRef.child(this.currentGame.id).remove();
            }
        }
        
        this.currentGame = null;
        this.gameActive = false;
        this.gameScreenCreated = false;
        this.playerSymbol = null;
        this.opponentSymbol = null;
        this.playerNumber = null;
        this.connectionChecked = false;
        this.messageConnectionChecked = false;
        this.emojiConnectionChecked = false;
        this.gameContainer.innerHTML = '';
        this.createGameLobby();
    }
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: ${this.colors.light};
            padding: 15px 25px;
            border-radius: 30px;
            z-index: 10000;
            animation: slideDown 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 20px;
            background: linear-gradient(135deg, ${color}, ${color}dd);
            color: ${this.colors.light};
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-size: 16px;
            letter-spacing: 1px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-3px)';
            button.style.boxShadow = '0 7px 20px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10001;
        `;
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, ${this.colors.primary}, ${this.colors.primary}cc);
            color: ${this.colors.light};
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = this.colors.primary;
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = `${this.colors.primary}cc`;
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, ${this.colors.error}, ${this.colors.error}cc);
            color: ${this.colors.light};
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = this.colors.error;
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = `${this.colors.error}cc`;
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        
        if (this.gameContainer) {
            this.gameContainer.appendChild(floatingButtons);
        }
    }
    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Clean up Firebase
        if (this.isFirebaseInitialized) {
            if (this.currentGame) {
                this.playersRef.child(this.userSessionId).remove();
                
                if (this.gameListener) {
                    this.gameRef.child(this.currentGame.id).off('value', this.gameListener);
                }
                
                if (this.messagesListener) {
                    this.messagesRef.child(this.currentGame.id).off('child_added', this.messagesListener);
                }
                
                // If game is waiting for player, delete it
                if (this.currentGame.status === 'waiting') {
                    this.gameRef.child(this.currentGame.id).remove();
                }
            }
            
            if (this.playersListener) {
                this.playersRef.off('value', this.playersListener);
            }
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        const floatingButtons = document.querySelector('.floating-buttons');
        if (floatingButtons) {
            floatingButtons.remove();
        }
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Tic Tac Toe closed. Thank you for playing!");
    }
    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}
// Create a singleton instance
const ticTacToeGame = new TicTacToeGame();
// Add this to your AI's command handling
if (/tic tac toe|tictactoe|game|two player game/i.test(userInputRaw)) {
    ticTacToeGame.loadBaseScreen();
    return;
}
// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    ticTacToeGame.closeGame();
    return;
}





class BaseScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'BASE ENCODER/DECODER',
            instructions: 'Encode or decode text using Base64 or Base32. Supports copy and clear functions.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputTextarea = null;
        this.outputTextarea = null;
        this.base64EncodeButton = null;
        this.base64DecodeButton = null;
        this.base32EncodeButton = null;
        this.base32DecodeButton = null;
        this.clearButton = null;
        this.copyButton = null;
        
        // Base32 alphabet (RFC 4648)
        this.base32Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    }
    
    /**
     * Load the Base Screen
     */
    loadBaseScreen() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create base screen
        this.createBaseScreen();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the base screen
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Base Screen UI
     */
    createBaseScreen() {
        // Create base container
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Base64 & Base32 Encoder/Decoder';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Encode or decode text using Base64 or Base32 algorithms';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);
        
        // Create input section
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Input Text:';
        inputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        
        this.inputTextarea = document.createElement('textarea');
        this.inputTextarea.placeholder = 'Enter text to encode or decode...';
        this.inputTextarea.style.cssText = `
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
        `;
        
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.inputTextarea);
        baseContainer.appendChild(inputSection);
        
        // Create button grid
        const buttonGrid = document.createElement('div');
        buttonGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Base64 Encode button
        this.base64EncodeButton = this.createButton('Base64 Encode', '#4CAF50', () => {
            this.base64Encode();
        });
        
        // Base64 Decode button
        this.base64DecodeButton = this.createButton('Base64 Decode', '#2196F3', () => {
            this.base64Decode();
        });
        
        // Base32 Encode button
        this.base32EncodeButton = this.createButton('Base32 Encode', '#FF9800', () => {
            this.base32Encode();
        });
        
        // Base32 Decode button
        this.base32DecodeButton = this.createButton('Base32 Decode', '#9C27B0', () => {
            this.base32Decode();
        });
        
        // Clear button
        this.clearButton = this.createButton('Clear', '#f44336', () => {
            this.clearFields();
        });
        
        // Copy button
        this.copyButton = this.createButton('Copy Output', '#607D8B', () => {
            this.copyOutput();
        });
        
        buttonGrid.appendChild(this.base64EncodeButton);
        buttonGrid.appendChild(this.base64DecodeButton);
        buttonGrid.appendChild(this.base32EncodeButton);
        buttonGrid.appendChild(this.base32DecodeButton);
        buttonGrid.appendChild(this.clearButton);
        buttonGrid.appendChild(this.copyButton);
        
        baseContainer.appendChild(buttonGrid);
        
        // Create output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Output Text:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        
        this.outputTextarea = document.createElement('textarea');
        this.outputTextarea.placeholder = 'Result will appear here...';
        this.outputTextarea.readOnly = true;
        this.outputTextarea.style.cssText = `
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
            background-color: #f9f9f9;
        `;
        
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputTextarea);
        baseContainer.appendChild(outputSection);
        
        // Create info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
        `;
        
        infoSection.innerHTML = `
            <strong>Tips:</strong><br>
            • Base64 is commonly used for encoding binary data in text format<br>
            • Base32 uses a 32-character set and is case-insensitive<br>
            • Use Copy Output to quickly copy the result to clipboard<br>
            • Clear button resets both input and output fields
        `;
        
        baseContainer.appendChild(infoSection);
        
        this.gameContainer.appendChild(baseContainer);
    }
    
    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        
        // Add hover effect
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        
        // Add click handler
        button.addEventListener('click', clickHandler);
        
        return button;
    }
    
    /**
     * Base64 Encode
     */
    base64Encode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some text to encode.');
            return;
        }
        
        try {
            const encoded = btoa(unescape(encodeURIComponent(input)));
            this.outputTextarea.value = encoded;
            botReply('Text encoded to Base64 successfully!');
        } catch (error) {
            console.error('Base64 encode error:', error);
            botReply('Error encoding to Base64. Please check your input.');
        }
    }
    
    /**
     * Base64 Decode
     */
    base64Decode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some Base64 text to decode.');
            return;
        }
        
        try {
            const decoded = decodeURIComponent(escape(atob(input)));
            this.outputTextarea.value = decoded;
            botReply('Base64 text decoded successfully!');
        } catch (error) {
            console.error('Base64 decode error:', error);
            botReply('Error decoding Base64. Please check your input.');
        }
    }
    
    /**
     * Base32 Encode
     */
    base32Encode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some text to encode.');
            return;
        }
        
        try {
            const encoded = this.encodeBase32(input);
            this.outputTextarea.value = encoded;
            botReply('Text encoded to Base32 successfully!');
        } catch (error) {
            console.error('Base32 encode error:', error);
            botReply('Error encoding to Base32. Please check your input.');
        }
    }
    
    /**
     * Base32 Decode
     */
    base32Decode() {
        const input = this.inputTextarea.value.trim().toUpperCase();
        if (!input) {
            botReply('Please enter some Base32 text to decode.');
            return;
        }
        
        try {
            const decoded = this.decodeBase32(input);
            this.outputTextarea.value = decoded;
            botReply('Base32 text decoded successfully!');
        } catch (error) {
            console.error('Base32 decode error:', error);
            botReply('Error decoding Base32. Please check your input.');
        }
    }
    
    /**
     * Encode string to Base32
     */
    encodeBase32(str) {
        // Convert string to Uint8Array
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        
        let result = '';
        let buffer = 0;
        let bitsLeft = 0;
        
        for (let i = 0; i < data.length; i++) {
            buffer = (buffer << 8) | data[i];
            bitsLeft += 8;
            
            while (bitsLeft >= 5) {
                const index = (buffer >>> (bitsLeft - 5)) & 0x1F;
                result += this.base32Alphabet[index];
                bitsLeft -= 5;
            }
        }
        
        // Handle remaining bits
        if (bitsLeft > 0) {
            const index = (buffer << (5 - bitsLeft)) & 0x1F;
            result += this.base32Alphabet[index];
        }
        
        // Add padding if needed
        const padding = (8 - (result.length % 8)) % 8;
        if (padding > 0) {
            result += '='.repeat(padding);
        }
        
        return result;
    }
    
    /**
     * Decode Base32 string
     */
    decodeBase32(str) {
        // Remove padding and convert to uppercase
        str = str.replace(/=/g, '').toUpperCase();
        
        let buffer = 0;
        let bitsLeft = 0;
        const result = [];
        
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            const index = this.base32Alphabet.indexOf(char);
            
            if (index === -1) {
                throw new Error('Invalid Base32 character: ' + char);
            }
            
            buffer = (buffer << 5) | index;
            bitsLeft += 5;
            
            if (bitsLeft >= 8) {
                result.push((buffer >>> (bitsLeft - 8)) & 0xFF);
                bitsLeft -= 8;
            }
        }
        
        // Convert Uint8Array to string
        const decoder = new TextDecoder();
        return decoder.decode(new Uint8Array(result));
    }
    
    /**
     * Clear input and output fields
     */
    clearFields() {
        this.inputTextarea.value = '';
        this.outputTextarea.value = '';
        botReply('Fields cleared.');
    }
    
    /**
     * Copy output to clipboard
     */
    copyOutput() {
        const output = this.outputTextarea.value;
        if (!output) {
            botReply('No output to copy.');
            return;
        }
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(output)
                .then(() => {
                    botReply('Output copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(output);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(output);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Output copied to clipboard!');
            } else {
                botReply('Unable to copy output');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy output');
        }

        document.body.removeChild(textArea);
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.inputTextarea = null;
        this.outputTextarea = null;
        this.base64EncodeButton = null;
        this.base64DecodeButton = null;
        this.base32EncodeButton = null;
        this.base32DecodeButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        
        botReply("Base Encoder/Decoder closed. Thank you!");
    }
}

// Create a singleton instance
const baseScreenLoader = new BaseScreenLoader();

// Add this to your AI's command handling
if (/base|base64|base32|encode|decode|Decrypt|Encrypt/i.test(userInputRaw)) {
    baseScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    baseScreenLoader.closeGame();
    return;
}


class ScreenLoader {
    constructor() {
        this.games = {
            Movie: {
                url: 'https://vipteammod897.github.io/VIPTEAMMOD-AI/AIMovie.html',
              //  name: 'VIPTEAMMOD AI MOVIES',
               // instructions: 'Browse and watch your favorite movies.'
            },
            Games: {
                url: 'https://vipteammod.site/VipTeamModServer.html',
             //   name: 'PLAY ONLINE GAMES',
               // instructions: 'Play a variety of online games in your browser.'
            }
        };
        
        this.gameContainer = null;
        this.gameIframe = null;
        this.currentGame = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.fullscreenButtonClickHandler = null;
        this.closeButton = null;
    }
    
    /**
     * Load a specific game
     * @param {string} gameKey - The key of the game to load
     */
    loadGame(gameKey) {
        // Check if a game is already active
        if (this.isActive) {
            botReply(`The ${this.currentGame.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check if the game exists
        if (!this.games[gameKey]) {
            botReply(`Screen not found. Available screens: ${Object.keys(this.games).map(key => this.games[key].name).join(', ')}`);
            return;
        }
        
        // Set the current game
        this.currentGame = this.games[gameKey];
        
        // Create game container
        this.createGameContainer();
        
        // Create iframe for the game
        this.createGameIframe();
        
        // Set up action buttons
        this.setupActionButtons();

        
        // Display the game
        this.displayGame();
        
        this.isActive = true;
        
       // botReply(`${this.currentGame.name} loaded! ${this.currentGame.instructions}`);
    }
    
    /**
     * List all available games
     */
    listGames() {
        const gameList = Object.keys(this.games).map(key => this.games[key].name).join(', ');
        botReply(`Available screens: ${gameList}. Type 'play [screen name]' to start.`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the game iframe
     */
    createGameIframe() {
        this.gameIframe = document.createElement('iframe');
        this.gameIframe.src = this.currentGame.url;
        this.gameIframe.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            max-height: 800px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        `;
        
        // Handle iframe load event
        this.gameIframe.onload = () => {
            // Game has loaded, focus on it for controls
            this.gameIframe.focus();
        };
        
        // Handle iframe error event
        this.gameIframe.onerror = () => {
            botReply(`Error loading the ${this.currentGame.name}. Please try again later.`);
            this.closeGame();
        };
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
    border-radius: 4px;
    box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        // Use a named function for the click handler
        this.fullscreenButtonClickHandler = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        // Remove any existing event listener before adding a new one
        this.fullscreenButton.removeEventListener('click', this.fullscreenButtonClickHandler);
        this.fullscreenButton.addEventListener('click', this.fullscreenButtonClickHandler);
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
    border-radius: 4px;
    box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
           
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add iframe to container
        this.gameContainer.appendChild(this.gameIframe);
        
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     * @param {KeyboardEvent} event - The keyboard event
     */
    handleKeyPress = (event) => {
        // Check if escape key was pressed
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        // Check if we're actually in fullscreen mode
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust iframe size based on fullscreen state
        if (this.isFullscreen) {
            this.gameIframe.style.width = '98%';
            this.gameIframe.style.height = '95vh';
        } else {
            this.gameIframe.style.width = '90%';
            this.gameIframe.style.height = '85vh';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) { /* Safari */
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) { /* IE11 */
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove fullscreen button event listener
        if (this.fullscreenButton && this.fullscreenButtonClickHandler) {
            this.fullscreenButton.removeEventListener('click', this.fullscreenButtonClickHandler);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.gameIframe = null;
        this.currentGame = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.fullscreenButtonClickHandler = null;
        this.closeButton = null;
        
        botReply("Screen closed. Thank you!");
    }
}

// Create a singleton instance
const screenloader = new ScreenLoader();

// Add this to your AI's command handling
if (/Movies|play Movie/i.test(userInputRaw)) {
    screenloader.loadGame('Movie');
    return;
}

// Add command for Games
if (/Games|play Games/i.test(userInputRaw)) {
    screenloader.loadGame('Games');
    return;
}

// Add command to list all screens
if (/list screens|available screens/i.test(userInputRaw)) {
    screenloader.listGames();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    screenloader.closeGame();
    return;
}







if (/unlock image to text/i.test(userInputRaw)) {
    // Add a small delay before opening the file picker
    setTimeout(() => {
        document.getElementById('hiddenFileInput').click();
    }, 1500); // 1500 milliseconds = 1.5 seconds delay
    return;
}

// Create Hidden File Input (if not already created elsewhere in your code)
let hiddenFileInput = document.getElementById('hiddenFileInput');
if (!hiddenFileInput) {
    hiddenFileInput = document.createElement("input");
    hiddenFileInput.type = "file";
    hiddenFileInput.accept = "image/*";
    hiddenFileInput.id = "hiddenFileInput";
    hiddenFileInput.style.display = "none"; // hide the input field
    document.body.appendChild(hiddenFileInput);
    
    // Function to handle file selection
    hiddenFileInput.addEventListener('change', handleFileSelect, false);
}

// Function to handle file selection and OCR processing
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    botReply("Reading the image file...");
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            // After image is loaded, you can preprocess and call an OCR function
            processImageToText(img);
        };
        img.onerror = function() {
            botReply("Error loading the image. Please try another image.");
        };
        img.src = e.target.result; // Load the image
    };
    reader.onerror = function() {
        botReply("Error reading the file. Please try again.");
    };
    reader.readAsDataURL(file); // Read the image file as a data URL
}

// Improved OCR function using Tesseract.js with preprocessing
function processImageToText(img) {
    botReply("Processing image... Please wait.");
    
    try {
        // Preprocess the image (resize, grayscale, binarization, etc.)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set a maximum size for better performance
        const MAX_WIDTH = 2000;
        const MAX_HEIGHT = 2000;
        let width = img.width;
        let height = img.height;
        
        if (width > height) {
            if (width > MAX_WIDTH) {
                height *= MAX_WIDTH / width;
                width = MAX_WIDTH;
            }
        } else {
            if (height > MAX_HEIGHT) {
                width *= MAX_HEIGHT / height;
                height = MAX_HEIGHT;
            }
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        // Preprocessing: Convert to grayscale
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
            data[i] = data[i + 1] = data[i + 2] = avg; // Set R, G, B to grayscale value
        }
        ctx.putImageData(imgData, 0, 0);
        
        // Additional preprocessing: Apply threshold for better OCR results
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const newData = imageData.data;
        for (let i = 0; i < newData.length; i += 4) {
            // Simple threshold: if pixel is darker than middle gray, make it black, otherwise white
            const value = newData[i] > 128 ? 255 : 0;
            newData[i] = newData[i + 1] = newData[i + 2] = value;
        }
        ctx.putImageData(imageData, 0, 0);
        
        // Use Tesseract.js to extract text from the processed image
        Tesseract.recognize(
            canvas,
            'eng', // Add more language support if needed
            {
                logger: (m) => {
                    if (m.status === 'recognizing text') {
                        const progress = Math.round(m.progress * 100);
                        botReply(`Processing image... ${progress}% complete`);
                    }
                },
            }
        ).then(({ data: { text } }) => {
            if (text.trim() === "") {
                botReply("No text was extracted from the image. Please try again with a clearer image.");
            } else {
                // Preserve some line breaks for better formatting
                const processedText = text.trim().replace(/\n{3,}/g, '\n\n');
                botReply(`Extracted Text:\n\n${processedText}`);
            }
        }).catch(error => {
            botReply("Error extracting text from the image. Please try again later.");
            console.error("OCR Error:", error);
        });
    } catch (error) {
        botReply("Error processing the image. Please try again.");
        console.error("Processing Error:", error);
    }
}



}

function botReply(message) {
    const chatBox = document.getElementById("chat-box");
    const botMessageContainer = document.createElement("div");
    botMessageContainer.classList.add("bot-container");

    // Create the copy button
    const copyButton = document.createElement("button");
    copyButton.classList.add("copy-btn");
    copyButton.innerText = "Copy";

    // Copy the message to clipboard when clicked
    copyButton.addEventListener("click", () => {
        navigator.clipboard.writeText(message).then(() => {
            // Change button text to "Copied"
            copyButton.innerText = "Copied";

            // Reset the button text after 2 seconds
            setTimeout(() => {
                copyButton.innerText = "Copy";
            }, 2000);
        }).catch(err => {
            console.error("Error copying text: ", err);
        });
    });

    // Create the share button (same style as copy button)
    const shareButton = document.createElement("button");
    shareButton.classList.add("copy-btn"); // Same class as copy button
    shareButton.innerText = "Share";

    // Share the message when clicked
    shareButton.addEventListener("click", () => {
        // Use the Web Share API to share the message (if supported)
        if (navigator.share) {
            navigator.share({
                title: "AI Bot Message",
                text: message,
                url: window.location.href
            }).then(() => {
                console.log("Message shared successfully!");
            }).catch(err => {
                console.error("Error sharing message: ", err);
            });
        } else {
            // If the Web Share API is not supported, alert the user
            alert("Sharing is not supported on this device/browser.");
        }
    });

    // Create the bot message
    const botMessage = document.createElement("div");
    botMessage.classList.add("bot-message");
    botMessage.innerHTML = `<strong style="color: white; background: linear-gradient(145deg, #d30, #d35); padding: 4px 8px; box-shadow: 0 0 5px #d35;border-radius: 6px; display: inline-block;">AI Bot:</strong> ${message}`;

    // Create a div for the buttons and apply flexbox for alignment
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("button-container");

    // Append buttons to the container
    buttonContainer.appendChild(copyButton);
    buttonContainer.appendChild(shareButton);

    // Append the button container and the message to the bot message container
    botMessageContainer.appendChild(buttonContainer);
    botMessageContainer.appendChild(botMessage);

    // Append the container to chatBox
    chatBox.appendChild(botMessageContainer);
    chatBox.appendChild(document.createElement("br"));

    // Save plain text message for history
    chatHistory.push(`[${new Date().toLocaleTimeString()}] AI Bot: ${botMessage.textContent}`);

    // Scroll to bottom
    chatBox.scrollTop = chatBox.scrollHeight;
}
        botReply(` Welcome To VIPTEAMMOD AI 3.0`);

// Function to download chat history as a .txt file

function downloadChatHistory() {
    if (chatHistory.length > 0) {
        chatHistory.push(`\nChat End: ${new Date().toLocaleString()}`);
    }
    const blob = new Blob([chatHistory.join("\n")], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "chat_history.txt";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

const downloadBtn = document.createElement("button");
downloadBtn.textContent = "Download Chat History";
downloadBtn.id = "downloadBtn"; // Assign the ID for styling
downloadBtn.onclick = downloadChatHistory;


    // Event listeners
    document.getElementById('user-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });
// Append the button inside the chat container
document.querySelector(".chat-container").appendChild(downloadBtn);


  </script>
  <script>
    // Disable right-click
document.addEventListener("contextmenu", function (e) {
    e.preventDefault();
});

// Disable keyboard shortcuts for DevTools
document.addEventListener("keydown", function (e) {
    if (e.ctrlKey && (e.key === "u" || e.key === "U" || e.key === "s" || e.key === "S" || e.key === "i" || e.key === "I" || e.key === "j" || e.key === "J" || e.key === "c" || e.key === "C")) {
        e.preventDefault();
    }
});

// Disable F12, Ctrl+Shift+I, Ctrl+Shift+J
document.onkeydown = function (e) {
    if (e.keyCode == 123) { return false; } // F12
    if (e.ctrlKey && e.shiftKey && (e.keyCode == 73 || e.keyCode == 74)) { return false; } // Ctrl+Shift+I/J
};
  
  </script>
<script>
    const blockScreen = document.getElementById('blockScreen');

    function detectDevTools() {
      const widthDiff = window.outerWidth - window.innerWidth;
      const heightDiff = window.outerHeight - window.innerHeight;
      const threshold = 120;

      // True if dimensions indicate DevTools or if debugger gets trapped
      let devtoolsOpen = widthDiff > threshold || heightDiff > threshold;

      // Mobile-specific trap
      const trap = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (trap) {
        const start = new Date();
        debugger;
        const end = new Date();
        if (end - start > 100) devtoolsOpen = true;
      }

      if (devtoolsOpen) {
       window.location.href = "https://c.tenor.com/x4V9PRp9R-0AAAAC/tenor.gif"; // Replace with your redirect URL

      } else {
        blockScreen.style.display = 'none';
        document.body.style.pointerEvents = 'auto';
      }
    }

    setInterval(detectDevTools, 600);

    // Block right-click
    document.addEventListener('contextmenu', e => e.preventDefault());

    // Block common dev hotkeys
    document.addEventListener('keydown', function (event) {
      if (
        event.key === 'F12' ||
        (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
        (event.ctrlKey && event.key.toLowerCase() === 'u')
      ) {
        event.preventDefault();
      }
    });
  </script>
    <script>
        // Function to adjust the container based on screen size
        function adjustScreenSize() {
            const container = document.getElementById('main-container');
            const windowWidth = window.innerWidth;
            
            // For desktop screens
            if (windowWidth > 1200) {
                container.style.width = '97%';
                container.style.margin = '0 auto';
            } 
            // For tablet screens
            else if (windowWidth > 768) {
                container.style.width = '97%';
                container.style.margin = '0 auto';
            } 
            // For mobile screens
            else {
                container.style.width = '97%';
                container.style.margin = '0';
            }
        }
        
        // Call the function when the page loads
        window.addEventListener('load', adjustScreenSize);
        
        // Call the function when the window is resized
        window.addEventListener('resize', adjustScreenSize);
    </script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>

</body>

</html>