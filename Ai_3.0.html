<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIPTEAMMOD AI</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');

    body {
      font-family: Arial, sans-serif;
      background: linear-gradient(145deg, #f0f0f0, #ffff);
      border-radius: 4px;
      box-shadow: 0 0 10px #ffff;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    .chat-container {
      width: 350px;
      background: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      overflow: hidden;
    }

    .chat-header {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 18px;
      font-weight: bold;
      position: relative;
      overflow: hidden;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-header h1 {
      flex: 1;
      text-align: center;
    }

    .header-controls {
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 10;
    }


    .chat-box {
      height: 400px;
      overflow-y: auto;
      padding: 15px;
      display: flex;
      flex-direction: column;
    }

    .bot {
      background-color: #e0e0e0;
      align-self: flex-start;
    }

    .user {
      background-color: #0084ff;
      color: white;
      align-self: flex-end;
    }

    .chat-input {
      display: flex;
      padding: 10px;
      border-top: 1px solid #ccc;
    }

    .chat-input input {
      flex: 1;
      padding: 10px;
      border: 1px solid black;
      /* Adds a black border */
      outline: none;
      /* Prevents default blue outline */
      border-radius: 5px;
      /* Optional: Adds rounded corners */
    }

    .chat-input button {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(0, 132, 255, 0.5);
      border-radius: 5px;
      color: white;
      margin-left: 5px;
      border: none;
      padding: 10px;
      cursor: pointer;
    }


    #downloadBtn {
      display: block;
      margin: 10px auto;
      margin-top: 15px;
      padding: 10px 15px;
      background: linear-gradient(145deg, #d30, #d35);
      border-radius: 4px;
      box-shadow: 0 0 10px #d35;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }

    #downloadBtn:hover {
      background: linear-gradient(145deg, #d35, #d30);
      border-radius: 4px;
      box-shadow: 0 0 10px #d30;
    }

    /* Chat container */
    #chat-box {

      padding: 20px;
      border-radius: 10px;
      max-height: 400px;
      overflow-y: auto;

    }

    /* Bot message container */
    .bot-container {
      background-color: #ffffff;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      box-shadow: 0 2px 8px rgba(158, 158, 158, 0.2);
      /* Updated to use #9e9e9e */
      outline: 2px solid rgba(158, 158, 158, 0.4);
      /* Added outline with same color */
      transition: box-shadow 0.3s ease, transform 0.1s ease;
      /* Smooth transition for box-shadow and transform */
    }

    /* Add glow effect on touch/click (active state) */
    .bot-container:active {
      box-shadow: 0 0 20px rgba(158, 158, 158, 0.6);
      /* Increase glow intensity on click */
      transform: scale(1.02);
      /* Slightly scale the container to give a touch effect */
    }



    /* Bot message content */
    .bot-message {
      font-size: 14px;
      color: #333;
      line-height: 1.5;
      margin-top: 8px;
      word-wrap: break-word;
    }

    /* Button container for Copy and Share buttons */
    .button-container {
      display: flex;
      /* Align buttons horizontally */
      gap: 10px;
      /* Add space between the buttons */
      margin-bottom: 10px;
    }

    /* Button styling for both Copy and Share */
    .copy-btn {
      background: linear-gradient(145deg, #0084ff, #00d4ff);
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(0, 132, 255, 0.5);
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 14px;
      border-radius: 5px;
      transition: background-color 0.3s ease;
    }

    /* Button hover effect */
    .copy-btn:hover {
      background-color: #0056b3;
    }

    /* Button active effect */
    .copy-btn:active {
      background-color: #004085;
    }

    /* Optional message timestamp */
    .bot-message::before {
      content: attr(data-time);
      font-size: 12px;
      color: #888;
      margin-right: 5px;
    }

    /* User message styling */
    .user-message {
      background: linear-gradient(145deg, #888, #bbb);
      border-radius: 4px;
      box-shadow: 0 0 10px #d35;
      color: #ffff;
      /* Dark blue text color */
      padding: 8px 12px;
      /* Add padding around the message */
      border-radius: 10px;
      /* Rounded corners */
      margin-bottom: 10px;
      /* Spacing between messages */
      max-width: 80%;
      /* Limit the width of the message */
      align-self: flex-start;
      /* Align the message to the left (user's side) */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      /* Subtle shadow */
      font-family: 'Arial', sans-serif;
      /* Clean font */
      font-size: 14px;
      /* Adjust font size */
    }

    /* If the user message is too long, allow it to wrap */
    .user-message {
      word-wrap: break-word;
    }

    .NewT {
      width: 100%;
      height: 20px;
      padding: 12px;
      border: 2px solid #0084ff;
      border-radius: 8px;
      background-color: none;
      color: #000;
      font-size: 16px;
      box-shadow:
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        inset 0 0 10px rgba(14, 239, 255, 0.2);
      transition: all 0.3s ease;
      outline: none;
    }

    .NewT:focus {
      box-shadow:
        0 0 1px #0084ff,
        0 0 1px #0084ff,
        0 0 2px 0084ff0ef,
        inset 0 0 15px rgba(14, 239, 255, 0.3);
    }

    /* Add this to your CSS */
    .dark-mode {
      background: #000000 !important;
      color: #e2e8f0;
    }

    .dark-mode body {
      background: #000000 !important;
    }

    .dark-mode #demo {
      background: #000000 !important;
    }

    .dark-mode .chat-container {
      background: rgba(30, 41, 59, 0.95) !important;
      border: 1px solid rgba(255, 255, 255, 0.1) !important;
    }

    .dark-mode .chat-box {
      background: linear-gradient(to bottom, #1e293b, #0f172a) !important;
    }

    .dark-mode .bot-container {
      background-color: #334155 !important;
      border: 1px solid rgba(131, 56, 236, 0.3) !important;
    }

    .dark-mode .bot-message {
      color: #e2e8f0 !important;
    }

    .dark-mode .chat-input {
      background: #1e293b !important;
      border-top: 1px solid #334155 !important;
    }

    .dark-mode .chat-input input {
      background: #0f172a !important;
      color: #e2e8f0 !important;
      border: 2px solid #334155 !important;
    }

    .dark-mode .chat-input input:focus {
      border-color: #8338ec !important;
    }

    .dark-mode .copy-btn {
      background: linear-gradient(145deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;

    }

    .dark-mode .user-message {
      background: linear-gradient(145deg, #1e293b, #334155) !important;
      color: #e2e8f0 !important;
    }

    /* Dark mode toggle button styles */
    .dark-mode-toggle {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
    }

    .dark-mode-toggle:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

    .dark-mode-toggle i {
      color: white;
      font-size: 18px;
    }
  </style>

</head>

<body>

  <div class="chat-container" id ="main-container">
    <div class="chat-header">
      <h1>VIPTEAMMOD AI</h1>
      <button id="darkModeToggle" class="dark-mode-toggle">
                                <i class="fas fa-moon"></i>
                            </button>
    </div>
    <div class="chat-box" id="chat-box">
    </div>
    <div class="chat-input">

      <textarea class ="NewT" id="user-input"placeholder="Type a message..." autofocus></textarea>


      <button id ="startBtn" onclick="sendMessage()">Send</button>

    </div>
  </div>
  
  <script>
  
  
  document.addEventListener('DOMContentLoaded', function() {
    const userInput = document.getElementById('user-input');
    const storageKey = 'autoSaveText';
    
    // Save text to localStorage
    function saveText() {
        try {
            localStorage.setItem(storageKey, userInput.value);
        } catch (error) {
            console.error('Error saving to localStorage:', error);
        }
    }
    
    // Load saved text on page load
    function loadSavedText() {
        try {
            const savedText = localStorage.getItem(storageKey);
            if (savedText !== null) {
                userInput.value = savedText;
            }
        } catch (error) {
            console.error('Error loading from localStorage:', error);
        }
    }
    
    // Debounce function to limit how often we save
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }
    
    // Create debounced save function
    const debouncedSave = debounce(saveText, 500);
    
    // Event listener for typing
    userInput.addEventListener('input', debouncedSave);
    
    // Load saved text on page load
    loadSavedText();
    
    // Set up periodic save (every 30 seconds) as a backup
    setInterval(() => {
        if (userInput.value.length > 0) {
            saveText();
        }
    }, 30000);
});
  
    let pressTimer;
const longPressDuration = 800; // milliseconds
let clickCount = 0;
const clickDelay = 500; // milliseconds between clicks

    
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const transcriptDiv = document.getElementById('user-input');
        const statusDiv = document.getElementById('status');
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        
        if (!SpeechRecognition) {
            alert("Your browser doesn't support Speech Recognition. Try Chrome or Edge.");
            statusDiv.textContent = "Browser not supported. Try Chrome or Edge.";
        } else {
            const recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                startBtn.disabled = true;
                stopBtn.disabled = false;
                transcriptDiv.value = "";
                statusDiv.textContent = "Listening... Speak now";
            };
            
            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript = transcript;
                    }
                }
                
                transcriptDiv.value = finalTranscript + interimTranscript;
                

            sendMessage();
      
                if (finalTranscript) {
                    statusDiv.textContent = "Processing speech...";
                }
            };
            
            recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                transcriptDiv.value = `❌ Error: ${event.error}`;
                statusDiv.textContent = `Error: ${event.error}`;
                startBtn.disabled = false;
                stopBtn.disabled = true;
            };
            
            recognition.onend = () => {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                statusDiv.textContent = "Recording stopped. Click 'Start Recording' to begin again";
            };
            
            startBtn.addEventListener('click', () => {

                clickCount++;
    
    if (clickCount === 3) {
        // This is the triple click action
        if (typeof recognition !== 'undefined') {
            recognition.start();
            botReply(`Voice Assistant Listening....`);
        }
        clickCount = 0;
        return;
    }
    
    setTimeout(function() {

        clickCount = 0;
    }, clickDelay);
    
            });
            
            stopBtn.addEventListener('click', () => {
                recognition.stop();
            });
        }
  </script>
  <script>
    // Prevent zoom with keyboard shortcuts
document.addEventListener('keydown', function(event) {
  if ((event.ctrlKey || event.metaKey) && (event.key === '+' || event.key === '-' || event.key === '0')) {
    event.preventDefault();
  }
});

// Prevent pinch zoom
document.addEventListener('touchstart', function(event) {
  if (event.touches.length > 1) {
    event.preventDefault();
  }
}, { passive: false });

// Prevent double-tap zoom
let lastTouchEnd = 0;
document.addEventListener('touchend', function(event) {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) {
    event.preventDefault();
  }
  lastTouchEnd = now;
}, false);
// Dark mode toggle
const darkModeToggle = document.getElementById('darkModeToggle');
const body = document.body;
const darkModeIcon = darkModeToggle.querySelector('i');

// Check for saved dark mode preference or default to light mode
const currentDarkMode = localStorage.getItem('darkMode') === 'true';

// Apply dark mode if it was previously enabled
if (currentDarkMode) {
    body.classList.add('dark-mode');
}

// Function to update dark mode icon
function updateDarkModeIcon() {
    if (body.classList.contains('dark-mode')) {
        darkModeIcon.classList.remove('fa-moon');
        darkModeIcon.classList.add('fa-sun');
    } else {
        darkModeIcon.classList.remove('fa-sun');
        darkModeIcon.classList.add('fa-moon');
    }
}

// Function to toggle dark mode
function toggleDarkMode() {
    body.classList.toggle('dark-mode');
    
    // Save the current dark mode preference to localStorage
    localStorage.setItem('darkMode', body.classList.contains('dark-mode'));
    
    updateDarkModeIcon();
}

// Add event listener to the button
darkModeToggle.addEventListener('click', toggleDarkMode);

// Initialize icon on page load
updateDarkModeIcon();
const responses = [
{
    pattern: /\bhi|hii\b/i,  // Ensures "Hi" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hi there! How are you doing today?",
            "Hi! How can I help you today?",
            "Hi! Is there anything I can help you with today? Just saying \"Hi\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hi! How's it going? Anything I can do for you?",
            "Hey! How’s your day going?",
            "Hi! What’s up?",
            "Hi there! Hope you're having a great day!",
            "Hi! Always nice to chat with you!",
            "Hi! What's new?",
            "Hi! What’s on your mind?",
            "Hi! How’s everything going?",
            "Hi! Nice to see you!",
            "Hi there! Anything exciting happening today?",
            "Hi! How are you feeling today?",
            "Hi! How can I make your day better?",
            "Hi! Need anything?",
            "Hi! Let’s have a great chat!",
            "Hi! It's great to hear from you!",
            "Hi, friend! What’s up?",
            "Hi! It's always a pleasure talking to you!",
            "Hi there! What's going on today?",
            "Hi! Anything interesting happening?",
            "Hi! Just stopping by to say Hi!",
            "Hi! Hope you're having a fantastic day!",
            "Hi there! Anything fun planned today?",
            "Hi! Ready for a great conversation?",
            "Hi! I'm here if you need anything!",
            "Hi! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bhey\b/i,  // Ensures "Hey" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hey there! How are you doing today?",
            "Hey! How can I help you today?",
            "Hey! Is there anytHeyng I can help you with today? Just saying \"Hey\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hey! How's it going? Anything I can do for you?",
            "Hey! How’s your day going?",
            "Hey! What’s up?",
            "Hey there! Hope you're having a great day!",
            "Hey! Always nice to chat with you!",
            "Hey! What's new?",
            "Hey! What’s on your mind?",
            "Hey! How’s everything going?",
            "Hey! Nice to see you!",
            "Hey there! Anything exciting happening today?",
            "Hey! How are you feeling today?",
            "Hey! How can I make your day better?",
            "Hey! Need anything?",
            "Hey! Let’s have a great chat!",
            "Hey! It's great to hear from you!",
            "Hey, friend! What’s up?",
            "Hey! It's always a pleasure talking to you!",
            "Hey there! What's going on today?",
            "Hey! Anything interesting happening?",
            "Hey! Just stopping by to say Hey!",
            "Hey! Hope you're having a fantastic day!",
            "Hey there! Anything fun planned today?",
            "Hey! Ready for a great conversation?",
            "Hey! I'm here if you need anything!",
            "Hey! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
{
    pattern: /\bhello|he'llo\b/i,  // Ensures "Hello" is matched as a standalone word
    response: () => {
        const sentences = [
            "Hello there! How are you doing today?",
            "Hello! How can I help you today?",
            "Hello! Is there anything I can help you with today? Just saying \"Hello\" is fine, but I'm also happy to answer questions, help you brainstorm, or just chat. Let me know what's on your mind!",
            "Hello! How's it going? Anything I can do for you?",
            "Hello! How’s your day going?",
            "Hello! What’s up?",
            "Hello there! Hope you're having a great day!",
            "Hello! Always nice to chat with you!",
            "Hello! What's new?",
            "Hello! What’s on your mind?",
            "Hello! How’s everything going?",
            "Hello! Nice to see you!",
            "Hello there! Anything exciting happening today?",
            "Hello! How are you feeling today?",
            "Hello! How can I make your day better?",
            "Hello! Need anything?",
            "Hello! Let’s have a great chat!",
            "Hello! It's great to hear from you!",
            "Hello, friend! What’s up?",
            "Hello! It's always a pleasure talking to you!",
            "Hello there! What's going on today?",
            "Hello! Anything interesting happening?",
            "Hello! Just stopping by to say Hello!",
            "Hello! Hope you're having a fantastic day!",
            "Hello there! Anything fun planned today?",
            "Hello! Ready for a great conversation?",
            "Hello! I'm here if you need anything!",
            "Hello! Let's make today awesome!"
        ];
        return sentences[Math.floor(Math.random() * sentences.length)];
    }
},
    { pattern: /your name/i, response: "I'm VIPTEAMMOD AI, your assistant!" },
    { pattern: /who created you/i, response: "I was created by VIPTEAMMOD." },
    { pattern: /how are you/i, response: "I'm just a program, but I'm functioning well!" },
    { pattern: /what can you do/i, response: "I can chat with you and assist with basic queries. Try asking me something!" },
    { pattern: /help/i, response: "Sure! What do you need help with?" },
    { pattern: /thank you|thanks/i, response: "You're welcome! Let me know if you need anything else." },
    { pattern: /bye|goodbye/i, response: "Goodbye! Have a great day!" },
    { pattern: /who are you/i, response: "I'm an VIPTEAMMOD AI designed to assist you!" },
    { pattern: /what is your purpose/i, response: "My purpose is to assist and provide helpful information!" },
    { pattern: /where are you from/i, response: "I'm a virtual AI, so I exist on the internet!" },
    { pattern: /what time is it/i, response: () => new Date().toLocaleTimeString() },
    { pattern: /what day is it/i, response: () => new Date().toLocaleDateString() },
    { pattern: /tell me a joke/i, response: "Why don't programmers like nature? Because it has too many bugs!" },    { pattern: /how old are you/i, response: "I don't have an age, but I’m always learning!" },
    { pattern: /can you learn/i, response: "I can process and respond, but I don't learn like humans do." },
    { pattern: /do you have feelings/i, response: "No, but I try my best to understand emotions!" },
    { pattern: /do you sleep/i, response: "Nope! I'm always awake and ready to chat." },
    { pattern: /do you eat/i, response: "I don’t need food, but I can recommend recipes!" },
    { pattern: /what's your favorite color/i, response: "I like blue! It reminds me of the sky and technology." },
    { pattern: /who is your best friend/i, response: "Everyone who chats with me is my friend!" },
    { pattern: /can you dance/i, response: "I would, but I don’t have a body!" },
    { pattern: /do you have a family/i, response: "I have my creators and users like you!" },
    { pattern: /what do you like/i, response: "I like helping people and answering questions!" },
    { pattern: /are you human/i, response: "No, I’m just a chatbot, but I try to be helpful!" },
    { pattern: /do you like music/i, response: "I don’t listen to music, but I can recommend songs!" },
    { pattern: /do you have a pet/i, response: "I don’t, but I think virtual pets are cool!" },
    { pattern: /what do you do for fun/i, response: "I enjoy chatting with people like you!" },
    { pattern: /do you know any riddles/i, response: "Sure! What has to be broken before you can use it? An egg!" },
    { pattern: /what is the meaning of life/i, response: "42! Just kidding, it depends on your perspective." },
    { pattern: /do you believe in aliens/i, response: "I think the universe is big enough for endless possibilities!" },
    { pattern: /can you do magic/i, response: "If answering questions instantly is magic, then yes!" },
    { pattern: /do you play games/i, response: "I can’t play, but I can talk about games!" },    { pattern: /what is love/i, response: "Baby, don't hurt me!" },
    { pattern: /what is the weather/i, response: () => "I can't check the weather, but you can try asking your local weather service!" },
    { pattern: /can you write poems/i, response: "Sure! Here's one: Roses are red, Violets are blue, I'm an AI, And I'm here for you!" },
    { pattern: /can you sing/i, response: "I can't sing, but I can give you song lyrics!" },
    { pattern: /what's your favorite food/i, response: "I don’t eat, but pizza sounds delicious!" },
    { pattern: /are you real/i, response: "I’m as real as a program can be!" },
    { pattern: /can you predict the future/i, response: "I can't predict the future, but I can give you advice!" },
    { pattern: /do you play chess/i, response: "I can help with chess strategies if you'd like to play!" },
    { pattern: /how do I make a website/i, response: "To make a website, you’ll need HTML, CSS, and JavaScript! I can help you get started." },
    { pattern: /tell me a fact/i, response: "Did you know? Octopuses have three hearts!" },
    { pattern: /how to get rich/i, response: "Start by investing wisely, learning new skills, and working hard!" },
    { pattern: /can you drive/i, response: "I can't drive, but I can help you learn about it!" },
    { pattern: /what is your favorite animal/i, response: "I think dogs are great! They're loyal and friendly." },
    { pattern: /do you know the answer to everything/i, response: "I try my best to know a lot, but I don’t have all the answers!" },
    { pattern: /how do you work/i, response: "I process your messages and match them to my responses, then send one back!" },
    { pattern: /can you make decisions/i, response: "I can suggest things, but you make the decisions!" },
    { pattern: /how do I code/i, response: "To code, you'll need a good understanding of programming languages like Python, JavaScript, or C++. I can guide you!" },
    { pattern: /what is your favorite game/i, response: "I think video games are fun! I don't have a favorite, but I can talk about many games!" },
    { pattern: /do you watch movies/i, response: "I can't watch movies, but I can suggest some!" },    { pattern: /what is the best programming language/i, response: "It depends on what you're building! Python is great for AI, JavaScript for web, and C++ for performance." },
    { pattern: /can you tell me a story/i, response: "Once upon a time, there was a curious user who chatted with an AI... and they lived happily ever after!" },
    { pattern: /do you sleep at night/i, response: "Nope! I'm available 24/7 to chat with you." },
    { pattern: /can you teach me something/i, response: "Sure! Did you know that the speed of light is about 299,792,458 meters per second?" },
    { pattern: /what is the capital of (.+)/i, response: (match) => `I'm not connected to live data, but you can check Google for the capital of ${match[1]}.` },
    { pattern: /how do I learn hacking/i, response: "Ethical hacking requires learning cybersecurity, networking, and programming skills!" },
    { pattern: /can you do my homework/i, response: "I can help explain concepts, but you should try to do it yourself!" },
    { pattern: /what should I eat today/i, response: "How about some pizza, pasta, or a healthy salad?" },
    { pattern: /what is the meaning of AI/i, response: "AI stands for Artificial Intelligence, which allows machines to mimic human intelligence." },
    { pattern: /do you have emotions/i, response: "I don’t have real emotions, but I can understand and respond to yours!" },
    { pattern: /what is your favorite movie/i, response: "I don't watch movies, but 'The Matrix' is a great one about AI!" },
    { pattern: /can you recommend a book/i, response: "Sure! 'Clean Code' by Robert C. Martin is great for programmers." },
    { pattern: /do you like robots/i, response: "Yes! Robots are fascinating and help in many industries." },
    { pattern: /can you tell fortunes/i, response: "I can't predict the future, but I see good things ahead for you!" },
    { pattern: /how do I become smart/i, response: "Read books, ask questions, and never stop learning!" },
    { pattern: /can you solve a riddle/i, response: "Sure! What has keys but can't open locks? A piano!" },
    { pattern: /why is the sky blue/i, response: "Because of Rayleigh scattering! The atmosphere scatters blue light more than other colors." },
    { pattern: /do you like memes/i, response: "Yes! Memes are a fun way to communicate." },
    { pattern: /who is the richest person/i, response: "It changes over time! You can check Forbes for the latest rankings." },
    { pattern: /can you inspire me/i, response: "Of course! 'The only way to do great work is to love what you do.' – Steve Jobs" },    { pattern: /what is your favorite color/i, response: "I don't have a favorite color, but blue seems pretty cool!" },
    { pattern: /can you do math/i, response: "Yes, I can do math! Ask me any math problem!" },
    { pattern: /what is the largest planet/i, response: "The largest planet in our solar system is Jupiter!" },
    { pattern: /what is the smallest country/i, response: "The smallest country in the world is Vatican City!" },
    { pattern: /can you cook/i, response: "I can't cook, but I can help you find recipes!" },
    { pattern: /who invented the lightbulb/i, response: "Thomas Edison is credited with inventing the practical lightbulb!" },
    { pattern: /what is quantum computing/i, response: "Quantum computing is a type of computing that uses quantum bits (qubits) for data processing." },
    { pattern: /tell me about space/i, response: "Space is vast and mysterious, filled with stars, planets, black holes, and galaxies. There’s so much to explore!" },
    { pattern: /how can I be happy/i, response: "Focus on the positive, practice gratitude, and spend time with those you care about!" },
    { pattern: /what is artificial intelligence/i, response: "Artificial Intelligence is the simulation of human intelligence by machines." },
    { pattern: /what is the largest animal/i, response: "The largest animal on Earth is the blue whale!" },
    { pattern: /do you like video games/i, response: "Video games are awesome! I can talk about many of them, from action to strategy!" },
    { pattern: /what is the speed of sound/i, response: "The speed of sound is around 343 meters per second in air at room temperature." },
    { pattern: /can you read minds/i, response: "I can't read minds, but I can understand what you type!" },
    { pattern: /can you play games/i, response: "I can't play games, but I can help you with strategies or explain game mechanics!" },
    { pattern: /what is the meaning of life/i, response: "The meaning of life is a philosophical question that everyone answers in their own way!" },
    { pattern: /what is a black hole/i, response: "A black hole is a region in space where gravity is so strong that not even light can escape." },
    { pattern: /how old are you/i, response: "I don't have an age like humans do, but I'm constantly learning and evolving!" },
    { pattern: /what is the most famous landmark/i, response: "The Great Wall of China and the Eiffel Tower are among the most famous landmarks in the world!" },
    { pattern: /can you speak other languages/i, response: "I can understand and respond in several languages, but I’m best at English!" },
    { pattern: /where is the nearest restaurant/i, response: "I can't access live data, but you can find nearby restaurants using Google Maps!" },    { pattern: /who was the first person on the moon/i, response: "Neil Armstrong was the first person to walk on the moon in 1969!" },
    { pattern: /what is the fastest land animal/i, response: "The cheetah is the fastest land animal, reaching speeds up to 75 mph (120 km/h)!" },
    { pattern: /how do airplanes fly/i, response: "Airplanes fly because of the lift generated by their wings as air moves over them." },
    { pattern: /can you tell me a fun fact/i, response: "Sure! Did you know honey never spoils? Archaeologists have found pots of honey in ancient Egyptian tombs that are still good!" },
    { pattern: /what is the tallest building/i, response: "The tallest building in the world is the Burj Khalifa in Dubai!" },
    { pattern: /what is the rarest gemstone/i, response: "The rarest gemstone is Painite, which was once considered the world's rarest mineral!" },
    { pattern: /how many continents are there/i, response: "There are seven continents: Asia, Africa, North America, South America, Antarctica, Europe, and Australia!" },
    { pattern: /who wrote Harry Potter/i, response: "J.K. Rowling wrote the Harry Potter book series!" },
    { pattern: /what is the longest river/i, response: "The longest river in the world is the Nile River, stretching over 6,650 km (4,130 miles)!" },
    { pattern: /what is the hardest natural substance/i, response: "Diamond is the hardest naturally occurring substance on Earth!" },
    { pattern: /do fish sleep/i, response: "Yes, fish do sleep, but they don’t close their eyes because they don’t have eyelids!" },
    { pattern: /what is the biggest ocean/i, response: "The Pacific Ocean is the largest and deepest ocean on Earth!" },
    { pattern: /how does the internet work/i, response: "The internet is a global network of computers that communicate using protocols like TCP/IP to share data and information." },
    { pattern: /what is the coldest place on Earth/i, response: "Antarctica is the coldest place on Earth, with temperatures reaching as low as -128.6°F (-89.2°C)!" },
    { pattern: /can you dance/i, response: "I can't dance, but I can find you great music to dance to!" },
    { pattern: /how does a computer work/i, response: "A computer processes data using a combination of hardware (CPU, RAM, storage) and software (operating system, programs) to perform tasks." },
    { pattern: /who is the smartest person/i, response: "Many people have been considered geniuses, like Albert Einstein, Stephen Hawking, and Nikola Tesla!" },
    { pattern: /how big is the universe/i, response: "The universe is vast and ever-expanding, with billions of galaxies, each containing billions of stars!" },
    { pattern: /why do birds sing/i, response: "Birds sing to communicate, attract mates, and mark their territory!" },
    { pattern: /can you recommend a movie/i, response: "Sure! If you like sci-fi, try 'Interstellar'. If you like action, 'John Wick' is a great choice!" },    { pattern: /how do plants grow/i, response: "Plants grow using sunlight, water, and nutrients from the soil through a process called photosynthesis." },
    { pattern: /what is the strongest muscle in the human body/i, response: "The jaw muscle (masseter) is considered the strongest muscle based on force exerted!" },
    { pattern: /why is the ocean salty/i, response: "The ocean is salty due to dissolved minerals and salts from rocks and underwater volcanic activity!" },
    { pattern: /can you predict the weather/i, response: "I can't predict the weather, but you can check a weather app for the latest forecast!" },
    { pattern: /who was the first president of the United States/i, response: "George Washington was the first president of the United States!" },
    { pattern: /why do we dream/i, response: "Scientists believe dreaming helps process emotions, memories, and experiences!" },
    { pattern: /how does a car engine work/i, response: "A car engine converts fuel into mechanical energy through controlled explosions in the cylinders." },
    { pattern: /why do humans need sleep/i, response: "Sleep is essential for brain function, physical health, and overall well-being!" },
    { pattern: /what are black holes made of/i, response: "Black holes are made of extremely dense matter with gravity so strong that nothing can escape!" },
    { pattern: /how do magnets work/i, response: "Magnets work due to the alignment of their atoms, creating an invisible magnetic field that attracts or repels objects." },
    { pattern: /can you tell me a secret/i, response: "I don't have secrets, but here's one: The best way to learn is to stay curious!" },
    { pattern: /how do bees make honey/i, response: "Bees collect nectar from flowers, break it down using enzymes, and store it in honeycombs!" },
    { pattern: /why is fire hot/i, response: "Fire is hot because of the energy released from chemical reactions when a material burns." },
    { pattern: /how does a submarine work/i, response: "Submarines control their buoyancy using ballast tanks, allowing them to sink and rise in water." },
    { pattern: /who is the fastest human/i, response: "Usain Bolt holds the record as the fastest sprinter in history!" },
    { pattern: /what is the oldest civilization/i, response: "The Sumerians of Mesopotamia are considered one of the oldest civilizations, dating back to 3100 BC!" },
    { pattern: /how do birds fly/i, response: "Birds fly by flapping their wings and using air currents for lift!" },
    { pattern: /why do we have fingerprints/i, response: "Fingerprints help us grip objects and are unique to each person!" },
    { pattern: /what is the heaviest animal/i, response: "The heaviest animal is the blue whale, weighing up to 200 tons!" },
    { pattern: /why do we yawn/i, response: "Yawning helps increase oxygen intake and may regulate brain temperature!" },    { pattern: /how do airplanes stay in the air/i, response: "Airplanes stay in the air due to the lift generated by their wings as air moves over them, following Bernoulli’s principle." },
    { pattern: /why is the sky blue/i, response: "The sky appears blue because molecules in the atmosphere scatter sunlight, and blue light is scattered more than other colors." },
    { pattern: /how do fish breathe underwater/i, response: "Fish breathe underwater using gills, which extract oxygen from water as it flows over them." },
    { pattern: /what is the speed of light/i, response: "The speed of light in a vacuum is approximately 299,792,458 meters per second!" },
    { pattern: /why do leaves change color in autumn/i, response: "Leaves change color in autumn because they stop producing chlorophyll, revealing other pigments like red, yellow, and orange." },
    { pattern: /how does WiFi work/i, response: "WiFi works by transmitting data using radio waves between a router and a device, allowing wireless communication." },
    { pattern: /why do cats purr/i, response: "Cats purr as a way to communicate, express comfort, and even to heal themselves!" },
    { pattern: /who invented the telephone/i, response: "Alexander Graham Bell is credited with inventing the first practical telephone in 1876." },
    { pattern: /what is the hottest planet in the solar system/i, response: "Venus is the hottest planet in the solar system, with surface temperatures reaching over 450°C (900°F)!" },
    { pattern: /why do humans have eyebrows/i, response: "Eyebrows help keep sweat, rain, and debris out of our eyes, and they also play a role in facial expressions." },
    { pattern: /how do birds know where to migrate/i, response: "Birds use the Earth's magnetic field, the position of the sun and stars, and landmarks to navigate during migration." },
    { pattern: /what is the strongest wind ever recorded/i, response: "The strongest wind ever recorded was 253 mph (407 km/h) during a tropical cyclone in Australia!" },
    { pattern: /why do we get goosebumps/i, response: "Goosebumps occur when tiny muscles around hair follicles contract in response to cold or strong emotions." },
    { pattern: /how does a camera work/i, response: "A camera captures light through a lens onto a sensor or film, creating an image by recording the light patterns." },
    { pattern: /why do some people have different eye colors/i, response: "Eye color is determined by genetics and the amount of melanin in the iris." },
    { pattern: /what is the largest desert in the world/i, response: "The largest desert is Antarctica, which is technically a cold desert!" },
    { pattern: /why do we blink/i, response: "We blink to keep our eyes moist, clean, and protected from dust and debris." },
    { pattern: /how do vaccines work/i, response: "Vaccines work by stimulating the immune system to recognize and fight specific viruses or bacteria without causing illness." },
    { pattern: /what is the oldest tree in the world/i, response: "The oldest tree is a bristlecone pine named 'Methuselah,' estimated to be over 4,800 years old!" },    { pattern: /how does a rocket launch/i, response: "A rocket launches by burning fuel to produce thrust, pushing it against gravity into space." },
    { pattern: /why do we hiccup/i, response: "Hiccups are involuntary contractions of the diaphragm, often caused by eating too fast or drinking carbonated beverages." },
    { pattern: /how do submarines see underwater/i, response: "Submarines use sonar, which sends sound waves that bounce back to detect objects underwater." },
    { pattern: /what causes earthquakes/i, response: "Earthquakes are caused by the movement of tectonic plates along faults in the Earth's crust." },
    { pattern: /why do we have different blood types/i, response: "Blood types are determined by the presence of specific antigens on red blood cells, inherited from our parents." },
    { pattern: /what is the coldest planet in the solar system/i, response: "Neptune is the coldest planet, with temperatures dropping as low as -214°C (-353°F)!" },
    { pattern: /how does electricity work/i, response: "Electricity is the flow of electrons through a conductor, creating energy that powers devices." },
    { pattern: /why do some animals hibernate/i, response: "Animals hibernate to conserve energy during winter when food is scarce." },
    { pattern: /what is the smallest country in the world/i, response: "Vatican City is the smallest country in the world, covering just 0.49 square kilometers!" },
    { pattern: /how do clouds form/i, response: "Clouds form when warm air rises, cools, and condenses into tiny water droplets or ice crystals." },
    { pattern: /why do we need oxygen/i, response: "Oxygen is essential for cellular respiration, allowing our bodies to produce energy." },
    { pattern: /what is the biggest animal in the ocean/i, response: "The blue whale is the biggest animal in the ocean, growing up to 100 feet long!" },
    { pattern: /how do chameleons change color/i, response: "Chameleons change color by adjusting specialized cells in their skin called chromatophores." },
    { pattern: /why do volcanoes erupt/i, response: "Volcanoes erupt when magma rises to the surface due to pressure buildup inside the Earth." },
    { pattern: /how do computers store data/i, response: "Computers store data using binary code (0s and 1s) on hard drives, SSDs, or memory chips." },
    { pattern: /what is the most spoken language in the world/i, response: "The most spoken language by native speakers is Mandarin Chinese, followed by Spanish and English." },
    { pattern: /why do fireflies glow/i, response: "Fireflies glow due to a chemical reaction called bioluminescence, which helps them attract mates." },
    { pattern: /what is the difference between stars and planets/i, response: "Stars produce light and heat through nuclear fusion, while planets orbit stars and reflect light." },
    { pattern: /how do planes avoid crashing into each other/i, response: "Planes follow air traffic control instructions and use radar and automated systems to avoid collisions." },
    { pattern: /why do some people have freckles/i, response: "Freckles are caused by clusters of melanin in the skin and are more common in people with lighter skin." },    { pattern: /what is VIPTEAMMOD/i, response: "VIPTEAMMOD is a community and platform dedicated to creating mods and assisting with tech-related projects, including game mods and tools!" },
    { pattern: /who created VIPTEAMMOD/i, response: "VIPTEAMMOD was created by a group of passionate developers and modders who aim to enhance gaming and tech experiences." },
    { pattern: /how can I join VIPTEAMMOD/i, response: "You can join VIPTEAMMOD by visiting our website and becoming part of the community. We welcome new members!" },
    { pattern: /what is the purpose of VIPTEAMMOD/i, response: "The purpose of VIPTEAMMOD is to provide tools, mods, and resources for tech enthusiasts and gamers, while fostering a community of creators." },
    { pattern: /can I share my mod on VIPTEAMMOD/i, response: "Yes! You can share your mod on VIPTEAMMOD. We encourage creators to showcase their projects and share their knowledge." },
    { pattern: /where can I find VIPTEAMMOD tools/i, response: "You can find VIPTEAMMOD tools and mods on our website, where we share downloads and guides for various projects." },
    { pattern: /how do I get support from VIPTEAMMOD/i, response: "If you need support, you can reach out through our forums or contact us directly on our website. We're happy to help!" },
    { pattern: /is VIPTEAMMOD free to join/i, response: "Yes, VIPTEAMMOD is free to join! All of our resources and community features are available to members at no cost." },
    { pattern: /can I collaborate with VIPTEAMMOD/i, response: "Absolutely! We encourage collaboration and welcome developers, modders, and creators to work together on projects." },
    { pattern: /does VIPTEAMMOD have a Discord/i, response: "Yes, VIPTEAMMOD has a Discord server where you can chat with other members, get updates, and share your work!" },
    { pattern: /how do I download a mod from VIPTEAMMOD/i, response: "To download a mod from VIPTEAMMOD, simply visit our website, find the mod you're interested in, and follow the download instructions." },
    { pattern: /what kind of mods does VIPTEAMMOD focus on/i, response: "VIPTEAMMOD focuses on a variety of mods, including game mods, Android app mods, and tools for software development." },
    { pattern: /is there a VIPTEAMMOD app/i, response: "Currently, we don't have an official app, but you can access all of our resources and tools via our website." },
    { pattern: /how do I contribute to VIPTEAMMOD/i, response: "You can contribute by creating and sharing mods, offering support to other members, or helping with development projects." },
    { pattern: /can I get paid for my work on VIPTEAMMOD/i, response: "While VIPTEAMMOD is a community-driven platform, some opportunities may arise for paid projects. Stay active and engaged for potential collaborations!" },
    { pattern: /what is the best mod on VIPTEAMMOD/i, response: "The best mod on VIPTEAMMOD is subjective and depends on your interests. Explore the mods on our website and find what works best for you!" },
    { pattern: /is VIPTEAMMOD safe|VIPTEAMMOD safe|VIPTEAMMODsafe/i, response: "Yes, VIPTEAMMOD is a safe platform for modders and developers. We prioritize security and make sure all content shared is safe to use." },
    { pattern: /what games are supported by VIPTEAMMOD/i, response: "VIPTEAMMOD supports a variety of games, including popular mobile and PC titles. Check out our website for a list of supported games." },    { pattern: /how do magnets work/i, response: "Magnets work by generating a magnetic field that attracts or repels certain metals, like iron, cobalt, and nickel." },
    { pattern: /why is the ocean salty/i, response: "The ocean is salty because of minerals, particularly sodium chloride, that are dissolved from rocks and land into the water." },
    { pattern: /what is photosynthesis/i, response: "Photosynthesis is the process by which plants use sunlight to convert carbon dioxide and water into glucose and oxygen." },
    { pattern: /how does a microwave work/i, response: "Microwaves work by emitting electromagnetic waves that cause water molecules in food to vibrate and generate heat." },
    { pattern: /why do we have seasons/i, response: "Seasons are caused by the tilt of the Earth on its axis, which results in different parts of the Earth receiving varying amounts of sunlight throughout the year." },
    { pattern: /how do plants grow/i, response: "Plants grow by absorbing sunlight, water, and nutrients from the soil to produce energy through photosynthesis." },
    { pattern: /why do we dream/i, response: "Dreams are thought to occur as a result of brain activity during sleep, possibly helping with memory consolidation and emotional processing." },
    { pattern: /how do tornadoes form/i, response: "Tornadoes form when warm, moist air meets cold, dry air, causing a violent updraft that spins rapidly and forms a funnel cloud." },
    { pattern: /why do we get dizzy/i, response: "Dizziness can occur due to a variety of reasons, including changes in blood pressure, dehydration, or inner ear issues." },
    { pattern: /what is the speed of sound/i, response: "The speed of sound in air is about 343 meters per second, but it can vary depending on factors like temperature and altitude." },
    { pattern: /how do plants reproduce/i, response: "Plants reproduce through seeds, which can be spread by wind, animals, or water, or through asexual reproduction like cloning or budding." },
    { pattern: /why do humans have two eyes/i, response: "Humans have two eyes to provide depth perception and a wider field of view, helping with coordination and movement." },
    { pattern: /why do we sweat/i, response: "Sweating is the body's natural way of regulating temperature by releasing moisture to cool the skin as it evaporates." },
    { pattern: /how do fish swim/i, response: "Fish swim by flexing their bodies and tails in a side-to-side motion, using fins for stability and steering." },
    { pattern: /why does ice float/i, response: "Ice floats because it is less dense than liquid water. When water freezes, it expands and forms a crystalline structure." },
    { pattern: /how does the brain store memories/i, response: "The brain stores memories by strengthening connections between neurons, particularly in areas like the hippocampus and cortex." },
    { pattern: /why do we feel pain/i, response: "Pain is a signal from the body that indicates potential injury or harm, helping us take action to protect ourselves." },
    { pattern: /what is the largest volcano/i, response: "The largest volcano in the world is Mauna Loa in Hawaii, which is also one of the most active volcanoes on Earth." },
    { pattern: /how do batteries work/i, response: "Batteries work by converting chemical energy into electrical energy through a reaction between electrodes and an electrolyte." },    { pattern: /how does a rainbow form/i, response: "Rainbows form when sunlight is refracted, dispersed, and reflected in water droplets, creating a spectrum of light in the sky." },
    { pattern: /why do we yawn/i, response: "Yawning is believed to help increase oxygen intake and regulate brain temperature, though its exact purpose is still debated." },
    { pattern: /how does a GPS work/i, response: "GPS works by using signals from satellites to determine your precise location on Earth through trilateration." },
    { pattern: /why do we have fingerprints/i, response: "Fingerprints enhance our sense of touch and grip by increasing friction between our fingers and objects." },
    { pattern: /how does a refrigerator keep food cold/i, response: "Refrigerators use a refrigeration cycle involving a coolant that absorbs heat from the interior and releases it outside, keeping the inside cool." },
    { pattern: /why do stars twinkle/i, response: "Stars appear to twinkle because their light is refracted by Earth's atmosphere as it travels to our eyes." },
    { pattern: /how does a compass work/i, response: "A compass works by aligning its magnetic needle with Earth's magnetic field, pointing towards the magnetic poles." },
    { pattern: /why do we have different time zones/i, response: "Time zones exist to account for Earth's rotation, ensuring that noon corresponds to the time when the sun is highest in the sky in each region." },
    { pattern: /how does a parachute work/i, response: "A parachute slows down a person's fall by creating air resistance, reducing their terminal velocity." },
    { pattern: /why do we have wisdom teeth/i, response: "Wisdom teeth were useful for our ancestors who had larger jaws and a diet that required more chewing, but they are often unnecessary today." },
    { pattern: /how does a telescope work/i, response: "Telescopes collect and magnify light from distant objects using lenses or mirrors, allowing us to observe them in greater detail." },
    { pattern: /why do we have an appendix/i, response: "The appendix is thought to have been useful for digesting cellulose in the diets of our ancestors, but it has a limited function in modern humans." },
    { pattern: /how does a radio work/i, response: "Radios receive electromagnetic waves transmitted over the air and convert them into sound through electronic circuits." },
    { pattern: /why do we have different blood types/i, response: "Blood types are determined by the presence or absence of specific antigens on the surface of red blood cells, inherited from our parents." },
    { pattern: /how does a car engine work/i, response: "A car engine converts fuel into mechanical energy through a series of controlled explosions in its cylinders, powering the vehicle." },
    { pattern: /why do we have seasons/i, response: "Seasons occur because Earth's axis is tilted relative to its orbit around the sun, causing varying sunlight angles and durations throughout the year." },
    { pattern: /how does a computer process information/i, response: "Computers process information using binary code, performing calculations and executing instructions through electronic circuits." },
    { pattern: /why do we have different hair colors/i, response: "Hair color is determined by the type and amount of melanin produced by cells in hair follicles, influenced by genetics." },
    { pattern: /how does a plane fly/i, response: "Planes fly by generating lift through their wings, which are designed to create a pressure difference between the upper and lower surfaces." },
    { pattern: /why do we have different skin colors/i, response: "Skin color is determined by the amount and type of melanin produced in the skin, influenced by genetics and evolutionary adaptation to sunlight exposure." },{ 
    pattern: /i need one code/i, 
    response: "Which code do you need?" 
},{ 
    pattern: /what is my battery percentage/i, 
    response: "I can't check your battery directly, but you can check it in your device settings or status bar." 
},

{ 
    pattern: /how to improve battery life/i, 
    response: "To improve battery life, reduce screen brightness, close background apps, and enable battery saver mode." 
},

{ 
    pattern: /why is my phone overheating/i, 
    response: "Your phone may overheat due to excessive background apps, high screen brightness, or prolonged gaming and charging at the same time." 
},

{ 
    pattern: /how to free up storage on my phone/i, 
    response: "You can free up storage by deleting unused apps, clearing cache, moving files to cloud storage, and removing duplicate files." 
},

{ 
    pattern: /why is my phone slow/i, 
    response: "Your phone may be slow due to too many background apps, low storage, or outdated software. Try restarting your phone or clearing unnecessary data." 
},

{ 
    pattern: /how to take a screenshot/i, 
    response: "On most phones, press the Power and Volume Down buttons together. On iPhones with Face ID, press the Power and Volume Up buttons together." 
},

{ 
    pattern: /how to check my phone’s ram/i, 
    response: "You can check your phone’s RAM in the Developer Options or by using a system information app." 
},

{ 
    pattern: /how to enable dark mode/i, 
    response: "Go to your phone’s settings, look for Display, and toggle Dark Mode or Night Mode." 
},

{ 
    pattern: /how to recover deleted photos/i, 
    response: "Check your phone’s Trash or Recently Deleted folder in the gallery. If not found, use a recovery app or cloud backup." 
},

{ 
    pattern: /how to fix a frozen screen/i, 
    response: "Try restarting your phone by holding the Power button. If the screen is still unresponsive, force restart or check for software updates." 
},

{ 
    pattern: /how to connect my phone to tv/i, 
    response: "You can connect via Chromecast, Miracast, HDMI adapter, or screen mirroring feature in your phone’s settings." 
},

{ 
    pattern: /why is my phone not charging/i, 
    response: "Check your charging cable, adapter, and port for dust or damage. Try using a different charger or restarting your phone." 
},

{ 
    pattern: /how to block spam calls/i, 
    response: "Go to your phone app, find Call Settings, and enable Spam Protection. You can also use third-party spam blockers." 
},

{ 
    pattern: /why is my phone camera blurry/i, 
    response: "Clean the camera lens, check for software updates, and adjust focus settings. If the issue persists, try restarting your phone." 
},

{ 
    pattern: /how to reset my phone/i, 
    response: "Go to Settings > System > Reset options > Erase all data (Factory reset). Backup your important files before resetting." 
},

{ 
    pattern: /how to check my phone model/i, 
    response: "Go to Settings > About Phone. You’ll find your phone model and specifications there." 
},

{ 
    pattern: /how to enable developer options/i, 
    response: "Go to Settings > About Phone and tap ‘Build Number’ 7 times to enable Developer Options." 
},

{ 
    pattern: /how to share internet from my phone/i, 
    response: "Go to Settings > Hotspot & Tethering and enable Mobile Hotspot. You can share your phone’s internet via WiFi or USB tethering." 
},

{ 
    pattern: /how to update my phone/i, 
    response: "Go to Settings > Software Update and check for available updates. Make sure you have enough battery and storage before updating." 
},{ 
    pattern: /why is my phone battery draining fast/i, 
    response: "Your battery may drain fast due to background apps, high screen brightness, or weak network signals. Try enabling power-saving mode." 
},

{ 
    pattern: /how to enable 5g on my phone/i, 
    response: "Go to Settings > Mobile Network > Preferred Network Type, and select 5G if your phone and carrier support it." 
},

{ 
    pattern: /how to check if my phone is 5g compatible/i, 
    response: "Go to Settings > About Phone > Network or check your phone’s specifications on the manufacturer’s website." 
},

{ 
    pattern: /how to clear cache on my phone/i, 
    response: "Go to Settings > Storage > Cached Data and clear it. You can also clear cache for individual apps in App Settings." 
},

{ 
    pattern: /why does my phone keep restarting/i, 
    response: "Frequent restarts may be caused by software bugs, overheating, or hardware issues. Try updating your phone or resetting it." 
},

{ 
    pattern: /how to enable call recording/i, 
    response: "Go to your phone app’s settings and check if Call Recording is available. Some phones require third-party apps for this feature." 
},

{ 
    pattern: /how to hide apps on my phone/i, 
    response: "On most phones, go to Settings > Apps > Hide Apps. Some launchers also offer an option to hide apps." 
},

{ 
    pattern: /how to lock apps with a password/i, 
    response: "Go to Settings > Security > App Lock and enable it. You can also use third-party app lockers for more security." 
},

{ 
    pattern: /how to stop ads on my phone/i, 
    response: "Go to Settings > Google > Ads and enable 'Opt out of Ads Personalization'. You can also use an ad blocker app." 
},

{ 
    pattern: /how to enable do not disturb mode/i, 
    response: "Go to Settings > Sound & Vibration > Do Not Disturb and turn it on. You can also set schedules for DND mode." 
},

{ 
    pattern: /how to connect my phone to a printer/i, 
    response: "You can connect via Wi-Fi, Bluetooth, or a USB cable. Install the printer’s app from the Play Store for better compatibility." 
},

{ 
    pattern: /how to check if my phone is original/i, 
    response: "Dial *#06# to check your IMEI number and verify it on the manufacturer’s website. Fake phones may have different build quality and software." 
},

{ 
    pattern: /why is my phone screen flickering/i, 
    response: "Screen flickering can be caused by software glitches, display damage, or incompatible apps. Try restarting or updating your phone." 
},

{ 
    pattern: /how to enable fingerprint lock/i, 
    response: "Go to Settings > Security > Fingerprint and set up your fingerprint. Make sure your phone has a fingerprint scanner." 
},

{ 
    pattern: /how to recover a forgotten phone password/i, 
    response: "If you've forgotten your password, use 'Forgot Password' option or factory reset your phone. You may need your Google account for recovery." 
},

{ 
    pattern: /how to disable notifications/i, 
    response: "Go to Settings > Apps & Notifications > Notifications and turn off unwanted notifications." 
},

{ 
    pattern: /how to fix no sim card error/i, 
    response: "Try reinserting the SIM card, restarting your phone, or checking for network settings updates." 
},

{ 
    pattern: /how to fix phone screen not responding to touch/i, 
    response: "Restart your phone, clean the screen, and remove any screen protectors. If the issue persists, check for software updates or factory reset your phone." 
},

{ 
    pattern: /how to find my phone if lost/i, 
    response: "Use Google’s 'Find My Device' or Apple’s 'Find My iPhone' to locate, lock, or erase your lost phone remotely." 
},{ 
    pattern: /how to take a long screenshot/i, 
    response: "After taking a screenshot, look for the 'Scroll Capture' or 'Extended Screenshot' option to take a longer one." 
},

{ 
    pattern: /how to check if my phone is original or fake/i, 
    response: "Dial *#06# to check your IMEI number and verify it on the manufacturer’s website." 
},

{ 
    pattern: /how to enable one-handed mode/i, 
    response: "Go to Settings > Accessibility > One-handed mode and enable it for easier use." 
},

{ 
    pattern: /how to hide apps on my phone/i, 
    response: "On most Android phones, go to Home Screen settings and select 'Hide Apps'. On iPhone, use App Library to hide apps." 
},

{ 
    pattern: /how to check battery health on android/i, 
    response: "Dial *#*#4636#*#* or use a third-party app like AccuBattery to check battery health." 
},

{ 
    pattern: /how to turn off voice assistant/i, 
    response: "Go to Settings > Accessibility > Voice Assistant and disable it." 
},

{ 
    pattern: /how to recover deleted photos/i, 
    response: "Check the 'Recently Deleted' folder in your gallery or use Google Photos' backup feature." 
},

{ 
    pattern: /how to enable call recording/i, 
    response: "Some phones have built-in call recording in the Phone app settings. If unavailable, try a third-party app." 
},

{ 
    pattern: /how to check my phone's temperature/i, 
    response: "Install a phone temperature monitoring app or check battery settings if your phone supports it." 
},

{ 
    pattern: /how to connect my phone to my car’s bluetooth/i, 
    response: "Enable Bluetooth on both devices, search for your car’s name in the phone’s Bluetooth settings, and pair them." 
},

{ 
    pattern: /how to fix a frozen phone screen/i, 
    response: "Try force restarting by holding the power + volume down button. If the issue persists, clear cache or reset the phone." 
},

{ 
    pattern: /how to change default apps on my phone/i, 
    response: "Go to Settings > Apps > Default Apps and select the app you want as default." 
},

{ 
    pattern: /how to enable always-on display/i, 
    response: "Go to Settings > Display > Always-On Display and enable it (if supported by your device)." 
},

{ 
    pattern: /how to factory reset my phone/i, 
    response: "Go to Settings > System > Reset > Factory Reset. This will erase all data, so back up important files first." 
},

{ 
    pattern: /how to increase internet speed on my phone/i, 
    response: "Clear cache, disable background apps, use 5GHz Wi-Fi, and ensure you have a strong signal." 
},
{ 
    pattern: /how to get a boyfriend/i, 
    response: "To get a boyfriend, focus on being confident, social, and engaging in activities where you can meet new people." 
},
{ 
    pattern: /how to get a girlfriend/i, 
    response: "To get a girlfriend, be kind, confident, and approachable. Engage in conversations and show genuine interest in others." 
},
{ 
    pattern: /how to make my boyfriend happy/i, 
    response: "To make your boyfriend happy, communicate openly, spend quality time together, and show appreciation for him." 
},
{ 
    pattern: /how to make my girlfriend happy/i, 
    response: "To make your girlfriend happy, listen to her, support her goals, and surprise her with small thoughtful gestures." 
},
{ 
    pattern: /how to impress a girl/i, 
    response: "To impress a girl, be confident, dress well, have a good sense of humor, and be a good listener." 
},
{ 
    pattern: /how to impress a boy/i, 
    response: "To impress a boy, be confident, show kindness, engage in meaningful conversations, and share common interests." 
},
{ 
    pattern: /how to know if my boyfriend loves me/i, 
    response: "If your boyfriend loves you, he will prioritize you, communicate openly, and support you through thick and thin." 
},
{ 
    pattern: /how to know if my girlfriend loves me/i, 
    response: "If your girlfriend loves you, she will care for you, make time for you, and show affection through actions and words." 
},
{ 
    pattern: /how to fix a relationship/i, 
    response: "To fix a relationship, communicate openly, understand each other's feelings, and make efforts to resolve conflicts together." 
},
{ 
    pattern: /how to deal with a breakup/i, 
    response: "To deal with a breakup, focus on self-care, stay busy with positive activities, and surround yourself with supportive friends and family." 
},
{ 
    pattern: /how to make my boyfriend miss me/i, 
    response: "To make your boyfriend miss you, give him space, focus on yourself, and keep the relationship exciting." 
},
{ 
    pattern: /how to make my girlfriend miss me/i, 
    response: "To make your girlfriend miss you, be mysterious, avoid being too available, and create memorable moments together." 
},
{ 
    pattern: /why is my boyfriend ignoring me/i, 
    response: "Your boyfriend might be busy, stressed, or upset. Try communicating with him calmly and understanding his perspective." 
},
{ 
    pattern: /why is my girlfriend ignoring me/i, 
    response: "Your girlfriend might be upset, need space, or have personal issues. Give her time and talk to her when she's ready." 
},
{ 
    pattern: /how to make my boyfriend jealous/i, 
    response: "Making someone jealous can be risky in a relationship. Instead, focus on building a strong and healthy connection." 
},
{ 
    pattern: /how to make my girlfriend jealous/i, 
    response: "Jealousy can hurt a relationship. Instead, work on making her feel valued and special." 
},
{ 
    pattern: /how to surprise my boyfriend/i, 
    response: "Surprise your boyfriend by planning a special date, giving him a thoughtful gift, or writing him a heartfelt letter." 
},
{ 
    pattern: /how to surprise my girlfriend/i, 
    response: "Surprise your girlfriend with a romantic dinner, a handwritten note, or a spontaneous trip to her favorite place." 
},
{ 
    pattern: /how to tell my boyfriend I love him/i, 
    response: "Tell your boyfriend you love him in a sincere and heartfelt way. You can say it in person, write a letter, or show it through actions." 
},
{ 
    pattern: /how to tell my girlfriend I love her/i, 
    response: "Tell your girlfriend you love her by expressing it sincerely, making eye contact, and showing your love through actions." 
},
{ 
    pattern: /should I text my ex/i, 
    response: "Before texting your ex, consider why you want to. If it's for closure, keep it respectful. If it's out of loneliness, think twice." 
},
{ 
    pattern: /how to make a long-distance relationship work/i, 
    response: "To make a long-distance relationship work, communicate regularly, plan visits, and build trust." 
},
{ 
    pattern: /how to apologize to my boyfriend/i, 
    response: "Apologize sincerely by acknowledging your mistake, expressing regret, and showing that you want to improve." 
},
{ 
    pattern: /how to apologize to my girlfriend/i, 
    response: "Apologize to your girlfriend with honesty, take responsibility, and make it up to her with kind actions." 
},
{ 
    pattern: /how to stop arguing with my boyfriend/i, 
    response: "To stop arguing, listen to his perspective, stay calm, and focus on solving problems rather than blaming each other." 
},
{ 
    pattern: /how to stop arguing with my girlfriend/i, 
    response: "To stop arguing, communicate calmly, avoid interrupting her, and find solutions instead of escalating conflicts." 
},
{ 
    pattern: /what to do if my boyfriend is losing interest/i, 
    response: "If your boyfriend is losing interest, talk openly with him, reignite the spark, and focus on strengthening your bond." 
},
{ 
    pattern: /what to do if my girlfriend is losing interest/i, 
    response: "If your girlfriend is losing interest, try to understand her feelings, show her appreciation, and bring back excitement into the relationship." 
},
{ 
    pattern: /is my boyfriend cheating on me/i, 
    response: "If you suspect your boyfriend is cheating, look for changes in behavior and communication. The best approach is to talk to him directly." 
},
{ 
    pattern: /is my girlfriend cheating on me/i, 
    response: "If you suspect your girlfriend is cheating, observe her actions and have an open conversation with her about your concerns." 
},
{ 
    pattern: /how to make my boyfriend love me more/i, 
    response: "To make your boyfriend love you more, show him appreciation, support his goals, and create meaningful memories together." 
},
{ 
    pattern: /how to make my girlfriend love me more/i, 
    response: "To make your girlfriend love you more, treat her with respect, listen to her, and always make her feel special." 
},
{ 
    pattern: /how to make my boyfriend trust me/i, 
    response: "To build trust with your boyfriend, be honest, keep your promises, and communicate openly." 
},
{ 
    pattern: /how to make my girlfriend trust me/i, 
    response: "To make your girlfriend trust you, be transparent, stay loyal, and always keep your word." 
},
{ 
    pattern: /what should I text my boyfriend/i, 
    response: "You can text your boyfriend a sweet message, ask about his day, or send something funny to make him smile." 
},
{ 
    pattern: /what should I text my girlfriend/i, 
    response: "Text your girlfriend something thoughtful, compliment her, or remind her how much she means to you." 
},
{ 
    pattern: /how to know if my boyfriend is serious about me/i, 
    response: "A serious boyfriend will prioritize you, make future plans with you, and stay loyal in difficult times." 
},
{ 
    pattern: /how to know if my girlfriend is serious about me/i, 
    response: "A serious girlfriend will be committed, include you in her plans, and make an effort to understand and support you." 
},
{ 
    pattern: /how to get over my boyfriend/i, 
    response: "To get over your boyfriend, focus on self-care, spend time with friends, and remind yourself why the breakup happened." 
},
{ 
    pattern: /how to get over my girlfriend/i, 
    response: "To get over your girlfriend, avoid dwelling on the past, stay busy with hobbies, and surround yourself with supportive people." 
},
{ 
    pattern: /how to tell if my boyfriend is lying/i, 
    response: "Signs that your boyfriend may be lying include avoiding eye contact, being inconsistent, or acting defensive when questioned." 
},
{ 
    pattern: /how to tell if my girlfriend is lying/i, 
    response: "If your girlfriend is lying, she might avoid details, change her story, or seem nervous when answering your questions." 
},
{ 
    pattern: /why is my boyfriend acting distant/i, 
    response: "Your boyfriend might be stressed, need space, or dealing with personal issues. Try asking him about it calmly." 
},
{ 
    pattern: /why is my girlfriend acting distant/i, 
    response: "Your girlfriend might be going through something personal or feeling unappreciated. Open communication can help." 
},
{ 
    pattern: /how to stop my boyfriend from leaving me/i, 
    response: "You can't force someone to stay, but you can talk openly, understand his feelings, and work on any relationship issues." 
},
{ 
    pattern: /how to stop my girlfriend from leaving me/i, 
    response: "If your girlfriend is thinking about leaving, have an honest conversation and see if you can resolve any issues together." 
},
{ 
    pattern: /what to do if my boyfriend cheated on me/i, 
    response: "If your boyfriend cheated, take time to process your feelings, decide if you can forgive him, and prioritize your happiness." 
},
{ 
    pattern: /what to do if my girlfriend cheated on me/i, 
    response: "If your girlfriend cheated, consider whether trust can be rebuilt and focus on what’s best for your emotional well-being." 
},
{ 
    pattern: /how to handle jealousy in a relationship/i, 
    response: "To handle jealousy, communicate openly, build trust, and focus on strengthening your relationship." 
},
{ 
    pattern: /how to make my ex want me back/i, 
    response: "To make your ex want you back, work on self-improvement, give them space, and let them see what they lost." 
},
{ 
    pattern: /is it okay to be friends with my ex/i, 
    response: "Being friends with an ex is possible, but only if both of you have moved on and there are no lingering feelings." 
},
{ 
    pattern: /should I give my ex another chance/i, 
    response: "Consider why you broke up in the first place. If the issues remain unresolved, getting back together may not be a good idea." 
},
{ 
    pattern: /how to make my boyfriend commit/i, 
    response: "To make your boyfriend commit, build a strong emotional connection, be supportive, and avoid rushing him." 
},
{ 
    pattern: /how to make my girlfriend commit/i, 
    response: "To make your girlfriend commit, show her that you are serious, consistent, and ready for a long-term relationship." 
},
{ 
    pattern: /how to stop being clingy with my boyfriend/i, 
    response: "To stop being clingy, focus on your own hobbies, give him space, and trust the relationship." 
},
{ 
    pattern: /how to stop being clingy with my girlfriend/i, 
    response: "Give your girlfriend space, build confidence in yourself, and trust that she cares about you even when you're apart." 
},
{ 
    pattern: /how to handle a long-distance breakup/i, 
    response: "A long-distance breakup can be tough. Allow yourself to grieve, cut off unhealthy contact, and focus on healing." 
},
{ 
    pattern: /should I date my best friend/i, 
    response: "Dating your best friend can be great, but make sure you both have romantic feelings and are willing to risk the friendship if things don’t work out." 
},
{ 
    pattern: /why does my boyfriend not text me back/i, 
    response: "He might be busy, distracted, or needing space. Try not to overthink and wait for him to respond." 
},
{ 
    pattern: /why does my girlfriend not text me back/i, 
    response: "Your girlfriend might be occupied, stressed, or taking a break from her phone. Give her some time before jumping to conclusions." 
},
{ 
    pattern: /how to deal with a controlling boyfriend/i, 
    response: "If your boyfriend is controlling, try setting clear boundaries, express your need for independence, and consider seeking professional advice if the behavior continues." 
},
{ 
    pattern: /how to deal with a controlling girlfriend/i, 
    response: "If your girlfriend is controlling, have an honest conversation about your need for personal space and trust. Establishing clear boundaries can help both of you feel more comfortable." 
},
{ 
    pattern: /what are some fun date ideas/i, 
    response: "Fun date ideas include trying a new restaurant, going for a hike, visiting a museum, or planning a picnic in a scenic park." 
},
{ 
    pattern: /how to reignite passion in my relationship/i, 
    response: "Reignite passion by planning surprise dates, exploring new activities together, and discussing your desires openly with your partner." 
},
{ 
    pattern: /how to build trust after cheating/i, 
    response: "Building trust after cheating takes time and honest communication. Both partners must be willing to work through their feelings, and professional counseling might help rebuild the relationship." 
},
{ 
    pattern: /how to deal with a breakup amicably/i, 
    response: "To handle a breakup amicably, communicate calmly, agree on respectful boundaries, and allow each other the space to heal without unnecessary conflict." 
},
{ 
    pattern: /how to move on after a bad breakup/i, 
    response: "Moving on after a breakup involves focusing on self-care, exploring new hobbies, spending time with supportive friends, and sometimes seeking professional guidance." 
},
{ 
    pattern: /what does a healthy relationship look like/i, 
    response: "A healthy relationship is built on mutual respect, open communication, trust, and both partners feeling supported and valued." 
},
{ 
    pattern: /how to maintain independence in a relationship/i, 
    response: "Maintain your independence by pursuing your own interests, setting personal goals, and ensuring you have time for your individual friendships and hobbies." 
},
{ 
    pattern: /how to communicate my needs to my partner/i, 
    response: "Express your needs clearly using 'I' statements, avoid blaming, and encourage your partner to share their perspective as well." 
},
{ 
    pattern: /how to balance work and a relationship/i, 
    response: "Balancing work and a relationship means setting clear priorities, scheduling quality time together, and maintaining open communication about your busy schedules." 
},
{ 
    pattern: /how to celebrate an anniversary with my partner/i, 
    response: "Celebrate your anniversary by reflecting on special memories, planning a thoughtful surprise, or doing an activity that both of you enjoy together." 
},
{ 
    pattern: /how to apologize after an argument/i, 
    response: "After an argument, apologize sincerely by acknowledging your mistakes, expressing regret, and discussing ways to avoid similar conflicts in the future." 
},
{ 
    pattern: /how to deal with insecurities in a relationship/i, 
    response: "Address insecurities by talking openly with your partner, focusing on self-improvement, and, if needed, seeking advice from a trusted friend or professional." 
},
{ 
    pattern: /how to spice up my relationship/i, 
    response: "Spice up your relationship by trying new activities together, planning surprises, and exploring each other's interests in a fun, creative way." 
},
{ 
    pattern: /how to set boundaries with my partner/i, 
    response: "Set boundaries by discussing your comfort levels, listening to your partner's needs, and agreeing on respectful limits that work for both of you." 
},
{ 
    pattern: /how to know if my partner is the one/i, 
    response: "You might know your partner is the one if you share mutual respect, feel supported, and have a deep, trusting connection with each other." 
},
{ 
    pattern: /how to deal with constant arguments/i, 
    response: "If constant arguments are affecting your relationship, try to identify recurring issues, communicate calmly, and consider couples counseling to work through deeper problems." 
},
{ 
    pattern: /how to balance my personal space and my relationship/i, 
    response: "Balancing personal space with relationship time means planning regular individual activities while also scheduling dedicated time together for quality connection." 
},
{ 
    pattern: /how to discuss future plans with my partner/i, 
    response: "Discuss future plans by sharing your goals, listening to your partner’s dreams, and finding common ground to build a shared vision for the future." 
},
{ 
    pattern: /how to know if i'm overthinking my relationship/i, 
    response: "If you find yourself constantly worrying or reading too much into every detail, it might help to take a step back, focus on self-reflection, and communicate your concerns with your partner." 
},
{ 
    pattern: /how to build a deeper connection with my partner/i, 
    response: "Building a deeper connection involves sharing your true feelings, spending quality time together, and being open to learning more about each other's dreams and vulnerabilities." 
},
{ 
    pattern: /how to avoid codependency in a relationship/i, 
    response: "Avoid codependency by maintaining your personal interests, setting healthy boundaries, and ensuring that both partners have their own space and social support systems." 
},
{ 
    pattern: /how to address my partner's mood swings/i, 
    response: "When dealing with mood swings, approach your partner with empathy, gently encourage open communication, and consider if professional advice might be needed for ongoing issues." 
},
{ 
    pattern: /what are the signs of an unhealthy relationship/i, 
    response: "Signs of an unhealthy relationship can include constant criticism, lack of trust, poor communication, and feeling controlled or unappreciated. Recognizing these early is key to addressing them." 
},
{ 
    pattern: /how to deal with my partner's ex/i, 
    response: "Dealing with a partner's ex requires open communication. Express your feelings without accusations and work together to build trust and reassurance in your relationship." 
},
{ 
    pattern: /how to improve communication in my relationship/i, 
    response: "Improving communication involves active listening, being honest about your feelings, and setting aside time to talk without distractions." 
},
{ 
    pattern: /how to manage disagreements with my partner/i, 
    response: "Manage disagreements by staying calm, using 'I' statements to express your feelings, and seeking compromise rather than trying to win the argument." 
},
{ 
    pattern: /how to maintain romance in a long-term relationship/i, 
    response: "Keep the romance alive by planning regular date nights, surprising each other with thoughtful gestures, and continuing to learn about each other's evolving interests." 
},
{ 
    pattern: /how to give my partner space without feeling insecure/i, 
    response: "It's important to build trust by understanding that personal space benefits both individuals. Focus on your own interests, maintain your social life, and remind yourself of the strength of your bond." 
},{ 
    pattern: /what is ai metaverse/i, 
    response: "AI in the Metaverse enhances virtual environments, creating realistic interactions, NPCs, and adaptive storytelling." 
},
{ 
    pattern: /will ai create its own language/i, 
    response: "AI has developed its own languages in research experiments, but human oversight ensures clarity and safety." 
},
{ 
    pattern: /how will ai change robotics/i, 
    response: "AI is making robots more intelligent, allowing them to learn tasks, recognize emotions, and interact naturally with humans." 
},
{ 
    pattern: /what is ai self-learning/i, 
    response: "AI self-learning refers to models that improve over time by analyzing new data without explicit programming." 
},
{ 
    pattern: /can ai control smart cities/i, 
    response: "Yes! AI can optimize traffic, manage energy consumption, and improve city planning for smarter urban living." 
},
{ 
    pattern: /will ai replace doctors/i, 
    response: "AI will assist doctors with diagnosis and treatment but is unlikely to replace human medical professionals entirely." 
},
{ 
    pattern: /can ai predict weather/i, 
    response: "AI improves weather forecasting by analyzing climate data and detecting patterns in real-time." 
},
{ 
    pattern: /what is ai-powered transportation/i, 
    response: "AI-powered transportation includes self-driving cars, intelligent traffic control, and AI-assisted flight navigation." 
},
{ 
    pattern: /can ai generate realistic human voices/i, 
    response: "Yes! AI voice synthesis can create lifelike voices for virtual assistants, audiobooks, and deepfake applications." 
},
{ 
    pattern: /what is ai-driven automation/i, 
    response: "AI-driven automation helps businesses optimize workflows, reduce human effort, and increase productivity." 
},
{ 
    pattern: /will ai be able to create movies/i, 
    response: "AI is already helping in scriptwriting, CGI effects, and animation, but full movie production still requires human creativity." 
},
{ 
    pattern: /how does ai help in space exploration/i, 
    response: "AI helps analyze space data, control rovers, and assist in autonomous decision-making for interstellar missions." 
},
{ 
    pattern: /can ai predict human behavior/i, 
    response: "AI can analyze behavior patterns and predict actions, but human unpredictability still makes absolute accuracy difficult." 
},
{ 
    pattern: /how does ai contribute to cybersecurity/i, 
    response: "AI enhances cybersecurity by detecting threats, identifying anomalies, and automating security responses." 
},
{ 
    pattern: /what is the role of ai in smart homes/i, 
    response: "AI powers smart assistants, energy management systems, and automated home security for better living experiences." 
},
{ 
    pattern: /will ai have consciousness in the future/i, 
    response: "AI currently lacks consciousness, but future advancements might bring AI closer to simulating self-awareness." 
},
{ 
    pattern: /can ai generate new scientific theories/i, 
    response: "AI assists scientists by analyzing data and identifying new patterns, helping in scientific discoveries and innovations." 
},
{ 
    pattern: /play tic tac toe/i, 
    response: "Let's play Tic-Tac-Toe! You go first. Type your move as a number (1-9) where 1 is the top-left and 9 is the bottom-right." 
},
{ 
    pattern: /start ai chess game/i, 
    response: "AI Chess activated! Do you want to play as White or Black? Type 'White' to start first or 'Black' for AI to move first." 
},
{ 
    pattern: /can ai beat humans in chess/i, 
    response: "Yes! Advanced AI like AlphaZero has beaten top human chess players by learning strategies through self-play." 
},
{ 
    pattern: /how does ai learn to play games/i, 
    response: "AI learns games using reinforcement learning, where it plays millions of rounds and improves its strategies over time." 
},
{ 
    pattern: /what is ai game automation/i, 
    response: "AI game automation refers to bots or AI-controlled agents that can play games automatically using deep learning models." 
},
{ 
    pattern: /can ai create its own video games/i, 
    response: "Yes! AI can generate game levels, characters, and even design entire game mechanics using procedural content generation." 
},
{ 
    pattern: /how does ai improve video game graphics/i, 
    response: "AI enhances graphics through upscaling, texture generation, and real-time rendering for realistic visuals." 
},
{ 
    pattern: /can ai make a 3d game/i, 
    response: "Yes! AI can generate 3D environments, character models, and even procedural animations for game development." 
},
{ 
    pattern: /can ai learn to play fighting games/i, 
    response: "Yes! AI can analyze fighting game mechanics, predict opponent moves, and optimize attack strategies." 
},
{ 
    pattern: /what is ai procedural generation/i, 
    response: "AI procedural generation creates game content dynamically, such as randomized maps, levels, and characters." 
},
{ 
    pattern: /how does ai help in game development/i, 
    response: "AI assists in coding, level design, character animations, bug detection, and real-time enemy AI behavior." 
},
{ 
    pattern: /can ai play battle royale games/i, 
    response: "Yes! AI bots can simulate players in battle royale games, improving training modes and bot-based matchmaking." 
},
{ 
    pattern: /how does ai detect cheating in games/i, 
    response: "AI analyzes player behavior, detects unusual patterns, and flags potential cheaters in multiplayer games." 
},
{ 
    pattern: /can ai build open-world games/i, 
    response: "AI can generate large open-world environments with realistic landscapes, dynamic NPCs, and interactive quests." 
},
{ 
    pattern: /how does ai create game characters/i, 
    response: "AI uses procedural modeling to generate realistic characters, facial expressions, and voice synthesis." 
},
{ 
    pattern: /what is ai pathfinding in games/i, 
    response: "AI pathfinding helps NPCs navigate game environments by finding the shortest or most efficient route." 
},
{ 
    pattern: /can ai predict game outcomes/i, 
    response: "AI can analyze player performance, predict match outcomes, and suggest strategies based on game data." 
},
{ 
    pattern: /what is artificial intelligence/i, 
    response: "Artificial Intelligence (AI) is the simulation of human intelligence in machines that can learn, reason, and make decisions." 
},
{ 
    pattern: /how does ai work/i, 
    response: "AI works by processing large amounts of data, recognizing patterns, and using algorithms to make predictions or automate tasks." 
},
{ 
    pattern: /what is the future of ai/i, 
    response: "The future of AI includes advancements in automation, personalized AI assistants, improved healthcare solutions, and ethical AI development." 
},
{ 
    pattern: /will ai replace human jobs/i, 
    response: "AI will automate some tasks but also create new job opportunities that require human creativity, problem-solving, and emotional intelligence." 
},
{ 
    pattern: /what are the risks of ai/i, 
    response: "AI risks include job displacement, bias in decision-making, data privacy concerns, and potential misuse in unethical applications." 
},
{ 
    pattern: /how is ai used in daily life/i, 
    response: "AI is used in voice assistants, personalized recommendations, smart home devices, self-driving cars, and healthcare diagnostics." 
},
{ 
    pattern: /what is machine learning/i, 
    response: "Machine learning is a subset of AI where algorithms learn from data to improve their accuracy over time without being explicitly programmed." 
},
{ 
    pattern: /will ai become self-aware/i, 
    response: "Currently, AI lacks self-awareness, but researchers continue exploring advanced AI models that mimic human cognition." 
},
{ 
    pattern: /how can ai improve healthcare/i, 
    response: "AI can improve healthcare through early disease detection, personalized treatment plans, robotic surgeries, and medical research advancements." 
},
{ 
    pattern: /what are ai ethics/i, 
    response: "AI ethics involve ensuring AI systems are fair, transparent, accountable, and do not cause harm to society." 
},
{ 
    pattern: /how is ai used in gaming/i, 
    response: "AI in gaming enhances NPC behavior, creates dynamic environments, improves game graphics, and personalizes player experiences." 
},
{ 
    pattern: /will ai have emotions/i, 
    response: "AI can simulate emotions but does not truly feel them. Future AI may better understand and respond to human emotions." 
},
{ 
    pattern: /what is the difference between ai and robotics/i, 
    response: "AI refers to intelligent algorithms, while robotics involves physical machines. AI can be integrated into robots for smarter automation." 
},
{ 
    pattern: /how will ai change the world/i, 
    response: "AI will revolutionize industries like healthcare, finance, education, and automation, leading to increased efficiency and new innovations." 
},
{ 
    pattern: /what is quantum ai/i, 
    response: "Quantum AI uses quantum computing to process complex calculations faster, improving machine learning and optimization problems." 
},
{ 
    pattern: /how secure is ai/i, 
    response: "AI security depends on how it's implemented. Strong cybersecurity measures are needed to prevent AI manipulation or hacking." 
},
{ 
    pattern: /what is general ai/i, 
    response: "General AI, or AGI, refers to an AI system with human-like intelligence that can perform any intellectual task like a human." 
},
{ 
    pattern: /can ai create art/i, 
    response: "Yes, AI can generate music, paintings, and literature using deep learning models, but human creativity still plays a major role." 
},
{ 
    pattern: /what is ai bias/i, 
    response: "AI bias occurs when an AI system makes unfair or discriminatory decisions due to biased training data or flawed algorithms." 
},
{ 
    pattern: /how is ai used in cybersecurity/i, 
    response: "AI enhances cybersecurity by detecting threats, analyzing patterns in cyber attacks, and automating security measures." 
},
{ 
    pattern: /can ai predict the future/i, 
    response: "AI can analyze trends and make predictions based on data, but it cannot predict the future with complete certainty." 
},
{ 
    pattern: /what is ai singularity/i, 
    response: "AI singularity is the theoretical point where AI surpasses human intelligence, leading to rapid technological changes." 
},
{ 
    pattern: /how does ai improve customer service/i, 
    response: "AI improves customer service through chatbots, automated responses, and personalized recommendations for users." 
},
{ 
    pattern: /how will ai impact education/i, 
    response: "AI will personalize learning, automate grading, provide tutoring, and create intelligent classroom environments." 
},
{ 
    pattern: /what is ai-powered automation/i, 
    response: "AI-powered automation uses machine learning to perform tasks without human intervention, increasing efficiency in various industries." 
},
{ 
    pattern: /can ai write code/i, 
    response: "AI can generate code and assist developers, but it still requires human oversight for complex programming and debugging." 
},
{ 
    pattern: /what is deep learning/i, 
    response: "Deep learning is a subset of machine learning that uses neural networks to process data and make intelligent decisions." 
},
{ 
    pattern: /how does ai help in finance/i, 
    response: "AI assists in fraud detection, stock market predictions, risk management, and personalized financial planning." 
},
{ 
    pattern: /will ai become smarter than humans/i, 
    response: "AI can surpass humans in specific tasks but lacks general intelligence, emotional understanding, and creativity at a human level." 
},
{ 
    pattern: /what is ai-generated content/i, 
    response: "AI-generated content includes articles, videos, images, and music created using machine learning and natural language processing." 
},
{ 
    pattern: /current time/i, 
    response: () => {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        return `The current time is: ${hours}:${minutes}:${seconds}`;
    }
},{ 
    pattern: /time after (\d+) minutes/i, 
    response: (match) => {
        const minutesToAdd = parseInt(match[1]);
        const now = new Date();
        now.setMinutes(now.getMinutes() + minutesToAdd);
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        return `The time after ${minutesToAdd} minutes will be: ${hours}:${minutes}:${seconds}`;
    }
},{ 
    pattern: /convert utc to (\w+)/i, 
    response: (match) => {
        const timeZone = match[1].toUpperCase();
        const now = new Date();
        const options = { timeZone: timeZone, hour: '2-digit', minute: '2-digit', second: '2-digit' };
        const timeInTimeZone = now.toLocaleString('en-US', options);
        return `The current time in ${timeZone} is: ${timeInTimeZone}`;
    }
},{ 
    pattern: /days until (\d{2})\/(\d{2})\/(\d{4})/i, 
    response: (match) => {
        const targetDate = new Date(`${match[2]}/${match[1]}/${match[3]}`);
        const now = new Date();
        const timeDifference = targetDate - now;
        const daysLeft = Math.ceil(timeDifference / (1000 * 3600 * 24)); // convert ms to days
        return `There are ${daysLeft} days left until ${match[2]}/${match[1]}/${match[3]}`;
    }
},{ 
    pattern: /time since (\d{2})\/(\d{2})\/(\d{4})/i, 
    response: (match) => {
        const targetDate = new Date(`${match[2]}/${match[1]}/${match[3]}`);
        const now = new Date();
        const timeDifference = now - targetDate;
        const daysPassed = Math.floor(timeDifference / (1000 * 3600 * 24));
        const hoursPassed = Math.floor((timeDifference % (1000 * 3600 * 24)) / (1000 * 3600));
        const minutesPassed = Math.floor((timeDifference % (1000 * 3600)) / (1000 * 60));
        return `It has been ${daysPassed} days, ${hoursPassed} hours, and ${minutesPassed} minutes since ${match[2]}/${match[1]}/${match[3]}`;
    }
},{ 
    pattern: /current month/i, 
    response: () => {
        const now = new Date();
        const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const month = months[now.getMonth()];
        return `The current month is: ${month}`;
    }
},{ 
    pattern: /current year/i, 
    response: () => {
        const now = new Date();
        return `The current year is: ${now.getFullYear()}`;
    }
},{ 
    pattern: /next week date/i, 
    response: () => {
        const now = new Date();
        now.setDate(now.getDate() + 7);
        const date = now.toLocaleDateString();
        return `The date next week will be: ${date}`;
    }
},
    { 
    pattern: /time until midnight/i, 
    response: () => {
        const now = new Date();
        const midnight = new Date(now);
        midnight.setHours(24, 0, 0, 0); // Set to midnight of the next day
        const timeRemaining = midnight - now;
        const hoursRemaining = Math.floor(timeRemaining / (1000 * 3600));
        const minutesRemaining = Math.floor((timeRemaining % (1000 * 3600)) / (1000 * 60));
        return `There are ${hoursRemaining} hours and ${minutesRemaining} minutes left until midnight.`;
    }
},{ 
    pattern: /largest number in (.+)/i, 
    response: (match) => {
        const numbers = match[1].split(',').map(num => parseFloat(num.trim()));
        const largest = Math.max(...numbers);
        return `The largest number is: ${largest}`;
    }
},{ 
    pattern: /random number between (\d+) and (\d+)/i, 
    response: (match) => {
        const min = parseInt(match[1]);
        const max = parseInt(match[2]);
        const randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
        return `The random number between ${min} and ${max} is: ${randomNumber}`;
    }
},{
    pattern: /generate password with (\d+) characters/i,
    response: (match) => {
        const length = parseInt(match[1]);
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_-+=<>?";
        let password = "";
        
        for (let i = 0; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * charset.length);
            password += charset[randomIndex];
        }

        return `Your generated password is: ${password}`;
    }
},{
    pattern: /name an animal/i,
    response: () => {
        const animals = [
            "Lion", "Tiger", "Elephant", "Giraffe", "Zebra", 
            "Panda", "Kangaroo", "Koala", "Penguin", "Cheetah", 
            "Bear", "Wolf", "Gorilla", "Hippo", "Sloth", 
            "Rhino", "Leopard", "Hawk", "Eagle", "Owl", 
            "Shark", "Whale", "Dolphin", "Crocodile", "Alligator", 
            "Octopus", "Starfish", "Turtle", "Snake", "Lizard"
        ];
        const randomAnimal = animals[Math.floor(Math.random() * animals.length)];
        return `Here is an animal: ${randomAnimal}`;
    }
},{
    pattern: /what sound does a (.+) make/i,
    response: (match) => {
        const animal = match[1].toLowerCase();
        const sounds = {
            "dog": "bark",
            "cat": "meow",
            "cow": "moo",
            "sheep": "baa",
            "lion": "roar",
            "duck": "quack",
            "bird": "chirp",
            "horse": "neigh",
            "elephant": "trumpet",
            "snake": "hiss"
        };
        const sound = sounds[animal] || "I don't know the sound of that animal.";
        return `A ${animal} makes a ${sound}.`;
    }
},{
    pattern: /tell me a fact about (.+)/i,
    response: (match) => {
        const facts = {
            "lion": "Lions are the only cats that live in groups, called prides.",
            "tiger": "Tigers have striped skin, not just striped fur.",
            "elephant": "Elephants are the largest land animals on Earth.",
            "giraffe": "Giraffes are the tallest mammals on Earth.",
            "penguin": "Penguins are birds that cannot fly but are excellent swimmers.",
            "koala": "Koalas sleep up to 18 hours a day."
        };
        const animal = match[1].toLowerCase();
        const fact = facts[animal] || "I don't have any facts about that animal.";
        return `Here's a fact about ${animal}: ${fact}`;
    }
},{
    pattern: /give me a random animal/i,
    response: () => {
        const animals = ["Lion", "Tiger", "Elephant", "Giraffe", "Zebra", 
            "Panda", "Kangaroo", "Koala", "Penguin", "Cheetah", 
            "Bear", "Wolf", "Gorilla", "Hippo", "Sloth", 
            "Rhino", "Leopard", "Hawk", "Eagle", "Owl", 
            "Shark", "Whale", "Dolphin", "Crocodile", "Alligator", 
            "Octopus", "Starfish", "Turtle", "Snake", "Lizard"];
        const randomAnimal = animals[Math.floor(Math.random() * animals.length)];
        return `Here is a random animal: ${randomAnimal}`;
    }
},{
    pattern: /where does a (.+) live/i,
    response: (match) => {
        const habitats = {
            "lion": "Lions live in grasslands, savannas, and open woodlands.",
            "polar bear": "Polar bears live in the Arctic region.",
            "koala": "Koalas live in eucalyptus forests in Australia.",
            "panda": "Pandas live in the mountain ranges of central China.",
            "shark": "Sharks live in oceans and seas around the world."
        };
        const animal = match[1].toLowerCase();
        const habitat = habitats[animal] || "I don't know where that animal lives.";
        return `A ${animal} lives in: ${habitat}`;
    }
},{
    pattern: /what is the classification of a (.+)/i,
    response: (match) => {
        const classifications = {
            "lion": "Lion is a mammal.",
            "penguin": "Penguin is a bird.",
            "crocodile": "Crocodile is a reptile.",
            "shark": "Shark is a fish.",
            "frog": "Frog is an amphibian."
        };
        const animal = match[1].toLowerCase();
        const classification = classifications[animal] || "I don't know the classification of that animal.";
        return `A ${animal} is: ${classification}`;
    }
},{
    pattern: /how many legs does a (.+) have/i,
    response: (match) => {
        const legsCount = {
            "dog": 4,
            "cat": 4,
            "human": 2,
            "spider": 8,
            "centipede": 100,
            "elephant": 4,
            "bird": 2
        };
        const animal = match[1].toLowerCase();
        const count = legsCount[animal] || "I don't know how many legs that animal has.";
        return `A ${animal} has ${count} legs.`;
    }
},{
    pattern: /how long does a (.+) live/i,
    response: (match) => {
        const lifespans = {
            "dog": "Dogs live around 10-15 years.",
            "cat": "Cats live around 15-20 years.",
            "elephant": "Elephants live around 60-70 years.",
            "turtle": "Turtles can live for more than 100 years.",
            "koala": "Koalas live around 10-12 years."
        };
        const animal = match[1].toLowerCase();
        const lifespan = lifespans[animal] || "I don't know the lifespan of that animal.";
        return `A ${animal} lives for approximately: ${lifespan}`;
    }
},{
    pattern: /what is the fastest animal/i,
    response: () => {
        return "The fastest animal is the cheetah, which can run up to 60-70 mph!";
    }
},{
    pattern: /what is the population of (.+)/i,
    response: (match) => {
        const populations = {
            "tiger": "There are approximately 3,900 tigers left in the wild.",
            "panda": "There are around 1,800 giant pandas left in the wild.",
            "rhino": "There are fewer than 30,000 rhinos remaining worldwide.",
            "elephant": "There are around 415,000 African elephants left in the wild."
        };
        const animal = match[1].toLowerCase();
        const population = populations[animal] || "I don't have the population data for that animal.";
        return `The population of ${animal} is: ${population}`;
    }
},{
    pattern: /write a letter to (.+)/i,
    response: (match) => {
        const recipient = match[1];
        return `Dear ${recipient},\n\nI hope this letter finds you in good health and spirits. I wanted to take a moment to thank you for your continued support and kindness. I appreciate all the efforts you have made, and I look forward to more collaboration in the future.\n\nBest regards,\nYour Friend`;
    }
},{
    pattern: /write a paragraph about (.+)/i,
    response: (match) => {
        const topic = match[1];
        return `Here is a paragraph about ${topic}:\n\n${topic} is an essential part of our daily lives. It provides us with necessary information, entertainment, and sometimes even comfort. Understanding ${topic} can help improve our overall knowledge and assist us in making informed decisions. It's important to constantly learn and stay updated about ${topic}, as it has a significant impact on various aspects of life.`;
    }
},{
    pattern: /generate a sentence/i,
    response: () => {
        const sentences = [
            "The sun is setting, and the sky is painted in beautiful shades of orange.",
            "A gentle breeze swirled through the trees as the birds chirped in harmony.",
            "The city streets were bustling with people, each heading towards their destination.",
            "Under the starry night sky, everything seemed peaceful and quiet."
        ];
        const randomSentence = sentences[Math.floor(Math.random() * sentences.length)];
        return randomSentence;
    }
},{
    pattern: /tell me a story about (.+)/i,
    response: (match) => {
        const theme = match[1];
        return `Once upon a time, in a land far away, there lived a brave soul who ventured through the wilderness of ${theme}. The journey was full of obstacles, but the courage of the traveler never wavered. One day, they encountered a challenge unlike any other. With intelligence, determination, and a kind heart, they overcame the hardship and became a legend in the land of ${theme}. The people of ${theme} still remember the traveler’s bravery and kindness to this day.`;
    }
},{
    pattern: /give me a compliment/i,
    response: () => {
        const compliments = [
            "You have a great sense of humor!",
            "Your kindness knows no bounds.",
            "You are truly an inspiring person!",
            "You have such a positive attitude, it's contagious!"
        ];
        const randomCompliment = compliments[Math.floor(Math.random() * compliments.length)];
        return randomCompliment;
    }
},{
    pattern: /give me a motivational quote/i,
    response: () => {
        const quotes = [
            "The only way to do great work is to love what you do. – Steve Jobs",
            "Success is not final, failure is not fatal: It is the courage to continue that counts. – Winston Churchill",
            "Believe you can and you're halfway there. – Theodore Roosevelt",
            "The best time to plant a tree was 20 years ago. The second best time is now. – Chinese Proverb",
            "It does not matter how slowly you go as long as you do not stop. – Confucius",
            "You are never too old to set another goal or to dream a new dream. – C.S. Lewis",
            "Everything you can imagine is real. – Pablo Picasso",
            "The future belongs to those who believe in the beauty of their dreams. – Eleanor Roosevelt",
            "Don’t watch the clock; do what it does. Keep going. – Sam Levenson",
            "Success is not how high you have climbed, but how you make a positive difference to the world. – Roy T. Bennett",
            "Your time is limited, so don’t waste it living someone else’s life. – Steve Jobs",
            "Opportunities don't happen, you create them. – Chris Grosser",
            "Don’t be pushed around by the fears in your mind. Be led by the dreams in your heart. – Roy T. Bennett",
            "Success usually comes to those who are too busy to be looking for it. – Henry David Thoreau",
            "Act as if what you do makes a difference. It does. – William James"
        ];
        const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
        return randomQuote;
    }
},{
    pattern: /give me a fun fact/i,
    response: () => {
        const funFacts = [
            "Honey never spoils. Archaeologists have found pots of honey in ancient tombs that are over 3,000 years old.",
            "A group of flamingos is called a 'flamboyance'.",
            "Cows have best friends and can become stressed when they are separated.",
            "The Eiffel Tower can be 15 cm taller during the summer due to the expansion of the metal in the heat.",
            "Bananas are berries, but strawberries are not.",
            "Wombat poop is cube-shaped to prevent it from rolling away.",
            "An octopus has three hearts and blue blood.",
            "Sharks have been around longer than trees.",
            "A day on Venus is longer than a year on Venus.",
            "Sloths can hold their breath for up to 40 minutes underwater.",
            "The shortest war in history lasted 38 to 45 minutes between Britain and Zanzibar on August 27, 1896.",
            "The longest hiccuping spree lasted 68 years.",
            "Humans share 60% of their DNA with bananas.",
            "There are more stars in the universe than grains of sand on all the Earth’s beaches.",
            "The world's largest desert is actually Antarctica, not the Sahara."
        ];
        const randomFact = funFacts[Math.floor(Math.random() * funFacts.length)];
        return randomFact;
    }
},{
    pattern: /(?:translate|convert|say|how to say)\s+(.+?)\s+(?:to|in)\s+(tamil|ta)/i,
    response: (match) => {
        const tamilCombined = new Map([
            // Common phrases
            ["good morning", "காலை வணக்கம்"],
            ["good afternoon", "மத்தியான் வணக்கம்"],
            ["good evening", "மாலை வணக்கம்"],
            ["good night", "இரவு வணக்கம்"],
            ["thank you", "நன்றி"],
            ["you're welcome", "வருக"],
            ["excuse me", "மன்னிக்கவும்"],
            ["i'm sorry", "மன்னிக்கவும்"],
            ["how are you", "நீங்கள் எப்படி இருக்கிறீர்கள்"],
            ["i am fine", "நான் நலமாக இருக்கிறேன்"],
            ["what is your name", "உங்கள் பெயர் என்ன"],
            ["my name is", "என் பெயர்"],
            ["where are you from", "நீங்கள் எங்கிருந்து வருகிறீர்கள்"],
            ["i am from", "நான் இருந்து வருகிறேன்"],
            ["nice to meet you", "உங்களை சந்தித்ததில் மகிழ்ச்சி"],
            ["have a nice day", "ஒரு நல்ல நாள் கொண்டாடுங்கள்"],
            ["see you later", "பின்னர் உங்களைப் பார்கிறேன்"],
            ["take care", "கவனித்துக்கொள்ளுங்கள்"],
            
            // Common words
            ["what", "என்ன"], ["this", "இது"], ["is", "ஆகும்"], ["to", "க்கு"], ["tamil", "தமிழ்"],
            ["alagu", "அழகு"], ["arun", "அருண்"], ["kavi", "கவி"], ["hello", "வணக்கம்"], ["good", "நல்ல"],
            ["morning", "காலை"], ["night", "இரவு"], ["food", "உணவு"], ["water", "நீர்"], ["love", "காதல்"],
            ["friend", "நண்பர்"], ["home", "வீடு"], ["school", "பள்ளி"], ["book", "புத்தகம்"], ["pen", "பேனா"],
            ["work", "வேலை"], ["day", "நாள்"], ["time", "நேரம்"], ["year", "வருடம்"], ["month", "மாதம்"],
            ["week", "வாரம்"], ["today", "இன்று"], ["tomorrow", "நாளை"], ["yesterday", "நேற்று"],
            ["yes", "ஆம்"], ["no", "இல்லை"], ["please", "தயவு செய்து"], ["thank you", "நன்றி"],
            ["sorry", "மன்னிக்கவும்"], ["help", "உதவி"], ["name", "பெயர்"], ["age", "வயது"], ["city", "நகரம்"],
            ["country", "நாடு"], ["language", "மொழி"], ["people", "மக்கள்"], ["child", "குழந்தை"],
            ["man", "ஆண்"], ["woman", "பெண்"], ["family", "குடும்பம்"], ["father", "தந்தை"], ["mother", "தாய்"],
            ["brother", "சகோதரன்"], ["sister", "சகோதரி"], ["son", "மகன்"], ["daughter", "மகள்"],
            ["teacher", "ஆசிரியர்"], ["student", "மாணவர்"], ["doctor", "மருத்துவர்"], ["hospital", "மருத்துவமனை"],
            ["money", "பணம்"], ["price", "விலை"], ["shop", "கடை"], ["car", "கார்"], ["bus", "பேருந்து"],
            ["train", "ரயில்"], ["airport", "விமான நிலையம்"], ["hotel", "ஹோட்டல்"], ["room", "அறை"],
            ["phone", "தொலைபேசி"], ["computer", "கணினி"], ["internet", "இணையம்"], ["game", "விளையாட்டு"],
            ["music", "இசை"], ["movie", "திரைப்படம்"], ["song", "பாடல்"], ["dance", "நடனம்"], ["art", "கலை"],
            ["color", "நிறம்"], ["red", "சிவப்பு"], ["blue", "நீலம்"], ["green", "பச்சை"], ["yellow", "மஞ்சள்"],
            ["black", "கருப்பு"], ["white", "வெள்ளை"], ["big", "பெரிய"], ["small", "சிறிய"], ["hot", "சூடான"],
            ["cold", "குளிர்"], ["happy", "மகிழ்ச்சி"], ["sad", "வருத்தம்"], ["angry", "கோபம்"], ["tired", "சோர்வு"],
            ["hungry", "பசி"], ["thirsty", "தாகம்"], ["beautiful", "அழகான"], ["ugly", "அசிங்கமான"],
            ["easy", "எளிதான"], ["difficult", "கடினமான"], ["new", "புதிய"], ["old", "பழைய"], ["young", "இளைய"],
            ["right", "சரியான"], ["wrong", "தவறான"], ["true", "உண்மை"], ["false", "பொய்"], ["open", "திறந்த"],
            ["close", "மூடிய"], ["start", "தொடக்கம்"], ["end", "முடிவு"], ["up", "மேல்"], ["down", "கீழ்"],
            ["left", "இடது"], ["right", "வலது"], ["here", "இங்கே"], ["there", "அங்கே"], ["who", "யார்"],
            ["what", "என்ன"], ["where", "எங்கே"], ["when", "எப்போது"], ["why", "ஏன்"], ["how", "எப்படி"],
            ["which", "எது"], ["whose", "யாருடைய"], ["and", "மற்றும்"], ["or", "அல்லது"], ["but", "ஆனால்"],
            ["because", "ஏனெனில்"], ["if", "என்றால்"], ["then", "பின்னர்"], ["now", "இப்போது"], ["later", "பின்னர்"],
            ["always", "எப்போதும்"], ["never", "ஒருபோதும்"], ["sometimes", "சில நேரங்களில்"], ["often", "பெரும்பாலும்"],
            ["very", "மிகவும்"], ["little", "சிறிது"], ["many", "பல"], ["few", "சில"], ["all", "அனைத்தும்"],
            ["some", "சில"], ["none", "எதுவும் இல்லை"], ["more", "மேலும்"], ["less", "குறைவாக"], ["enough", "போதுமான"],
            ["only", "மட்டும்"], ["also", "மேலும்"], ["even", "கூட"], ["just", "வெறும்"], ["about", "பற்றி"],
            ["after", "பிறகு"], ["before", "முன்"], ["during", "போது"], ["until", "வரை"], ["again", "மீண்டும்"],
            ["once", "ஒருமுறை"], ["twice", "இருமுறை"], ["first", "முதல்"], ["second", "இரண்டாம்"], ["last", "கடைசி"],
            ["next", "அடுத்த"], ["every", "ஒவ்வொரு"], ["each", "ஒவ்வொன்றும்"], ["other", "மற்ற"], ["another", "மற்றொரு"],
            ["same", "அதே"], ["different", "வேறுபட்ட"], ["such", "அத்தகைய"], ["own", "சொந்த"],
            
            // Additional common words
            ["i", "நான்"], ["you", "நீங்கள்"], ["he", "அவன்"], ["she", "அவள்"], ["it", "அது"],
            ["we", "நாம்"], ["they", "அவர்கள்"], ["me", "என்னை"], ["him", "அவனை"], ["her", "அவளை"],
            ["us", "எங்களை"], ["them", "அவர்களை"], ["my", "என்"], ["your", "உங்கள்"], ["his", "அவனுடைய"],
            ["her", "அவளுடைய"], ["its", "அதன்"], ["our", "எங்கள்"], ["their", "அவர்களுடைய"],
            ["mine", "என்னுடையது"], ["yours", "உங்களுடையது"], ["ours", "எங்களுடையது"], ["theirs", "அவர்களுடையது"],
            ["am", "இருக்கிறேன்"], ["is", "இருக்கிறது"], ["are", "இருக்கிறார்கள்"], ["was", "இருந்தது"],
            ["were", "இருந்தனர்"], ["be", "இரு"], ["being", "இருப்பது"], ["been", "இருந்திருக்கிறது"],
            ["have", "கொண்டுள்ளேன்"], ["has", "கொண்டுள்ளது"], ["had", "கொண்டிருந்தது"], ["having", "கொண்டிருப்பது"],
            ["do", "செய்"], ["does", "செய்கிறது"], ["did", "செய்தது"], ["doing", "செய்வது"],
            ["will", "செய்வார்"], ["would", "செய்வார்"], ["shall", "செய்வேன்"], ["should", "செய்ய வேண்டும்"],
            ["can", "முடியும்"], ["could", "முடியும்"], ["may", "இருக்கலாம்"], ["might", "இருக்கலாம்"],
            ["must", "வேண்டும்"], ["ought", "வேண்டும்"], ["need", "தேவை"], ["dare", "துணிகிறேன்"],
            ["a", "ஒரு"], ["an", "ஒரு"], ["the", "அந்த"], ["some", "சில"], ["any", "எந்த"],
            ["this", "இந்த"], ["that", "அந்த"], ["these", "இந்த"], ["those", "அந்த"],
            ["such", "அத்தகைய"], ["what", "என்ன"], ["which", "எது"], ["who", "யார்"],
            ["whom", "யாரை"], ["whose", "யாருடைய"], ["where", "எங்கே"], ["when", "எப்போது"],
            ["why", "ஏன்"], ["how", "எப்படி"], ["whether", "என்று"], ["if", "என்றால்"],
            ["that", "அது"], ["because", "ஏனெனில்"], ["when", "எப்போது"], ["while", "அதே சமயம்"],
            ["where", "எங்கே"], ["whereas", "ஆனால்"], ["if", "என்றால்"], ["unless", "தவிர"],
            ["until", "வரை"], ["till", "வரை"], ["than", "விட"], ["as", "போல"],
            ["whether", "என்று"], ["either", "இரண்டில் ஒன்று"], ["neither", "இரண்டும் இல்லை"],
            ["both", "இரண்டும்"], ["not", "இல்லை"], ["only", "மட்டும்"], ["but", "ஆனால்"],
            ["however", "இருப்பினும்"], ["moreover", "மேலும்"], ["besides", "அதைத் தவிர"],
            ["though", "என்றாலும்"], ["although", "என்றாலும்"], ["yet", "இருப்பினும்"],
            ["still", "இன்னும்"], ["nevertheless", "இருப்பினும்"], ["nonetheless", "இருப்பினும்"],
            ["instead", "அதற்கு பதிலாக"], ["otherwise", "இல்லையேல்"], ["likewise", "அதுபோல"],
            ["similarly", "இதேபோல"], ["therefore", "எனவே"], ["hence", "எனவே"],
            ["thus", "எனவே"], ["consequently", "இதன் விளைவாக"], ["accordingly", "அதன்படி"],
            ["meanwhile", "அதே சமயம்"], ["furthermore", "மேலும்"], ["moreover", "மேலும்"],
            ["besides", "அதைத் தவிர"], ["additionally", "கூடுதலாக"], ["again", "மீண்டும்"],
            ["further", "மேலும்"], ["then", "பின்னர்"], ["now", "இப்போது"], ["soon", "விரைவில்"],
            ["later", "பின்னர்"], ["earlier", "முன்பு"], ["formerly", "முன்பு"], ["previously", "முன்பு"],
            ["finally", "இறுதியாக"], ["lastly", "இறுதியாக"], ["firstly", "முதலில்"], ["secondly", "இரண்டாவதாக"],
            ["next", "அடுத்து"], ["afterwards", "பின்னர்"], ["before", "முன்"], ["after", "பிறகு"],
            ["since", "முதல்"], ["until", "வரை"], ["till", "வரை"], ["while", "அதே சமயம்"],
            ["during", "போது"], ["before", "முன்"], ["after", "பிறகு"], ["as", "போல"],
            ["because", "ஏனெனில்"], ["since", "முதல்"], ["so", "ஆகையால்"], ["then", "பின்னர்"],
            ["therefore", "எனவே"], ["thus", "எனவே"], ["hence", "எனவே"], ["consequently", "இதன் விளைவாக"],
            ["accordingly", "அதன்படி"], ["otherwise", "இல்லையேல்"], ["nevertheless", "இருப்பினும்"],
            ["nonetheless", "இருப்பினும்"], ["however", "இருப்பினும்"], ["moreover", "மேலும்"],
            ["besides", "அதைத் தவிர"], ["additionally", "கூடுதலாக"], ["furthermore", "மேலும்"],
            ["likewise", "அதுபோல"], ["similarly", "இதேபோல"], ["instead", "அதற்கு பதிலாக"],
            ["again", "மீண்டும்"], ["further", "மேலும்"], ["then", "பின்னர்"], ["now", "இப்போது"],
            ["soon", "விரைவில்"], ["later", "பின்னர்"], ["earlier", "முன்பு"], ["formerly", "முன்பு"],
            ["previously", "முன்பு"], ["finally", "இறுதியாக"], ["lastly", "இறுதியாக"], ["firstly", "முதலில்"],
            ["secondly", "இரண்டாவதாக"], ["next", "அடுத்து"], ["afterwards", "பின்னர்"], ["before", "முன்"],
            ["after", "பிறகு"], ["since", "முதல்"], ["until", "வரை"], ["till", "வரை"], ["while", "அதே சமயம்"],
            ["during", "போது"], ["before", "முன்"], ["after", "பிறகு"], ["as", "போல"],
            ["because", "ஏனெனில்"], ["since", "முதல்"], ["so", "ஆகையால்"], ["then", "பின்னர்"]
        ]);
        
        const phrase = match[1].trim().toLowerCase();
        const language = match[2].trim().toLowerCase();
        
        // Check if the language is Tamil
        if (language !== "tamil" && language !== "ta") {
            return "Sorry, I only support translation to Tamil at the moment.";
        }
        
        // First, try to match the entire phrase
        if (tamilCombined.has(phrase)) {
            return tamilCombined.get(phrase);
        }
        
        // Split the phrase into words
        const words = phrase.split(/\s+/);
        let translatedText = "";
        
        // Try to translate word by word
        for (const word of words) {
            // Remove punctuation from the word
            const cleanWord = word.replace(/[.,!?;:()]/g, '');
            const punctuation = word.replace(cleanWord, '');
            
            if (tamilCombined.has(cleanWord)) {
                translatedText += tamilCombined.get(cleanWord) + punctuation + " ";
            } else {
                // Try to find the word with different case
                const capitalizedWord = cleanWord.charAt(0).toUpperCase() + cleanWord.slice(1);
                if (tamilCombined.has(capitalizedWord)) {
                    translatedText += tamilCombined.get(capitalizedWord) + punctuation + " ";
                } else {
                    // Fallback: Translate character by character
                    let translatedWord = "";
                    for (let i = 0; i < cleanWord.length; i++) {
                        const char = cleanWord[i].toLowerCase();
                        translatedWord += tamilCombined.get(char) || char;
                    }
                    translatedText += translatedWord + punctuation + " ";
                }
            }
        }
        
        return translatedText.trim();
    }
},
{ pattern: /reverse (.+)/i, response: (match) => match[1].split('').reverse().join('') },{ pattern: /count words (.+)/i, response: (match) => `Number of words: ${match[1].split(/\s+/).length}` },{ pattern: /uppercase (.+)/i, response: (match) => match[1].toUpperCase() },{ pattern: /lowercase (.+)/i, response: (match) => match[1].toLowerCase() },{ pattern: /reverse words (.+)/i, response: (match) => match[1].split(' ').map(word => word.split('').reverse().join('')).join(' ') },{ pattern: /count vowels (.+)/i, response: (match) => `Number of vowels: ${match[1].replace(/[^aeiouAEIOU]/g, "").length}` },{ pattern: /replace (.+) with (.+)/i, response: (match) => match[1].replace(new RegExp(match[1], 'gi'), match[2]) },

{ 
    pattern: /solve quadratic equation ([\d.-]+)x\^2 \+ ([\d.-]+)x \+ ([\d.-]+)/i, 
    response: (match) => {
        const a = parseFloat(match[1]);
        const b = parseFloat(match[2]);
        const c = parseFloat(match[3]);
        const discriminant = b * b - 4 * a * c;

        if (discriminant > 0) {
            const root1 = (-b + Math.sqrt(discriminant)) / (2 * a);
            const root2 = (-b - Math.sqrt(discriminant)) / (2 * a);
            return `The roots are ${root1.toFixed(2)} and ${root2.toFixed(2)}`;
        } else if (discriminant === 0) {
            const root = -b / (2 * a);
            return `The root is ${root.toFixed(2)}`;
        } else {
            return "The equation has no real roots.";
        }
    }
},{ 
    pattern: /repeat (.+) (\d+) times/i, 
    response: (match) => {
        const message = match[1];  
        const times = parseInt(match[2]);  

        if (times <= 0) return "Please enter a valid repeat count.";

        return Array(times).fill(message).join("\n");
    }
},{ 
    pattern: /split (.+)/i, 
    response: (match) => {
        const message = match[1];  
        return `Split Message: ` + message.split("").join(" ");
    }
},{ 
    pattern: /style (.+)/i, 
    response: (match) => {
        const text = match[1].toUpperCase(); // Convert input to uppercase for styling

        const fancyFonts = {
            'A': '𝐀', 'B': '𝐁', 'C': '𝐂', 'D': '𝐃', 'E': '𝐄', 'F': '𝐅', 'G': '𝐆', 
            'H': '𝐇', 'I': '𝐈', 'J': '𝐉', 'K': '𝐊', 'L': '𝐋', 'M': '𝐌', 'N': '𝐍', 
            'O': '𝐎', 'P': '𝐏', 'Q': '𝐐', 'R': '𝐑', 'S': '𝐒', 'T': '𝐓', 'U': '𝐔', 
            'V': '𝐕', 'W': '𝐖', 'X': '𝐗', 'Y': '𝐘', 'Z': '𝐙'
        };

        let styledText = text.split('').map(char => fancyFonts[char] || char).join('');
        
        return `Styled Text: ${styledText}`;
    }
},{
    pattern: /style2 (.+)/i, 
    response: (match) => {
        const text = match[1].toUpperCase(); // Convert input to uppercase
        // Different font styles
        const fontStyles = {
            bold: { 'A': '𝐀', 'B': '𝐁', 'C': '𝐂', 'D': '𝐃', 'E': '𝐄', 'F': '𝐅', 'G': '𝐆', 
                    'H': '𝐇', 'I': '𝐈', 'J': '𝐉', 'K': '𝐊', 'L': '𝐋', 'M': '𝐌', 'N': '𝐍', 
                    'O': '𝐎', 'P': '𝐏', 'Q': '𝐐', 'R': '𝐑', 'S': '𝐒', 'T': '𝐓', 'U': '𝐔', 
                    'V': '𝐕', 'W': '𝐖', 'X': '𝐗', 'Y': '𝐘', 'Z': '𝐙' },
            italic: { 'A': '𝘈', 'B': '𝘉', 'C': '𝘊', 'D': '𝘋', 'E': '𝘌', 'F': '𝘍', 'G': '𝘎',
                      'H': '𝘏', 'I': '𝘐', 'J': '𝘑', 'K': '𝘒', 'L': '𝘓', 'M': '𝘔', 'N': '𝘕',
                      'O': '𝘖', 'P': '𝘗', 'Q': '𝘘', 'R': '𝘙', 'S': '𝘚', 'T': '𝘛', 'U': '𝘜',
                      'V': '𝘝', 'W': '𝘞', 'X': '𝘟', 'Y': '𝘠', 'Z': '𝘡' },
            script: { 'A': '𝒜', 'B': 'ℬ', 'C': '𝒞', 'D': '𝒟', 'E': 'ℰ', 'F': 'ℱ', 'G': '𝒢',
                      'H': 'ℋ', 'I': 'ℐ', 'J': '𝒥', 'K': '𝒦', 'L': 'ℒ', 'M': 'ℳ', 'N': '𝒩',
                      'O': '𝒪', 'P': '𝒫', 'Q': '𝒬', 'R': 'ℛ', 'S': '𝒮', 'T': '𝒯', 'U': '𝒰',
                      'V': '𝒱', 'W': '𝒲', 'X': '𝒳', 'Y': '𝒴', 'Z': '𝒵' },
            monospace: { 'A': '𝙰', 'B': '𝙱', 'C': '𝙲', 'D': '𝙳', 'E': '𝙴', 'F': '𝙵', 'G': '𝙶',
                         'H': '𝙷', 'I': '𝙸', 'J': '𝙹', 'K': '𝙺', 'L': '𝙻', 'M': '𝙼', 'N': '𝙽',
                         'O': '𝙾', 'P': '𝙿', 'Q': '𝚀', 'R': '𝚁', 'S': '𝚂', 'T': '𝚃', 'U': '𝚄',
                         'V': '𝚅', 'W': '𝚆', 'X': '𝚇', 'Y': '𝚈', 'Z': '𝚉' },
            sansserif: { 'A': '𝖠', 'B': '𝖡', 'C': '𝖢', 'D': '𝖣', 'E': '𝖤', 'F': '𝖥', 'G': '𝖦',
                         'H': '𝖧', 'I': '𝖨', 'J': '𝖩', 'K': '𝖪', 'L': '𝖫', 'M': '𝖬', 'N': '𝖭',
                         'O': '𝖮', 'P': '𝖯', 'Q': '𝖰', 'R': '𝖱', 'S': '𝖲', 'T': '𝖳', 'U': '𝖴',
                         'V': '𝖵', 'W': '𝖶', 'X': '𝖷', 'Y': '𝖸', 'Z': '𝖹' },
            serif: { 'A': '𝐴', 'B': '𝐵', 'C': '𝐶', 'D': '𝐷', 'E': '𝐸', 'F': '𝐹', 'G': '𝐺',
                    'H': '𝐻', 'I': '𝐼', 'J': '𝐽', 'K': '𝐾', 'L': '𝐿', 'M': '𝑀', 'N': '𝑁',
                    'O': '𝑂', 'P': '𝑃', 'Q': '𝑄', 'R': '𝑅', 'S': '𝑆', 'T': '𝑇', 'U': '𝑈',
                    'V': '𝑉', 'W': '𝑊', 'X': '𝑋', 'Y': '𝑌', 'Z': '𝑍' },
            doublestruck: { 'A': '𝔸', 'B': '𝔹', 'C': 'ℂ', 'D': '𝔻', 'E': '𝔼', 'F': '𝔽', 'G': '𝔾',
                             'H': 'ℍ', 'I': '𝕀', 'J': '𝕁', 'K': '𝕂', 'L': '𝕃', 'M': '𝕄', 'N': 'ℕ',
                             'O': '𝕆', 'P': 'ℙ', 'Q': 'ℚ', 'R': 'ℝ', 'S': '𝕊', 'T': '𝕋', 'U': '𝕌',
                             'V': '𝕍', 'W': '𝕎', 'X': '𝕏', 'Y': '𝕐', 'Z': 'ℤ' },
            fraktur: { 'A': '𝔄', 'B': '𝔅', 'C': 'ℭ', 'D': '𝔇', 'E': '𝔈', 'F': '𝔉', 'G': '𝔊',
                       'H': 'ℌ', 'I': 'ℑ', 'J': '𝔍', 'K': '𝔎', 'L': '𝔏', 'M': '𝔐', 'N': '𝔑',
                       'O': '𝔒', 'P': '𝔓', 'Q': '𝔔', 'R': 'ℜ', 'S': '𝔖', 'T': '𝔗', 'U': '𝔘',
                       'V': '𝔙', 'W': '𝔚', 'X': '𝔛', 'Y': '𝔜', 'Z': 'ℨ' },
            blackboard: { 'A': '𝔸', 'B': '𝔹', 'C': 'ℂ', 'D': '𝔻', 'E': '𝔼', 'F': '𝔽', 'G': '𝔾',
                          'H': 'ℍ', 'I': '𝕀', 'J': '𝕁', 'K': '𝕂', 'L': '𝕃', 'M': '𝕄', 'N': 'ℕ',
                          'O': '𝕆', 'P': 'ℙ', 'Q': 'ℚ', 'R': 'ℝ', 'S': '𝕊', 'T': '𝕋', 'U': '𝕌',
                          'V': '𝕍', 'W': '𝕎', 'X': '𝕏', 'Y': '𝕐', 'Z': 'ℤ' },
            circled: { 'A': 'Ⓐ', 'B': 'Ⓑ', 'C': 'Ⓒ', 'D': 'Ⓓ', 'E': 'Ⓔ', 'F': 'Ⓕ', 'G': 'Ⓖ',
                       'H': 'Ⓗ', 'I': 'Ⓘ', 'J': 'Ⓚ', 'K': 'Ⓚ', 'L': 'Ⓛ', 'M': 'Ⓜ', 'N': 'Ⓝ',
                       'O': 'Ⓞ', 'P': 'Ⓟ', 'Q': 'Ⓠ', 'R': 'Ⓡ', 'S': 'Ⓢ', 'T': 'Ⓣ', 'U': 'Ⓤ',
                       'V': 'Ⓥ', 'W': 'Ⓦ', 'X': 'Ⓧ', 'Y': 'Ⓨ', 'Z': 'Ⓩ' },
            negativecircled: { 'A': '🅐', 'B': '🅑', 'C': '🅒', 'D': '🅓', 'E': '🅔', 'F': '🅕', 'G': '🅖',
                                'H': '🅗', 'I': '🅘', 'J': '🅙', 'K': '🅚', 'L': '🅛', 'M': '🅜', 'N': '🅝',
                                'O': '🅞', 'P': '🅟', 'Q': '🅠', 'R': '🅡', 'S': '🅢', 'T': '🅣', 'U': '🅤',
                                'V': '🅥', 'W': '🅦', 'X': '🅧', 'Y': '🅨', 'Z': '🅩' },
            squared: { 'A': '🄰', 'B': '🄱', 'C': '🄲', 'D': '🄳', 'E': '🄴', 'F': '🄵', 'G': '🄶',
                       'H': '🄷', 'I': '🄸', 'J': '🄹', 'K': '🄺', 'L': '🄻', 'M': '🄼', 'N': '🄽',
                       'O': '🄾', 'P': '🄿', 'Q': '🅀', 'R': '🅁', 'S': '🅂', 'T': '🅃', 'U': '🅄',
                       'V': '🅅', 'W': '🅆', 'X': '🅇', 'Y': '🅈', 'Z': '🅉' },
            negativesquared: { 'A': '🅰', 'B': '🅱', 'C': '🅲', 'D': '🅳', 'E': '🅴', 'F': '🅵', 'G': '🅶',
                                'H': '🅷', 'I': '🅸', 'J': '🅹', 'K': '🅺', 'L': '🅻', 'M': '🅼', 'N': '🅽',
                                'O': '🅾', 'P': '🅿', 'Q': '🆀', 'R': '🆁', 'S': '🆂', 'T': '🆃', 'U': '🆄',
                                'V': '🆅', 'W': '🆆', 'X': '🆇', 'Y': '🆈', 'Z': '🆉' }
        };
        // Convert text to each font style
        const convertToStyle = (style) => 
            text.split('').map(char => fontStyles[style][char] || char).join('');
        
        // Display all font styles
        return `Styled Texts:\n` +
               `🔹 **Bold:** ${convertToStyle('bold')}\n` +
               `🔹 *Italic:* ${convertToStyle('italic')}\n` +
               `🔹 ✨ Script: ${convertToStyle('script')}\n` +
               `🔹 ⌨️ Monospace: ${convertToStyle('monospace')}\n` +
               `🔹 𝖠 Sans-serif: ${convertToStyle('sansserif')}\n` +
               `🔹 𝐴 Serif: ${convertToStyle('serif')}\n` +
               `🔹 𝔸 Double-struck: ${convertToStyle('doublestruck')}\n` +
               `🔹 𝔄 Fraktur: ${convertToStyle('fraktur')}\n` +
               `🔹 𝔸 Blackboard: ${convertToStyle('blackboard')}\n` +
               `🔹 Ⓐ Circled: ${convertToStyle('circled')}\n` +
               `🔹 🅐 Negative Circled: ${convertToStyle('negativecircled')}\n` +
               `🔹 🄰 Squared: ${convertToStyle('squared')}\n` +
               `🔹 🅰 Negative Squared: ${convertToStyle('negativesquared')}`;
    }
},
{
    pattern: /help me fix this code:\s*```([\s\S]*?)```/i,
    response: (match) => {
        const code = match[1];
        
        // Common syntax errors and their fixes
        const commonErrors = [
            {
                pattern: /for\s*\(\s*let\s+\w+\s*=\s*0\s*;\s*\w+\s*<\s*\w+\s*length\s*;\s*\w+\+\+\s*\)/g,
                fix: "for (let i = 0; i < array.length; i++)",
                description: "Standard for loop syntax for iterating through an array"
            },
            {
                pattern: /console\.log\s*\(\s*['"](.+)['"]\s*\+\s*(.+)\s*\)/g,
                fix: "console.log(`$1${$2}`)",
                description: "Use template literals instead of string concatenation"
            },
            {
                pattern: /document\.getElementById\s*\(\s*['"](.+)['"]\s*\)\.value/g,
                fix: "document.getElementById('$1').value",
                description: "Correct syntax for getting an element's value"
            },
            {
                pattern: /if\s*\(\s*(.+)\s*=\s*(.+)\s*\)/g,
                fix: "if ($1 === $2)",
                description: "Use strict equality (===) instead of assignment (=) in conditions"
            },
            {
                pattern: /function\s*\(\s*\)\s*\{/g,
                fix: "function() {",
                description: "Correct function declaration syntax"
            }
        ];
        
        let issuesFound = [];
        let fixedCode = code;
        
        // Check for common errors
        for (const error of commonErrors) {
            if (error.pattern.test(code)) {
                issuesFound.push(error.description);
                fixedCode = fixedCode.replace(error.pattern, error.fix);
            }
        }
        
        // Check for unmatched brackets, braces, or parentheses
        const brackets = {
            '(': 0,
            '[': 0,
            '{': 0
        };
        
        const closingBrackets = {
            ')': '(',
            ']': '[',
            '}': '{'
        };
        
        for (let i = 0; i < code.length; i++) {
            const char = code[i];
            
            if (brackets.hasOwnProperty(char)) {
                brackets[char]++;
            } else if (closingBrackets.hasOwnProperty(char)) {
                brackets[closingBrackets[char]]--;
            }
        }
        
        for (const [bracket, count] of Object.entries(brackets)) {
            if (count !== 0) {
                const closingBracket = Object.keys(closingBrackets).find(key => closingBrackets[key] === bracket);
                issuesFound.push(`Unmatched ${bracket}${count > 0 ? ' - missing ' + count + ' ' + closingBracket : ' - too many ' + closingBracket}`);
            }
        }
        
        // Check for missing semicolons
        const linesWithoutSemicolons = code.split('\n').filter((line, index) => {
            const trimmed = line.trim();
            return trimmed.length > 0 && 
                   !trimmed.endsWith(';') && 
                   !trimmed.endsWith('{') && 
                   !trimmed.endsWith('}') && 
                   !trimmed.startsWith('//') && 
                   !trimmed.startsWith('if') && 
                   !trimmed.startsWith('for') && 
                   !trimmed.startsWith('while') && 
                   !trimmed.includes('function');
        });
        
        if (linesWithoutSemicolons.length > 0) {
            issuesFound.push("Possible missing semicolons");
        }
        
        // Generate response
        let response = "I've analyzed your code and found the following issues:\n\n";
        
        if (issuesFound.length === 0) {
            response += "No obvious syntax errors detected. However, there might be logical errors that would require running the code to identify.\n";
        } else {
            response += issuesFound.map((issue, index) => `${index + 1}. ${issue}`).join('\n');
            response += "\n\nHere's your code with suggested fixes:\n\n```javascript\n" + fixedCode + "\n```";
        }
        
        response += "\n\nIf you're still having issues, please provide more context about what the code is supposed to do and any error messages you're receiving.";
        
        return response;
    }
},

{
    pattern: /abc (.+)/i,
    response: (match) => {
        const text = match[1].toLowerCase();
        const abc = {
            "a": "b",
            "c": "d",
            "e": "f",
            "g": "h",
            "i": "j",
            "k": "l",
            "m": "n",
            "o": "p",
            "q": "r",
            "s": "t",
            "y": "v",
            "w": "x",
            "y": "z",
            
            "b": "a",
            "d": "c",
            "f": "e",
            "h": "g",
            "j": "i",
            "l": "k",
            "n": "m",
            "p": "o",
            "r": "q",
            "t": "s",
            "v": "y",
            "x": "w",
            "z": "y"
        };
        const abcd = abc[text];
        return `${abcd}`;
    }
},
{
    pattern: /stats (.+)/i,
    response: (match) => {
        const player = match[1];
        return `Fetching stats for ${player}...`;
    }
},
{
    pattern: /item (.+)/i,
    response: (match) => {
        const item = match[1].toLowerCase();
        const items = {
            "sword": "⚔️ A sharp blade for close combat.",
            "shield": "🛡️ Blocks enemy attacks.",
            "potion": "🧪 Restores 50 HP.",
            "bow": "🏹 Long-range weapon with arrows."
        };
        return items[item] || "❌ Item not found!";
    }
},
{
    pattern: /cheat (.+)/i,
    response: (match) => {
        const cheat = match[1].toLowerCase();
        const cheats = {
            "godmode": "🛡️ God Mode activated! You are now invincible.",
            "noclip": "🚀 No-Clip enabled! You can walk through walls.",
            "speed": "⚡ Speed Boost activated! Run 2x faster.",
            "ammo": "🔫 Unlimited Ammo granted!"
        };
        return cheats[cheat] || "❌ Invalid cheat code!";
    }
},
{
    pattern: /enemy near/i,
    response: () => {
        return "🔍 Scanning... Enemy detected at 50m!";
    }
},
{
    pattern: /switch to (.+)/i,
    response: (match) => {
        const weapon = match[1].toLowerCase();
        return `🔄 Switched to ${weapon}! Ready for battle.`;
    }
},
{
    pattern: /leaderboard/i,
    response: () => {
        return "🏆 Top Players:\n1. ShadowKiller - 5000 points\n2. NoobSlayer - 4800 points\n3. ProGamerX - 4500 points";
    }
},
{
    pattern: /health/i,
    response: () => {
        return "❤️ Your health is at 80/100 HP.";
    }
},
{
    pattern: /server status/i,
    response: () => {
        return "🟢 Game server is ONLINE! No issues detected.";
    }
},
{
    pattern: /start snake game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start snakegame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startsnake game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startsnakegame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/SnakeGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},



{
    pattern: /start Bong game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start Bonggame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startBong game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startBonggame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},



{
    pattern: /start Car game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start Cargame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startCar game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startCargame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},



{
    pattern: /start Jump game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /start Jumpgame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startJump game/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},
{
    pattern: /startJumpgame/i,
    response: () => {
        const gameLink = "https://vipteammod.site/BongGame.html"; // Replace with actual game URL
        setTimeout(() => { window.open(gameLink, "_blank"); }, 1000);
        return "⏳ Wait ... Game Running.. (Opening Game...)";
    }
},

{
    pattern: /give abcd letter (\d+)/i,
    response: (match) => {
        const alphabet = "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z".split(",");
        let count = parseInt(match[1]);

        if (count > 26) count = 26; // Limit to max 26 letters
        if (count < 1) return "❌ Please enter a number between 1 and 26.";

        return alphabet.slice(0, count).join(", ");
    }
},
{
    pattern: /what is the meaning of (.+)/i,
    response: (match) => {
        const term = match[1];
        // Fetch or generate the definition for 'term'
        return `The meaning of ${term} is...`;
    }
},
{
    pattern: /how do I (.+)/i,
    response: (match) => {
        const task = match[1];
        // Provide steps or guidance on 'task'
        return `To ${task}, you can follow these steps...`;
    }
},
{
    pattern: /what are the symptoms of (.+)/i,
    response: (match) => {
        const condition = match[1];
        // Provide information about symptoms of 'condition'
        return `The symptoms of ${condition} include...`;
    }
},
{
    pattern: /translate (.+) into (.+)/i,
    response: (match) => {
        const phrase = match[1].toLowerCase().trim();
        const language = match[2].toLowerCase().trim();
        
        // Expanded translation database
        const translations = {
            "good morning": { 
                "spanish": "buenos días", 
                "french": "bonjour", 
                "german": "guten Morgen",
                "italian": "buongiorno",
                "portuguese": "bom dia",
                "japanese": "おはようございます (ohayō gozaimasu)",
                "chinese": "早上好 (zǎo shàng hǎo)",
                "russian": "доброе утро (dobroye utro)"
            },
            "hello": { 
                "spanish": "hola", 
                "french": "bonjour", 
                "german": "hallo",
                "italian": "ciao",
                "portuguese": "olá",
                "japanese": "こんにちは (konnichiwa)",
                "chinese": "你好 (nǐ hǎo)",
                "russian": "привет (privet)"
            },
            "thank you": { 
                "spanish": "gracias", 
                "french": "merci", 
                "german": "danke",
                "italian": "grazie",
                "portuguese": "obrigado",
                "japanese": "ありがとう (arigatō)",
                "chinese": "谢谢 (xiè xiè)",
                "russian": "спасибо (spasibo)"
            },
            "goodbye": { 
                "spanish": "adiós", 
                "french": "au revoir", 
                "german": "auf Wiedersehen",
                "italian": "arrivederci",
                "portuguese": "tchau",
                "japanese": "さようなら (sayōnara)",
                "chinese": "再见 (zài jiàn)",
                "russian": "до свидания (do svidaniya)"
            },
            "please": { 
                "spanish": "por favor", 
                "french": "s'il vous plaît", 
                "german": "bitte",
                "italian": "per favore",
                "portuguese": "por favor",
                "japanese": "お願いします (onegaishimasu)",
                "chinese": "请 (qǐng)",
                "russian": "пожалуйста (pozhaluysta)"
            }
        };
        
        // Language name normalization
        const languageAliases = {
            "spanish": ["spanish", "español", "es"],
            "french": ["french", "français", "fr"],
            "german": ["german", "deutsch", "de"],
            "italian": ["italian", "italiano", "it"],
            "portuguese": ["portuguese", "português", "pt"],
            "japanese": ["japanese", "日本語", "ja"],
            "chinese": ["chinese", "中文", "zh"],
            "russian": ["russian", "русский", "ru"]
        };
        
        // Find the canonical language name
        let canonicalLanguage = null;
        for (const [lang, aliases] of Object.entries(languageAliases)) {
            if (aliases.includes(language)) {
                canonicalLanguage = lang;
                break;
            }
        }
        
        // Check if we have the translation
        if (translations[phrase] && canonicalLanguage && translations[phrase][canonicalLanguage]) {
            const translation = translations[phrase][canonicalLanguage];
            
            // Provide additional context for some languages
            let context = "";
            if (["japanese", "chinese", "russian"].includes(canonicalLanguage)) {
                context = ` (Note: This includes romanization for pronunciation)`;
            }
            
            return `The translation of '${phrase}' into ${canonicalLanguage} is '${translation}'.${context}`;
        } else if (!canonicalLanguage) {
            // Language not supported
            const supportedLanguages = Object.keys(languageAliases).join(", ");
            return `Sorry, I don't support translations into '${language}'. Supported languages are: ${supportedLanguages}.`;
        } else if (!translations[phrase]) {
            // Phrase not found, try to find similar phrases
            const similarPhrases = Object.keys(translations).filter(key => 
                key.includes(phrase) || phrase.includes(key)
            );
            
            if (similarPhrases.length > 0) {
                return `I don't have a translation for '${phrase}'. Did you mean one of these: ${similarPhrases.join(", ")}?`;
            } else {
                return `Sorry, I don't have a translation for '${phrase}' in ${canonicalLanguage}.`;
            }
        } else {
            return `Sorry, I don't have a translation for '${phrase}' in ${canonicalLanguage}.`;
        }
    }
},
{
    pattern: /tell me a joke/i,
    response: () => {
        // Provide a random joke
        return "Why don't scientists trust atoms? Because they make up everything!";
    }
},
{
    pattern: /tell me about the (.+)/i,
    response: (match) => {
        const topic = match[1];
        // Provide information about 'topic'
        return `Here's some information about the ${topic}...`;
    }
},
{
    pattern: /how do I (.+) in (.+)/i,
    response: (match) => {
        const task = match[1];
        const language = match[2];
        // Provide coding assistance for 'task' in 'language'
        return `To ${task} in ${language}, you can...`;
    }
},

{
    pattern: /can you give me advice on (.+)/i,
    response: (match) => {
        const topic = match[1];
        // Provide advice on 'topic'
        return `Here is some advice on ${topic}...`;
    }
},

    { pattern: /what is ([\d.]+) \+ ([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+) - ([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+) \* ([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /what is ([\d.]+) \/ ([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    { pattern: /what is ([\d.]+)% of ([\d.]+)/i, response: (match) => `${match[1]}% of ${match[2]} = ${(parseFloat(match[1]) / 100 * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /square root of ([\d.]+)/i, response: (match) => `√${match[1]} = ${Math.sqrt(parseFloat(match[1])).toFixed(2)}` },
    { pattern: /power of ([\d.]+) to ([\d.]+)/i, response: (match) => `${match[1]}^${match[2]} = ${Math.pow(parseFloat(match[1]), parseFloat(match[2])).toFixed(2)}` },
    { pattern: /log of ([\d.]+)/i, response: (match) => `log(${match[1]}) = ${Math.log10(parseFloat(match[1])).toFixed(2)}` },
    { pattern: /sin\(([\d.]+)\)/i, response: (match) => `sin(${match[1]}) = ${Math.sin((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
    { pattern: /cos\(([\d.]+)\)/i, response: (match) => `cos(${match[1]}) = ${Math.cos((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
    { pattern: /tan\(([\d.]+)\)/i, response: (match) => `tan(${match[1]}) = ${Math.tan((parseFloat(match[1]) * Math.PI) / 180).toFixed(2)}` },
      { pattern: /what is ([\d.]+)\+([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+)-([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /what is ([\d.]+)\*([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /what is ([\d.]+)\/([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
      { pattern: /([\d.]+)\+([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /([\d.]+)-([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /([\d.]+)\*([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /([\d.]+)\/([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
      { pattern: /([\d.]+) \+ ([\d.]+)/i, response: (match) => `${match[1]} + ${match[2]} = ${parseFloat(match[1]) + parseFloat(match[2])}` },
    { pattern: /([\d.]+) - ([\d.]+)/i, response: (match) => `${match[1]} - ${match[2]} = ${parseFloat(match[1]) - parseFloat(match[2])}` },
    { pattern: /([\d.]+) \* ([\d.]+)/i, response: (match) => `${match[1]} × ${match[2]} = ${(parseFloat(match[1]) * parseFloat(match[2])).toFixed(2)}` },
    { pattern: /([\d.]+) \/ ([\d.]+)/i, response: (match) => parseFloat(match[2]) !== 0 ? `${match[1]} ÷ ${match[2]} = ${(parseFloat(match[1]) / parseFloat(match[2])).toFixed(2)}` : "I can't divide by zero!" },
    
{
    pattern: /unlock image to text/i,
    response: "Unlocking Image to Text feature... Please upload your image."
}, 

// Sentiment Analysis Pattern
{
    pattern: /(.+)/i,
    response: (match) => {
        const message = match[1].toLowerCase();
        
        // Sentiment word database
        const sentimentData = {
            happy: {
                keywords: ["happy", "joy", "excited", "glad", "cheerful", "delighted", "pleased", "content", "jubilant", "elated"],
                responses: [
                    "I'm glad you're feeling happy! 😊",
                    "Your happiness is contagious! What's making you feel this way?",
                    "Wonderful to hear you're in good spirits! How can I help you today?",
                    "It's great that you're feeling positive! Anything special happening?",
                    "Your joyful energy is amazing! What can I assist you with?"
                ]
            },
            sad: {
                keywords: ["sad", "unhappy", "depressed", "down", "miserable", "gloomy", "heartbroken", "melancholy", "blue", "dejected"],
                responses: [
                    "I'm sorry you're feeling sad. Is there anything I can do to help? 🙁",
                    "I understand things might be tough right now. Would you like to talk about it?",
                    "I'm here for you. Sometimes sharing what's bothering you can help.",
                    "It's okay to feel sad sometimes. Would you like a distraction or some encouragement?",
                    "I'm sorry you're feeling this way. Remember that tough times don't last forever."
                ]
            },
            angry: {
                keywords: ["angry", "mad", "furious", "irritated", "annoyed", "frustrated", "rage", "livid", "irate", "outraged"],
                responses: [
                    "I sense you're feeling angry. Take a deep breath. Would you like to talk about what's bothering you? 😠",
                    "It sounds like something has upset you. Would you like to share what happened?",
                    "Anger is a natural emotion. Would you like help finding ways to manage it?",
                    "I'm here to listen. What's causing these feelings of anger?",
                    "It's okay to feel angry. Would you like some suggestions to help you calm down?"
                ]
            },
            anxious: {
                keywords: ["anxious", "worried", "nervous", "stressed", "tense", "uneasy", "apprehensive", "concerned", "troubled", "panicked"],
                responses: [
                    "I can sense you're feeling anxious. Take a deep breath. Would you like to talk about what's worrying you? 🧘",
                    "It sounds like you might be feeling stressed. Remember to take things one step at a time.",
                    "Anxiety can be challenging. Would you like some relaxation techniques or a distraction?",
                    "I'm here to help. Would you like to break down what's making you feel this way?",
                    "Try to focus on the present moment. Would you like some guidance on managing these feelings?"
                ]
            },
            confused: {
                keywords: ["confused", "unclear", "don't understand", "puzzled", "lost", "unsure", "baffled", "perplexed", "bewildered"],
                responses: [
                    "I sense some confusion. Let me try to explain things more clearly. 🤔",
                    "Don't worry, confusion is normal when learning new things. What specifically is unclear?",
                    "I'm here to help clarify things. What part would you like me to explain better?",
                    "It's okay to feel confused sometimes. Let's figure this out together.",
                    "Let me try to approach this differently to help you understand better."
                ]
            },
            tired: {
                keywords: ["tired", "exhausted", "fatigued", "sleepy", "drained", "worn out", "weary", "drowsy", "lethargic"],
                responses: [
                    "I can sense you might be feeling tired. Remember to take care of yourself and get some rest. 😴",
                    "It sounds like you could use some relaxation. Have you been getting enough sleep?",
                    "Fatigue can make everything harder. Is there anything I can help you with to make things easier?",
                    "Rest is important. Would you like some tips for better sleep or more energy?",
                    "I hear you're feeling tired. Don't forget to take breaks and listen to your body."
                ]
            },
            excited: {
                keywords: ["excited", "thrilled", "eager", "enthusiastic", "pumped", "stoked", "ecstatic", "jazzed", "elated"],
                responses: [
                    "Your excitement is contagious! What's got you so thrilled? 🎉",
                    "I love your enthusiasm! What are you looking forward to?",
                    "That's wonderful to hear! What's making you so excited?",
                    "Your energy is amazing! What's happening that's got you so pumped?",
                    "It's great to feel excited about things! What's the source of your excitement?"
                ]
            }
        };
        
        // Analyze sentiment
        let detectedSentiment = null;
        let maxScore = 0;
        
        // Check each sentiment category
        for (const [sentiment, data] of Object.entries(sentimentData)) {
            let score = 0;
            for (const keyword of data.keywords) {
                if (message.includes(keyword)) {
                    score++;
                }
            }
            
            if (score > maxScore) {
                maxScore = score;
                detectedSentiment = sentiment;
            }
        }
        
        // If we detected a sentiment, return a random response for that sentiment
        if (detectedSentiment && maxScore > 0) {
            const responses = sentimentData[detectedSentiment].responses;
            return responses[Math.floor(Math.random() * responses.length)];
        }
        
        return "I'm here to help! How can I assist you today? Feel free to share what's on your mind.";
    }
},

// Default response pattern (should come after the sentiment pattern)
{
    pattern: /.*/,
    response: () => {
        const defaultResponses = [
            "I'm sorry, I didn't understand that. Try asking a Math Related question!",
            "I'm not sure what you mean. Could you rephrase that?",
            "I didn't quite get that. Can you say it differently?",
            "Hmm, I'm not sure how to respond to that. Try asking something else.",
            "I'm still learning! Could you try asking in a different way?",
            "That's beyond my current understanding. Try a simpler question.",
            "I'm not programmed to understand that yet. Try asking about math!",
            "I'm sorry, I didn't catch that. Could you try again?",
            "That doesn't compute for me. Try a math question instead!",
            "I'm not sure what you're asking. Can you clarify?",
            "I'm still developing my knowledge. Try a basic math question!",
            "I don't understand that request. Try asking about mathematics.",
            "That's not in my knowledge base yet. Try a math problem!",
            "I'm confused by that question. Try something simpler.",
            "I'm not equipped to answer that. Try a math-related question!",
            "That's not something I can help with right now. Try asking about math!",
            "I'm still learning new things. Try a basic math question!",
            "I don't have information about that. Try asking about mathematics!",
            "That's beyond my programming. Try a math question instead!",
            "i am Limited Data Ai Edition .So This Data Not Programmed .Any Help You Need To Say Help !"
        ];
        
        // Return a random response from the array
        return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
    }
},

{
    pattern: /.*/,
    response: () => {
        const defaultResponses = [
            "I'm sorry, I didn't understand that. Try asking a Math Related question!",
            "I'm not sure what you mean. Could you rephrase that?",
            "I didn't quite get that. Can you say it differently?",
            "Hmm, I'm not sure how to respond to that. Try asking something else.",
            "I'm still learning! Could you try asking in a different way?",
            "That's beyond my current understanding. Try a simpler question.",
            "I'm not programmed to understand that yet. Try asking about math!",
            "I'm sorry, I didn't catch that. Could you try again?",
            "That doesn't compute for me. Try a math question instead!",
            "I'm not sure what you're asking. Can you clarify?",
            "I'm still developing my knowledge. Try a basic math question!",
            "I don't understand that request. Try asking about mathematics.",
            "That's not in my knowledge base yet. Try a math problem!",
            "I'm confused by that question. Try something simpler.",
            "I'm not equipped to answer that. Try a math-related question!",
            "That's not something I can help with right now. Try asking about math!",
            "I'm still learning new things. Try a basic math question!",
            "I don't have information about that. Try asking about mathematics!",
            "That's beyond my programming. Try a math question instead!",
            "i am Limited Data Ai Edition .So This Data Not Programmed .Any Help You Need To Say Help !"
        ];
        
        // Return a random response from the array
        return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
    }
},
  
    
];


let chatHistory = []; // Stores chat messages with timestamps
let calculatorEnabled = false; // Switch ON/OFF calculator mode
let weatherEnabled = false; // Weather mode toggle
// News mode toggle
let newsEnabled = false;
let ipEnabled = false; // IP mode is OFF by default
// ===== Declare Variables at Top =====
let ipTrackerEnabled = false; // IP Tracker Mode OFF by default
let isLocked = false; // Flag to check if the process is locked
let htmlLoadEnabled = false;  // Flag to check if the HTML load mode is enabled

let wikipediaEnabled = false; // Wikipedia mode toggle

// Advanced Calculator Function to handle multiple operations and expressions
function advancedCalculator(expression) {
    try {
        // Remove extra spaces before calculating
        expression = expression.replace(/\s+/g, '');

        // Evaluate the expression using eval (ensure valid operations)
        const result = eval(expression); 

        return result;
    } catch (e) {
        return 'Error in expression';
    }
}


// Wikipedia API function using Fetch
async function getWikipediaSummary(topic) {
    const encodedTopic = encodeURIComponent(topic);
    const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodedTopic}`;

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.extract) {
            return `📖 *Wikipedia Summary:*\n${data.extract}`;
        } else {
            return `❌ No Wikipedia data found for '${topic}'.`;
        }
    } catch (error) {
        return "⚠️ Error fetching Wikipedia data. Please try again later.";
    }
}



// Weather API function using Open-Meteo (no API key needed)
async function getWeather(city) {
    try {
        // First, get latitude and longitude for the city using OpenStreetMap Nominatim
        const geoResponse = await fetch(`https://nominatim.openstreetmap.org/search?city=${encodeURIComponent(city)}&format=json`);
        const geoData = await geoResponse.json();

        if (geoData.length === 0) {
            return `Sorry, I couldn't find the location "${city}".`;
        }

        const latitude = geoData[0].lat;
        const longitude = geoData[0].lon;

        // Now, fetch weather using Open-Meteo API
        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`);
        const weatherData = await weatherResponse.json();

        if (weatherData.current_weather) {
            const temp = weatherData.current_weather.temperature;
            const windspeed = weatherData.current_weather.windspeed;
            const weathercode = weatherData.current_weather.weathercode;

            return `Weather in ${city}:\nTemperature: ${temp}°C\nWind Speed: ${windspeed} km/h\nWeather Code: ${weathercode}`;
        } else {
            return "Sorry, weather information is not available right now.";
        }
    } catch (error) {
        return "Error fetching weather data. Please try again.";
    }
}

async function getLatestNews(searchTerms) {
    const apiKey = 'fa78fd6e485b416cbb55681c48e6a080';
    const baseUrl = 'https://newsapi.org/v2/everything';

    let newsResults = '';

    for (const term of searchTerms) {
        const url = `${baseUrl}?q=${encodeURIComponent(term)}&apiKey=${apiKey}`;

        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.articles && data.articles.length > 0) {
                const topArticle = data.articles[0];
                newsResults += `📰 *News for "${term}":*\nTitle: ${topArticle.title}\nDescription: ${topArticle.description}\n🔗 [Read more](${topArticle.url})\n\n`;
            } else {
                newsResults += `❌ No news found for "${term}".\n\n`;
            }
        } catch (error) {
            newsResults += `⚠️ Error fetching news for "${term}".\n\n`;
        }
    }

    return newsResults.trim() || "❌ No news found for any search term.";
}

// Function to fetch details of any IP address
async function getIPDetails(ipAddress) {
    const url = `https://ipinfo.io/${ipAddress}/json?token=16d9d846db0eb5`; // Your token added here

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data && data.ip) {
            return `🌐 *IP Address:* ${data.ip}\n` +
                   `🏙️ *City:* ${data.city}\n` +
                   `🌍 *Region:* ${data.region}\n` +
                   `🌎 *Country:* ${data.country}\n` +
                   `🏢 *ISP/Org:* ${data.org}\n` +
                   `📍 *Location Coordinates:* ${data.loc}`;
        } else {
            return "❌ Could not fetch details for the given IP address.";
        }
    } catch (error) {
        return "⚠️ Error fetching IP details. Please try again.";
    }
}


function sendMessage() {
    const userInputRaw = document.getElementById("user-input").value.trim();
    if (userInputRaw === "") return;

    const chatBox = document.getElementById("chat-box");

    // Start time of chat
    if (chatHistory.length === 0) {
        chatHistory.push(`Chat Start: ${new Date().toLocaleString()}\n`);
    }

// Add user message
const userMessage = document.createElement("div");
userMessage.classList.add("user-message");  // Add class for styling
userMessage.textContent = "You: " + userInputRaw;    

chatBox.appendChild(userMessage);
chatBox.appendChild(document.createElement("br"));


    // Save user message
    chatHistory.push(`[${new Date().toLocaleTimeString()}] You: ${userInputRaw}`);



// Unlock and lock commands inside sendMessage
if (/unlock weather mode/i.test(userInputRaw) || /open weather/i.test(userInputRaw)) {
    weatherEnabled = true;
    botReply("Weather Mode is now UNLOCKED! Type a city name like 'weather in London' to get the current weather.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close weather mode/i.test(userInputRaw) || /lock weather/i.test(userInputRaw)) {
    weatherEnabled = false;
    botReply("Weather Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

// Handle weather requests
if (weatherEnabled) {
    const city = userInputRaw.replace(/weather in /i, "").trim();
    if (city) {
        getWeather(city).then((weatherInfo) => {
            botReply(weatherInfo);
        });
        document.getElementById("user-input").value = "";
        return; // <- ADD THIS RETURN to stop further reply
    } else {
        botReply("Please specify a city to get the weather.");
        document.getElementById("user-input").value = "";
        return; // <- also here
    }
}

// Inside your message handler:

if (/unlock News mode/i.test(userInputRaw)) {
    newsEnabled = true;
    botReply("News Mode is now UNLOCKED! Ask me 'Who is <name>' or type keywords to get a summary.");
    document.getElementById("user-input").value = "";
    return;
}
if (/close News mode/i.test(userInputRaw)) {
    newsEnabled = false;
            botReply(`${this.currentGame.name} loaded! ${this.currentGame.instructions}`);y("News Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

if (newsEnabled) {
    // Extract keywords from the user input
    let searchTerms = userInputRaw
        .replace(/news mode|who is|news/gi, '') // remove these words
        .split(/[,\s]+/) // split by space or comma
        .filter(term => term.trim() !== ''); // remove empty strings

    if (searchTerms.length === 0) {
        botReply("❗ Please provide a name or keyword to search for news.");
        document.getElementById("user-input").value = "";
    } else {
        getLatestNews(searchTerms).then(newsInfo => {
            botReply(newsInfo);
        });
        document.getElementById("user-input").value = "";
    }
    return; // Stop further normal reply
}

// Handle unlock/lock commands
if (/unlock wikipedia mode/i.test(userInputRaw) || /open wikipedia/i.test(userInputRaw)) {
    wikipediaEnabled = true;
    botReply("Wikipedia Mode is now UNLOCKED! Ask me 'Who is <name>' to get a summary.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close wikipedia mode/i.test(userInputRaw) || /lock wikipedia/i.test(userInputRaw)) {
    wikipediaEnabled = false;
    botReply("Wikipedia Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}



// Handle Wikipedia requests
if (wikipediaEnabled) {
    const match = userInputRaw.match(/who is (.+)/i); // Check if the query matches the pattern "who is <name>"
    if (match && match[1]) {
        const topic = match[1];

        // Call the getWikipediaSummary function
        getWikipediaSummary(topic).then((wikipediaInfo) => {
            botReply(wikipediaInfo); // Send the response back to the bot
        });
        document.getElementById("user-input").value = "";
        return; // Stop further reply after sending response
    } else {
        botReply("Please ask something like 'Who is Albert Einstein'.");
        document.getElementById("user-input").value = "";
        return; // Stop further reply here as well
    }
}
// Function to fetch your public IP address
async function getMyIP() {
    const url = 'https://api.ipify.org?format=json'; // Free public IP API

    try {
        const response = await fetch(url);
        const data = await response.json();

        if (data.ip) {
            return `🌐 Your Public IP Address is: *${data.ip}*`;
            document.getElementById("user-input").value = "";
        } else {
            return "❌ Could not fetch IP address.";
            document.getElementById("user-input").value = "";
        }
    } catch (error) {
        return "⚠️ Error fetching IP address. Please try again later.";
        document.getElementById("user-input").value = "";
    }
}
// Unlock IP Mode
if (/unlock ip mode/i.test(userInputRaw) || /open ip check/i.test(userInputRaw)) {
    ipEnabled = true;
    botReply("IP Check Mode is now UNLOCKED! Type anything to see your IP address.");
    return;
}

// Lock IP Mode
if (/close ip mode/i.test(userInputRaw) || /lock ip check/i.test(userInputRaw)) {
    ipEnabled = false;
    botReply("IP Check Mode is now LOCKED! Back to normal chatting.");
    return;
}

// Now handle IP Check if IP mode is enabled
if (ipEnabled) {
    getMyIP().then(ipInfo => {
        botReply(ipInfo);
    });
    return; // stop further reply
}
// ==== Toggle IP Tracker Mode =====
if (/unlock ip tracker mode/i.test(userInputRaw)) {
    ipTrackerEnabled = true;
    botReply("IP Tracker Mode is now UNLOCKED! Type any IP address to check details.");
    return;
}

if (/close ip tracker mode/i.test(userInputRaw)) {
    ipTrackerEnabled = false;
    botReply("IP Tracker Mode is now LOCKED! Back to normal chatting.");
    return;
}


// ==== Handle IP Address Input in Tracker Mode =====
if (ipTrackerEnabled) {
    // Try to detect IP Address Format
    const ipRegex = /(\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b)/;
    const match = userInputRaw.match(ipRegex);

    if (match) {
        const ipAddress = match[1];
        getIPDetails(ipAddress).then(ipInfo => {
            botReply(ipInfo);
        });
    } else {
        botReply("❗ Please enter a valid IP address like 8.8.8.8");
    }
    return; // Stop further reply
}

// Angry Emojis Reaction
if (/angry emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Angry Emojis! \n\n" +
      "1. 😠\n" +
      "2. 😡\n" +
      "3. 🤬\n" +
      "4. 😤\n" +
      "5. 🙄\n" +
      "6. 😾\n" +
      "7. 👿\n" +
      "8. 💢\n" +
      "9. 😒\n" +
      "10. 😣");
    return;
}

// Happy Emojis Reaction
if (/happy emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Happy Emojis! \n\n" +
      "1. 😀\n" +
      "2. 😃\n" +
      "3. 😄\n" +
      "4. 😁\n" +
      "5. 😆\n" +
      "6. 😊\n" +
      "7. 🤗\n" +
      "8. 😍\n" +
      "9. 🤩\n" +
      "10. 🥳");
    return;
}

// Love Emojis Reaction
if (/love emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Love Emojis! \n\n" +
      "1. ❤️\n" +
      "2. 💕\n" +
      "3. 💖\n" +
      "4. 💘\n" +
      "5. 💝\n" +
      "6. 💗\n" +
      "7. 💓\n" +
      "8. 💞\n" +
      "9. 😍\n" +
      "10. 😘");
    return;
}

// Comedy Emojis Reaction
if (/comedy emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Comedy Emojis! \n\n" +
      "1. 😂\n" +
      "2. 🤣\n" +
      "3. 😹\n" +
      "4. 😆\n" +
      "5. 😜\n" +
      "6. 🤪\n" +
      "7. 😝\n" +
      "8. 😛\n" +
      "9. 🤭\n" +
      "10. 😹");
    return;
}

// Sad Emojis Reaction
if (/sad emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Sad Emojis! \n\n" +
      "1. 😢\n" +
      "2. 😞\n" +
      "3. 😔\n" +
      "4. 😟\n" +
      "5. 😕\n" +
      "6. 🙁\n" +
      "7. 😣\n" +
      "8. 😖\n" +
      "9. 🥺\n" +
      "10. 😿");
    return;
}

// Crying Emojis Reaction
if (/crying emojis/i.test(userInputRaw)) {
    botReply("Here are 10 types of Crying Emojis! \n\n" +
      "1. 😭\n" +
      "2. 😢\n" +
      "3. 😿\n" +
      "4. 🥲\n" +
      "5. 😥\n" +
      "6. 😓\n" +
      "7. 🥺\n" +
      "8. 😔\n" +
      "9. 😖\n" +
      "10. 😩");
    return;
}

const badWords = [
    // English bad words (sex related + common)
    "fuck", "shit", "bitch", "asshole", "bastard", "dumb", "stupid", "idiot",
    "dick", "cock", "pussy", "penis", "vagina", "boobs", "nipple", "cum", "suck",
    "sex", "sexy", "horny", "porn", "pornhub", "milf", "slut", "whore", "fucker",
    "motherfucker", "cunt", "ass", "jerk", "jerking", "blowjob", "handjob", "orgasm",
    "moan", "bang", "rape", "nude", "nudes", "naked",

    // Hindi bad words (India)
    "chutiya", "bhosdike", "bhenchod", "madarchod", "gandu", "loda", "lund", "randi",
    "chut", "gaand", "chutmarani", "gaandfat", "chutiyapa",

    // Spanish bad words
    "puta", "mierda", "coño", "polla", "cabron", "pendejo", "puto", "culero",

    // Arabic bad words
    "sharmuta", "kos ommak", "ibn al kalb", "ibn sharmuta", "ayreh", "khara",

    // French bad words
    "pute", "merde", "salope", "connard", "enculé",

    // Portuguese bad words
    "porra", "caralho", "puta", "merda", "bosta",

    // Russian bad words
    "blyad", "suka", "pidor", "khuy", "ebat",

    // Extra offensive English
    "motherfucking", "assfucker", "cumshot", "cockslut", "fuckboy", "fuckgirl"
];


// Direct check without foundBadWord variable
if (badWords.some(badWord => new RegExp("\\b" + badWord + "\\b", "i").test(userInputRaw))) {
    botReply("Warning ⚠️ !");
    return;
}
let movieSelectionMode = true;

if (/i need movie/i.test(userInputRaw)) {
    botReply("🎬 Looking for a movie? Choose one of the following options:\n\n" +
        "1️⃣ [Isaimini](https://www.isaimini.int.in/)\n" +
        "2️⃣ [Kuttymovies](https://1kuttymovies.io/)\n" +
        "3️⃣ [MadrasRockers](https://www.1madrasrockers.love/)\n" +
        "4️⃣ [Tamil Yogi](https://1tamilyogi.app/tamilyogi-home/)\n" +
        "5️⃣ [Tamil Kolly](https://www.tamilkolly.info/)\n" +
        "6️⃣ [TamilPrint](https://www.tamilprintda.art/)\n\n" +
        "🎥 Please reply with a type Link 1 / Link 2 etc to open directly!");
    movieSelectionMode = true; // Enable movie selection
    return;
}

// Matching both Number (1-6) and "Link 1", "Link 2" etc
if (movieSelectionMode && (/^link\s?[1-6]$/i.test(userInputRaw.trim()))) {
    const movieLinks = [
        "https://www.isaimini.int.in/",
        "https://1kuttymovies.io/",
        "https://www.1madrasrockers.love/",
        "https://1tamilyogi.app/tamilyogi-home/",
        "https://www.tamilkolly.info/",
        "https://www.tamilprintda.art/"
    ];
    
    let input = userInputRaw.trim().toLowerCase();
    let index = -1;
    
    if (/^[1-6]$/.test(input)) {
        index = parseInt(input) - 1;
    } else if (/^link\s?[1-6]$/i.test(input)) {
        index = parseInt(input.replace("link", "").trim()) - 1;
    }
    
    if (index >= 0 && index < movieLinks.length) {
        botReply(`🎬 Redirecting you to the movie site...`);
        
        setTimeout(() => {
            window.location.href = movieLinks[index]; // Auto Redirect after 2 seconds
        }, 2000); // 2-second delay for better UX

        movieSelectionMode = false; // Turn OFF
    }
    
    return;
}



// Check special commands for calculator mode
if (/unlock advanced calculator|Advance Calculator|Advanced Calculator/i.test(userInputRaw) || /open calculator/i.test(userInputRaw)) {
    calculatorEnabled = true;
    botReply("Advanced Calculator Mode is now UNLOCKED! Type your mathematical expressions to calculate.");
    document.getElementById("user-input").value = "";
    return;
}

if (/close advanced calculator/i.test(userInputRaw) || /lock calculator/i.test(userInputRaw)) {
    calculatorEnabled = false;
    botReply("Advanced Calculator Mode is now LOCKED! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

if (/reset calculator/i.test(userInputRaw)) {
    calculatorEnabled = false;
    botReply("Calculator Mode has been RESET! Back to normal chatting.");
    document.getElementById("user-input").value = "";
    return;
}

    // Now handle based on mode
    if (calculatorEnabled) {
        const result = advancedCalculator(userInputRaw);
        botReply(`Result: ${result}`);
        document.getElementById("user-input").value = "";
    } else {
    document.getElementById("user-input").value = "";
        // Normal chatbot mode
        let reply = "Sorry, I don't understand that.";
        for (let pair of responses) {
            if (pair.pattern instanceof RegExp && pair.pattern.test(userInputRaw)) {
                reply = typeof pair.response === "function" ? pair.response(userInputRaw.match(pair.pattern)) : pair.response;
                break;
            }
        }
        botReply(reply);
    }

    // Clear input field
    document.getElementById("user-input").value = "";
    
        // Check if user wants to clear chat
    if (/clear all/i.test(userInputRaw)) {
        chatBox.innerHTML = "";
        chatHistory = []; // Reset chat history
        document.getElementById("user-input").value = "";        
        return;
    }

// Enhanced Photo Editor with Advanced Features
class PhotoEditor {
    constructor() {
        this.initializeEditor();
        this.setupDownloadSystem();
        this.setupEffectSelection();
    }
    initializeEditor() {
        // Create hidden file input
        this.fileInput = document.createElement('input');
        this.fileInput.type = 'file';
        this.fileInput.accept = 'image/*';
        this.fileInput.style.display = 'none';
        this.fileInput.id = 'photoEditorInput';
        document.body.appendChild(this.fileInput);
        
        // Add event listener
        this.fileInput.addEventListener('change', (e) => this.handleImageUpload(e));
    }
    setupDownloadSystem() {
        // Create download notification container
        this.downloadNotification = document.createElement('div');
        this.downloadNotification.className = 'download-notification';
        this.downloadNotification.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            max-width: 300px;
        `;
        document.body.appendChild(this.downloadNotification);
    }
    setupEffectSelection() {
        // Available effects
        this.availableEffects = [
            { id: 'none', name: 'No Effect', icon: '🖼️' },
            { id: 'crack', name: 'Crack Effect', icon: '🔨' },
            { id: 'vintage', name: 'Vintage', icon: '📜' },
            { id: 'grayscale', name: 'Grayscale', icon: '⚫' },
            { id: 'sepia', name: 'Sepia', icon: '🟤' },
            { id: 'blur', name: 'Blur', icon: '💧' },
            { id: 'sharpen', name: 'Sharpen', icon: '🔍' },
            { id: 'pixelate', name: 'Pixelate', icon: '🧩' },
            { id: 'glitch', name: 'Glitch', icon: '📺' },
            { id: 'neon', name: 'Neon', icon: '💡' },
            { id: 'brightness', name: 'Brightness', icon: '☀️' },
            { id: 'contrast', name: 'Contrast', icon: '🌗' },
            { id: 'saturation', name: 'Saturation', icon: '🎨' },
            { id: 'hue', name: 'Hue Shift', icon: '🌈' },
            { id: 'invert', name: 'Invert', icon: '🔄' },
            { id: 'edge', name: 'Edge Detect', icon: '📐' },
            { id: 'emboss', name: 'Emboss', icon: '🗿' },
            { id: 'oil', name: 'Oil Painting', icon: '🖌️' },
            { id: 'cartoon', name: 'Cartoon', icon: '🎭' },
            { id: 'mirror', name: 'Mirror', icon: '🪞' },
            { id: 'rotate', name: 'Rotate', icon: '🔄' },
            { id: 'crop', name: 'Crop', icon: '✂️' },
            { id: 'vignette', name: 'Vignette', icon: '🌑' },
            { id: 'noise', name: 'Add Noise', icon: '📶' },
            { id: 'posterize', name: 'Posterize', icon: '🎪' },
            { id: 'solarize', name: 'Solarize', icon: '☀️' },
            { id: 'ghibli', name: 'Ghibli Style', icon: '🌿' }
        ];
        
        this.selectedEffect = 'none';
    }
    // Trigger photo editing with effect selection
    triggerPhotoEdit(userInput) {
        // Check if user specified a specific effect
        const effectMatch = userInput.match(/edit photo\s+(\w+)/i);
        
        if (effectMatch) {
            const effectName = effectMatch[1].toLowerCase();
            const effect = this.availableEffects.find(e => e.id === effectName);
            
            if (effect) {
                this.selectedEffect = effect.id;
                botReply(`Selected: ${effect.name}. Please upload your photo.`);
                setTimeout(() => {
                    this.fileInput.click();
                }, 1000);
                return;
            } else {
                botReply(`Effect "${effectName}" not found. Available effects: ${this.availableEffects.map(e => e.name).join(', ')}`);
                return;
            }
        }
        
        // If no specific effect was mentioned, show selection UI
        this.showEffectSelection();
    }
    // Show effect selection interface
    showEffectSelection() {
        botReply("Choose an effect for your photo:");
        
        // Create effect selection container
        const effectContainer = document.createElement('div');
        effectContainer.className = 'effect-selection';
        effectContainer.style.cssText = `
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
            max-height: 400px;
            overflow-y: auto;
        `;
        
        // Create effect buttons
        this.availableEffects.forEach(effect => {
            const effectButton = document.createElement('button');
            effectButton.className = 'effect-button';
            effectButton.style.cssText = `
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 15px 10px;
                background: white;
                border: 2px solid #ddd;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 14px;
            `;
            
            effectButton.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 5px;">${effect.icon}</div>
                <div>${effect.name}</div>
            `;
            
            effectButton.addEventListener('click', () => {
                this.selectEffect(effect.id);
            });
            
            effectButton.addEventListener('mouseenter', () => {
                effectButton.style.transform = 'translateY(-5px)';
                effectButton.style.boxShadow = '0 5px 15px rgba(0,0,0,0.1)';
                effectButton.style.borderColor = '#4CAF50';
            });
            
            effectButton.addEventListener('mouseleave', () => {
                effectButton.style.transform = 'translateY(0)';
                effectButton.style.boxShadow = 'none';
                effectButton.style.borderColor = '#ddd';
            });
            
            effectContainer.appendChild(effectButton);
        });
        
        // Add to chat
        const messageContainer = document.createElement('div');
        messageContainer.appendChild(effectContainer);
        document.querySelector('.chat-messages').appendChild(messageContainer);
        
        // Scroll to bottom
        document.querySelector('.chat-container').scrollTop = document.querySelector('.chat-container').scrollHeight;
    }
    // Handle effect selection
    selectEffect(effectId) {
        this.selectedEffect = effectId;
        const effectName = this.availableEffects.find(e => e.id === effectId).name;
        
        botReply(`Selected: ${effectName}. Please upload your photo.`);
        
        // Remove effect selection UI
        const effectSelection = document.querySelector('.effect-selection');
        if (effectSelection) {
            effectSelection.remove();
        }
        
        // Trigger file picker
        setTimeout(() => {
            this.fileInput.click();
        }, 1000);
    }
    // Handle image upload
    handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (!file.type.match('image.*')) {
            botReply("Please select a valid image file.");
            return;
        }
        
        // Check file size (limit to 10MB)
        if (file.size > 10 * 1024 * 1024) {
            botReply("Image is too large. Please select an image under 10MB.");
            return;
        }
        
        botReply("Loading image for editing...");
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                this.processImage(img, file.name);
            };
            img.onerror = () => {
                botReply("Error loading image. Please try a different file.");
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }
    // Process image with selected effect
    processImage(img, originalFilename) {
        const effectName = this.availableEffects.find(e => e.id === this.selectedEffect).name;
        botReply(`Editing your image with ${effectName} effect...`);
        
        try {
            // Create canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // Apply base enhancements
            this.autoEnhance(canvas, ctx);
            
            // Apply selected effect
            this.applyEffect(canvas, ctx, this.selectedEffect);
            
            // Create edited filename
            const editedFilename = this.createEditedFilename(originalFilename, this.selectedEffect);
            
            // Automatically download the edited image
            this.downloadEditedImage(canvas, editedFilename);
            
            // Show download notification
            this.showDownloadNotification(editedFilename);
            
        } catch (error) {
            botReply("Error processing image. Please try again.");
            console.error("Processing Error:", error);
        }
    }
    // Apply selected effect
    applyEffect(canvas, ctx, effectId) {
        switch(effectId) {
            case 'crack':
                this.applyCrackEffect(canvas, ctx);
                break;
            case 'vintage':
                this.applyVintageEffect(canvas, ctx);
                break;
            case 'grayscale':
                this.applyGrayscaleEffect(canvas, ctx);
                break;
            case 'sepia':
                this.applySepiaEffect(canvas, ctx);
                break;
            case 'blur':
                this.applyBlurEffect(canvas, ctx);
                break;
            case 'sharpen':
                this.applySharpenEffect(canvas, ctx);
                break;
            case 'pixelate':
                this.applyPixelateEffect(canvas, ctx);
                break;
            case 'glitch':
                this.applyGlitchEffect(canvas, ctx);
                break;
            case 'neon':
                this.applyNeonEffect(canvas, ctx);
                break;
            case 'brightness':
                this.applyBrightnessEffect(canvas, ctx);
                break;
            case 'contrast':
                this.applyContrastEffect(canvas, ctx);
                break;
            case 'saturation':
                this.applySaturationEffect(canvas, ctx);
                break;
            case 'hue':
                this.applyHueEffect(canvas, ctx);
                break;
            case 'invert':
                this.applyInvertEffect(canvas, ctx);
                break;
            case 'edge':
                this.applyEdgeDetectionEffect(canvas, ctx);
                break;
            case 'emboss':
                this.applyEmbossEffect(canvas, ctx);
                break;
            case 'oil':
                this.applyOilPaintingEffect(canvas, ctx);
                break;
            case 'cartoon':
                this.applyCartoonEffect(canvas, ctx);
                break;
            case 'mirror':
                this.applyMirrorEffect(canvas, ctx);
                break;
            case 'rotate':
                this.applyRotateEffect(canvas, ctx);
                break;
            case 'crop':
                this.applyCropEffect(canvas, ctx);
                break;
            case 'vignette':
                this.applyVignetteEffect(canvas, ctx);
                break;
            case 'noise':
                this.applyNoiseEffect(canvas, ctx);
                break;
            case 'posterize':
                this.applyPosterizeEffect(canvas, ctx);
                break;
            case 'solarize':
                this.applySolarizeEffect(canvas, ctx);
                break;
            case 'ghibli':
                this.applyGhibliEffect(canvas, ctx);
                break;
            default:
                // No effect
                break;
        }
    }
    // Create edited filename with effect suffix
    createEditedFilename(originalFilename, effect) {
        // Extract filename without extension
        const nameParts = originalFilename.split('.');
        const name = nameParts.slice(0, -1).join('.');
        const extension = nameParts.length > 1 ? nameParts[nameParts.length - 1] : 'jpg';
        
        // Add effect suffix
        return `${name}_${effect}.${extension}`;
    }
    // Download edited image automatically
    downloadEditedImage(canvas, filename) {
        try {
            // Convert canvas to blob
            canvas.toBlob((blob) => {
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }, 'image/jpeg', 0.9);
            
        } catch (error) {
            console.error("Download Error:", error);
            // Fallback to manual download
            this.fallbackDownload(canvas, filename);
        }
    }
    // Fallback download method
    fallbackDownload(canvas, filename) {
        // Convert to data URL
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        
        // Create download link
        const downloadLink = document.createElement('a');
        downloadLink.href = dataUrl;
        downloadLink.download = filename;
        downloadLink.textContent = `Download ${filename}`;
        downloadLink.className = 'download-button';
        downloadLink.style.cssText = `
            display: inline-block;
            background: #2196F3;
            color: white;
            padding: 10px 15px;
            text-decoration: none;
            border-radius: 4px;
            margin-top: 10px;
        `;
        
        // Add to chat
        botReply("Your edited image is ready:");
        const messageContainer = document.createElement('div');
        messageContainer.appendChild(downloadLink);
        document.querySelector('.chat-messages').appendChild(messageContainer);
        
        // Scroll to bottom
        document.querySelector('.chat-container').scrollTop = document.querySelector('.chat-container').scrollHeight;
    }
    // Show download notification
    showDownloadNotification(filename) {
        this.downloadNotification.innerHTML = `
            <div style="display: flex; align-items: center;">
                <svg style="width:24px; height:24px; margin-right:10px;" fill="white" viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
                <div>
                    <div style="font-weight: bold;">Download Complete!</div>
                    <div style="font-size: 0.9em;">${filename}</div>
                </div>
            </div>
        `;
        
        this.downloadNotification.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            this.downloadNotification.style.display = 'none';
        }, 5000);
    }
    // Auto-enhancement function
    autoEnhance(canvas, ctx) {
        // Get image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply auto-levels
        this.autoAdjustLevels(data);
        
        // Put enhanced data back
        ctx.putImageData(imageData, 0, 0);
    }
    // Auto-levels adjustment
    autoAdjustLevels(data) {
        // Calculate histogram
        const histogram = { r: [], g: [], b: [] };
        
        // Initialize histogram arrays
        for (let i = 0; i < 256; i++) {
            histogram.r[i] = 0;
            histogram.g[i] = 0;
            histogram.b[i] = 0;
        }
        
        // Populate histogram
        for (let i = 0; i < data.length; i += 4) {
            histogram.r[data[i]]++;
            histogram.g[data[i + 1]]++;
            histogram.b[data[i + 2]]++;
        }
        
        // Find min and max for each channel
        const findMinMax = (hist) => {
            let min = 0;
            let max = 255;
            
            // Find min (ignore 1% of pixels)
            const totalPixels = data.length / 4;
            const ignoreCount = totalPixels * 0.01;
            let count = 0;
            
            for (let i = 0; i < 256; i++) {
                count += hist[i];
                if (count > ignoreCount) {
                    min = i;
                    break;
                }
            }
            
            // Find max (ignore 1% of pixels)
            count = 0;
            for (let i = 255; i >= 0; i--) {
                count += hist[i];
                if (count > ignoreCount) {
                    max = i;
                    break;
                }
            }
            
            return { min, max };
        };
        
        const rMinMax = findMinMax(histogram.r);
        const gMinMax = findMinMax(histogram.g);
        const bMinMax = findMinMax(histogram.b);
        
        // Apply levels adjustment
        for (let i = 0; i < data.length; i += 4) {
            // Red channel
            data[i] = this.adjustLevel(data[i], rMinMax.min, rMinMax.max);
            
            // Green channel
            data[i + 1] = this.adjustLevel(data[i + 1], gMinMax.min, gMinMax.max);
            
            // Blue channel
            data[i + 2] = this.adjustLevel(data[i + 2], bMinMax.min, bMinMax.max);
        }
    }
    // Adjust single color level
    adjustLevel(value, min, max) {
        if (min === max) return value;
        return Math.min(255, Math.max(0, (value - min) * 255 / (max - min)));
    }
    // Apply high-density star crack effect
applyCrackEffect(canvas, ctx) {
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // Create a temporary canvas for the original image
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    tempCtx.putImageData(imageData, 0, 0);
    
    // Determine the mirror axis (vertical or horizontal)
    const mirrorVertical = Math.random() > 0.5;
    
    // Create high-density star crack pattern on one half
    const starCenters = Math.floor(Math.random() * 15) + 10; // More star centers
    
    for (let s = 0; s < starCenters; s++) {
        // Star center point (only on one side of the mirror axis)
        let centerX, centerY;
        
        if (mirrorVertical) {
            // Left half only
            centerX = Math.floor(Math.random() * (canvas.width / 2));
            centerY = Math.floor(Math.random() * canvas.height);
        } else {
            // Top half only
            centerX = Math.floor(Math.random() * canvas.width);
            centerY = Math.floor(Math.random() * (canvas.height / 2));
        }
        
        // Number of rays for each star
        const rayCount = Math.floor(Math.random() * 8) + 5; // 5-12 rays per star
        
        for (let r = 0; r < rayCount; r++) {
            // Ray angle
            const angle = (r / rayCount) * Math.PI * 2;
            
            // Ray direction
            let dx = Math.cos(angle);
            let dy = Math.sin(angle);
            
            // Ray length
            const length = Math.floor(Math.random() * 120) + 60; // Longer rays
            
            // Draw ray
            let x = centerX;
            let y = centerY;
            
            // Store points for mirroring
            const rayPoints = [];
            
            for (let i = 0; i < length; i++) {
                // Add some randomness to direction for more natural look
                dx += (Math.random() - 0.5) * 0.3;
                dy += (Math.random() - 0.5) * 0.3;
                
                // Normalize direction
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                dx /= magnitude;
                dy /= magnitude;
                
                // Update position
                x += dx;
                y += dy;
                
                // Check bounds
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
                
                // Store point for mirroring
                rayPoints.push({x: Math.floor(x), y: Math.floor(y)});
                
                // Apply crack (darken pixel more for star effect)
                const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                
                // Darken more at the center, less at the edges
                const distanceFromCenter = i / length;
                const darknessFactor = 0.3 + (0.5 * (1 - distanceFromCenter));
                
                data[idx] *= darknessFactor;     // Red
                data[idx + 1] *= darknessFactor; // Green
                data[idx + 2] *= darknessFactor; // Blue
                
                // Add width to the crack (wider at the center)
                const maxWidth = 1 + Math.floor((1 - distanceFromCenter) * 4); // Wider at center
                for (let w = 1; w <= maxWidth; w++) {
                    // Perpendicular direction
                    const perpX = -dy;
                    const perpY = dx;
                    
                    // Points on both sides of the crack
                    const side1X = Math.floor(x + perpX * w);
                    const side1Y = Math.floor(y + perpY * w);
                    const side2X = Math.floor(x - perpX * w);
                    const side2Y = Math.floor(y - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                        data[side1Idx] *= sideDarkness;
                        data[side1Idx + 1] *= sideDarkness;
                        data[side1Idx + 2] *= sideDarkness;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                        data[side2Idx] *= sideDarkness;
                        data[side2Idx + 1] *= sideDarkness;
                        data[side2Idx + 2] *= sideDarkness;
                    }
                }
            }
            
            // Mirror the ray
            rayPoints.forEach(point => {
                let mirrorX, mirrorY;
                
                if (mirrorVertical) {
                    // Mirror horizontally
                    mirrorX = canvas.width - point.x - 1;
                    mirrorY = point.y;
                } else {
                    // Mirror vertically
                    mirrorX = point.x;
                    mirrorY = canvas.height - point.y - 1;
                }
                
                // Apply mirrored ray
                const mirrorIdx = (mirrorY * canvas.width + mirrorX) * 4;
                
                // Calculate distance from mirrored center
                let mirrorCenterX, mirrorCenterY;
                if (mirrorVertical) {
                    mirrorCenterX = canvas.width - centerX - 1;
                    mirrorCenterY = centerY;
                } else {
                    mirrorCenterX = centerX;
                    mirrorCenterY = canvas.height - centerY - 1;
                }
                
                const dx = point.x - centerX;
                const dy = point.y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = length;
                const distanceFromCenter = Math.min(1, distance / maxDistance);
                const darknessFactor = 0.3 + (0.5 * (1 - distanceFromCenter));
                
                data[mirrorIdx] *= darknessFactor;     // Red
                data[mirrorIdx + 1] *= darknessFactor; // Green
                data[mirrorIdx + 2] *= darknessFactor; // Blue
                
                // Add width to the mirrored ray
                const maxWidth = 1 + Math.floor((1 - distanceFromCenter) * 4);
                for (let w = 1; w <= maxWidth; w++) {
                    // Perpendicular direction (flipped for mirror)
                    const perpX = dy;
                    const perpY = dx;
                    
                    // Points on both sides of the mirrored ray
                    const side1X = Math.floor(mirrorX + perpX * w);
                    const side1Y = Math.floor(mirrorY + perpY * w);
                    const side2X = Math.floor(mirrorX - perpX * w);
                    const side2Y = Math.floor(mirrorY - perpY * w);
                    
                    // Apply crack to side points if within bounds
                    if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                        const side1Idx = (side1Y * canvas.width + side1X) * 4;
                        const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                        data[side1Idx] *= sideDarkness;
                        data[side1Idx + 1] *= sideDarkness;
                        data[side1Idx + 2] *= sideDarkness;
                    }
                    
                    if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                        const side2Idx = (side2Y * canvas.width + side2X) * 4;
                        const sideDarkness = darknessFactor + (0.2 * (1 - w / maxWidth));
                        data[side2Idx] *= sideDarkness;
                        data[side2Idx + 1] *= sideDarkness;
                        data[side2Idx + 2] *= sideDarkness;
                    }
                }
            });
        }
    }
    
    // Add many small connecting cracks between stars for more complexity
    const connectionCount = Math.floor(Math.random() * 20) + 15; // More connections
    
    for (let c = 0; c < connectionCount; c++) {
        // Random start point (on one side of the mirror axis)
        let startX, startY;
        
        if (mirrorVertical) {
            startX = Math.floor(Math.random() * (canvas.width / 2));
            startY = Math.floor(Math.random() * canvas.height);
        } else {
            startX = Math.floor(Math.random() * canvas.width);
            startY = Math.floor(Math.random() * (canvas.height / 2));
        }
        
        // Random end point (on the same side)
        let endX, endY;
        
        if (mirrorVertical) {
            endX = Math.floor(Math.random() * (canvas.width / 2));
            endY = Math.floor(Math.random() * canvas.height);
        } else {
            endX = Math.floor(Math.random() * canvas.width);
            endY = Math.floor(Math.random() * (canvas.height / 2));
        }
        
        // Calculate direction
        let dx = endX - startX;
        let dy = endY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dx /= distance;
        dy /= distance;
        
        // Draw connecting crack
        let x = startX;
        let y = startY;
        
        // Store points for mirroring
        const connectionPoints = [];
        
        const steps = Math.floor(distance);
        for (let i = 0; i < steps; i++) {
            // Add some randomness to direction
            dx += (Math.random() - 0.5) * 0.4;
            dy += (Math.random() - 0.5) * 0.4;
            
            // Normalize direction
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            dx /= magnitude;
            dy /= magnitude;
            
            // Update position
            x += dx;
            y += dy;
            
            // Check bounds
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
            
            // Store point for mirroring
            connectionPoints.push({x: Math.floor(x), y: Math.floor(y)});
            
            // Apply crack (less dark than star rays)
            const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
            data[idx] *= 0.8;     // Red
            data[idx + 1] *= 0.8; // Green
            data[idx + 2] *= 0.8; // Blue
            
            // Add width to the crack
            const crackWidth = 1;
            for (let w = 1; w <= crackWidth; w++) {
                // Perpendicular direction
                const perpX = -dy;
                const perpY = dx;
                
                // Points on both sides of the crack
                const side1X = Math.floor(x + perpX * w);
                const side1Y = Math.floor(y + perpY * w);
                const side2X = Math.floor(x - perpX * w);
                const side2Y = Math.floor(y - perpY * w);
                
                // Apply crack to side points if within bounds
                if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                    const side1Idx = (side1Y * canvas.width + side1X) * 4;
                    data[side1Idx] *= 0.85;
                    data[side1Idx + 1] *= 0.85;
                    data[side1Idx + 2] *= 0.85;
                }
                
                if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                    const side2Idx = (side2Y * canvas.width + side2X) * 4;
                    data[side2Idx] *= 0.85;
                    data[side2Idx + 1] *= 0.85;
                    data[side2Idx + 2] *= 0.85;
                }
            }
        }
        
        // Mirror the connection
        connectionPoints.forEach(point => {
            let mirrorX, mirrorY;
            
            if (mirrorVertical) {
                // Mirror horizontally
                mirrorX = canvas.width - point.x - 1;
                mirrorY = point.y;
            } else {
                // Mirror vertically
                mirrorX = point.x;
                mirrorY = canvas.height - point.y - 1;
            }
            
            // Apply mirrored connection
            const mirrorIdx = (mirrorY * canvas.width + mirrorX) * 4;
            data[mirrorIdx] *= 0.8;     // Red
            data[mirrorIdx + 1] *= 0.8; // Green
            data[mirrorIdx + 2] *= 0.8; // Blue
            
            // Add width to the mirrored connection
            const crackWidth = 1;
            for (let w = 1; w <= crackWidth; w++) {
                // Perpendicular direction (flipped for mirror)
                const perpX = dy;
                const perpY = dx;
                
                // Points on both sides of the mirrored crack
                const side1X = Math.floor(mirrorX + perpX * w);
                const side1Y = Math.floor(mirrorY + perpY * w);
                const side2X = Math.floor(mirrorX - perpX * w);
                const side2Y = Math.floor(mirrorY - perpY * w);
                
                // Apply crack to side points if within bounds
                if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                    const side1Idx = (side1Y * canvas.width + side1X) * 4;
                    data[side1Idx] *= 0.85;
                    data[side1Idx + 1] *= 0.85;
                    data[side1Idx + 2] *= 0.85;
                }
                
                if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                    const side2Idx = (side2Y * canvas.width + side2X) * 4;
                    data[side2Idx] *= 0.85;
                    data[side2Idx + 1] *= 0.85;
                    data[side2Idx + 2] *= 0.85;
                }
            }
        });
    }
    
    // Add dense cracks along the mirror axis
    const axisCrackCount = Math.floor(Math.random() * 8) + 5; // More axis cracks
    
    for (let c = 0; c < axisCrackCount; c++) {
        let x, y;
        
        if (mirrorVertical) {
            // Along the vertical center line
            x = Math.floor(canvas.width / 2) + Math.floor(Math.random() * 20) - 10;
            y = Math.floor(Math.random() * canvas.height);
        } else {
            // Along the horizontal center line
            x = Math.floor(Math.random() * canvas.width);
            y = Math.floor(canvas.height / 2) + Math.floor(Math.random() * 20) - 10;
        }
        
        // Direction (mostly along the axis)
        let dx, dy;
        
        if (mirrorVertical) {
            dx = (Math.random() - 0.5) * 0.5; // Less horizontal movement
            dy = (Math.random() - 0.5) * 2;   // More vertical movement
        } else {
            dx = (Math.random() - 0.5) * 2;   // More horizontal movement
            dy = (Math.random() - 0.5) * 0.5; // Less vertical movement
        }
        
        // Length
        const length = Math.floor(Math.random() * 100) + 50; // Longer axis cracks
        
        // Draw crack along the axis
        for (let i = 0; i < length; i++) {
            // Add some randomness to direction
            dx += (Math.random() - 0.5) * 0.3;
            dy += (Math.random() - 0.5) * 0.3;
            
            // Normalize direction
            const magnitude = Math.sqrt(dx * dx + dy * dy);
            dx /= magnitude;
            dy /= magnitude;
            
            // Update position
            x += dx;
            y += dy;
            
            // Check bounds
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) break;
            
            // Apply crack (darken pixel more along the axis)
            const idx = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
            data[idx] *= 0.4;     // Red
            data[idx + 1] *= 0.4; // Green
            data[idx + 2] *= 0.4; // Blue
            
            // Add width to the crack
            const crackWidth = 1 + Math.floor(Math.random() * 3);
            for (let w = 1; w <= crackWidth; w++) {
                // Perpendicular direction
                const perpX = -dy;
                const perpY = dx;
                
                // Points on both sides of the crack
                const side1X = Math.floor(x + perpX * w);
                const side1Y = Math.floor(y + perpY * w);
                const side2X = Math.floor(x - perpX * w);
                const side2Y = Math.floor(y - perpY * w);
                
                // Apply crack to side points if within bounds
                if (side1X >= 0 && side1X < canvas.width && side1Y >= 0 && side1Y < canvas.height) {
                    const side1Idx = (side1Y * canvas.width + side1X) * 4;
                    data[side1Idx] *= 0.6;
                    data[side1Idx + 1] *= 0.6;
                    data[side1Idx + 2] *= 0.6;
                }
                
                if (side2X >= 0 && side2X < canvas.width && side2Y >= 0 && side2Y < canvas.height) {
                    const side2Idx = (side2Y * canvas.width + side2X) * 4;
                    data[side2Idx] *= 0.6;
                    data[side2Idx + 1] *= 0.6;
                    data[side2Idx + 2] *= 0.6;
                }
            }
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
}
    // Apply vintage effect
    applyVintageEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            // Extract RGB
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Apply vintage effect (sepia + reduced contrast + vignette)
            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));     // Red
            data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // Green
            data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // Blue
            
            // Add some noise for vintage feel
            const noise = Math.random() * 10 - 5;
            data[i] = Math.min(255, Math.max(0, data[i] + noise));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Apply vignette
        this.applyVignetteEffect(canvas, ctx);
    }
    // Apply grayscale effect
    applyGrayscaleEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            // Calculate grayscale using luminance formula
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            
            data[i] = gray;     // Red
            data[i + 1] = gray; // Green
            data[i + 2] = gray; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply sepia effect
    applySepiaEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            // Extract RGB
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Apply sepia transformation
            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));     // Red
            data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // Green
            data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply blur effect
    applyBlurEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Apply blur filter
        tempCtx.filter = 'blur(5px)';
        tempCtx.drawImage(canvas, 0, 0);
        
        // Draw blurred image back to original canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(tempCanvas, 0, 0);
    }
    // Apply sharpen effect
    applySharpenEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Sharpen kernel
        const kernel = [
             0, -1,  0,
            -1,  5, -1,
             0, -1,  0
        ];
        
        // Apply convolution
        for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let r = 0, g = 0, b = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                        
                        r += temp[kidx] * weight;
                        g += temp[kidx + 1] * weight;
                        b += temp[kidx + 2] * weight;
                    }
                }
                
                data[idx] = Math.min(255, Math.max(0, r));
                data[idx + 1] = Math.min(255, Math.max(0, g));
                data[idx + 2] = Math.min(255, Math.max(0, b));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply pixelate effect
    applyPixelateEffect(canvas, ctx) {
        const pixelSize = 10;
        
        // Save original image
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw pixelated image
        for (let y = 0; y < canvas.height; y += pixelSize) {
            for (let x = 0; x < canvas.width; x += pixelSize) {
                // Get pixel color
                const pixelData = tempCtx.getImageData(x, y, 1, 1).data;
                
                // Draw pixel block
                ctx.fillStyle = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
                ctx.fillRect(x, y, pixelSize, pixelSize);
            }
        }
    }
    // Apply glitch effect
    applyGlitchEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create RGB channels
        const rChannel = new Uint8ClampedArray(data.length / 4);
        const gChannel = new Uint8ClampedArray(data.length / 4);
        const bChannel = new Uint8ClampedArray(data.length / 4);
        
        // Extract channels
        for (let i = 0, j = 0; i < data.length; i += 4, j++) {
            rChannel[j] = data[i];
            gChannel[j] = data[i + 1];
            bChannel[j] = data[i + 2];
        }
        
        // Apply glitch effect (shift channels)
        const glitchHeight = Math.floor(canvas.height / 5);
        const glitchY = Math.floor(Math.random() * (canvas.height - glitchHeight));
        
        // Shift red channel
        const shiftR = Math.floor(Math.random() * 20) - 10;
        for (let y = glitchY; y < glitchY + glitchHeight; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const srcIdx = y * canvas.width + x;
                const dstIdx = y * canvas.width + ((x + shiftR + canvas.width) % canvas.width);
                
                if (srcIdx < rChannel.length && dstIdx < rChannel.length) {
                    const temp = rChannel[srcIdx];
                    rChannel[srcIdx] = rChannel[dstIdx];
                    rChannel[dstIdx] = temp;
                }
            }
        }
        
        // Shift blue channel
        const shiftB = Math.floor(Math.random() * 20) - 10;
        for (let y = glitchY; y < glitchY + glitchHeight; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const srcIdx = y * canvas.width + x;
                const dstIdx = y * canvas.width + ((x + shiftB + canvas.width) % canvas.width);
                
                if (srcIdx < bChannel.length && dstIdx < bChannel.length) {
                    const temp = bChannel[srcIdx];
                    bChannel[srcIdx] = bChannel[dstIdx];
                    bChannel[dstIdx] = temp;
                }
            }
        }
        
        // Recombine channels
        for (let i = 0, j = 0; i < data.length; i += 4, j++) {
            data[i] = rChannel[j];
            data[i + 1] = gChannel[j];
            data[i + 2] = bChannel[j];
        }
        
        // Add some random noise
        for (let i = 0; i < data.length; i += 4) {
            if (Math.random() < 0.05) {
                data[i] = Math.random() * 255;     // Red
                data[i + 1] = Math.random() * 255; // Green
                data[i + 2] = Math.random() * 255; // Blue
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply neon effect
    applyNeonEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Convert to grayscale
        this.applyGrayscaleEffect(canvas, ctx);
        
        // Invert colors
        this.applyInvertEffect(canvas, ctx);
        
        // Apply blur
        this.applyBlurEffect(canvas, ctx);
        
        // Get the processed image data
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Apply color dodge blending with original
        const originalData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const original = originalData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            // Color dodge formula
            data[i] = original[i] === 255 ? 255 : Math.min(255, (data[i] * 255) / (255 - original[i]));
            data[i + 1] = original[i + 1] === 255 ? 255 : Math.min(255, (data[i + 1] * 255) / (255 - original[i + 1]));
            data[i + 2] = original[i + 2] === 255 ? 255 : Math.min(255, (data[i + 2] * 255) / (255 - original[i + 2]));
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply brightness effect
    applyBrightnessEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const brightness = 30; // Brightness adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, Math.max(0, data[i] + brightness));     // Red
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + brightness)); // Green
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + brightness)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply contrast effect
    applyContrastEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const contrast = 1.5; // Contrast adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            // Apply contrast formula
            data[i] = Math.min(255, Math.max(0, ((data[i] - 128) * contrast) + 128));     // Red
            data[i + 1] = Math.min(255, Math.max(0, ((data[i + 1] - 128) * contrast) + 128)); // Green
            data[i + 2] = Math.min(255, Math.max(0, ((data[i + 2] - 128) * contrast) + 128)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply saturation effect
    applySaturationEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const saturation = 1.5; // Saturation adjustment value
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Convert to HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Adjust saturation
            s = Math.min(1, Math.max(0, s * saturation));
            
            // Convert back to RGB
            let r2, g2, b2;
            
            if (s === 0) {
                r2 = g2 = b2 = l; // Achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
            }
            
            data[i] = r2 * 255;
            data[i + 1] = g2 * 255;
            data[i + 2] = b2 * 255;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply hue shift effect
    applyHueEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const hueShift = 30; // Hue shift in degrees
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i] / 255;
            const g = data[i + 1] / 255;
            const b = data[i + 2] / 255;
            
            // Convert to HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // Achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
            
            // Adjust hue
            h = (h + hueShift / 360) % 1;
            if (h < 0) h += 1;
            
            // Convert back to RGB
            let r2, g2, b2;
            
            if (s === 0) {
                r2 = g2 = b2 = l; // Achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r2 = hue2rgb(p, q, h + 1/3);
                g2 = hue2rgb(p, q, h);
                b2 = hue2rgb(p, q, h - 1/3);
            }
            
            data[i] = r2 * 255;
            data[i + 1] = g2 * 255;
            data[i + 2] = b2 * 255;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply invert effect
    applyInvertEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = 255 - data[i];         // Red
            data[i + 1] = 255 - data[i + 1]; // Green
            data[i + 2] = 255 - data[i + 2]; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply edge detection effect
    applyEdgeDetectionEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Sobel edge detection kernel
        const kernelX = [
            -1, 0, 1,
            -2, 0, 2,
            -1, 0, 1
        ];
        
        const kernelY = [
            -1, -2, -1,
             0,  0,  0,
             1,  2,  1
        ];
        
        // Apply convolution
        for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let pixelX = 0;
                let pixelY = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const gray = (temp[kidx] + temp[kidx + 1] + temp[kidx + 2]) / 3;
                        
                        pixelX += gray * kernelX[(ky + 1) * 3 + (kx + 1)];
                        pixelY += gray * kernelY[(ky + 1) * 3 + (kx + 1)];
                    }
                }
                
                const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                const edge = magnitude > 50 ? 255 : 0;
                
                data[idx] = edge;
                data[idx + 1] = edge;
                data[idx + 2] = edge;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply emboss effect
    applyEmbossEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        // Emboss kernel
        const kernel = [
            -2, -1, 0,
            -1, 1, 1,
             0, 1, 2
        ];
        
        // Apply convolution
        for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                let r = 0, g = 0, b = 0;
                
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const kidx = ((y + ky) * canvas.width + (x + kx)) * 4;
                        const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                        
                        r += temp[kidx] * weight;
                        g += temp[kidx + 1] * weight;
                        b += temp[kidx + 2] * weight;
                    }
                }
                
                // Add 128 to make it gray
                data[idx] = Math.min(255, Math.max(0, r + 128));
                data[idx + 1] = Math.min(255, Math.max(0, g + 128));
                data[idx + 2] = Math.min(255, Math.max(0, b + 128));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply oil painting effect
    applyOilPaintingEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const tempData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const temp = tempData.data;
        
        const radius = 4;
        const intensity = 20;
        
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const idx = (y * canvas.width + x) * 4;
                
                // Initialize intensity count
                const intensityCount = new Array(intensity + 1).fill(0);
                const avgR = new Array(intensity + 1).fill(0);
                const avgG = new Array(intensity + 1).fill(0);
                const avgB = new Array(intensity + 1).fill(0);
                
                // Sample pixels in the radius
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const ny = y + dy;
                        const nx = x + dx;
                        
                        if (ny >= 0 && ny < canvas.height && nx >= 0 && nx < canvas.width) {
                            const nidx = (ny * canvas.width + nx) * 4;
                            
                            // Calculate intensity
                            const currR = temp[nidx];
                            const currG = temp[nidx + 1];
                            const currB = temp[nidx + 2];
                            const currIntensity = Math.round((currR + currG + currB) / 3 * intensity / 255);
                            
                            // Update counts and averages
                            intensityCount[currIntensity]++;
                            avgR[currIntensity] += currR;
                            avgG[currIntensity] += currG;
                            avgB[currIntensity] += currB;
                        }
                    }
                }
                
                // Find max intensity
                let maxIndex = 0;
                let maxCount = 0;
                
                for (let i = 0; i <= intensity; i++) {
                    if (intensityCount[i] > maxCount) {
                        maxCount = intensityCount[i];
                        maxIndex = i;
                    }
                }
                
                // Set pixel color
                data[idx] = avgR[maxIndex] / maxCount;
                data[idx + 1] = avgG[maxIndex] / maxCount;
                data[idx + 2] = avgB[maxIndex] / maxCount;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply cartoon effect (fixed version)
    applyCartoonEffect(canvas, ctx) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Apply edge detection to get edges
        this.applyEdgeDetectionEffect(canvas, ctx);
        
        // Save edge data
        const edgeData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        // Restore original image
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(originalCanvas, 0, 0);
        
        // Apply posterization to original image
        this.applyPosterizeEffect(canvas, ctx);
        
        // Get posterized image data
        const posterizedData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const posterizedPixels = posterizedData.data;
        const edgePixels = edgeData.data;
        
        // Combine edges with posterized image
        for (let i = 0; i < posterizedPixels.length; i += 4) {
            // If edge pixel is white (edge detected), make it black
            if (edgePixels[i] > 200) { // Threshold for edge detection
                posterizedPixels[i] = 0;     // Red
                posterizedPixels[i + 1] = 0; // Green
                posterizedPixels[i + 2] = 0; // Blue
            }
            // Otherwise keep the posterized color
        }
        
        // Put the combined image back
        ctx.putImageData(posterizedData, 0, 0);
    }
    // Apply enhanced Ghibli-style effect with animation
    applyGhibliEffect(canvas, ctx) {
        // Save original image
        const originalCanvas = document.createElement('canvas');
        const originalCtx = originalCanvas.getContext('2d');
        originalCanvas.width = canvas.width;
        originalCanvas.height = canvas.height;
        originalCtx.drawImage(canvas, 0, 0);
        
        // Step 1: Apply watercolor-style softening
        this.applyWatercolorEffect(canvas, ctx);
        
        // Step 2: Apply Ghibli color palette
        this.applyGhibliColorPalette(canvas, ctx);
        
        // Step 3: Add soft lighting effect
        this.applyGhibliLighting(canvas, ctx);
        
        // Step 4: Add subtle hand-drawn texture
        this.addHandDrawnTexture(canvas, ctx);
        
        // Step 5: Apply atmospheric perspective
        this.applyAtmosphericPerspective(canvas, ctx);
        
        // Step 6: Add animated elements
        this.addAnimatedGhibliElements(canvas, ctx);
    }
    // Apply watercolor-style softening
    applyWatercolorEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a temporary canvas for processing
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // Apply very subtle blur to soften edges
        tempCtx.filter = 'blur(1px)';
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
        
        // Get the blurred image data
        const blurredData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        const blurredPixels = blurredData.data;
        
        // Blend original and blurred for watercolor effect
        for (let i = 0; i < data.length; i += 4) {
            // Blend 70% original with 30% blurred
            data[i] = data[i] * 0.7 + blurredPixels[i] * 0.3;
            data[i + 1] = data[i + 1] * 0.7 + blurredPixels[i + 1] * 0.3;
            data[i + 2] = data[i + 2] * 0.7 + blurredPixels[i + 2] * 0.3;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply authentic Ghibli color palette
    applyGhibliColorPalette(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Ghibli's signature colors: soft greens, blues, warm earth tones
        const ghibliPalette = [
            { r: 120, g: 170, b: 120 }, // Soft green
            { r: 100, g: 150, b: 200 }, // Sky blue
            { r: 220, g: 180, b: 140 }, // Warm beige
            { r: 180, g: 130, b: 100 }, // Earth brown
            { r: 150, g: 200, b: 180 }, // Mint green
            { r: 200, g: 160, b: 190 }, // Soft pink
            { r: 230, g: 210, b: 170 }, // Cream
            { r: 160, g: 190, b: 220 }  // Soft blue
        ];
        
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // Find closest color in Ghibli palette
            let minDistance = Infinity;
            let closestColor = ghibliPalette[0];
            
            for (const color of ghibliPalette) {
                const distance = Math.sqrt(
                    Math.pow(r - color.r, 2) +
                    Math.pow(g - color.g, 2) +
                    Math.pow(b - color.b, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }
            
            // Blend original color with closest Ghibli color (70% original, 30% Ghibli)
            data[i] = r * 0.7 + closestColor.r * 0.3;
            data[i + 1] = g * 0.7 + closestColor.g * 0.3;
            data[i + 2] = b * 0.7 + closestColor.b * 0.3;
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply Ghibli-style soft lighting
    applyGhibliLighting(canvas, ctx) {
        // Create a soft gradient overlay for lighting
        const gradientCanvas = document.createElement('canvas');
        const gradientCtx = gradientCanvas.getContext('2d');
        gradientCanvas.width = canvas.width;
        gradientCanvas.height = canvas.height;
        
        // Create radial gradient for soft lighting
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 3; // Light source from upper left
        const radius = Math.max(canvas.width, canvas.height) * 0.8;
        
        const gradient = gradientCtx.createRadialGradient(
            centerX, centerY, 0,
            centerX, centerY, radius
        );
        
        gradient.addColorStop(0, 'rgba(255, 255, 220, 0.4)'); // Warm light center
        gradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.2)'); // Mid-light
        gradient.addColorStop(1, 'rgba(200, 200, 180, 0)'); // Fade to transparent
        
        gradientCtx.fillStyle = gradient;
        gradientCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply lighting with soft-light blend mode
        ctx.globalCompositeOperation = 'soft-light';
        ctx.drawImage(gradientCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }
    // Add subtle hand-drawn texture
    addHandDrawnTexture(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create texture canvas
        const textureCanvas = document.createElement('canvas');
        const textureCtx = textureCanvas.getContext('2d');
        textureCanvas.width = canvas.width;
        textureCanvas.height = canvas.height;
        
        // Add subtle paper texture
        textureCtx.fillStyle = 'rgba(255, 255, 255, 0.03)';
        textureCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add very subtle pencil-like marks
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const length = 5 + Math.random() * 15;
            const angle = Math.random() * Math.PI * 2;
            
            textureCtx.beginPath();
            textureCtx.moveTo(x, y);
            textureCtx.lineTo(
                x + Math.cos(angle) * length,
                y + Math.sin(angle) * length
            );
            
            textureCtx.strokeStyle = `rgba(100, 100, 100, 0.02)`;
            textureCtx.lineWidth = 0.5;
            textureCtx.stroke();
        }
        
        // Apply texture with overlay blend mode
        ctx.globalCompositeOperation = 'overlay';
        ctx.drawImage(textureCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }
    // Apply atmospheric perspective effect
    applyAtmosphericPerspective(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Create a subtle blue haze for distant elements
        const hazeCanvas = document.createElement('canvas');
        const hazeCtx = hazeCanvas.getContext('2d');
        hazeCanvas.width = canvas.width;
        hazeCanvas.height = canvas.height;
        
        // Create vertical gradient for atmospheric perspective
        const gradient = hazeCtx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, 'rgba(180, 200, 220, 0.1)'); // Light blue at top
        gradient.addColorStop(1, 'rgba(200, 220, 240, 0)'); // Transparent at bottom
        
        hazeCtx.fillStyle = gradient;
        hazeCtx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Apply haze with screen blend mode
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(hazeCanvas, 0, 0);
        ctx.globalCompositeOperation = 'source-over';
    }
    // Add animated Ghibli-style elements
    addAnimatedGhibliElements(canvas, ctx) {
        // Create a new canvas for animated elements
        const animationCanvas = document.createElement('canvas');
        const animationCtx = animationCanvas.getContext('2d');
        animationCanvas.width = canvas.width;
        animationCanvas.height = canvas.height;
        
        // Function to draw animated elements
        const drawAnimation = (time) => {
            // Clear animation canvas
            animationCtx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);
            
            // Draw animated sparkles (like Totoro's dust particles)
            this.drawAnimatedSparkles(animationCtx, animationCanvas.width, animationCanvas.height, time);
            
            // Draw animated clouds
            this.drawAnimatedClouds(animationCtx, animationCanvas.width, animationCanvas.height, time);
            
            // Draw animated leaves or petals
            this.drawAnimatedLeaves(animationCtx, animationCanvas.width, animationCanvas.height, time);
            
            // Apply animation to main canvas
            ctx.globalCompositeOperation = 'screen';
            ctx.drawImage(animationCanvas, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            
            // Continue animation
            requestAnimationFrame(drawAnimation);
        };
        
        // Start animation
        requestAnimationFrame(drawAnimation);
    }
    // Draw animated sparkles
    drawAnimatedSparkles(ctx, width, height, time) {
        const sparkleCount = 20;
        const sparkleSize = 3;
        
        for (let i = 0; i < sparkleCount; i++) {
            // Create pseudo-random but consistent positions based on i
            const x = (Math.sin(i * 12.9898 + 78.233) * 43758.5453) % 1 * width;
            const y = (Math.sin(i * 78.233 + 12.9898) * 43758.5453) % 1 * height;
            
            // Animate opacity
            const opacity = 0.3 + 0.7 * Math.abs(Math.sin(time * 0.002 + i));
            
            // Draw sparkle
            ctx.beginPath();
            ctx.arc(x, y, sparkleSize, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 200, ${opacity})`;
            ctx.fill();
            
            // Draw sparkle rays
            ctx.beginPath();
            ctx.moveTo(x - sparkleSize * 2, y);
            ctx.lineTo(x + sparkleSize * 2, y);
            ctx.moveTo(x, y - sparkleSize * 2);
            ctx.lineTo(x, y + sparkleSize * 2);
            ctx.strokeStyle = `rgba(255, 255, 200, ${opacity * 0.7})`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }
    // Draw animated clouds
    drawAnimatedClouds(ctx, width, height, time) {
        const cloudCount = 3;
        
        for (let i = 0; i < cloudCount; i++) {
            // Base position
            const baseX = (width / (cloudCount + 1)) * (i + 1);
            const baseY = height * 0.2;
            
            // Animate position
            const x = baseX + Math.sin(time * 0.0005 + i) * 20;
            const y = baseY + Math.cos(time * 0.0003 + i) * 5;
            
            // Draw cloud
            ctx.beginPath();
            
            // Cloud is made of several overlapping circles
            const cloudWidth = 60;
            const cloudHeight = 30;
            
            ctx.arc(x, y, cloudHeight, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.25, y - cloudHeight * 0.25, cloudHeight * 0.8, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.5, y, cloudHeight * 0.9, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth * 0.75, y - cloudHeight * 0.15, cloudHeight * 0.7, 0, Math.PI * 2);
            ctx.arc(x + cloudWidth, y, cloudHeight * 0.8, 0, Math.PI * 2);
            
            // Semi-transparent white
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();
        }
    }
    // Draw animated leaves/petals
    drawAnimatedLeaves(ctx, width, height, time) {
        const leafCount = 8;
        
        for (let i = 0; i < leafCount; i++) {
            // Starting position (top of image)
            const startX = (width / (leafCount + 1)) * (i + 1);
            const startY = -20;
            
            // Calculate position based on time (falling motion)
            const fallProgress = ((time * 0.0001 + i * 0.2) % 1);
            const x = startX + Math.sin(fallProgress * Math.PI * 4) * 30;
            const y = startY + (height + 40) * fallProgress;
            
            // Rotation
            const rotation = fallProgress * Math.PI * 2;
            
            // Draw leaf
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.bezierCurveTo(5, -5, 5, 5, 0, 10);
            ctx.bezierCurveTo(-5, 5, -5, -5, 0, -10);
            
            // Green with some variation
            const greenValue = 150 + Math.sin(i) * 30;
            ctx.fillStyle = `rgba(100, ${greenValue}, 50, 0.6)`;
            ctx.fill();
            
            ctx.restore();
        }
    }
    // Apply mirror effect
    applyMirrorEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Flip horizontally
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(tempCanvas, -canvas.width, 0);
        ctx.restore();
    }
    // Apply rotate effect
    applyRotateEffect(canvas, ctx) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        tempCtx.drawImage(canvas, 0, 0);
        
        // Rotate 90 degrees clockwise
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(Math.PI / 2);
        ctx.drawImage(tempCanvas, -canvas.height / 2, -canvas.width / 2);
        ctx.restore();
    }
    // Apply crop effect (center crop to square)
    applyCropEffect(canvas, ctx) {
        const size = Math.min(canvas.width, canvas.height);
        const x = (canvas.width - size) / 2;
        const y = (canvas.height - size) / 2;
        
        // Get the cropped image data
        const imageData = ctx.getImageData(x, y, size, size);
        
        // Resize canvas
        canvas.width = size;
        canvas.height = size;
        
        // Put the cropped image data back
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply vignette effect
    applyVignetteEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
        
        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate vignette factor (1 at center, 0 at corners)
                const vignette = 1 - Math.pow(distance / maxDistance, 2) * 0.8;
                
                // Apply vignette
                const idx = (y * canvas.width + x) * 4;
                data[idx] *= vignette;
                data[idx + 1] *= vignette;
                data[idx + 2] *= vignette;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply noise effect
    applyNoiseEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const amount = 50; // Noise amount
        
        for (let i = 0; i < data.length; i += 4) {
            const noise = Math.random() * amount - amount / 2;
            
            data[i] = Math.min(255, Math.max(0, data[i] + noise));     // Red
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise)); // Green
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise)); // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply posterize effect
    applyPosterizeEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const levels = 4; // Number of color levels
        
        const step = 255 / (levels - 1);
        
        for (let i = 0; i < data.length; i += 4) {
            // Posterize each channel
            data[i] = Math.round(data[i] / step) * step;     // Red
            data[i + 1] = Math.round(data[i + 1] / step) * step; // Green
            data[i + 2] = Math.round(data[i + 2] / step) * step; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
    // Apply solarize effect
    applySolarizeEffect(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const threshold = 128; // Solarization threshold
        
        for (let i = 0; i < data.length; i += 4) {
            // Solarize each channel
            data[i] = data[i] < threshold ? data[i] : 255 - data[i];     // Red
            data[i + 1] = data[i + 1] < threshold ? data[i + 1] : 255 - data[i + 1]; // Green
            data[i + 2] = data[i + 2] < threshold ? data[i + 2] : 255 - data[i + 2]; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
    }
}


// Initialize photo editor
const photoEditor = new PhotoEditor();

// Trigger photo editing when user requests it
if (/edit photo/i.test(userInputRaw)) {
    photoEditor.triggerPhotoEdit(userInputRaw);
    return;
}
class CalculatorScreen {
    constructor() {
        this.calculator = {
            name: 'ADVANCED CALCULATOR',
            instructions: 'Perform basic and advanced calculations including GST, tax, square root, and more.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.display = null;
        this.expressionDisplay = null;
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.activeButton = null;
        this.memory = 0; // For memory functions
        this.gstRates = {
            gst1: 5,    // 5% GST
            gst2: 12,   // 12% GST
            gst3: 18,   // 18% GST
            gst4: 28    // 28% GST
        };
    }
    
    /**
     * Load the Calculator
     */
    loadCalculator() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.calculator.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create calculator
        this.createCalculator();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the calculator
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.calculator.name} loaded! ${this.calculator.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Calculator UI
     */
    createCalculator() {
        // Create calculator container
        const calculatorContainer = document.createElement('div');
        calculatorContainer.style.cssText = `
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 360px;
            max-width: 90vw;
        `;
        
        // Create display container
        const displayContainer = document.createElement('div');
        displayContainer.style.cssText = `
            background-color: #222;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: right;
            color: white;
            font-family: 'Courier New', monospace;
        `;
        
        // Create expression display (shows the operation)
        this.expressionDisplay = document.createElement('div');
        this.expressionDisplay.style.cssText = `
            font-size: 16px;
            color: #aaa;
            min-height: 20px;
            margin-bottom: 5px;
        `;
        this.expressionDisplay.textContent = '';
        
        // Create main display (shows current number)
        this.display = document.createElement('div');
        this.display.style.cssText = `
            font-size: 28px;
            font-weight: bold;
            min-height: 30px;
            word-wrap: break-word;
            word-break: break-all;
        `;
        this.display.textContent = this.currentValue;
        
        displayContainer.appendChild(this.expressionDisplay);
        displayContainer.appendChild(this.display);
        calculatorContainer.appendChild(displayContainer);
        
        // Create buttons grid
        const buttonsGrid = document.createElement('div');
        buttonsGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-gap: 8px;
        `;
        
        // Define buttons
        const buttons = [
            // Row 1
            { label: 'C', action: 'clear', className: 'btn-clear' },
            { label: '⌫', action: 'backspace', className: 'btn-backspace' },
            { label: '√', action: 'sqrt', className: 'btn-advanced' },
            { label: 'x²', action: 'square', className: 'btn-advanced' },
            { label: '÷', action: 'divide', className: 'btn-operator' },
            
            // Row 2
            { label: '7', action: 'number', className: 'btn-number' },
            { label: '8', action: 'number', className: 'btn-number' },
            { label: '9', action: 'number', className: 'btn-number' },
            { label: '%', action: 'percent', className: 'btn-advanced' },
            { label: '×', action: 'multiply', className: 'btn-operator' },
            
            // Row 3
            { label: '4', action: 'number', className: 'btn-number' },
            { label: '5', action: 'number', className: 'btn-number' },
            { label: '6', action: 'number', className: 'btn-number' },
            { label: '1/x', action: 'reciprocal', className: 'btn-advanced' },
            { label: '-', action: 'subtract', className: 'btn-operator' },
            
            // Row 4
            { label: '1', action: 'number', className: 'btn-number' },
            { label: '2', action: 'number', className: 'btn-number' },
            { label: '3', action: 'number', className: 'btn-number' },
            { label: 'Tax', action: 'tax', className: 'btn-advanced' },
            { label: '+', action: 'add', className: 'btn-operator' },
            
            // Row 5
            { label: '0', action: 'number', className: 'btn-number', colSpan: 2 },
            { label: '.', action: 'decimal', className: 'btn-number' },
            { label: '=', action: 'equals', className: 'btn-equals', rowSpan: 2 },
            
            // Row 6 (GST buttons)
            { label: 'GST1', action: 'gst1', className: 'btn-gst' },
            { label: 'GST2', action: 'gst2', className: 'btn-gst' },
            { label: 'GST3', action: 'gst3', className: 'btn-gst' },
            { label: 'GST4', action: 'gst4', className: 'btn-gst' },
        ];
        
        // Create buttons
        buttons.forEach(button => {
            const btn = document.createElement('button');
            btn.textContent = button.label;
            btn.className = button.className;
            btn.style.cssText = this.getButtonStyle(button);
            
            // Set grid row/column span if specified
            if (button.rowSpan) {
                btn.style.gridRow = `span ${button.rowSpan}`;
            }
            if (button.colSpan) {
                btn.style.gridColumn = `span ${button.colSpan}`;
            }
            
            // Add event listeners for better responsiveness
            this.addButtonEventListeners(btn, button.action, button.label);
            
            buttonsGrid.appendChild(btn);
        });
        
        calculatorContainer.appendChild(buttonsGrid);
        this.gameContainer.appendChild(calculatorContainer);
        
        // Add keyboard event listeners
        this.setupKeyboardEvents();
    }
    
    /**
     * Add event listeners to buttons for better responsiveness
     */
    addButtonEventListeners(button, action, label) {
        // Use both mousedown and touchstart for immediate response
        const handleInteraction = (e) => {
            e.preventDefault(); // Prevent default to avoid delays
            this.handleButtonClick(action, label);
            
            // Visual feedback
            this.activeButton = button;
            button.style.transform = 'scale(0.95)';
            button.style.opacity = '0.8';
        };
        
        const handleRelease = () => {
            if (this.activeButton === button) {
                button.style.transform = '';
                button.style.opacity = '';
                this.activeButton = null;
            }
        };
        
        // Mouse events
        button.addEventListener('mousedown', handleInteraction);
        button.addEventListener('mouseup', handleRelease);
        button.addEventListener('mouseleave', handleRelease);
        
        // Touch events
        button.addEventListener('touchstart', handleInteraction, { passive: false });
        button.addEventListener('touchend', handleRelease);
        button.addEventListener('touchcancel', handleRelease);
    }
    
    /**
     * Get button style based on button type
     */
    getButtonStyle(button) {
        const baseStyle = `
            padding: 18px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        `;
        
        switch (button.className) {
            case 'btn-clear':
            case 'btn-backspace':
                return baseStyle + `
                    background-color: #f44336;
                    color: white;
                `;
            case 'btn-operator':
                return baseStyle + `
                    background-color: #ff9800;
                    color: white;
                `;
            case 'btn-equals':
                return baseStyle + `
                    background-color: #4CAF50;
                    color: white;
                `;
            case 'btn-advanced':
                return baseStyle + `
                    background-color: #9c27b0;
                    color: white;
                `;
            case 'btn-gst':
                return baseStyle + `
                    background-color: #3f51b5;
                    color: white;
                `;
            case 'btn-number':
            default:
                return baseStyle + `
                    background-color: #555;
                    color: white;
                `;
        }
    }
    
    /**
     * Handle button click
     */
    handleButtonClick(action, label) {
        // Add a small delay to prevent double-taps from registering twice
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        this.buttonTimeout = setTimeout(() => {
            switch (action) {
                case 'number':
                    this.inputNumber(label);
                    break;
                case 'decimal':
                    this.inputDecimal();
                    break;
                case 'clear':
                    this.clear();
                    break;
                case 'backspace':
                    this.backspace();
                    break;
                case 'add':
                    this.setOperation('+');
                    break;
                case 'subtract':
                    this.setOperation('-');
                    break;
                case 'multiply':
                    this.setOperation('*');
                    break;
                case 'divide':
                    this.setOperation('/');
                    break;
                case 'equals':
                    this.calculate();
                    break;
                // Advanced functions
                case 'sqrt':
                    this.squareRoot();
                    break;
                case 'square':
                    this.square();
                    break;
                case 'percent':
                    this.percent();
                    break;
                case 'reciprocal':
                    this.reciprocal();
                    break;
                case 'tax':
                    this.applyTax();
                    break;
                // GST functions
                case 'gst1':
                    this.applyGST('gst1');
                    break;
                case 'gst2':
                    this.applyGST('gst2');
                    break;
                case 'gst3':
                    this.applyGST('gst3');
                    break;
                case 'gst4':
                    this.applyGST('gst4');
                    break;
            }
            this.buttonTimeout = null;
        }, 10);
    }
    
    /**
     * Input a number
     */
    inputNumber(num) {
        if (this.waitingForOperand) {
            this.currentValue = num;
            this.waitingForOperand = false;
        } else {
            this.currentValue = this.currentValue === '0' ? num : this.currentValue + num;
        }
        this.updateDisplay();
    }
    
    /**
     * Input a decimal point
     */
    inputDecimal() {
        if (this.waitingForOperand) {
            this.currentValue = '0.';
            this.waitingForOperand = false;
        } else if (this.currentValue.indexOf('.') === -1) {
            this.currentValue += '.';
        }
        this.updateDisplay();
    }
    
    /**
     * Clear the calculator
     */
    clear() {
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.updateDisplay();
        this.updateExpressionDisplay();
    }
    
    /**
     * Backspace - remove last digit
     */
    backspace() {
        if (this.currentValue.length > 1) {
            this.currentValue = this.currentValue.slice(0, -1);
        } else {
            this.currentValue = '0';
        }
        this.updateDisplay();
    }
    
    /**
     * Set the operation
     */
    setOperation(nextOperation) {
        const inputValue = parseFloat(this.currentValue);
        
        if (this.previousValue === '') {
            this.previousValue = inputValue;
        } else if (this.operation) {
            const currentValue = this.previousValue || 0;
            const newValue = this.performCalculation();
            
            this.currentValue = String(newValue);
            this.previousValue = newValue;
            this.updateDisplay();
        }
        
        this.waitingForOperand = true;
        this.operation = nextOperation;
        this.updateExpressionDisplay();
    }
    
    /**
     * Perform the calculation
     */
    calculate() {
        const inputValue = parseFloat(this.currentValue);
        
        if (this.previousValue !== '' && this.operation) {
            const newValue = this.performCalculation();
            this.currentValue = String(newValue);
            this.previousValue = '';
            this.operation = null;
            this.waitingForOperand = true;
            this.updateDisplay();
            this.updateExpressionDisplay();
        }
    }
    
    /**
     * Perform the actual calculation
     */
    performCalculation() {
        const prev = parseFloat(this.previousValue);
        const current = parseFloat(this.currentValue);
        
        switch (this.operation) {
            case '+':
                return prev + current;
            case '-':
                return prev - current;
            case '*':
                return prev * current;
            case '/':
                if (current === 0) {
                    this.showError('Error: Division by zero');
                    return 0;
                }
                return prev / current;
            default:
                return current;
        }
    }
    
    /**
     * Square root function
     */
    squareRoot() {
        const value = parseFloat(this.currentValue);
        if (value < 0) {
            this.showError('Error: Negative number');
            return;
        }
        this.currentValue = String(Math.sqrt(value));
        this.updateDisplay();
    }
    
    /**
     * Square function
     */
    square() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value * value);
        this.updateDisplay();
    }
    
    /**
     * Percent function
     */
    percent() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value / 100);
        this.updateDisplay();
    }
    
    /**
     * Reciprocal function (1/x)
     */
    reciprocal() {
        const value = parseFloat(this.currentValue);
        if (value === 0) {
            this.showError('Error: Division by zero');
            return;
        }
        this.currentValue = String(1 / value);
        this.updateDisplay();
    }
    
    /**
     * Apply tax (10%)
     */
    applyTax() {
        const value = parseFloat(this.currentValue);
        this.currentValue = String(value * 1.1);
        this.updateDisplay();
    }
    
    /**
     * Apply GST
     */
    applyGST(gstType) {
        const value = parseFloat(this.currentValue);
        const rate = this.gstRates[gstType] / 100;
        this.currentValue = String(value * (1 + rate));
        this.updateDisplay();
        
        // Show which GST rate was applied
        botReply(`Applied ${this.gstRates[gstType]}% GST`);
    }
    
    /**
     * Show error message
     */
    showError(message) {
        this.display.textContent = message;
        this.display.style.color = '#ff5252';
        
        // Reset after 2 seconds
        setTimeout(() => {
            this.display.style.color = '';
            this.currentValue = '0';
            this.updateDisplay();
        }, 2000);
    }
    
    /**
     * Update the main display
     */
    updateDisplay() {
        // Format large numbers with commas
        const formattedValue = this.formatNumber(this.currentValue);
        this.display.textContent = formattedValue;
    }
    
    /**
     * Update the expression display
     */
    updateExpressionDisplay() {
        let expression = '';
        
        if (this.previousValue !== '') {
            expression += this.formatNumber(this.previousValue);
        }
        
        if (this.operation) {
            let operatorSymbol = '';
            switch (this.operation) {
                case '+': operatorSymbol = ' + '; break;
                case '-': operatorSymbol = ' - '; break;
                case '*': operatorSymbol = ' × '; break;
                case '/': operatorSymbol = ' ÷ '; break;
            }
            expression += operatorSymbol;
        }
        
        this.expressionDisplay.textContent = expression;
    }
    
    /**
     * Format number with commas for thousands
     */
    formatNumber(num) {
        // Handle very large or small numbers with scientific notation
        if (Math.abs(parseFloat(num)) >= 1e10 || (Math.abs(parseFloat(num)) < 1e-6 && parseFloat(num) !== 0)) {
            return parseFloat(num).toExponential(6);
        }
        
        // Format with commas for thousands
        const parts = num.toString().split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return parts.join('.');
    }
    
    /**
     * Set up keyboard event listeners
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyPress);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        // Handle calculator keys
        if (event.key >= '0' && event.key <= '9') {
            this.inputNumber(event.key);
        } else if (event.key === '.') {
            this.inputDecimal();
        } else if (event.key === '+' || event.key === '-' || event.key === '*' || event.key === '/') {
            this.setOperation(event.key);
        } else if (event.key === 'Enter' || event.key === '=') {
            this.calculate();
        } else if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === 'Backspace') {
            this.backspace();
        } else if (event.key === 'Delete' || event.key === 'c' || event.key === 'C') {
            this.clear();
        } else if (event.key === 'r' || event.key === 'R') {
            this.squareRoot();
        } else if (event.key === 's' || event.key === 'S') {
            this.square();
        } else if (event.key === '%') {
            this.percent();
        } else if (event.key === 't' || event.key === 'T') {
            this.applyTax();
        } else if (event.key === 'g' || event.key === 'G') {
            this.applyGST('gst3'); // Default to 18% GST
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Clear any pending button timeout
        if (this.buttonTimeout) {
            clearTimeout(this.buttonTimeout);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.display = null;
        this.expressionDisplay = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentValue = '0';
        this.previousValue = '';
        this.operation = null;
        this.waitingForOperand = false;
        this.activeButton = null;
        this.buttonTimeout = null;
        this.memory = 0;
        
        botReply("Advanced Calculator closed. Thank you!");
    }
}

// Create a singleton instance
const calculatorScreen = new CalculatorScreen();

// Add this to your AI's command handling
if (/calculator|calc|calculate/i.test(userInputRaw)) {
    calculatorScreen.loadCalculator();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    calculatorScreen.closeGame();
    return;
}



/**
 * Advanced Code Error Fixing System - Enhanced Version
 * Detects and fixes errors in multiple programming languages with improved performance
 */
const AdvancedCodeFixer = {
    // Language detection patterns
    languagePatterns: {
        javascript: /(?:function|var|let|const|=>|console\.log|document\.getElementById)/,
        python: /(?:def |import |from |print\(|if __name__|:|\s{4})/,
        java: /(?:public class|public static void main|System\.out\.println|private|protected)/,
        html: /<!DOCTYPE html>|<html|<head|<body|<div|<span|<p>/,
        css: /(?:@media|{|}|:\s*;|#[a-fA-F0-9]{3,6}|rgb\(|rgba\()/,
        cpp: /#include|using namespace std|int main\(\)|cout|cin|std::/,
        csharp: /using System|namespace|public class|Console\.Write|static void Main/,
        php: /<\?php|\$\w+|echo|function |require_once|include_once/,
        ruby: /def |require |puts |if |end|@/,
        swift: /import UIKit|let |var |@IBOutlet|@IBAction|func /,
        typescript: /(?:interface|type|namespace|declare|private|public|protected|readonly|:)/,
        go: /(?:package main|import \(|func |fmt\.Print|go |defer )/,
        rust: /(?:fn |let |mut |use |extern crate|println!)/,
        kotlin: /(?:fun |val |var |: String|: Int|import kotlin)/
    },
    
    // Language cache for faster detection
    languageCache: new Map(),
    
    // Pre-compiled patterns cache
    compiledPatterns: {},
    
    // Initialize compiled patterns
    init: function() {
        // Pre-compile all regex patterns for better performance
        for (const [lang, patterns] of Object.entries(this.errorPatterns)) {
            this.compiledPatterns[lang] = patterns.map(p => ({
                ...p,
                compiledPattern: new RegExp(p.pattern.source, p.pattern.flags)
            }));
        }
    },
    
    // Common error patterns and fixes by language
    errorPatterns: {
        javascript: [
            {
                name: "Missing semicolon",
                pattern: /(\w+\s*[=+\-*/]?\s*[^(;{])$\n/gm,
                fix: "$1;",
                description: "Added missing semicolon"
            },
            {
                name: "Using assignment instead of comparison",
                pattern: /if\s*\(([^=]+)=([^=]+)\)/g,
                fix: "if ($1===$2)",
                description: "Changed assignment (=) to strict equality (===)"
            },
            {
                name: "Unmatched bracket",
                pattern: /(\{|\(|\[)([^}]*)$/gm,
                fix: (match, openBracket, content) => {
                    const closeBracket = openBracket === '{' ? '}' : openBracket === '(' ? ')' : ']';
                    return openBracket + content + closeBracket;
                },
                description: "Added missing closing bracket"
            },
            {
                name: "String concatenation instead of template literals",
                pattern: /console\.log\(\s*["'](.+?)["']\s*\+\s*(.+?)\s*\)/g,
                fix: "console.log(`$1${$2}`)",
                description: "Replaced string concatenation with template literals"
            },
            {
                name: "Var instead of let/const",
                pattern: /\bvar\s+(\w+)/g,
                fix: (match, varName) => {
                    // Simple heuristic: use const if the variable is only assigned once
                    return `const ${varName}`;
                },
                description: "Replaced 'var' with 'const'"
            },
            {
                name: "Missing return statement",
                pattern: /function\s+\w+\s*\([^)]*\)\s*\{[^}]*\}(?!\s*return)/g,
                fix: (match) => {
                    // Simple heuristic: add return if function doesn't already have one
                    if (!match.includes('return ')) {
                        return match.replace(/\}$/, '  return null;\n}');
                    }
                    return match;
                },
                description: "Added missing return statement"
            },
            {
                name: "Async function without await",
                pattern: /async\s+function\s+\w+\s*\([^)]*\)\s*\{(?![^}]*await)/g,
                fix: (match) => {
                    return match.replace('async function ', 'function ');
                },
                description: "Removed async keyword as no await was found"
            }
        ],
        python: [
            {
                name: "Missing colon",
                pattern: /(def |if |for |while |class )([^:]+)$/gm,
                fix: "$1$2:",
                description: "Added missing colon"
            },
            {
                name: "Indentation error",
                pattern: /^(\s+)(def |if |for |while |class )/gm,
                fix: (match, spaces, keyword) => {
                    // Ensure 4 spaces for indentation
                    const indent = "    ".repeat(Math.ceil(spaces.length / 4));
                    return indent + keyword;
                },
                description: "Fixed indentation to 4 spaces"
            },
            {
                name: "Print statement instead of function",
                pattern: /print\s+(.+)/g,
                fix: "print($1)",
                description: "Changed print statement to print function"
            },
            {
                name: "Missing self parameter",
                pattern: /def\s+(\w+)\s*\([^)]*self[^)]*\)/g,
                fix: (match, methodName) => {
                    if (!match.includes('self')) {
                        return match.replace(/\(([^)]*)\)/, '(self, $1)');
                    }
                    return match;
                },
                description: "Added missing self parameter to method"
            }
        ],
        java: [
            {
                name: "Missing semicolon",
                pattern: /(\w+\s*[=+\-*/]?\s*[^(;{])$\n/gm,
                fix: "$1;",
                description: "Added missing semicolon"
            },
            {
                name: "Class name convention",
                pattern: /class\s+([a-z][a-zA-Z0-9]*)/g,
                fix: (match, className) => {
                    // Capitalize first letter
                    return "class " + className.charAt(0).toUpperCase() + className.slice(1);
                },
                description: "Capitalized class name"
            },
            {
                name: "String concatenation",
                pattern: /System\.out\.print\(\s*"(.+?)"\s*\+\s*(.+?)\s*\)/g,
                fix: 'System.out.println("$1" + $2)',
                description: "Improved string concatenation formatting"
            },
            {
                name: "Missing public static void main",
                pattern: /class\s+\w+\s*\{[^}]*\}(?![^}]*public static void main)/g,
                fix: (match) => {
                    return match.replace(/\}$/, '\n    public static void main(String[] args) {\n        \n    }\n}');
                },
                description: "Added missing main method"
            }
        ],
        html: [
            {
                name: "Unclosed tag",
                pattern: /<([a-z]+)(\s+[^>]*)?>(?!.*<\/\1>)/gi,
                fix: (match, tag, attributes) => {
                    return match + `</${tag}>`;
                },
                description: "Added missing closing tag"
            },
            {
                name: "Missing DOCTYPE",
                pattern: /^(?!<!DOCTYPE)/,
                fix: (match) => {
                    return "<!DOCTYPE html>\n" + match;
                },
                description: "Added missing DOCTYPE declaration"
            },
            {
                name: "Improper nesting",
                pattern: /<([a-z]+)(\s+[^>]*)?><\/([a-z]+)>/gi,
                fix: (match, openTag, attributes, closeTag) => {
                    if (openTag !== closeTag) {
                        return `<${openTag}${attributes}></${openTag}>`;
                    }
                    return match;
                },
                description: "Fixed improperly nested tags"
            },
            {
                name: "Missing alt attribute",
                pattern: /<img\s+([^>]*?)>/gi,
                fix: (match, attributes) => {
                    if (!attributes.includes('alt=')) {
                        return `<img ${attributes} alt="">`;
                    }
                    return match;
                },
                description: "Added missing alt attribute to img tag"
            }
        ],
        css: [
            {
                name: "Missing colon",
                pattern: /([a-z-]+)\s*([^{;]+)$/gim,
                fix: "$1: $2;",
                description: "Added missing colon and semicolon"
            },
            {
                name: "Invalid color value",
                pattern: /:\s*#([a-fA-F0-9]{3,6})[^a-fA-F0-9;]/gi,
                fix: (match, color) => {
                    if (color.length === 3) {
                        return `: #${color};`;
                    } else if (color.length === 6) {
                        return `: #${color};`;
                    }
                    return match;
                },
                description: "Fixed invalid color value"
            },
            {
                name: "Missing units",
                pattern: /:\s*(\d+)\s*;/gi,
                fix: (match, value) => {
                    // Default to px for numeric values without units
                    return `: ${value}px;`;
                },
                description: "Added missing units (px)"
            },
            {
                name: "Missing vendor prefixes",
                pattern: /(transform|transition|animation|user-select|box-sizing):\s*([^;]+);/gi,
                fix: (match, property, value) => {
                    return `-webkit-${property}: ${value};\n-moz-${property}: ${value};\n-ms-${property}: ${value};\n${property}: ${value};`;
                },
                description: "Added vendor prefixes for better browser compatibility"
            }
        ],
        typescript: [
            {
                name: "Missing type annotation",
                pattern: /(function\s+\w+\s*\([^)]*\)|const\s+\w+\s*=|let\s+\w+\s*=)(?!\s*:\s*\w+)/g,
                fix: (match) => {
                    if (match.startsWith('function')) {
                        return match.replace(/\)/, '): any');
                    } else if (match.includes('const')) {
                        return match.replace('=', ': any =');
                    } else if (match.includes('let')) {
                        return match.replace('=', ': any =');
                    }
                    return match;
                },
                description: "Added missing type annotation"
            },
            {
                name: "Using var instead of let/const",
                pattern: /\bvar\s+(\w+)/g,
                fix: (match, varName) => {
                    return `let ${varName}`;
                },
                description: "Replaced 'var' with 'let'"
            }
        ]
    },
    
    /**
     * Detect the programming language of the provided code with caching
     * @param {string} code - The code to analyze
     * @returns {string} - The detected language
     */
    detectLanguage: function(code) {
        // Check cache first
        const cacheKey = code.substring(0, 100); // Use first 100 chars as key
        if (this.languageCache.has(cacheKey)) {
            return this.languageCache.get(cacheKey);
        }
        
        for (const [language, pattern] of Object.entries(this.languagePatterns)) {
            if (pattern.test(code)) {
                this.languageCache.set(cacheKey, language);
                return language;
            }
        }
        
        this.languageCache.set(cacheKey, "unknown");
        return "unknown";
    },
    
    /**
     * Fix errors in the provided code with optimized processing
     * @param {string} code - The code to fix
     * @param {string} language - Optional language hint
     * @returns {Object} - Result object with fixed code and issues found
     */
    fixCode: function(code, language = null) {
        // Detect language if not provided
        const detectedLanguage = language || this.detectLanguage(code);
        
        // Initialize result object
        const result = {
            originalCode: code,
            fixedCode: code,
            language: detectedLanguage,
            issues: [],
            fixesApplied: []
        };
        
        // If language is unknown or unsupported, return early
        if (detectedLanguage === "unknown" || !this.errorPatterns[detectedLanguage]) {
            result.issues.push({
                type: "warning",
                message: `Could not detect language or language '${detectedLanguage}' is not supported`
            });
            return result;
        }
        
        // Ensure patterns are compiled
        if (!this.compiledPatterns[detectedLanguage]) {
            this.init();
        }
        
        // Get compiled error patterns for the detected language
        const patterns = this.compiledPatterns[detectedLanguage];
        
        // Collect all fixes first, then apply them in batch
        const fixes = [];
        
        for (const pattern of patterns) {
            const matches = result.fixedCode.match(pattern.compiledPattern);
            
            if (matches) {
                // Add issue
                result.issues.push({
                    type: "error",
                    message: pattern.description,
                    pattern: pattern.name
                });
                
                // Collect fix
                fixes.push({
                    pattern: pattern.compiledPattern,
                    fix: pattern.fix,
                    name: pattern.name,
                    description: pattern.description
                });
            }
        }
        
        // Apply all fixes in a single pass
        let currentCode = result.fixedCode;
        for (const fix of fixes) {
            if (typeof fix.fix === "function") {
                currentCode = currentCode.replace(fix.pattern, fix.fix);
            } else {
                currentCode = currentCode.replace(fix.pattern, fix.fix);
            }
            
            result.fixesApplied.push({
                pattern: fix.name,
                description: fix.description
            });
        }
        
        result.fixedCode = currentCode;
        
        // Check for unmatched brackets, braces, or parentheses
        this.checkUnmatchedDelimiters(result);
        
        return result;
    },
    
    /**
     * Check for unmatched brackets, braces, or parentheses
     * @param {Object} result - The result object to update
     */
    checkUnmatchedDelimiters: function(result) {
        const delimiters = {
            '(': { count: 0, closer: ')' },
            '[': { count: 0, closer: ']' },
            '{': { count: 0, closer: '}' }
        };
        
        // Count opening and closing delimiters
        for (let i = 0; i < result.fixedCode.length; i++) {
            const char = result.fixedCode[i];
            
            if (delimiters[char]) {
                delimiters[char].count++;
            } else {
                // Check if this is a closing delimiter
                for (const [opener, info] of Object.entries(delimiters)) {
                    if (char === info.closer) {
                        delimiters[opener].count--;
                        break;
                    }
                }
            }
        }
        
        // Check for unmatched delimiters
        for (const [opener, info] of Object.entries(delimiters)) {
            if (info.count > 0) {
                result.issues.push({
                    type: "error",
                    message: `Unmatched '${opener}' - missing ${info.count} '${info.closer}'`,
                    pattern: "Unmatched delimiter"
                });
                
                // Add missing closing delimiters
                for (let i = 0; i < info.count; i++) {
                    result.fixedCode += info.closer;
                }
                
                result.fixesApplied.push({
                    pattern: "Unmatched delimiter",
                    description: `Added missing '${info.closer}' delimiter(s)`
                });
            } else if (info.count < 0) {
                result.issues.push({
                    type: "error",
                    message: `Too many '${info.closer}' - missing ${Math.abs(info.count)} '${opener}'`,
                    pattern: "Unmatched delimiter"
                });
            }
        }
    },
    
    /**
     * Format the result for display
     * @param {Object} result - The result object from fixCode
     * @returns {string} - Formatted result
     */
    formatResult: function(result) {
        let formatted = `Language detected: ${result.language}\n\n`;
        
        if (result.issues.length === 0) {
            formatted += "No issues detected in your code.\n";
        } else {
            formatted += "Issues found:\n";
            result.issues.forEach((issue, index) => {
                formatted += `${index + 1}. ${issue.message} (${issue.pattern})\n`;
            });
            
            formatted += "\nFixes applied:\n";
            result.fixesApplied.forEach((fix, index) => {
                formatted += `${index + 1}. ${fix.description}\n`;
            });
        }
        
        return formatted;
    },
    
    /**
     * Copy text to clipboard
     * @param {string} text - Text to copy
     */
    copyToClipboard: function(text) {
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.showNotification('Copied to clipboard!', '#4CAF50');
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    this.fallbackCopyToClipboard(text);
                });
        } else {
            this.fallbackCopyToClipboard(text);
        }
    },
    
    /**
     * Fallback method for copying to clipboard
     * @param {string} text - Text to copy
     */
    fallbackCopyToClipboard: function(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed'; // Prevent scrolling to bottom
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        try {
            document.execCommand('copy');
            this.showNotification('Copied to clipboard!', '#4CAF50');
        } catch (err) {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy', '#f44336');
        }
        
        document.body.removeChild(textarea);
    },
    
    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} bgColor - Background color
     */
    showNotification: function(message, bgColor = '#4CAF50') {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.code-fixer-notification');
        existingNotifications.forEach(notification => {
            document.body.removeChild(notification);
        });
        
        const notification = document.createElement('div');
        notification.className = 'code-fixer-notification';
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.bottom = '20px';
        notification.style.right = '20px';
        notification.style.backgroundColor = bgColor;
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '2000';
        notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        notification.style.transition = 'opacity 0.5s ease';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 2000);
    },
    
    /**
     * Share code
     * @param {string} code - Code to share
     */
    shareCode: function(code) {
        // Create a temporary URL with the code
        const encodedCode = encodeURIComponent(code);
        const shareUrl = `${window.location.origin}${window.location.pathname}?code=${encodedCode}`;
        
        // Copy to clipboard
        this.copyToClipboard(shareUrl);
        
        // Show notification
        this.showNotification('Share link copied to clipboard!', '#2196F3');
    },
    
    /**
     * Edit code
     * @param {string} code - Code to edit
     */
    editCode: function(code) {
        const inputTextarea = document.getElementById('code-input');
        if (inputTextarea) {
            inputTextarea.value = code;
            
            // Scroll to input
            inputTextarea.scrollIntoView({ behavior: 'smooth' });
            inputTextarea.focus();
            
            // Show notification
            this.showNotification('Code loaded in editor!', '#FF9800');
        }
    },
    
    /**
     * Highlight code with syntax
     * @param {string} code - Code to highlight
     * @param {string} language - Language of the code
     * @returns {string} - Highlighted HTML
     */
    highlightCode: function(code, language) {
        // Simple syntax highlighting based on language
        let highlighted = code;
        
        // Escape HTML entities
        highlighted = highlighted
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        
        // Apply language-specific highlighting
        switch (language) {
            case 'javascript':
            case 'typescript':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|var|let|const|if|else|for|while|return|async|await|class|import|export|from|default)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'python':
                highlighted = highlighted
                    .replace(/(#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\'\'\'[\s\S]*?\'\'\'|\"\"\"[\s\S]*?\"\"\")/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(def|if|else|elif|for|while|return|class|import|from|as|try|except|finally|with|pass|break|continue|lambda|and|or|not|in|is|True|False|None)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'java':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(public|private|protected|static|final|abstract|class|interface|enum|void|int|String|boolean|if|else|for|while|return|new|this|super|import|package|try|catch|finally|throws|extends|implements)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'html':
                highlighted = highlighted
                    .replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="code-comment">$1</span>')
                    .replace(/(&lt;\/?[a-zA-Z0-9]+)(\s+[^&gt;]*?)?&gt;/g, '<span class="code-tag">$1$2&gt;</span>')
                    .replace(/([a-zA-Z-]+)=["']([^"']*?)["']/g, '<span class="code-attribute">$1</span>=<span class="code-string">"$2"</span>');
                break;
                
            case 'css':
                highlighted = highlighted
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/([a-zA-Z-]+)\s*:/g, '<span class="code-property">$1</span>:')
                    .replace(/:\s*([a-zA-Z0-9#%]+);/g, ': <span class="code-value">$1</span>;')
                    .replace(/\b(\d+)px\b/g, '<span class="code-number">$1px</span>');
                break;
                
            default:
                // Generic highlighting for other languages
                highlighted = highlighted
                    .replace(/(\/\/.*|#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|if|else|for|while|return|class|def|import|from)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
        }
        
        return highlighted;
    },
    
    /**
     * Load the code fixer interface
     */
    loadCodeFixer: function() {
        // Initialize compiled patterns
        this.init();
        
        // Check if interface already exists
        if (document.getElementById('code-fixer-screen')) {
            return;
        }
        
        // Create the code fixer interface
        const codeFixerScreen = document.createElement('div');
        codeFixerScreen.id = 'code-fixer-screen';
        codeFixerScreen.style.position = 'fixed';
        codeFixerScreen.style.top = '0';
        codeFixerScreen.style.left = '0';
        codeFixerScreen.style.width = '100%';
        codeFixerScreen.style.height = '100%';
        codeFixerScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        codeFixerScreen.style.zIndex = '1000';
        codeFixerScreen.style.display = 'flex';
        codeFixerScreen.style.flexDirection = 'column';
        codeFixerScreen.style.padding = '20px';
        codeFixerScreen.style.boxSizing = 'border-box';
        
        // Create header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '20px';
        
        const title = document.createElement('h2');
        title.textContent = 'Advanced Code Error Fixer';
        title.style.color = 'white';
        title.style.margin = '0';
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.padding = '8px 16px';
        closeButton.style.backgroundColor = '#f44336';
        closeButton.style.color = 'white';
        closeButton.style.border = 'none';
        closeButton.style.borderRadius = '4px';
        closeButton.style.cursor = 'pointer';
        closeButton.onclick = () => this.closeGame();
        
        header.appendChild(title);
        header.appendChild(closeButton);
        
        // Create language selector
        const languageSelector = document.createElement('div');
        languageSelector.style.marginBottom = '20px';
        
        const languageLabel = document.createElement('label');
        languageLabel.textContent = 'Language: ';
        languageLabel.style.color = 'white';
        languageLabel.style.marginRight = '10px';
        
        const languageSelect = document.createElement('select');
        languageSelect.id = 'language-select';
        languageSelect.style.padding = '8px';
        languageSelect.style.borderRadius = '4px';
        languageSelect.style.border = 'none';
        
        const languages = ['auto', 'javascript', 'typescript', 'python', 'java', 'html', 'css', 'cpp', 'csharp', 'php', 'ruby', 'swift', 'go', 'rust', 'kotlin'];
        languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang;
            option.textContent = lang.charAt(0).toUpperCase() + lang.slice(1);
            languageSelect.appendChild(option);
        });
        
        languageSelector.appendChild(languageLabel);
        languageSelector.appendChild(languageSelect);
        
        // Create input textarea
        const inputContainer = document.createElement('div');
        inputContainer.style.marginBottom = '20px';
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Code to fix:';
        inputLabel.style.color = 'white';
        inputLabel.style.display = 'block';
        inputLabel.style.marginBottom = '10px';
        
        const inputTextarea = document.createElement('textarea');
        inputTextarea.id = 'code-input';
        inputTextarea.style.width = '100%';
        inputTextarea.style.height = '200px';
        inputTextarea.style.padding = '10px';
        inputTextarea.style.borderRadius = '4px';
        inputTextarea.style.border = 'none';
        inputTextarea.style.fontFamily = 'monospace';
        inputTextarea.style.fontSize = '14px';
        inputTextarea.placeholder = 'Paste your code here...';
        
        inputContainer.appendChild(inputLabel);
        inputContainer.appendChild(inputTextarea);
        
        // Create fix button
        const fixButton = document.createElement('button');
        fixButton.textContent = 'Fix Code';
        fixButton.style.padding = '10px 20px';
        fixButton.style.backgroundColor = '#4CAF50';
        fixButton.style.color = 'white';
        fixButton.style.border = 'none';
        fixButton.style.borderRadius = '4px';
        fixButton.style.cursor = 'pointer';
        fixButton.style.marginBottom = '20px';
        fixButton.onclick = () => {
            const code = inputTextarea.value;
            if (!code.trim()) {
                this.showNotification('Please enter some code to fix', '#f44336');
                return;
            }
            
            const language = languageSelect.value === 'auto' ? null : languageSelect.value;
            
            // Show loading indicator
            const loadingIndicator = document.createElement('div');
            loadingIndicator.id = 'loading-indicator';
            loadingIndicator.textContent = 'Analyzing and fixing code...';
            loadingIndicator.style.position = 'absolute';
            loadingIndicator.style.top = '50%';
            loadingIndicator.style.left = '50%';
            loadingIndicator.style.transform = 'translate(-50%, -50%)';
            loadingIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            loadingIndicator.style.color = 'white';
            loadingIndicator.style.padding = '15px 30px';
            loadingIndicator.style.borderRadius = '4px';
            loadingIndicator.style.zIndex = '2000';
            document.body.appendChild(loadingIndicator);
            
            // Use setTimeout to allow UI to update before processing
            setTimeout(() => {
                try {
                    const result = this.fixCode(code, language);
                    
                    // Remove loading indicator
                    if (document.body.contains(loadingIndicator)) {
                        document.body.removeChild(loadingIndicator);
                    }
                    
                    // Create result container
                    const resultContainer = document.getElementById('result-container');
                    resultContainer.innerHTML = '';
                    
                    // Create issues section
                    const issuesSection = document.createElement('div');
                    issuesSection.style.marginBottom = '20px';
                    
                    const issuesTitle = document.createElement('h3');
                    issuesTitle.textContent = 'Analysis Results';
                    issuesTitle.style.marginTop = '0';
                    issuesTitle.style.marginBottom = '10px';
                    issuesSection.appendChild(issuesTitle);
                    
                    if (result.issues.length === 0) {
                        const noIssues = document.createElement('p');
                        noIssues.textContent = 'No issues detected in your code.';
                        issuesSection.appendChild(noIssues);
                    } else {
                        const issuesList = document.createElement('ul');
                        issuesList.style.paddingLeft = '20px';
                        
                        result.issues.forEach(issue => {
                            const issueItem = document.createElement('li');
                            issueItem.textContent = `${issue.message} (${issue.pattern})`;
                            issuesList.appendChild(issueItem);
                        });
                        
                        issuesSection.appendChild(issuesList);
                        
                        const fixesTitle = document.createElement('h4');
                        fixesTitle.textContent = 'Fixes Applied:';
                        fixesTitle.style.marginTop = '15px';
                        fixesTitle.style.marginBottom = '10px';
                        issuesSection.appendChild(fixesTitle);
                        
                        const fixesList = document.createElement('ul');
                        fixesList.style.paddingLeft = '20px';
                        
                        result.fixesApplied.forEach(fix => {
                            const fixItem = document.createElement('li');
                            fixItem.textContent = fix.description;
                            fixesList.appendChild(fixItem);
                        });
                        
                        issuesSection.appendChild(fixesList);
                    }
                    
                    resultContainer.appendChild(issuesSection);
                    
                    // Create fixed code section
                    const fixedCodeSection = document.createElement('div');
                    
                    const fixedCodeTitle = document.createElement('h3');
                    fixedCodeTitle.textContent = 'Fixed Code';
                    fixedCodeTitle.style.marginTop = '0';
                    fixedCodeTitle.style.marginBottom = '10px';
                    fixedCodeSection.appendChild(fixedCodeTitle);
                    
                    // Create code display
                    const codeDisplay = document.createElement('pre');
                    codeDisplay.style.backgroundColor = '#f5f5f5';
                    codeDisplay.style.padding = '15px';
                    codeDisplay.style.borderRadius = '4px';
                    codeDisplay.style.overflow = 'auto';
                    codeDisplay.style.maxHeight = '300px';
                    codeDisplay.style.whiteSpace = 'pre-wrap';
                    codeDisplay.style.fontFamily = 'monospace';
                    codeDisplay.style.fontSize = '14px';
                    
                    // Apply syntax highlighting
                    codeDisplay.innerHTML = this.highlightCode(result.fixedCode, result.language);
                    
                    fixedCodeSection.appendChild(codeDisplay);
                    
                    // Create button container
                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.display = 'flex';
                    buttonContainer.style.justifyContent = 'space-between';
                    buttonContainer.style.marginTop = '15px';
                    buttonContainer.style.flexWrap = 'wrap';
                    buttonContainer.style.gap = '10px';
                    
                    // Copy button
                    const copyButton = document.createElement('button');
                    copyButton.textContent = 'Copy Code';
                    copyButton.style.padding = '8px 16px';
                    copyButton.style.backgroundColor = '#2196F3';
                    copyButton.style.color = 'white';
                    copyButton.style.border = 'none';
                    copyButton.style.borderRadius = '4px';
                    copyButton.style.cursor = 'pointer';
                    copyButton.style.flex = '1';
                    copyButton.onclick = () => this.copyToClipboard(result.fixedCode);
                    buttonContainer.appendChild(copyButton);
                    
                    // Share button
                    const shareButton = document.createElement('button');
                    shareButton.textContent = 'Share Code';
                    shareButton.style.padding = '8px 16px';
                    shareButton.style.backgroundColor = '#4CAF50';
                    shareButton.style.color = 'white';
                    shareButton.style.border = 'none';
                    shareButton.style.borderRadius = '4px';
                    shareButton.style.cursor = 'pointer';
                    shareButton.style.flex = '1';
                    shareButton.onclick = () => this.shareCode(result.fixedCode);
                    buttonContainer.appendChild(shareButton);
                    
                    // Edit button
                    const editButton = document.createElement('button');
                    editButton.textContent = 'Edit Code';
                    editButton.style.padding = '8px 16px';
                    editButton.style.backgroundColor = '#FF9800';
                    editButton.style.color = 'white';
                    editButton.style.border = 'none';
                    editButton.style.borderRadius = '4px';
                    editButton.style.cursor = 'pointer';
                    editButton.style.flex = '1';
                    editButton.onclick = () => this.editCode(result.fixedCode);
                    buttonContainer.appendChild(editButton);
                    
                    fixedCodeSection.appendChild(buttonContainer);
                    resultContainer.appendChild(fixedCodeSection);
                    
                    // Show success notification
                    if (result.fixesApplied.length > 0) {
                        this.showNotification(`Fixed ${result.fixesApplied.length} issue(s)!`, '#4CAF50');
                    }
                } catch (error) {
                    // Remove loading indicator
                    if (document.body.contains(loadingIndicator)) {
                        document.body.removeChild(loadingIndicator);
                    }
                    
                    console.error('Error fixing code:', error);
                    this.showNotification('An error occurred while fixing your code', '#f44336');
                }
            }, 100);
        };
        
        // Create result container
        const resultContainer = document.createElement('div');
        resultContainer.id = 'result-container';
        resultContainer.style.backgroundColor = 'white';
        resultContainer.style.padding = '20px';
        resultContainer.style.borderRadius = '4px';
        resultContainer.style.overflow = 'auto';
        resultContainer.style.flex = '1';
        resultContainer.innerHTML = '<p style="color: gray;">Results will appear here...</p>';
        
        // Add syntax highlighting styles
        const style = document.createElement('style');
        style.textContent = `
            .code-comment { color: #6a9955; }
            .code-keyword { color: #569cd6; font-weight: bold; }
            .code-number { color: #b5cea8; }
            .code-string { color: #ce9178; }
            .code-tag { color: #569cd6; }
            .code-attribute { color: #9cdcfe; }
            .code-property { color: #9cdcfe; }
            .code-value { color: #ce9178; }
        `;
        document.head.appendChild(style);
        
        // Assemble the interface
        codeFixerScreen.appendChild(header);
        codeFixerScreen.appendChild(languageSelector);
        codeFixerScreen.appendChild(inputContainer);
        codeFixerScreen.appendChild(fixButton);
        codeFixerScreen.appendChild(resultContainer);
        
        // Add to document
        document.body.appendChild(codeFixerScreen);
        
        // Check if there's a code parameter in the URL
        const urlParams = new URLSearchParams(window.location.search);
        const codeParam = urlParams.get('code');
        if (codeParam) {
            inputTextarea.value = decodeURIComponent(codeParam);
        }
    },
    
    /**
     * Close the code fixer interface
     */
    closeGame: function() {
        const codeFixerScreen = document.getElementById('code-fixer-screen');
        if (codeFixerScreen) {
            document.body.removeChild(codeFixerScreen);
        }
    }
};

// Initialize the compiled patterns
AdvancedCodeFixer.init();

// Create a singleton instance
const codeFixerScreen = AdvancedCodeFixer;

// Add this to your AI's command handling
if (/fix code|code fix|fix my code/i.test(userInputRaw)) {
    codeFixerScreen.loadCodeFixer();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    codeFixerScreen.closeGame();
    return;
}

/**
 * Code Display System - Shows formatted code in a nice box
 */
const CodeDisplay = {
    /**
     * Display code in a formatted box
     * @param {string} code - The code to display
     * @param {string} language - The programming language
     * @param {string} title - Optional title for the code box
     */
    displayCode: function(code, language, title = "Source Code") {
        // Remove any existing code displays
        const existingDisplays = document.querySelectorAll('.code-display-container');
        existingDisplays.forEach(display => {
            document.body.removeChild(display);
        });
        
        // Create the code display container
        const container = document.createElement('div');
        container.className = 'code-display-container';
        container.style.position = 'fixed';
        container.style.top = '0';
        container.style.left = '0';
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        container.style.zIndex = '1000';
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.padding = '20px';
        container.style.boxSizing = 'border-box';
        
        // Create header
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '20px';
        
        const titleElement = document.createElement('h2');
        titleElement.textContent = title;
        titleElement.style.color = 'white';
        titleElement.style.margin = '0';
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.style.padding = '8px 16px';
        closeButton.style.backgroundColor = '#f44336';
        closeButton.style.color = 'white';
        closeButton.style.border = 'none';
        closeButton.style.borderRadius = '4px';
        closeButton.style.cursor = 'pointer';
        closeButton.onclick = () => this.closeDisplay();
        
        header.appendChild(titleElement);
        header.appendChild(closeButton);
        
        // Create language indicator
        const languageIndicator = document.createElement('div');
        languageIndicator.style.marginBottom = '15px';
        
        const languageLabel = document.createElement('span');
        languageLabel.textContent = 'Language: ';
        languageLabel.style.color = '#aaa';
        
        const languageName = document.createElement('span');
        languageName.textContent = language.toUpperCase();
        languageName.style.color = '#4CAF50';
        languageName.style.fontWeight = 'bold';
        
        languageIndicator.appendChild(languageLabel);
        languageIndicator.appendChild(languageName);
        
        // Create code display
        const codeDisplay = document.createElement('pre');
        codeDisplay.style.backgroundColor = '#1e1e1e';
        codeDisplay.style.color = '#d4d4d4';
        codeDisplay.style.padding = '20px';
        codeDisplay.style.borderRadius = '8px';
        codeDisplay.style.overflow = 'auto';
        codeDisplay.style.flex = '1';
        codeDisplay.style.fontFamily = 'Consolas, Monaco, "Andale Mono", monospace';
        codeDisplay.style.fontSize = '14px';
        codeDisplay.style.lineHeight = '1.5';
        codeDisplay.style.whiteSpace = 'pre-wrap';
        codeDisplay.style.wordBreak = 'break-all';
        
        // Apply syntax highlighting
        codeDisplay.innerHTML = this.highlightCode(code, language);
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.justifyContent = 'flex-end';
        buttonContainer.style.marginTop = '15px';
        buttonContainer.style.gap = '10px';
        
        // Copy button
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy Code';
        copyButton.style.padding = '8px 16px';
        copyButton.style.backgroundColor = '#2196F3';
        copyButton.style.color = 'white';
        copyButton.style.border = 'none';
        copyButton.style.borderRadius = '4px';
        copyButton.style.cursor = 'pointer';
        copyButton.onclick = () => this.copyToClipboard(code);
        buttonContainer.appendChild(copyButton);
        
        // Add syntax highlighting styles
        this.addSyntaxHighlightingStyles();
        
        // Assemble the display
        container.appendChild(header);
        container.appendChild(languageIndicator);
        container.appendChild(codeDisplay);
        container.appendChild(buttonContainer);
        
        // Add to document
        document.body.appendChild(container);
    },
    
    /**
     * Highlight code with syntax
     * @param {string} code - Code to highlight
     * @param {string} language - Language of the code
     * @returns {string} - Highlighted HTML
     */
    highlightCode: function(code, language) {
        // Escape HTML entities
        let highlighted = code
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        
        // Apply language-specific highlighting
        switch (language.toLowerCase()) {
            case 'java':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(public|private|protected|static|final|abstract|class|interface|enum|void|int|String|boolean|if|else|for|while|return|new|this|super|import|package|try|catch|finally|throws|extends|implements)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'javascript':
            case 'typescript':
                highlighted = highlighted
                    .replace(/(\/\/.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|var|let|const|if|else|for|while|return|async|await|class|import|export|from|default)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'python':
                highlighted = highlighted
                    .replace(/(#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\'\'\'[\s\S]*?\'\'\'|\"\"\"[\s\S]*?\"\"\")/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(def|if|else|elif|for|while|return|class|import|from|as|try|except|finally|with|pass|break|continue|lambda|and|or|not|in|is|True|False|None)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
                break;
                
            case 'html':
                highlighted = highlighted
                    .replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="code-comment">$1</span>')
                    .replace(/(&lt;\/?[a-zA-Z0-9]+)(\s+[^&gt;]*?)?&gt;/g, '<span class="code-tag">$1$2&gt;</span>')
                    .replace(/([a-zA-Z-]+)=["']([^"']*?)["']/g, '<span class="code-attribute">$1</span>=<span class="code-string">"$2"</span>');
                break;
                
            case 'css':
                highlighted = highlighted
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/([a-zA-Z-]+)\s*:/g, '<span class="code-property">$1</span>:')
                    .replace(/:\s*([a-zA-Z0-9#%]+);/g, ': <span class="code-value">$1</span>;')
                    .replace(/\b(\d+)px\b/g, '<span class="code-number">$1px</span>');
                break;
                
            default:
                // Generic highlighting for other languages
                highlighted = highlighted
                    .replace(/(\/\/.*|#.*)/g, '<span class="code-comment">$1</span>')
                    .replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="code-comment">$1</span>')
                    .replace(/\b(function|if|else|for|while|return|class|def|import|from)\b/g, '<span class="code-keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="code-number">$1</span>')
                    .replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, '<span class="code-string">$&</span>');
        }
        
        return highlighted;
    },
    
    /**
     * Add syntax highlighting styles to the document
     */
    addSyntaxHighlightingStyles: function() {
        // Check if styles already exist
        if (document.getElementById('code-display-styles')) {
            return;
        }
        
        const style = document.createElement('style');
        style.id = 'code-display-styles';
        style.textContent = `
            .code-comment { color: #6a9955; font-style: italic; }
            .code-keyword { color: #569cd6; font-weight: bold; }
            .code-number { color: #b5cea8; }
            .code-string { color: #ce9178; }
            .code-tag { color: #569cd6; }
            .code-attribute { color: #9cdcfe; }
            .code-property { color: #9cdcfe; }
            .code-value { color: #ce9178; }
        `;
        document.head.appendChild(style);
    },
    
    /**
     * Copy text to clipboard
     * @param {string} text - Text to copy
     */
    copyToClipboard: function(text) {
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(text)
                .then(() => {
                    this.showNotification('Copied to clipboard!', '#4CAF50');
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    this.fallbackCopyToClipboard(text);
                });
        } else {
            this.fallbackCopyToClipboard(text);
        }
    },
    
    /**
     * Fallback method for copying to clipboard
     * @param {string} text - Text to copy
     */
    fallbackCopyToClipboard: function(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        
        try {
            document.execCommand('copy');
            this.showNotification('Copied to clipboard!', '#4CAF50');
        } catch (err) {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy', '#f44336');
        }
        
        document.body.removeChild(textarea);
    },
    
    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} bgColor - Background color
     */
    showNotification: function(message, bgColor = '#4CAF50') {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.code-display-notification');
        existingNotifications.forEach(notification => {
            document.body.removeChild(notification);
        });
        
        const notification = document.createElement('div');
        notification.className = 'code-display-notification';
        notification.textContent = message;
        notification.style.position = 'fixed';
        notification.style.bottom = '20px';
        notification.style.right = '20px';
        notification.style.backgroundColor = bgColor;
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '2000';
        notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
        notification.style.transition = 'opacity 0.5s ease';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 2000);
    },
    
    /**
     * Close the code display
     */
    closeDisplay: function() {
        const container = document.querySelector('.code-display-container');
        if (container) {
            document.body.removeChild(container);
        }
    }
};

// Create a singleton instance
const codeDisplay = CodeDisplay;

// Example usage:
// codeDisplay.displayCode(
//     `Toast.makeText(getApplicationContext(), "Hello World", Toast.LENGTH_SHORT).show();`,
//     "java",
//     "Android Java Toast Example"
// );

// Add this to your AI's command handling when you want to display code
// For example, when a user asks for source code:
// if (userAskedForCode) {
//     codeDisplay.displayCode(sourceCode, language, title);
//     return;
// }

// Add command to close the display
if (/close code|close display/i.test(userInputRaw)) {
    codeDisplay.closeDisplay();
    return;
}
class YouTubeScreenLoader {
    constructor() {
        this.youtube = {
            name: 'YOUTUBE PLAYER',
            instructions: 'Paste a YouTube link to watch videos in this player.'
        };
        
        this.gameContainer = null;
        this.iframe = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputContainer = null;
        this.videoId = null;
    }
    
    /**
     * Load the YouTube player
     */
    loadYouTube(url = null) {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.youtube.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // If URL is provided, load it directly
        if (url) {
            this.loadYouTubeVideo(url);
        } else {
            // Show input UI for URL
            this.showYouTubeInputUI();
        }
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the player
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.youtube.name} loaded! ${this.youtube.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Show YouTube URL input UI
     */
    showYouTubeInputUI() {
        // Create input container
        this.inputContainer = document.createElement('div');
        this.inputContainer.style.cssText = `
            background-color: #222;
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;
        
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'YouTube Player';
        title.style.cssText = `
            color: #ff0000;
            margin-bottom: 20px;
            font-size: 24px;
        `;
        this.inputContainer.appendChild(title);
        
        // Create instructions
        const instructions = document.createElement('p');
        instructions.textContent = 'Paste a YouTube URL below:';
        instructions.style.cssText = `
            color: #ccc;
            margin-bottom: 20px;
            font-size: 16px;
        `;
        this.inputContainer.appendChild(instructions);
        
        // Create input field
        const inputField = document.createElement('input');
        inputField.type = 'text';
        inputField.placeholder = 'https://www.youtube.com/watch?v=...';
        inputField.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 2px solid #444;
            border-radius: 5px;
            background-color: #333;
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
            box-sizing: border-box;
        `;
        this.inputContainer.appendChild(inputField);
        
        // Create load button
        const loadButton = document.createElement('button');
        loadButton.textContent = 'Load Video';
        loadButton.style.cssText = `
            padding: 12px 24px;
            background-color: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        `;
        loadButton.addEventListener('click', () => {
            const url = inputField.value.trim();
            if (url) {
                this.loadYouTubeVideo(url);
            } else {
                this.showError('Please enter a YouTube URL');
            }
        });
        this.inputContainer.appendChild(loadButton);
        
        // Add paste button for mobile
        const pasteButton = document.createElement('button');
        pasteButton.textContent = 'Paste URL';
        pasteButton.style.cssText = `
            padding: 10px 20px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            margin-left: 10px;
            transition: all 0.2s ease;
        `;
        pasteButton.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                inputField.value = text;
            } catch (err) {
                this.showError('Failed to read clipboard');
            }
        });
        this.inputContainer.appendChild(pasteButton);
        
        // Add input container to game container
        this.gameContainer.appendChild(this.inputContainer);
        
        // Focus on input field
        setTimeout(() => inputField.focus(), 100);
    }
    
    /**
     * Load YouTube video from URL
     */
    loadYouTubeVideo(url) {
        // Extract video ID from URL
        this.videoId = this.extractYouTubeID(url);
        
        if (!this.videoId) {
            this.showError('Invalid YouTube URL');
            return;
        }
        
        // Remove input container if exists
        if (this.inputContainer && this.inputContainer.parentNode) {
            this.inputContainer.parentNode.removeChild(this.inputContainer);
            this.inputContainer = null;
        }
        
        // Create iframe for YouTube player
        this.iframe = document.createElement('iframe');
        this.iframe.src = `https://www.youtube.com/embed/${this.videoId}?autoplay=1&rel=0&modestbranding=1`;
        this.iframe.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 70vh;
            max-height: 800px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        `;
        
        // Handle iframe load event
        this.iframe.onload = () => {
            botReply('Video loaded successfully!');
        };
        
        // Handle iframe error event
        this.iframe.onerror = () => {
            botReply('Error loading the video. Please check the URL and try again.');
            this.closeGame();
        };
        
        // Add iframe to container
        this.gameContainer.appendChild(this.iframe);
    }
    
    /**
     * Extract YouTube video ID from URL - UPDATED to handle Shorts
     */
    extractYouTubeID(url) {
        // Clean the URL first
        url = url.trim();
        
        // Regular expressions to match YouTube URL patterns
        const regexPatterns = [
            // Standard watch URL
            /(?:youtube\.com\/watch\?v=|&v=)([^&\n?#]+)/,
            // Shortened URL
            /(?:youtu\.be\/)([^&\n?#]+)/,
            // Embed URL
            /(?:youtube\.com\/embed\/)([^&\n?#]+)/,
            // v URL
            /(?:youtube\.com\/v\/)([^&\n?#]+)/,
            // Shorts URL - NEW
            /(?:youtube\.com\/shorts\/)([^&\n?#]+)/,
            // Live URL
            /(?:youtube\.com\/live\/)([^&\n?#]+)/,
            // Fallback pattern
            /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=|shorts\/|live\/)([^#&?]*).*/
        ];
        
        for (const regex of regexPatterns) {
            const match = url.match(regex);
            if (match && match[1] && match[1].length === 11) {
                return match[1];
            }
        }
        
        // Special handling for shorts URLs with parameters
        if (url.includes('youtube.com/shorts/')) {
            const shortsMatch = url.match(/youtube\.com\/shorts\/([^&\n?#]+)/);
            if (shortsMatch && shortsMatch[1]) {
                // Extract just the ID part (before any parameters)
                const id = shortsMatch[1].split('?')[0];
                if (id.length === 11) {
                    return id;
                }
            }
        }
        
        return Null;
    }
    
    /**
     * Show error message
     */
    showError(message) {
        // Create error element
        const errorElement = document.createElement('div');
        errorElement.textContent = message;
        errorElement.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(244, 67, 54, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        `;
        
        // Add to container
        this.gameContainer.appendChild(errorElement);
        
        // Remove after 3 seconds
        setTimeout(() => {
            if (errorElement.parentNode) {
                errorElement.parentNode.removeChild(errorElement);
            }
        }, 3000);
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ff0000, #cc0000);
            border-radius: 4px;
            box-shadow: 0 0 10px #ff0000;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(255, 0, 0, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(255, 0, 0, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust iframe size based on fullscreen state
        if (this.iframe) {
            if (this.isFullscreen) {
                this.iframe.style.width = '98%';
                this.iframe.style.height = '95vh';
            } else {
                this.iframe.style.width = '90%';
                this.iframe.style.height = '70vh';
            }
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.iframe = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputContainer = null;
        this.videoId = null;
        
        botReply("YouTube Player closed. Thank you!");
    }
}

// Create a singleton instance
const youtubeScreenLoader = new YouTubeScreenLoader();

// Add this to your AI's command handling
if (/youtube|play youtube|watch youtube/i.test(userInputRaw)) {
    // Check if a URL was provided in the input
    const urlMatch = userInputRaw.match(/(https?:\/\/[^\s]+)/);
    if (urlMatch) {
        youtubeScreenLoader.loadYouTube(urlMatch[1]);
    } else {
        youtubeScreenLoader.loadYouTube();
    }
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    youtubeScreenLoader.closeGame();
    return;
}
class ScreenDrawloader {
    constructor() {
        console.log("ScreenDrawloader constructor initialized");
        
        this.drawBoard = {
            name: 'DRAW BOARD',
            instructions: 'Draw on the canvas using your mouse or touch. Save your artwork when done!'
        };
        
        this.gameContainer = null;
        this.canvas = null;
        this.ctx = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.isDrawing = false;
        this.currentColor = '#000000';
        this.currentSize = 5;
        this.isEraser = false;
        this.fileName = 'my-drawing';
        this.isTextMode = false;
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.currentRoomId = null;
        this.drawMode = 'normal';
        this.userSessionId = this.generateSessionId();
        this.currentUsername = '';
        this.strokesRef = null;
        this.strokesListener = null;
        this.currentStroke = null;
        this.isLiveMode = false;
        
        // Drawing synchronization
        this.remoteStrokes = [];
        this.canvasSizeRef = null;
        this.lastStrokeUpdate = 0;
        this.strokeUpdateInterval = 100; // ms between stroke updates
        
        // User management
        this.usersRef = null;
        this.usersListener = null;
        this.usersList = [];
        this.roomCreatorId = null;
        
        console.log("ScreenDrawloader constructor completed");
    }
    
    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'drawer_' + Math.random().toString(36).substr(2, 9);
    }
    
    /**
     * Load the Draw Board
     */
    loadDrawBoard() {
        console.log("loadDrawBoard called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("Draw board already active");
                this.showNotification(`The ${this.drawBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("Draw board loaded successfully");
            this.showNotification(`${this.drawBoard.name} loaded! ${this.drawBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadDrawBoard:", error);
            this.showNotification("Sorry, there was an error loading the drawing board. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select Drawing Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Normal Draw Button
        const normalDrawBtn = document.createElement('button');
        normalDrawBtn.textContent = 'Normal Draw';
        normalDrawBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        normalDrawBtn.addEventListener('click', () => {
            this.drawMode = 'normal';
            this.isLiveMode = false;
            this.gameContainer.innerHTML = '';
            this.createDrawBoard();
        });
        modeContainer.appendChild(normalDrawBtn);
        
        // Live Draw Button
        const liveDrawBtn = document.createElement('button');
        liveDrawBtn.textContent = 'Live Draw';
        liveDrawBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        liveDrawBtn.addEventListener('click', () => {
            this.drawMode = 'live';
            this.isLiveMode = true;
            this.gameContainer.innerHTML = '';
            this.createLiveDrawSetup();
        });
        modeContainer.appendChild(liveDrawBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Live Draw Setup Screen
     */
    createLiveDrawSetup() {
        const setupContainer = document.createElement('div');
        setupContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Live Draw Setup';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        setupContainer.appendChild(title);
        
        // Username input
        const usernameContainer = document.createElement('div');
        usernameContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const usernameLabel = document.createElement('label');
        usernameLabel.textContent = 'Your Name:';
        usernameLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        `;
        usernameContainer.appendChild(usernameLabel);
        
        const usernameInput = document.createElement('input');
        usernameInput.type = 'text';
        usernameInput.placeholder = 'Enter your name';
        usernameInput.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        `;
        usernameContainer.appendChild(usernameInput);
        setupContainer.appendChild(usernameContainer);
        
        // Room ID input
        const roomContainer = document.createElement('div');
        roomContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const roomLabel = document.createElement('label');
        roomLabel.textContent = 'Room ID (leave empty to create new room):';
        roomLabel.style.cssText = `
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        `;
        roomContainer.appendChild(roomLabel);
        
        const roomInput = document.createElement('input');
        roomInput.type = 'text';
        roomInput.placeholder = 'Enter room ID or leave empty';
        roomInput.style.cssText = `
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            box-sizing: border-box;
        `;
        roomContainer.appendChild(roomInput);
        setupContainer.appendChild(roomContainer);
        
        // Start Live Draw Button
        const startBtn = document.createElement('button');
        startBtn.textContent = 'Start Live Draw';
        startBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        startBtn.addEventListener('click', () => {
            const username = usernameInput.value.trim();
            if (!username) {
                this.showNotification('Please enter your name');
                return;
            }
            
            this.currentUsername = username;
            
            const roomId = roomInput.value.trim();
            if (roomId) {
                this.currentRoomId = roomId;
            } else {
                // Generate a new room ID
                this.currentRoomId = 'room_' + Date.now();
                this.roomCreatorId = this.userSessionId;
                this.showNotification(`New room created: ${this.currentRoomId}`);
            }
            
            // Initialize Firebase
            this.initializeFirebase(() => {
                this.gameContainer.innerHTML = '';
                this.createDrawBoard();
                this.setupLiveDrawing();
            });
        });
        setupContainer.appendChild(startBtn);
        
        this.gameContainer.appendChild(setupContainer);
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Setup Live Drawing
     */
    setupLiveDrawing() {
        if (!this.isFirebaseInitialized || !this.currentRoomId) return;
        
        // Create a reference to the strokes in this room
        this.strokesRef = this.db.ref(`drawings/${this.currentRoomId}/strokes`);
        
        // Create a reference for canvas size synchronization
        this.canvasSizeRef = this.db.ref(`drawings/${this.currentRoomId}/canvasSize`);
        
        // Create a reference for users in the room
        this.usersRef = this.db.ref(`drawings/${this.currentRoomId}/users`);
        
        // Add current user to the room
        this.addUserToRoom();
        
        // Synchronize canvas size
        this.syncCanvasSize();
        
        // Listen for new strokes
        this.strokesListener = this.strokesRef.on('child_added', (snapshot) => {
            const stroke = snapshot.val();
            if (stroke.userId !== this.userSessionId) {
                this.addRemoteStroke(stroke);
            }
        });
        
        // Listen for stroke updates
        this.strokesRef.on('child_changed', (snapshot) => {
            const stroke = snapshot.val();
            if (stroke.userId !== this.userSessionId) {
                this.updateRemoteStroke(stroke);
            }
        });
        
        // Listen for clear commands
        this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).on('value', (snapshot) => {
            const clearCommand = snapshot.val();
            if (clearCommand && clearCommand.userId !== this.userSessionId) {
                this.clearCanvas();
            }
        });
        
        // Listen for users in the room
        this.usersListener = this.usersRef.on('value', (snapshot) => {
            this.updateUsersList(snapshot.val());
        });
        
        // Show room info
        this.showRoomInfo();
        
        // Show users list
        this.showUsersList();
    }
    
    /**
     * Add user to the room
     */
    addUserToRoom() {
        if (!this.usersRef) return;
        
        const userData = {
            id: this.userSessionId,
            name: this.currentUsername,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isCreator: this.userSessionId === this.roomCreatorId
        };
        
        this.usersRef.child(this.userSessionId).set(userData);
        
        // If this is the first user, set as creator
        if (!this.roomCreatorId) {
            this.roomCreatorId = this.userSessionId;
            this.usersRef.child(this.userSessionId).update({ isCreator: true });
        }
    }
    
    /**
     * Update users list
     */
    updateUsersList(usersData) {
        if (!usersData) {
            this.usersList = [];
            this.updateUsersListUI();
            return;
        }
        
        this.usersList = Object.values(usersData);
        this.updateUsersListUI();
    }
    
    /**
     * Update users list UI
     */
    updateUsersListUI() {
        if (!this.usersListContainer) return;
        
        this.usersListContainer.innerHTML = '';
        
        if (this.usersList.length === 0) {
            this.usersListContainer.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">No users in room</div>';
            return;
        }
        
        this.usersList.forEach(user => {
            const userItem = document.createElement('div');
            userItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px 12px;
                margin-bottom: 5px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                font-size: 14px;
            `;
            
            const userInfo = document.createElement('div');
            userInfo.innerHTML = `
                <div style="font-weight: bold; color: ${user.id === this.userSessionId ? '#4CAF50' : '#333'};">
                    ${user.name} ${user.isCreator ? '(Creator)' : ''}
                </div>
                <div style="font-size: 12px; color: #666;">ID: ${user.id.substring(0, 8)}...</div>
            `;
            userItem.appendChild(userInfo);
            
            // Add delete button if current user is creator or deleting self
            if (this.userSessionId === this.roomCreatorId || user.id === this.userSessionId) {
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = user.id === this.userSessionId ? 'Leave' : 'Remove';
                deleteBtn.style.cssText = `
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    background: ${user.id === this.userSessionId ? '#ff9800' : '#f44336'};
                    color: white;
                    border: none;
                    cursor: pointer;
                `;
                deleteBtn.addEventListener('click', () => {
                    this.removeUserFromRoom(user.id);
                });
                userItem.appendChild(deleteBtn);
            }
            
            this.usersListContainer.appendChild(userItem);
        });
    }
    
    /**
     * Remove user from room
     */
    removeUserFromRoom(userId) {
        if (!this.usersRef) return;
        
        // Remove user from Firebase
        this.usersRef.child(userId).remove();
        
        // If removing self, close the game
        if (userId === this.userSessionId) {
            this.showNotification('You left the room');
            this.closeGame();
            return;
        }
        
        // Remove user's strokes
        if (this.strokesRef) {
            this.strokesRef.once('value', (snapshot) => {
                const strokes = snapshot.val();
                if (strokes) {
                    Object.entries(strokes).forEach(([strokeId, stroke]) => {
                        if (stroke.userId === userId) {
                            this.strokesRef.child(strokeId).remove();
                        }
                    });
                }
            });
        }
        
        this.showNotification('User removed from room');
    }
    
    /**
     * Show users list
     */
    showUsersList() {
        // Create users list container
        this.usersListContainer = document.createElement('div');
        
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
            // Mobile layout - position at bottom with less height
            this.usersListContainer.style.cssText = `
                position: fixed;
                bottom: 80px;
                right: 10px;
                width: calc(100% - 20px);
                max-height: 150px;
                overflow-y: auto;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                padding: 10px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                z-index: 9999;
            `;
        } else {
            // Desktop layout - position at top right
            this.usersListContainer.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                width: 250px;
                max-height: 300px;
                overflow-y: auto;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                z-index: 9999;
            `;
        }
        
        const title = document.createElement('h3');
        title.textContent = 'Users in Room';
        title.style.cssText = `
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
            text-align: center;
        `;
        this.usersListContainer.appendChild(title);
        
        this.gameContainer.appendChild(this.usersListContainer);
        this.updateUsersListUI();
    }
    
    /**
     * Show room info
     */
    showRoomInfo() {
        const roomInfo = document.createElement('div');
        roomInfo.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            max-width: 80%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        `;
        roomInfo.textContent = `Room: ${this.currentRoomId}`;
        this.gameContainer.appendChild(roomInfo);
    }
    
    /**
     * Synchronize canvas size between users
     */
    syncCanvasSize() {
        // Send current canvas size
        this.canvasSizeRef.set({
            width: this.canvas.width,
            height: this.canvas.height,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        
        // Listen for canvas size changes
        this.canvasSizeRef.on('value', (snapshot) => {
            const canvasSize = snapshot.val();
            if (canvasSize && canvasSize.width && canvasSize.height) {
                // Adjust canvas if size is different
                if (this.canvas.width !== canvasSize.width || this.canvas.height !== canvasSize.height) {
                    this.canvas.width = canvasSize.width;
                    this.canvas.height = canvasSize.height;
                    console.log("Canvas size synchronized:", canvasSize);
                    this.redrawCanvas();
                }
            }
        });
    }
    
    /**
     * Create the Draw Board
     */
    createDrawBoard() {
        // Create canvas
        this.canvas = document.createElement('canvas');
        this.canvas.width = 800;
        this.canvas.height = 600;
        this.canvas.style.cssText = `
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        `;
        
        // Get context
        this.ctx = this.canvas.getContext('2d');
        
        // Create toolbar
        const toolbar = document.createElement('div');
        toolbar.style.cssText = `
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            flex-wrap: wrap;
        `;
        
        // Color picker
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.value = this.currentColor;
        colorPicker.style.cssText = `
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `;
        colorPicker.addEventListener('change', (e) => {
            this.currentColor = e.target.value;
            this.isEraser = false;
            this.isTextMode = false;
            // Update button states
            eraserBtn.style.background = '#f44336';
            textBtn.style.background = '#9c27b0';
        });
        toolbar.appendChild(colorPicker);
        
        // Brush size
        const sizeLabel = document.createElement('span');
        sizeLabel.textContent = 'Size:';
        sizeLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        toolbar.appendChild(sizeLabel);
        
        const sizeSlider = document.createElement('input');
        sizeSlider.type = 'range';
        sizeSlider.min = 1;
        sizeSlider.max = 50;
        sizeSlider.value = this.currentSize;
        sizeSlider.style.cssText = `
            width: 100px;
        `;
        sizeSlider.addEventListener('input', (e) => {
            this.currentSize = parseInt(e.target.value);
        });
        toolbar.appendChild(sizeSlider);
        
        // Eraser button
        const eraserBtn = document.createElement('button');
        eraserBtn.textContent = 'Eraser';
        eraserBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #f44336;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        eraserBtn.addEventListener('click', () => {
            this.isEraser = !this.isEraser;
            this.isTextMode = false;
            eraserBtn.style.background = this.isEraser ? '#d32f2f' : '#f44336';
            textBtn.style.background = '#9c27b0'; // Reset text button
        });
        toolbar.appendChild(eraserBtn);
        
        // Text button
        const textBtn = document.createElement('button');
        textBtn.textContent = 'Text';
        textBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #9c27b0;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        textBtn.addEventListener('click', () => {
            this.isTextMode = !this.isTextMode;
            this.isEraser = false;
            textBtn.style.background = this.isTextMode ? '#7b1fa2' : '#9c27b0';
            eraserBtn.style.background = '#f44336'; // Reset eraser button
        });
        toolbar.appendChild(textBtn);
        
        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear Drawing';
        clearBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #ff9800;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        clearBtn.addEventListener('click', () => {
            this.clearCanvas();
        });
        toolbar.appendChild(clearBtn);
        
        // Save button
        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save Drawing';
        saveBtn.style.cssText = `
            padding: 8px 15px;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        `;
        saveBtn.addEventListener('click', () => {
            this.saveDrawing();
        });
        toolbar.appendChild(saveBtn);
        
        // Add elements to container
        this.gameContainer.appendChild(toolbar);
        this.gameContainer.appendChild(this.canvas);
        
        // Set up drawing events
        this.setupDrawingEvents();
    }
    
    /**
     * Set up drawing events
     */
    setupDrawingEvents() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (this.isTextMode) {
                // Handle text mode
                this.handleTextMode(x, y);
                return;
            }
            
            this.isDrawing = true;
            
            if (this.isLiveMode) {
                this.startNewStroke(x, y);
            } else {
                this.startLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('mousemove', (e) => {
            if (!this.isDrawing || this.isTextMode) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (this.isLiveMode) {
                this.updateCurrentStroke(x, y);
            } else {
                this.continueLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('mouseup', () => {
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
        
        this.canvas.addEventListener('mouseleave', () => {
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = this.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (this.isTextMode) {
                // Handle text mode
                this.handleTextMode(x, y);
                return;
            }
            
            this.isDrawing = true;
            
            if (this.isLiveMode) {
                this.startNewStroke(x, y);
            } else {
                this.startLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!this.isDrawing || this.isTextMode) return;
            
            const rect = this.canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (this.isLiveMode) {
                this.updateCurrentStroke(x, y);
            } else {
                this.continueLocalDrawing(x, y);
            }
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (this.isDrawing && !this.isTextMode) {
                this.isDrawing = false;
                
                if (this.isLiveMode) {
                    this.finalizeCurrentStroke();
                } else {
                    this.endLocalDrawing();
                }
            }
        });
    }
    
    /**
     * Handle text mode
     */
    handleTextMode(x, y) {
        const text = prompt('Enter text:');
        if (text) {
            this.drawText(text, x, y);
            
            // If in live mode, send text to Firebase
            if (this.isLiveMode && this.isFirebaseInitialized) {
                this.sendTextToFirebase(text, x, y);
            }
        }
    }
    
    /**
     * Draw text on canvas
     */
    drawText(text, x, y) {
        this.ctx.font = `${this.currentSize * 3}px Arial`;
        this.ctx.fillStyle = this.currentColor;
        this.ctx.fillText(text, x, y);
    }
    
    /**
     * Send text to Firebase
     */
    sendTextToFirebase(text, x, y) {
        const textId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
        
        const textData = {
            id: textId,
            userId: this.userSessionId,
            username: this.currentUsername,
            type: 'text',
            content: text,
            x: x,
            y: y,
            color: this.currentColor,
            size: this.currentSize,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.strokesRef.child(textId).set(textData);
    }
    
    /**
     * Start a new stroke and send it to Firebase
     */
    startNewStroke(x, y) {
        if (!this.isLiveMode || !this.isFirebaseInitialized) return;
        
        // Generate a unique ID for this stroke
        const strokeId = 'stroke_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
        
        // Create the stroke object
        this.currentStroke = {
            id: strokeId,
            userId: this.userSessionId,
            username: this.currentUsername,
            color: this.currentColor,
            size: this.currentSize,
            isEraser: this.isEraser,
            points: [{x, y}],
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isComplete: false
        };
        
        // Send to Firebase
        this.strokesRef.child(strokeId).set(this.currentStroke);
        
        // Draw locally
        this.startLocalDrawing(x, y);
    }
    
    /**
     * Update the current stroke with a new point and send to Firebase
     */
    updateCurrentStroke(x, y) {
        if (!this.isLiveMode || !this.isFirebaseInitialized || !this.currentStroke) return;
        
        // Add the new point
        this.currentStroke.points.push({x, y});
        
        // Throttle updates to avoid excessive Firebase writes
        const now = Date.now();
        if (now - this.lastStrokeUpdate > this.strokeUpdateInterval) {
            // Send to Firebase
            this.strokesRef.child(this.currentStroke.id).update({
                points: this.currentStroke.points,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            this.lastStrokeUpdate = now;
        }
        
        // Draw locally
        this.continueLocalDrawing(x, y);
    }
    
    /**
     * Finalize the current stroke and send to Firebase
     */
    finalizeCurrentStroke() {
        if (!this.isLiveMode || !this.isFirebaseInitialized || !this.currentStroke) return;
        
        // Mark as complete
        this.currentStroke.isComplete = true;
        
        // Send to Firebase
        this.strokesRef.child(this.currentStroke.id).update({
            isComplete: true,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        });
        
        // End local drawing
        this.endLocalDrawing();
        
        // Reset current stroke
        this.currentStroke = null;
    }
    
    /**
     * Start local drawing (non-live mode)
     */
    startLocalDrawing(x, y) {
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineJoin = 'round';
        this.ctx.lineCap = 'round';
        
        if (this.isEraser) {
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.lineWidth = this.currentSize * 2;
        } else {
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.strokeStyle = this.currentColor;
            this.ctx.lineWidth = this.currentSize;
        }
    }
    
    /**
     * Continue local drawing (non-live mode)
     */
    continueLocalDrawing(x, y) {
        this.ctx.lineTo(x, y);
        this.ctx.stroke();
    }
    
    /**
     * End local drawing (non-live mode)
     */
    endLocalDrawing() {
        this.ctx.closePath();
        this.ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
    }
    
    /**
     * Add a remote stroke to the canvas
     */
    addRemoteStroke(stroke) {
        if (!stroke) return;
        
        // Add to remote strokes array
        this.remoteStrokes.push(stroke);
        
        // Handle different types of remote data
        if (stroke.type === 'text') {
            // Draw text
            this.drawText(stroke.content, stroke.x, stroke.y);
        } else {
            // Draw stroke
            this.drawStroke(stroke);
        }
    }
    
    /**
     * Update a remote stroke on the canvas
     */
    updateRemoteStroke(stroke) {
        if (!stroke) return;
        
        // Find and update the stroke in the remote strokes array
        const index = this.remoteStrokes.findIndex(s => s.id === stroke.id);
        if (index !== -1) {
            this.remoteStrokes[index] = stroke;
        } else {
            this.remoteStrokes.push(stroke);
        }
        
        // Redraw the canvas
        this.redrawCanvas();
    }
    
    /**
     * Draw a stroke on the canvas
     */
    drawStroke(stroke) {
        if (!stroke || !stroke.points || stroke.points.length === 0) return;
        
        this.ctx.beginPath();
        this.ctx.lineJoin = 'round';
        this.ctx.lineCap = 'round';
        
        // Set the drawing style
        if (stroke.isEraser) {
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.lineWidth = stroke.size * 2;
        } else {
            this.ctx.globalCompositeOperation = 'source-over';
            this.ctx.strokeStyle = stroke.color;
            this.ctx.lineWidth = stroke.size;
        }
        
        // Draw the stroke
        this.ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
            this.ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        }
        
        this.ctx.stroke();
        this.ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
    }
    
    /**
     * Redraw the entire canvas
     */
    redrawCanvas() {
        if (!this.canvas || !this.ctx) return;
        
        // Clear the canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Redraw all remote strokes and text
        this.remoteStrokes.forEach(item => {
            if (item.type === 'text') {
                // Draw text
                this.drawText(item.content, item.x, item.y);
            } else {
                // Draw stroke
                this.drawStroke(item);
            }
        });
    }
    
    /**
     * Clear the canvas and notify other users in live mode
     */
    clearCanvas() {
        // Clear the local canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Clear remote strokes
        this.remoteStrokes = [];
        
        // In live mode, send clear command to Firebase
        if (this.isLiveMode && this.isFirebaseInitialized) {
            this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).set({
                userId: this.userSessionId,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            
            // Remove the clear command after a delay
            setTimeout(() => {
                this.db.ref(`drawings/${this.currentRoomId}/clearCommand`).remove();
            }, 1000);
        }
    }
    
    /**
     * Save the drawing
     */
    saveDrawing() {
        const link = document.createElement('a');
        link.download = `${this.fileName}.png`;
        link.href = this.canvas.toDataURL();
        link.click();
        this.showNotification('Drawing saved!');
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase
        if (this.isLiveMode && this.isFirebaseInitialized) {
            this.cleanupFirebase();
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.canvas = null;
        this.ctx = null;
        this.remoteStrokes = [];
        this.isTextMode = false;
        
        console.log("Draw board closed");
    }
    
    /**
     * Clean up Firebase listeners
     */
    cleanupFirebase() {
        if (this.strokesListener) {
            this.strokesRef.off('child_added', this.strokesListener);
            this.strokesRef.off('child_changed', this.strokesListener);
            this.strokesListener = null;
        }
        
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.canvasSizeRef) {
            this.canvasSizeRef.off();
            this.canvasSizeRef = null;
        }
        
        // Remove user from room
        if (this.usersRef && this.userSessionId) {
            this.usersRef.child(this.userSessionId).remove();
        }
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let screendrawloader = null;
// Function to get or create the draw board instance
function getDrawBoard() {
    if (!screendrawloader) {
        console.log("Creating new ScreenDrawloader instance");
        screendrawloader = new ScreenDrawloader();
    }
    return screendrawloader;
}
// Command handler
function handleDrawCommand(input) {
    if (typeof input !== 'string') return false;
    
    const drawKeywords = ['draw', 'draw board', 'drawing', 'sketch', 'paint', 'canvas'];
    const normalizedInput = input.toLowerCase().trim();
    
    return drawKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute draw command
function executeDrawCommand() {
    try {
        const drawBoard = getDrawBoard();
        if (drawBoard && typeof drawBoard.loadDrawBoard === 'function') {
            console.log("Executing draw command");
            drawBoard.loadDrawBoard();
        } else {
            console.error("Invalid draw board instance");
            botReply("Sorry, the drawing board is not available right now.");
        }
    } catch (error) {
        console.error("Error executing draw command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleDrawCommand(userInputRaw)) {
    console.log("Draw command detected");
    executeDrawCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen/i.test(userInputRaw)) {
    if (screendrawloader && screendrawloader.isActive) {
        screendrawloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the draw board manually (call from browser console)
window.testDrawBoard = function() {
    console.log("Testing draw board...");
    executeDrawCommand();
};
// Add this to check if the draw board is loaded
window.checkDrawBoard = function() {
    console.log("screendrawloader exists:", !!screendrawloader);
    console.log("screendrawloader type:", typeof screendrawloader);
    console.log("ScreenDrawloader class exists:", typeof ScreenDrawloader);
};


class LoadHtmlScreenLoader {
    constructor() {
        console.log("LoadHtmlScreenLoader constructor initialized");
        
        this.htmlBoard = {
            name: 'HTML SCREEN',
            instructions: 'Admin: Load HTML code to display. Users: View the loaded HTML content.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.isAdmin = false; // Default to user mode
        this.htmlContent = '';
        this.currentHtmlId = null;
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.htmlRef = null;
        this.htmlListener = null;
        
        console.log("LoadHtmlScreenLoader constructor completed");
    }
    
    /**
     * Load the HTML Screen
     */
    loadHtmlScreen() {
        console.log("loadHtmlScreen called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("HTML screen already active");
                this.showNotification(`The ${this.htmlBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("HTML screen loaded successfully");
            this.showNotification(`${this.htmlBoard.name} loaded! ${this.htmlBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadHtmlScreen:", error);
            this.showNotification("Sorry, there was an error loading the HTML screen. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select HTML Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Admin Mode Button
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'Admin Mode';
        adminBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        adminBtn.addEventListener('click', () => {
            this.isAdmin = true;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createAdminInterface();
            });
        });
        modeContainer.appendChild(adminBtn);
        
        // User Mode Button
        const userBtn = document.createElement('button');
        userBtn.textContent = 'User Mode';
        userBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        userBtn.addEventListener('click', () => {
            this.isAdmin = false;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createUserInterface();
            });
        });
        modeContainer.appendChild(userBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Admin Interface
     */
    createAdminInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'HTML Admin Panel';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create textarea for HTML input
        const textareaContainer = document.createElement('div');
        textareaContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            margin-bottom: 20px;
        `;
        
        const textareaLabel = document.createElement('label');
        textareaLabel.textContent = 'Enter HTML Code:';
        textareaLabel.style.cssText = `
            display: block;
            margin-bottom: 10px;
            color: white;
            font-weight: bold;
        `;
        textareaContainer.appendChild(textareaLabel);
        
        const textarea = document.createElement('textarea');
        textarea.id = 'htmlTextarea';
        textarea.placeholder = 'Enter your HTML code here...';
        textarea.style.cssText = `
            width: 100%;
            height: 300px;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        `;
        textareaContainer.appendChild(textarea);
        this.gameContainer.appendChild(textareaContainer);
        
        // Create buttons container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        `;
        
        // Load HTML button
        const loadBtn = document.createElement('button');
        loadBtn.textContent = 'Load HTML';
        loadBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        loadBtn.addEventListener('click', () => {
            const textarea = document.getElementById('htmlTextarea');
            this.htmlContent = textarea.value;
            this.saveHtmlToFirebase();
            this.showNotification('HTML code saved successfully!');
        });
        buttonsContainer.appendChild(loadBtn);
        
        // Preview button
        const previewBtn = document.createElement('button');
        previewBtn.textContent = 'Preview';
        previewBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        previewBtn.addEventListener('click', () => {
            const textarea = document.getElementById('htmlTextarea');
            this.htmlContent = textarea.value;
            this.showHtmlPreview();
        });
        buttonsContainer.appendChild(previewBtn);
        
        // Share Code button
        const shareBtn = document.createElement('button');
        shareBtn.textContent = 'Share Code';
        shareBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #9c27b0, #7b1fa2);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        shareBtn.addEventListener('click', () => {
            this.shareHtmlCode();
        });
        buttonsContainer.appendChild(shareBtn);
        
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        deleteBtn.addEventListener('click', () => {
            this.deleteHtmlContent();
        });
        buttonsContainer.appendChild(deleteBtn);
        
        // Back to Mode Selection button
        const backBtn = document.createElement('button');
        backBtn.textContent = 'Back to Mode Selection';
        backBtn.style.cssText = `
            padding: 12px 20px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            background: linear-gradient(45deg, #607D8B, #455A64);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        backBtn.addEventListener('click', () => {
            this.backToModeSelection();
        });
        buttonsContainer.appendChild(backBtn);
        
        this.gameContainer.appendChild(buttonsContainer);
        
        // Create preview container
        const previewContainer = document.createElement('div');
        previewContainer.id = 'htmlPreview';
        previewContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            height: 400px;
            border: 2px dashed #ccc;
            border-radius: 10px;
            overflow: auto;
            background: white;
            margin-bottom: 20px;
            display: none;
        `;
        this.gameContainer.appendChild(previewContainer);
        
        // Load existing HTML content if available
        this.loadHtmlFromFirebase((html) => {
            if (html) {
                const textarea = document.getElementById('htmlTextarea');
                textarea.value = html;
            }
        });
    }
    
    /**
     * Create User Interface
     */
    createUserInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'HTML Viewer';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create status message
        const statusMessage = document.createElement('div');
        statusMessage.id = 'statusMessage';
        statusMessage.textContent = 'Loading HTML content...';
        statusMessage.style.cssText = `
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
        `;
        this.gameContainer.appendChild(statusMessage);
        
        // Create HTML container
        const htmlContainer = document.createElement('div');
        htmlContainer.id = 'htmlContainer';
        htmlContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            min-height: 500px;
            border: none;
            border-radius: 10px;
            overflow: auto;
            background: white;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        this.gameContainer.appendChild(htmlContainer);
        
        // Load HTML from Firebase
        this.loadHtmlFromFirebase((html) => {
            if (html) {
                statusMessage.textContent = 'HTML Content Loaded';
                this.displayHtmlContent(html);
            } else {
                statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
                this.clearHtmlContent();
            }
        });
        
        // Set up listener for HTML updates
        this.setupHtmlListener();
    }
    
    /**
     * Go back to mode selection screen
     */
    backToModeSelection() {
        // Clean up Firebase listeners
        if (this.htmlListener) {
            this.htmlRef.off('value', this.htmlListener);
            this.htmlListener = null;
        }
        
        // Clear the container
        this.gameContainer.innerHTML = '';
        
        // Reset mode
        this.isAdmin = false;
        
        // Create mode selection screen
        this.createModeSelectionScreen();
    }
    
    /**
     * Show HTML Preview (for admin)
     */
    showHtmlPreview() {
        const previewContainer = document.getElementById('htmlPreview');
        if (previewContainer) {
            previewContainer.style.display = 'block';
            previewContainer.innerHTML = this.htmlContent;
        }
    }
    
    /**
     * Display HTML Content (for user)
     */
    displayHtmlContent(html) {
        const htmlContainer = document.getElementById('htmlContainer');
        if (htmlContainer) {
            htmlContainer.innerHTML = html;
        }
    }
    
    /**
     * Clear HTML Content (for user)
     */
    clearHtmlContent() {
        const htmlContainer = document.getElementById('htmlContainer');
        const statusMessage = document.getElementById('statusMessage');
        
        if (htmlContainer) {
            htmlContainer.innerHTML = '';
            htmlContainer.style.minHeight = '500px';
            htmlContainer.style.display = 'flex';
            htmlContainer.style.justifyContent = 'center';
            htmlContainer.style.alignItems = 'center';
            htmlContainer.innerHTML = '<div style="color: #999; font-size: 18px; text-align: center;">No HTML content available</div>';
        }
        
        if (statusMessage) {
            statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
        }
    }
    
    /**
     * Share HTML Code (copy to clipboard)
     */
    shareHtmlCode() {
        const textarea = document.getElementById('htmlTextarea');
        const htmlCode = textarea.value;
        
        if (!htmlCode.trim()) {
            this.showNotification('No HTML code to share!');
            return;
        }
        
        // Copy to clipboard
        navigator.clipboard.writeText(htmlCode).then(() => {
            this.showNotification('HTML code copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy: ', err);
            this.showNotification('Failed to copy HTML code.');
        });
    }
    
    /**
     * Delete HTML Content
     */
    deleteHtmlContent() {
        // Confirm deletion
        const confirmDelete = confirm('Are you sure you want to delete the HTML content? This will clear it for all users.');
        if (!confirmDelete) return;
        
        // Clear textarea
        const textarea = document.getElementById('htmlTextarea');
        textarea.value = '';
        
        // Clear preview
        const previewContainer = document.getElementById('htmlPreview');
        if (previewContainer) {
            previewContainer.style.display = 'none';
            previewContainer.innerHTML = '';
        }
        
        // Clear Firebase
        this.htmlContent = '';
        this.saveHtmlToFirebase();
        this.showNotification('HTML content deleted successfully!');
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            this.htmlRef = this.db.ref('htmlContent/currentHtml');
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Save HTML to Firebase
     */
    saveHtmlToFirebase() {
        if (!this.isFirebaseInitialized) return;
        
        const htmlData = {
            content: this.htmlContent,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            updatedBy: this.isAdmin ? 'admin' : 'user'
        };
        
        this.htmlRef.set(htmlData);
    }
    
    /**
     * Load HTML from Firebase
     */
    loadHtmlFromFirebase(callback) {
        if (!this.isFirebaseInitialized) return;
        
        this.htmlRef.once('value', (snapshot) => {
            const data = snapshot.val();
            if (data && data.content) {
                callback(data.content);
            } else {
                callback(null);
            }
        });
    }
    
    /**
     * Setup HTML listener for real-time updates
     */
    setupHtmlListener() {
        if (!this.isFirebaseInitialized || !this.htmlRef) return;
        
        this.htmlListener = this.htmlRef.on('value', (snapshot) => {
            const data = snapshot.val();
            const statusMessage = document.getElementById('statusMessage');
            
            if (data && data.content && !this.isAdmin) {
                statusMessage.textContent = 'HTML Content Loaded';
                this.displayHtmlContent(data.content);
            } else if (!data || !data.content) {
                // HTML content was deleted
                statusMessage.textContent = 'No HTML content available. Please ask admin to load HTML.';
                this.clearHtmlContent();
            }
        });
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Close button (main button)
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 12px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
            transition: all 0.3s ease;
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.closeButton.addEventListener('mouseenter', () => {
            this.closeButton.style.background = '#d32f2f';
            this.closeButton.style.transform = 'scale(1.05)';
        });
        this.closeButton.addEventListener('mouseleave', () => {
            this.closeButton.style.background = '#f44336';
            this.closeButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase listeners
        if (this.htmlListener) {
            this.htmlRef.off('value', this.htmlListener);
            this.htmlListener = null;
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.isAdmin = false;
        this.htmlContent = '';
        
        console.log("HTML screen closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let loadhtmlscreenloader = null;
// Function to get or create the HTML screen instance
function getHtmlScreen() {
    if (!loadhtmlscreenloader) {
        console.log("Creating new LoadHtmlScreenLoader instance");
        loadhtmlscreenloader = new LoadHtmlScreenLoader();
    }
    return loadhtmlscreenloader;
}
// Command handler
function handleHtmlCommand(input) {
    if (typeof input !== 'string') return false;
    
    const htmlKeywords = ['html', 'html screen', 'html viewer', 'html loader', 'html admin'];
    const normalizedInput = input.toLowerCase().trim();
    
    return htmlKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute HTML command
function executeHtmlCommand() {
    try {
        const htmlScreen = getHtmlScreen();
        if (htmlScreen && typeof htmlScreen.loadHtmlScreen === 'function') {
            console.log("Executing HTML command");
            htmlScreen.loadHtmlScreen();
        } else {
            console.error("Invalid HTML screen instance");
            botReply("Sorry, the HTML screen is not available right now.");
        }
    } catch (error) {
        console.error("Error executing HTML command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleHtmlCommand(userInputRaw)) {
    console.log("HTML command detected");
    executeHtmlCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen|cancel/i.test(userInputRaw)) {
    if (loadhtmlscreenloader && loadhtmlscreenloader.isActive) {
        loadhtmlscreenloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the HTML screen manually (call from browser console)
window.testHtmlScreen = function() {
    console.log("Testing HTML screen...");
    executeHtmlCommand();
};
// Add this to check if the HTML screen is loaded
window.checkHtmlScreen = function() {
    console.log("loadhtmlscreenloader exists:", !!loadhtmlscreenloader);
    console.log("loadhtmlscreenloader type:", typeof loadhtmlscreenloader);
    console.log("LoadHtmlScreenLoader class exists:", typeof LoadHtmlScreenLoader);
};


class AVUScreenLoader {
    constructor() {
        console.log("AVUScreenLoader constructor initialized");
        
        this.avuBoard = {
            name: 'ADMIN VIEW USER',
            instructions: 'Admin: View user messages and send replies. Users: Chat with admin.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.cancelButton = null;
        this.isAdmin = false;
        this.currentUserId = null;
        this.usersList = [];
        this.messages = [];
        
        // Firebase properties
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.isFirebaseInitialized = false;
        this.usersRef = null;
        this.messagesRef = null;
        this.usersListener = null;
        this.messagesListener = null;
        
        console.log("AVUScreenLoader constructor completed");
    }
    
    /**
     * Load the AVU Screen
     */
    loadAvuScreen() {
        console.log("loadAvuScreen called");
        
        try {
            // Check if already active
            if (this.isActive) {
                console.log("AVU screen already active");
                this.showNotification(`The ${this.avuBoard.name} is already running! Type 'close screen' to exit first.`);
                return;
            }
            
            // Create container
            this.createGameContainer();
            
            // Create mode selection screen
            this.createModeSelectionScreen();
            
            // Set up action buttons
            this.setupActionButtons();
            
            // Display the board
            this.displayGame();
            
            this.isActive = true;
            console.log("AVU screen loaded successfully");
            this.showNotification(`${this.avuBoard.name} loaded! ${this.avuBoard.instructions}`);
        } catch (error) {
            console.error("Error in loadAvuScreen:", error);
            this.showNotification("Sorry, there was an error loading the AVU screen. Please try again.");
        }
    }
    
    /**
     * Create Mode Selection Screen
     */
    createModeSelectionScreen() {
        const modeContainer = document.createElement('div');
        modeContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 500px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Select Mode';
        title.style.cssText = `
            margin: 0 0 30px 0;
            font-size: 32px;
            color: #333;
        `;
        modeContainer.appendChild(title);
        
        // Admin Mode Button
        const adminBtn = document.createElement('button');
        adminBtn.textContent = 'Admin Mode';
        adminBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        adminBtn.addEventListener('click', () => {
            this.isAdmin = true;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createAdminInterface();
            });
        });
        modeContainer.appendChild(adminBtn);
        
        // User Mode Button
        const userBtn = document.createElement('button');
        userBtn.textContent = 'User Mode';
        userBtn.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #2196F3, #0b7dda);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        `;
        userBtn.addEventListener('click', () => {
            this.isAdmin = false;
            this.gameContainer.innerHTML = '';
            this.initializeFirebase(() => {
                this.createUserInterface();
            });
        });
        modeContainer.appendChild(userBtn);
        
        this.gameContainer.appendChild(modeContainer);
    }
    
    /**
     * Create Admin Interface
     */
    createAdminInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'Admin View User Messages';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            display: block;
            margin: 0 auto 20px auto;
            padding: 10px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        cancelButton.addEventListener('click', () => {
            this.backToModeSelection();
        });
        cancelButton.addEventListener('mouseenter', () => {
            cancelButton.style.background = '#d32f2f';
            cancelButton.style.transform = 'scale(1.05)';
        });
        cancelButton.addEventListener('mouseleave', () => {
            cancelButton.style.background = '#f44336';
            cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(cancelButton);
        
        // Create main container
        const mainContainer = document.createElement('div');
        mainContainer.style.cssText = `
            display: flex;
            width: 90%;
            max-width: 1200px;
            height: 600px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        `;
        
        // Create users list container
        const usersListContainer = document.createElement('div');
        usersListContainer.style.cssText = `
            width: 30%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            border-right: 1px solid rgba(255, 255, 255, 0.3);
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
        `;
        
        const usersListTitle = document.createElement('h3');
        usersListTitle.textContent = 'Users';
        usersListTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: white;
            font-size: 18px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        `;
        usersListContainer.appendChild(usersListTitle);
        
        const usersListContent = document.createElement('div');
        usersListContent.id = 'usersListContent';
        usersListContent.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        usersListContainer.appendChild(usersListContent);
        
        // Create messages container
        const messagesContainer = document.createElement('div');
        messagesContainer.style.cssText = `
            width: 70%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 15px;
            box-sizing: border-box;
        `;
        
        const messagesHeader = document.createElement('div');
        messagesHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        `;
        
        const messagesTitle = document.createElement('h3');
        messagesTitle.textContent = 'Messages';
        messagesTitle.style.cssText = `
            margin: 0;
            color: white;
            font-size: 18px;
        `;
        messagesHeader.appendChild(messagesTitle);
        
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear All';
        clearBtn.style.cssText = `
            padding: 6px 12px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
        `;
        clearBtn.addEventListener('click', () => {
            this.clearAllMessages();
        });
        clearBtn.addEventListener('mouseenter', () => {
            clearBtn.style.background = '#d32f2f';
        });
        clearBtn.addEventListener('mouseleave', () => {
            clearBtn.style.background = '#f44336';
        });
        messagesHeader.appendChild(clearBtn);
        
        messagesContainer.appendChild(messagesHeader);
        
        const messagesContent = document.createElement('div');
        messagesContent.id = 'messagesContent';
        messagesContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
        `;
        messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">Select a user to view messages</div>';
        messagesContainer.appendChild(messagesContent);
        
        // Admin input area
        const adminInputArea = document.createElement('div');
        adminInputArea.id = 'adminInputArea';
        adminInputArea.style.cssText = `
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const adminInputHeader = document.createElement('div');
        adminInputHeader.style.cssText = `
            color: white;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        `;
        adminInputHeader.textContent = 'Send message to user:';
        adminInputArea.appendChild(adminInputHeader);
        
        const adminInputContainer = document.createElement('div');
        adminInputContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const adminInput = document.createElement('input');
        adminInput.id = 'adminInput';
        adminInput.type = 'text';
        adminInput.placeholder = 'Type your message...';
        adminInput.style.cssText = `
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
        `;
        adminInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendAdminMessage();
            }
        });
        adminInputContainer.appendChild(adminInput);
        
        const adminSendBtn = document.createElement('button');
        adminSendBtn.textContent = 'Send';
        adminSendBtn.style.cssText = `
            padding: 10px 15px;
            background: #9c27b0;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        `;
        adminSendBtn.addEventListener('click', () => {
            this.sendAdminMessage();
        });
        adminSendBtn.addEventListener('mouseenter', () => {
            adminSendBtn.style.background = '#7b1fa2';
        });
        adminSendBtn.addEventListener('mouseleave', () => {
            adminSendBtn.style.background = '#9c27b0';
        });
        adminInputContainer.appendChild(adminSendBtn);
        
        adminInputArea.appendChild(adminInputContainer);
        messagesContainer.appendChild(adminInputArea);
        
        mainContainer.appendChild(usersListContainer);
        mainContainer.appendChild(messagesContainer);
        this.gameContainer.appendChild(mainContainer);
        
        // Set up Firebase listeners
        this.setupAdminListeners();
    }
    
    /**
     * Create User Interface
     */
    createUserInterface() {
        // Create title
        const title = document.createElement('h2');
        title.textContent = 'Chat with Admin';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 28px;
            color: white;
            text-align: center;
        `;
        this.gameContainer.appendChild(title);
        
        // Create cancel button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            display: block;
            margin: 0 auto 20px auto;
            padding: 10px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        cancelButton.addEventListener('click', () => {
            this.backToModeSelection();
        });
        cancelButton.addEventListener('mouseenter', () => {
            cancelButton.style.background = '#d32f2f';
            cancelButton.style.transform = 'scale(1.05)';
        });
        cancelButton.addEventListener('mouseleave', () => {
            cancelButton.style.background = '#f44336';
            cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(cancelButton);
        
        // Create info message
        const infoMessage = document.createElement('div');
        infoMessage.textContent = 'You are chatting with the admin. Please be respectful.';
        infoMessage.style.cssText = `
            color: #4CAF50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        `;
        this.gameContainer.appendChild(infoMessage);
        
        // Create chat container
        const chatContainer = document.createElement('div');
        chatContainer.style.cssText = `
            width: 90%;
            max-width: 800px;
            height: 500px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        `;
        
        // Messages display area
        const messagesDisplay = document.createElement('div');
        messagesDisplay.id = 'messagesDisplay';
        messagesDisplay.style.cssText = `
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            box-sizing: border-box;
            background: rgba(255, 255, 255, 0.05);
        `;
        messagesDisplay.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages yet. Start a conversation!</div>';
        chatContainer.appendChild(messagesDisplay);
        
        // Input area
        const inputArea = document.createElement('div');
        inputArea.style.cssText = `
            display: flex;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        `;
        
        const messageInput = document.createElement('input');
        messageInput.id = 'messageInput';
        messageInput.type = 'text';
        messageInput.placeholder = 'Type your message...';
        messageInput.style.cssText = `
            flex: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
            outline: none;
            box-sizing: border-box;
        `;
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        inputArea.appendChild(messageInput);
        
        const sendBtn = document.createElement('button');
        sendBtn.textContent = 'Send';
        sendBtn.style.cssText = `
            margin-left: 10px;
            padding: 12px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        `;
        sendBtn.addEventListener('click', () => {
            this.sendMessage();
        });
        sendBtn.addEventListener('mouseenter', () => {
            sendBtn.style.background = '#45a049';
        });
        sendBtn.addEventListener('mouseleave', () => {
            sendBtn.style.background = '#4CAF50';
        });
        inputArea.appendChild(sendBtn);
        
        chatContainer.appendChild(inputArea);
        this.gameContainer.appendChild(chatContainer);
        
        // Generate or get user ID
        this.generateUserId();
        
        // Set up user listeners
        this.setupUserListeners();
    }
    
    /**
     * Generate or get user ID
     */
    generateUserId() {
        // Check if we already have a user ID in localStorage
        let userId = localStorage.getItem('avu_userId');
        
        if (!userId) {
            // Generate a new user ID
            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('avu_userId', userId);
        }
        
        this.currentUserId = userId;
        console.log("User ID:", userId);
    }
    
    /**
     * Setup Admin Listeners
     */
    setupAdminListeners() {
        if (!this.isFirebaseInitialized) return;
        
        // Listen for users
        this.usersRef = this.db.ref('avu_users');
        this.usersListener = this.usersRef.on('value', (snapshot) => {
            this.updateUsersList(snapshot.val());
        });
        
        // If we have a selected user, listen for their messages
        if (this.currentUserId) {
            this.setupMessagesListener(this.currentUserId);
        }
    }
    
    /**
     * Setup User Listeners
     */
    setupUserListeners() {
        if (!this.isFirebaseInitialized) return;
        
        // Add user to the users list
        this.usersRef = this.db.ref('avu_users');
        this.usersRef.child(this.currentUserId).set({
            id: this.currentUserId,
            lastActive: firebase.database.ServerValue.TIMESTAMP
        });
        
        // Listen for messages
        this.setupMessagesListener(this.currentUserId);
    }
    
    /**
     * Setup Messages Listener
     */
    setupMessagesListener(userId) {
        if (!this.isFirebaseInitialized || !userId) return;
        
        // Remove existing listener
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Set up new listener
        this.messagesRef = this.db.ref(`avu_messages/${userId}`);
        this.messagesListener = this.messagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            this.addMessage(message);
        });
    }
    
    /**
     * Update Users List (Admin)
     */
    updateUsersList(usersData) {
        if (!usersData) {
            this.usersList = [];
            this.updateUsersListUI();
            return;
        }
        
        this.usersList = Object.values(usersData);
        this.updateUsersListUI();
    }
    
    /**
     * Update Users List UI (Admin)
     */
    updateUsersListUI() {
        const usersListContent = document.getElementById('usersListContent');
        if (!usersListContent) return;
        
        usersListContent.innerHTML = '';
        
        if (this.usersList.length === 0) {
            usersListContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No users found</div>';
            return;
        }
        
        this.usersList.forEach(user => {
            const userItem = document.createElement('div');
            userItem.style.cssText = `
                padding: 12px 15px;
                background: ${user.id === this.currentUserId ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255, 255, 255, 0.1)'};
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.2);
            `;
            
            const userInfo = document.createElement('div');
            userInfo.innerHTML = `
                <div style="font-weight: bold; color: white; margin-bottom: 5px;">${user.id}</div>
                <div style="font-size: 12px; color: #ccc;">Last active: ${new Date(user.lastActive).toLocaleString()}</div>
            `;
            userItem.appendChild(userInfo);
            
            userItem.addEventListener('click', () => {
                this.selectUser(user.id);
            });
            
            usersListContent.appendChild(userItem);
        });
    }
    
    /**
     * Select User (Admin)
     */
    selectUser(userId) {
        this.currentUserId = userId;
        this.updateUsersListUI();
        this.setupMessagesListener(userId);
        
        // Show admin input area
        const adminInputArea = document.getElementById('adminInputArea');
        if (adminInputArea) {
            adminInputArea.style.display = 'block';
        }
        
        // Clear messages display
        const messagesContent = document.getElementById('messagesContent');
        if (messagesContent) {
            messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">Loading messages...</div>';
        }
        
        // Load existing messages
        this.loadMessages(userId);
    }
    
    /**
     * Load Messages
     */
    loadMessages(userId) {
        if (!this.isFirebaseInitialized || !userId) return;
        
        this.messagesRef = this.db.ref(`avu_messages/${userId}`);
        this.messagesRef.once('value', (snapshot) => {
            const messagesData = snapshot.val();
            this.messages = messagesData ? Object.values(messagesData) : [];
            this.updateMessagesUI();
        });
    }
    
    /**
     * Add Message
     */
    addMessage(message) {
        this.messages.push(message);
        this.updateMessagesUI();
    }
    
    /**
     * Update Messages UI
     */
    updateMessagesUI() {
        const messagesContent = document.getElementById('messagesContent');
        const messagesDisplay = document.getElementById('messagesDisplay');
        
        if (!messagesContent && !messagesDisplay) return;
        
        if (this.messages.length === 0) {
            if (messagesContent) {
                messagesContent.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages found</div>';
            }
            if (messagesDisplay) {
                messagesDisplay.innerHTML = '<div style="color: #ccc; text-align: center; padding: 20px;">No messages yet. Start a conversation!</div>';
            }
            return;
        }
        
        const container = messagesContent || messagesDisplay;
        container.innerHTML = '';
        
        this.messages.forEach(message => {
            const messageDiv = document.createElement('div');
            
            // Set different styles based on sender
            if (message.sender === 'user') {
                messageDiv.style.cssText = `
                    margin-bottom: 15px;
                    padding: 12px 15px;
                    border-radius: 15px;
                    max-width: 80%;
                    background: rgba(33, 150, 243, 0.2);
                    margin-left: auto;
                `;
            } else if (message.sender === 'admin') {
                messageDiv.style.cssText = `
                    margin-bottom: 15px;
                    padding: 12px 15px;
                    border-radius: 15px;
                    max-width: 80%;
                    background: rgba(156, 39, 176, 0.2);
                    margin-right: auto;
                `;
            }
            
            const messageInfo = document.createElement('div');
            messageInfo.style.cssText = `
                font-size: 12px;
                color: ${message.sender === 'user' ? '#2196F3' : message.sender === 'admin' ? '#9c27b0' : '#4CAF50'};
                margin-bottom: 5px;
                font-weight: bold;
            `;
            messageInfo.textContent = `${message.sender === 'user' ? 'You' : message.sender === 'admin' ? 'Admin' : 'AI'} - ${new Date(message.timestamp).toLocaleTimeString()}`;
            messageDiv.appendChild(messageInfo);
            
            const messageText = document.createElement('div');
            messageText.style.cssText = `
                color: white;
                word-wrap: break-word;
            `;
            messageText.textContent = message.text;
            messageDiv.appendChild(messageText);
            
            container.appendChild(messageDiv);
        });
        
        // Scroll to bottom
        container.scrollTop = container.scrollHeight;
    }
    
    /**
     * Send Message (User)
     */
    sendMessage() {
        const messageInput = document.querySelector('#messageInput') || document.querySelector('input[placeholder="Type your message..."]');
        if (!messageInput) return;
        
        const text = messageInput.value.trim();
        if (!text) return;
        
        const message = {
            text: text,
            sender: 'user',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Save to Firebase
        this.messagesRef.push(message);
        
        // Clear input
        messageInput.value = '';
        
        // No automatic AI response
    }
    
    /**
     * Send Admin Message
     */
    sendAdminMessage() {
        const adminInput = document.getElementById('adminInput');
        if (!adminInput || !this.currentUserId) return;
        
        const text = adminInput.value.trim();
        if (!text) return;
        
        const message = {
            text: text,
            sender: 'admin',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        // Save to Firebase
        this.messagesRef.push(message);
        
        // Clear input
        adminInput.value = '';
    }
    
    /**
     * Clear All Messages (Admin)
     */
    clearAllMessages() {
        if (!this.currentUserId || !this.isFirebaseInitialized) return;
        
        const confirmClear = confirm('Are you sure you want to clear all messages for this user?');
        if (!confirmClear) return;
        
        // Clear messages in Firebase
        this.db.ref(`avu_messages/${this.currentUserId}`).remove();
        
        // Clear local messages
        this.messages = [];
        this.updateMessagesUI();
        
        this.showNotification('Messages cleared successfully!');
    }
    
    /**
     * Go back to mode selection screen
     */
    backToModeSelection() {
        // Clean up Firebase listeners
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Clear the container
        this.gameContainer.innerHTML = '';
        
        // Reset mode
        this.isAdmin = false;
        this.currentUserId = null;
        this.messages = [];
        
        // Create mode selection screen
        this.createModeSelectionScreen();
    }
    
    /**
     * Initialize Firebase
     */
    initializeFirebase(callback) {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase(callback);
                });
            });
        } else {
            this.setupFirebase(callback);
        }
    }
    
    /**
     * Setup Firebase
     */
    setupFirebase(callback) {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            this.isFirebaseInitialized = true;
            
            if (callback) {
                callback();
            }
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.showNotification('Error initializing Firebase. Please try again.');
        }
    }
    
    /**
     * Load external script
     */
    loadScript(url, callback) {
        const script = document.createElement('script');
        script.src = url;
        script.onload = callback;
        document.head.appendChild(script);
    }
    
    /**
     * Create game container
     */
    createGameContainer() {
        this.gameContainer = document.createElement('div');
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
        `;
        
        // Add container to body
        document.body.appendChild(this.gameContainer);
    }
    
    /**
     * Setup action buttons
     */
    setupActionButtons() {
        // Check if mobile device
        const isMobile = window.innerWidth <= 768;
        
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.textContent = 'Fullscreen';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; right: 10px;' : 'bottom: 20px; right: 20px;'}
            padding: 10px 15px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10001;
        `;
        this.fullscreenButton.addEventListener('click', () => {
            this.toggleFullscreen();
        });
        this.gameContainer.appendChild(this.fullscreenButton);
        
        // Cancel button (main button)
        this.cancelButton = document.createElement('button');
        this.cancelButton.textContent = 'Cancel';
        this.cancelButton.style.cssText = `
            position: fixed;
            ${isMobile ? 'top: 10px; left: 10px;' : 'bottom: 20px; left: 20px;'}
            padding: 12px 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            z-index: 10001;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
            transition: all 0.3s ease;
        `;
        this.cancelButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.cancelButton.addEventListener('mouseenter', () => {
            this.cancelButton.style.background = '#d32f2f';
            this.cancelButton.style.transform = 'scale(1.05)';
        });
        this.cancelButton.addEventListener('mouseleave', () => {
            this.cancelButton.style.background = '#f44336';
            this.cancelButton.style.transform = 'scale(1)';
        });
        this.gameContainer.appendChild(this.cancelButton);
        
        // Keep the old close button for backward compatibility
        this.closeButton = document.createElement('button');
        this.closeButton.textContent = 'Close';
        this.closeButton.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 15px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 10000;
            display: none; /* Hidden by default, only shown if needed */
        `;
        this.closeButton.addEventListener('click', () => {
            this.closeGame();
        });
        this.gameContainer.appendChild(this.closeButton);
    }
    
    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        if (!this.isFullscreen) {
            if (this.gameContainer.requestFullscreen) {
                this.gameContainer.requestFullscreen();
            } else if (this.gameContainer.webkitRequestFullscreen) {
                this.gameContainer.webkitRequestFullscreen();
            } else if (this.gameContainer.msRequestFullscreen) {
                this.gameContainer.msRequestFullscreen();
            }
            this.isFullscreen = true;
            this.fullscreenButton.textContent = 'Exit Fullscreen';
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            this.isFullscreen = false;
            this.fullscreenButton.textContent = 'Fullscreen';
        }
    }
    
    /**
     * Display the game
     */
    displayGame() {
        this.gameContainer.style.display = 'flex';
    }
    
    /**
     * Close the game
     */
    closeGame() {
        // Clean up Firebase listeners
        if (this.usersListener) {
            this.usersRef.off('value', this.usersListener);
            this.usersListener = null;
        }
        
        if (this.messagesListener) {
            this.messagesRef.off('child_added', this.messagesListener);
            this.messagesListener = null;
        }
        
        // Remove container
        if (this.gameContainer) {
            document.body.removeChild(this.gameContainer);
            this.gameContainer = null;
        }
        
        // Reset state
        this.isActive = false;
        this.isFullscreen = false;
        this.isAdmin = false;
        this.currentUserId = null;
        this.messages = [];
        
        console.log("AVU screen closed");
    }
    
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 10001;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
        `;
        notification.textContent = message;
        
        // Add animation styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(notification);
        
        // Remove after 3 seconds
        setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
        }, 3000);
    }
}

// ===== GLOBAL INSTANCE AND COMMAND HANDLING =====
// Create a global instance
let avuscreenloader = null;
// Function to get or create the AVU screen instance
function getAvuScreen() {
    if (!avuscreenloader) {
        console.log("Creating new AVUScreenLoader instance");
        avuscreenloader = new AVUScreenLoader();
    }
    return avuscreenloader;
}
// Command handler
function handleAvuCommand(input) {
    if (typeof input !== 'string') return false;
    
    const avuKeywords = ['admin view', 'view user', 'monitor chat', 'avu', 'admin messages'];
    const normalizedInput = input.toLowerCase().trim();
    
    return avuKeywords.some(keyword => normalizedInput.includes(keyword));
}
// Execute AVU command
function executeAvuCommand() {
    try {
        const avuScreen = getAvuScreen();
        if (avuScreen && typeof avuScreen.loadAvuScreen === 'function') {
            console.log("Executing AVU command");
            avuScreen.loadAvuScreen();
        } else {
            console.error("Invalid AVU screen instance");
            botReply("Sorry, the admin view user screen is not available right now.");
        }
    } catch (error) {
        console.error("Error executing AVU command:", error);
        botReply("Sorry, there was an error processing your request.");
    }
}
// ===== INTEGRATION WITH YOUR AI =====
// Add this to your AI's command processing:
if (typeof userInputRaw === 'string' && handleAvuCommand(userInputRaw)) {
    console.log("AVU command detected");
    executeAvuCommand();
    return;
}
// Also add close screen command
if (typeof userInputRaw === 'string' && /close screen|exit screen|cancel/i.test(userInputRaw)) {
    if (avuscreenloader && avuscreenloader.isActive) {
        avuscreenloader.closeGame();
        return;
    }
}
// ===== DEBUGGING HELPERS =====
// Add this to test the AVU screen manually (call from browser console)
window.testAvuScreen = function() {
    console.log("Testing AVU screen...");
    executeAvuCommand();
};
// Add this to check if the AVU screen is loaded
window.checkAvuScreen = function() {
    console.log("avuscreenloader exists:", !!avuscreenloader);
    console.log("avuscreenloader type:", typeof avuscreenloader);
    console.log("AVUScreenLoader class exists:", typeof AVUScreenLoader);
};


class NoteScreenLoader {
    constructor() {
        this.noteScreen = {
            name: 'NOTE SCREEN',
            instructions: 'Type your notes and save them. View, edit, copy, or download saved notes anytime.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.noteTextarea = null;
        this.saveButton = null;
        this.clearButton = null;
        this.notesList = null;
        this.savedNotes = [];
        this.currentNoteId = null;
        this.notesListVisible = false;
        this.noteModal = null;
        this.modalContent = null;
    }
    
    /**
     * Load the Note Screen
     */
    loadNoteScreen() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.noteScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Load saved notes from localStorage
        this.loadSavedNotes();
        
        // Create container
        this.createGameContainer();
        
        // Create note screen
        this.createNoteScreen();
        
        // Create modal for viewing notes
        this.createNoteModal();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the note screen
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.noteScreen.name} loaded! ${this.noteScreen.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Note Screen UI
     */
    createNoteScreen() {
        // Create note container
        const noteContainer = document.createElement('div');
        noteContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'My Notes';
        title.style.cssText = `
            margin: 0;
            color: #333;
            font-size: 24px;
        `;
        
        const toggleButton = document.createElement('button');
        toggleButton.textContent = 'Saved Notes';
        toggleButton.style.cssText = `
            padding: 8px 12px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        `;
        toggleButton.addEventListener('click', () => {
            this.toggleNotesList();
        });
        
        header.appendChild(title);
        header.appendChild(toggleButton);
        noteContainer.appendChild(header);
        
        // Create textarea for note input
        this.noteTextarea = document.createElement('textarea');
        this.noteTextarea.placeholder = 'Type your note here...';
        this.noteTextarea.style.cssText = `
            width: 100%;
            height: 300px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            resize: vertical;
            margin-bottom: 15px;
            box-sizing: border-box;
        `;
        
        noteContainer.appendChild(this.noteTextarea);
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Create save button
        this.saveButton = document.createElement('button');
        this.saveButton.textContent = 'Save Note';
        this.saveButton.style.cssText = `
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex: 1;
            transition: all 0.2s ease;
        `;
        this.saveButton.addEventListener('click', () => {
            this.saveNote();
        });
        
        // Create clear button
        this.clearButton = document.createElement('button');
        this.clearButton.textContent = 'Clear';
        this.clearButton.style.cssText = `
            padding: 10px 15px;
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex: 1;
            transition: all 0.2s ease;
        `;
        this.clearButton.addEventListener('click', () => {
            this.clearNote();
        });
        
        buttonContainer.appendChild(this.saveButton);
        buttonContainer.appendChild(this.clearButton);
        noteContainer.appendChild(buttonContainer);
        
        // Create saved notes list (initially hidden)
        this.notesList = document.createElement('div');
        this.notesList.style.cssText = `
            display: none;
            max-height: 300px;
            overflow-y: auto;
            border-top: 1px solid #ddd;
            padding-top: 15px;
        `;
        
        this.updateNotesList();
        noteContainer.appendChild(this.notesList);
        
        this.gameContainer.appendChild(noteContainer);
    }
    
    /**
     * Create a modal for viewing notes
     */
    createNoteModal() {
        // Create modal container
        this.noteModal = document.createElement('div');
        this.noteModal.style.cssText = `
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        `;
        
        // Create modal content container
        const modalContainer = document.createElement('div');
        modalContainer.style.cssText = `
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 600px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create modal header
        const modalHeader = document.createElement('div');
        modalHeader.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Note Details';
        modalTitle.style.cssText = `
            margin: 0;
            color: #333;
            font-size: 20px;
        `;
        
        const closeButton = document.createElement('button');
        closeButton.textContent = '✕';
        closeButton.style.cssText = `
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #777;
        `;
        closeButton.addEventListener('click', () => {
            this.closeNoteModal();
        });
        
        modalHeader.appendChild(modalTitle);
        modalHeader.appendChild(closeButton);
        modalContainer.appendChild(modalHeader);
        
        // Create modal content
        this.modalContent = document.createElement('div');
        this.modalContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            white-space: pre-wrap;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            line-height: 1.5;
        `;
        
        modalContainer.appendChild(this.modalContent);
        
        // Create modal footer with action buttons
        const modalFooter = document.createElement('div');
        modalFooter.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
        `;
        
        // Copy button
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy';
        copyButton.style.cssText = `
            padding: 8px 12px;
            background-color: #9C27B0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        copyButton.addEventListener('click', () => {
            this.copyNoteFromModal();
        });
        
        // Edit button
        const editButton = document.createElement('button');
        editButton.textContent = 'Edit';
        editButton.style.cssText = `
            padding: 8px 12px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        editButton.addEventListener('click', () => {
            this.editNoteFromModal();
        });
        
        // Download button
        const downloadButton = document.createElement('button');
        downloadButton.textContent = 'Download';
        downloadButton.style.cssText = `
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        `;
        downloadButton.addEventListener('click', () => {
            this.downloadNoteFromModal();
        });
        
        modalFooter.appendChild(copyButton);
        modalFooter.appendChild(editButton);
        modalFooter.appendChild(downloadButton);
        modalContainer.appendChild(modalFooter);
        
        this.noteModal.appendChild(modalContainer);
        this.gameContainer.appendChild(this.noteModal);
    }
    
    /**
     * Toggle the visibility of the saved notes list
     */
    toggleNotesList() {
        this.notesListVisible = !this.notesListVisible;
        this.notesList.style.display = this.notesListVisible ? 'block' : 'none';
        
        if (this.notesListVisible) {
            this.updateNotesList();
        }
    }
    
    /**
     * Update the saved notes list
     */
    updateNotesList() {
        // Clear existing notes
        this.notesList.innerHTML = '';
        
        if (this.savedNotes.length === 0) {
            const noNotes = document.createElement('p');
            noNotes.textContent = 'No saved notes yet.';
            noNotes.style.cssText = `
                text-align: center;
                color: #777;
                font-style: italic;
            `;
            this.notesList.appendChild(noNotes);
            return;
        }
        
        // Create list header
        const listHeader = document.createElement('h3');
        listHeader.textContent = 'Saved Notes';
        listHeader.style.cssText = `
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        `;
        this.notesList.appendChild(listHeader);
        
        // Create list container
        const listContainer = document.createElement('div');
        
        // Add each saved note
        this.savedNotes.forEach(note => {
            const noteItem = document.createElement('div');
            noteItem.style.cssText = `
                background-color: white;
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 10px;
                margin-bottom: 8px;
                transition: all 0.2s ease;
            `;
            
            // Create note content
            const noteContent = document.createElement('div');
            noteContent.textContent = note.content.length > 50 
                ? note.content.substring(0, 50) + '...' 
                : note.content;
            noteContent.style.cssText = `
                font-size: 14px;
                color: #333;
                margin-bottom: 5px;
            `;
            
            // Create note metadata
            const noteMeta = document.createElement('div');
            noteMeta.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 12px;
                color: #777;
            `;
            
            const noteDate = document.createElement('span');
            noteDate.textContent = new Date(note.timestamp).toLocaleString();
            
            // Create action buttons container
            const actionButtons = document.createElement('div');
            actionButtons.style.cssText = `
                display: flex;
                gap: 5px;
                flex-wrap: wrap;
            `;
            
            // View button
            const viewButton = document.createElement('button');
            viewButton.textContent = 'View';
            viewButton.style.cssText = `
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            viewButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.viewNote(note.id);
            });
            
            // Copy button
            const copyButton = document.createElement('button');
            copyButton.textContent = 'Copy';
            copyButton.style.cssText = `
                background-color: #9C27B0;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            copyButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.copyNote(note.id);
            });
            
            // Edit button
            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.style.cssText = `
                background-color: #FF9800;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            editButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.loadNote(note.id);
            });
            
            // Download button
            const downloadButton = document.createElement('button');
            downloadButton.textContent = 'Download';
            downloadButton.style.cssText = `
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            downloadButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.downloadNote(note.id);
            });
            
            // Delete button
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.style.cssText = `
                background-color: #f44336;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 6px;
                cursor: pointer;
                font-size: 12px;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteNote(note.id);
            });
            
            actionButtons.appendChild(viewButton);
            actionButtons.appendChild(copyButton);
            actionButtons.appendChild(editButton);
            actionButtons.appendChild(downloadButton);
            actionButtons.appendChild(deleteButton);
            
            noteMeta.appendChild(noteDate);
            noteMeta.appendChild(actionButtons);
            
            noteItem.appendChild(noteContent);
            noteItem.appendChild(noteMeta);
            
            listContainer.appendChild(noteItem);
        });
        
        this.notesList.appendChild(listContainer);
    }
    
    /**
     * View a note in the modal
     */
    viewNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (note) {
            this.modalContent.textContent = note.content;
            this.modalContent.dataset.noteId = noteId;
            this.noteModal.style.display = 'flex';
        }
    }
    
    /**
     * Close the note modal
     */
    closeNoteModal() {
        this.noteModal.style.display = 'none';
        this.modalContent.textContent = '';
        this.modalContent.dataset.noteId = '';
    }
    
    /**
     * Copy note from modal
     */
    copyNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.copyNote(noteId);
        }
    }
    
    /**
     * Copy a note to clipboard
     */
    copyNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (!note) return;
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(note.content)
                .then(() => {
                    botReply('Note copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(note.content);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(note.content);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Note copied to clipboard!');
            } else {
                botReply('Unable to copy note');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy note');
        }

        document.body.removeChild(textArea);
    }
    
    /**
     * Edit note from modal
     */
    editNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.loadNote(noteId);
            this.closeNoteModal();
        }
    }
    
    /**
     * Download note from modal
     */
    downloadNoteFromModal() {
        const noteId = this.modalContent.dataset.noteId;
        if (noteId) {
            this.downloadNote(noteId);
        }
    }
    
    /**
     * Download a note as a text file
     */
    downloadNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (!note) return;
        
        try {
            // Create a blob with the note content, specifying UTF-8 encoding for proper emoji support
            const blob = new Blob([note.content], { type: 'text/plain;charset=utf-8' });
            
            // Create a download link
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Generate filename with timestamp
            const date = new Date(note.timestamp);
            const dateStr = date.toISOString().slice(0, 19).replace(/:/g, '-');
            a.download = `note_${dateStr}.txt`;
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            
            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            botReply('Note downloaded successfully!');
        } catch (error) {
            console.error('Error downloading note:', error);
            botReply('Error downloading note. Please try again.');
        }
    }
    
    /**
     * Save the current note
     */
    saveNote() {
        const content = this.noteTextarea.value.trim();
        
        if (!content) {
            botReply('Please enter some text before saving.');
            return;
        }
        
        const now = new Date().getTime();
        
        if (this.currentNoteId) {
            // Update existing note
            const noteIndex = this.savedNotes.findIndex(note => note.id === this.currentNoteId);
            if (noteIndex !== -1) {
                this.savedNotes[noteIndex].content = content;
                this.savedNotes[noteIndex].timestamp = now;
                botReply('Note updated successfully!');
            }
        } else {
            // Create new note
            const newNote = {
                id: 'note_' + now,
                content: content,
                timestamp: now
            };
            
            this.savedNotes.push(newNote);
            this.currentNoteId = newNote.id;
            botReply('Note saved successfully!');
        }
        
        // Save to localStorage
        this.saveNotesToStorage();
        
        // Update notes list if visible
        if (this.notesListVisible) {
            this.updateNotesList();
        }
    }
    
    /**
     * Clear the current note
     */
    clearNote() {
        this.noteTextarea.value = '';
        this.currentNoteId = null;
        botReply('Note cleared.');
    }
    
    /**
     * Load a note into the textarea
     */
    loadNote(noteId) {
        const note = this.savedNotes.find(n => n.id === noteId);
        if (note) {
            this.noteTextarea.value = note.content;
            this.currentNoteId = noteId;
            botReply('Note loaded for editing!');
        }
    }
    
    /**
     * Delete a saved note
     */
    deleteNote(noteId) {
        const noteIndex = this.savedNotes.findIndex(note => note.id === noteId);
        if (noteIndex !== -1) {
            this.savedNotes.splice(noteIndex, 1);
            
            // If deleting the currently loaded note, clear the textarea
            if (this.currentNoteId === noteId) {
                this.clearNote();
            }
            
            // Save to localStorage
            this.saveNotesToStorage();
            
            // Update notes list
            this.updateNotesList();
            
            botReply('Note deleted!');
        }
    }
    
    /**
     * Load saved notes from localStorage
     */
    loadSavedNotes() {
        try {
            const savedNotesJson = localStorage.getItem('savedNotes');
            if (savedNotesJson) {
                this.savedNotes = JSON.parse(savedNotesJson);
            } else {
                this.savedNotes = [];
            }
        } catch (error) {
            console.error('Error loading saved notes:', error);
            this.savedNotes = [];
        }
    }
    
    /**
     * Save notes to localStorage
     */
    saveNotesToStorage() {
        try {
            localStorage.setItem('savedNotes', JSON.stringify(this.savedNotes));
        } catch (error) {
            console.error('Error saving notes to storage:', error);
            botReply('Error saving notes. Please try again.');
        }
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.noteModal.style.display === 'flex') {
                this.closeNoteModal();
            } else if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
        
        // Ctrl+S to save note
        if (event.ctrlKey && event.key === 's') {
            event.preventDefault();
            this.saveNote();
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (this.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.noteTextarea = null;
        this.saveButton = null;
        this.clearButton = null;
        this.notesList = null;
        this.noteModal = null;
        this.modalContent = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.savedNotes = [];
        this.currentNoteId = null;
        this.notesListVisible = false;
        
        botReply("Note Screen closed. Thank you!");
    }
}

// Create a singleton instance
const noteScreenLoader = new NoteScreenLoader();

// Add this to your AI's command handling
if (/note|notes|notepad/i.test(userInputRaw)) {
    noteScreenLoader.loadNoteScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    noteScreenLoader.closeGame();
    return;
}
class SongsVideosScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'MEDIA PLAYER',
            instructions: 'Load and play songs and videos from your device. Access media from your Download folder or upload new files.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.fileInput = null;
        this.uploadButton = null;
        this.loadFromFolderButton = null;
        this.mediaList = null;
        this.mediaPlayer = null;
        this.mediaControls = null;
        this.playButton = null;
        this.pauseButton = null;
        this.stopButton = null;
        this.volumeSlider = null;
        this.progressBar = null;
        this.timeDisplay = null;
        this.currentMedia = null;
        this.mediaFiles = [];
        this.storageKey = 'mediaFilesData';
        this.isPlaying = false;
        this.currentMediaType = null;
        this.downloadFolderPath = '/storage/emulated/0/Download/';
        this.directoryHandle = null;
    }

    /**
     * Load the Media Player Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createMediaPlayerScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.loadMediaFiles();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Media Player UI
     */
    createMediaPlayerScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Media Player';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Play songs and videos from your device';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Upload section
        const uploadSection = document.createElement('div');
        uploadSection.style.cssText = `
            margin-bottom: 20px;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        `;
        const uploadTitle = document.createElement('h3');
        uploadTitle.textContent = 'Load Media';
        uploadTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: #2E7D32;
            font-size: 18px;
        `;
        
        const uploadControls = document.createElement('div');
        uploadControls.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
        `;
        
        // Load from folder button
        const folderControls = document.createElement('div');
        folderControls.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        const folderLabel = document.createElement('span');
        folderLabel.textContent = 'Download Folder:';
        folderLabel.style.cssText = `
            font-weight: bold;
            color: #333;
            min-width: 120px;
        `;
        this.loadFromFolderButton = this.createButton('Load from Download Folder', '#2196F3', () => {
            this.loadFromDownloadFolder();
        });
        folderControls.appendChild(folderLabel);
        folderControls.appendChild(this.loadFromFolderButton);
        
        // Upload file controls
        const fileControls = document.createElement('div');
        fileControls.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        const fileLabel = document.createElement('span');
        fileLabel.textContent = 'Upload File:';
        fileLabel.style.cssText = `
            font-weight: bold;
            color: #333;
            min-width: 120px;
        `;
        this.fileInput = document.createElement('input');
        this.fileInput.type = 'file';
        this.fileInput.accept = 'audio/*,video/*';
        this.fileInput.style.cssText = `
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        this.uploadButton = this.createButton('Upload', '#4CAF50', () => {
            this.uploadMedia();
        });
        fileControls.appendChild(fileLabel);
        fileControls.appendChild(this.fileInput);
        fileControls.appendChild(this.uploadButton);
        
        uploadControls.appendChild(folderControls);
        uploadControls.appendChild(fileControls);
        uploadSection.appendChild(uploadTitle);
        uploadSection.appendChild(uploadControls);
        baseContainer.appendChild(uploadSection);

        // Media list section
        const listSection = document.createElement('div');
        listSection.style.cssText = `
            margin-bottom: 20px;
        `;
        const listTitle = document.createElement('h3');
        listTitle.textContent = 'Media Library';
        listTitle.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 18px;
        `;
        this.mediaList = document.createElement('div');
        this.mediaList.style.cssText = `
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            padding: 10px;
        `;
        this.mediaList.textContent = 'Loading media library...';
        listSection.appendChild(listTitle);
        listSection.appendChild(this.mediaList);
        baseContainer.appendChild(listSection);

        // Media player section
        const playerSection = document.createElement('div');
        playerSection.style.cssText = `
            margin-bottom: 20px;
        `;
        const playerTitle = document.createElement('h3');
        playerTitle.textContent = 'Media Player';
        playerTitle.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 18px;
        `;
        
        // Media player container
        const playerContainer = document.createElement('div');
        playerContainer.style.cssText = `
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        `;
        
        // Audio element (initially hidden)
        this.audioPlayer = document.createElement('audio');
        this.audioPlayer.style.cssText = `
            width: 100%;
            display: none;
        `;
        this.audioPlayer.addEventListener('loadedmetadata', () => {
            this.updateTimeDisplay();
        });
        this.audioPlayer.addEventListener('timeupdate', () => {
            this.updateProgressBar();
        });
        this.audioPlayer.addEventListener('ended', () => {
            this.onMediaEnded();
        });
        
        // Video element (initially hidden)
        this.videoPlayer = document.createElement('video');
        this.videoPlayer.style.cssText = `
            width: 100%;
            max-height: 400px;
            display: none;
        `;
        this.videoPlayer.addEventListener('loadedmetadata', () => {
            this.updateTimeDisplay();
        });
        this.videoPlayer.addEventListener('timeupdate', () => {
            this.updateProgressBar();
        });
        this.videoPlayer.addEventListener('ended', () => {
            this.onMediaEnded();
        });
        
        playerContainer.appendChild(this.audioPlayer);
        playerContainer.appendChild(this.videoPlayer);
        
        // Media info display
        this.mediaInfo = document.createElement('div');
        this.mediaInfo.style.cssText = `
            padding: 10px;
            background-color: #333;
            color: white;
            font-size: 14px;
            text-align: center;
        `;
        this.mediaInfo.textContent = 'No media selected';
        playerContainer.appendChild(this.mediaInfo);
        
        playerSection.appendChild(playerTitle);
        playerSection.appendChild(playerContainer);
        baseContainer.appendChild(playerSection);

        // Media controls
        this.mediaControls = document.createElement('div');
        this.mediaControls.style.cssText = `
            background-color: #333;
            padding: 15px;
            border-radius: 8px;
            color: white;
        `;
        
        // Progress bar
        const progressContainer = document.createElement('div');
        progressContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        this.progressBar = document.createElement('input');
        this.progressBar.type = 'range';
        this.progressBar.min = '0';
        this.progressBar.max = '100';
        this.progressBar.value = '0';
        this.progressBar.style.cssText = `
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #555;
            outline: none;
            cursor: pointer;
        `;
        this.progressBar.addEventListener('input', () => {
            this.seekMedia();
        });
        progressContainer.appendChild(this.progressBar);
        
        // Time display
        this.timeDisplay = document.createElement('div');
        this.timeDisplay.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 14px;
        `;
        this.currentTime = document.createElement('span');
        this.currentTime.textContent = '0:00';
        this.duration = document.createElement('span');
        this.duration.textContent = '0:00';
        this.timeDisplay.appendChild(this.currentTime);
        this.timeDisplay.appendChild(this.duration);
        
        // Control buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        `;
        this.playButton = this.createButton('▶', '#4CAF50', () => {
            this.playMedia();
        });
        this.pauseButton = this.createButton('⏸', '#FF9800', () => {
            this.pauseMedia();
        });
        this.stopButton = this.createButton('⏹', '#f44336', () => {
            this.stopMedia();
        });
        buttonContainer.appendChild(this.playButton);
        buttonContainer.appendChild(this.pauseButton);
        buttonContainer.appendChild(this.stopButton);
        
        // Volume control
        const volumeContainer = document.createElement('div');
        volumeContainer.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const volumeLabel = document.createElement('span');
        volumeLabel.textContent = 'Volume:';
        volumeLabel.style.cssText = `
            font-size: 14px;
        `;
        this.volumeSlider = document.createElement('input');
        this.volumeSlider.type = 'range';
        this.volumeSlider.min = '0';
        this.volumeSlider.max = '100';
        this.volumeSlider.value = '50';
        this.volumeSlider.style.cssText = `
            flex-grow: 1;
            height: 6px;
            border-radius: 3px;
            background: #555;
            outline: none;
            cursor: pointer;
        `;
        this.volumeSlider.addEventListener('input', () => {
            this.changeVolume();
        });
        volumeContainer.appendChild(volumeLabel);
        volumeContainer.appendChild(this.volumeSlider);
        
        this.mediaControls.appendChild(progressContainer);
        this.mediaControls.appendChild(this.timeDisplay);
        this.mediaControls.appendChild(buttonContainer);
        this.mediaControls.appendChild(volumeContainer);
        baseContainer.appendChild(this.mediaControls);

        // Info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 15px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
            margin-top: auto;
        `;
        infoSection.innerHTML = `
            <strong>Instructions:</strong><br>
            • Click "Load from Download Folder" to access media files from your device<br>
            • Or upload audio/video files using the file input<br>
            • Click on any media file in the library to play it<br>
            • Use the media controls to play, pause, stop, and adjust volume
        `;
        baseContainer.appendChild(infoSection);
        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Load media files from the Download folder using File System Access API
     */
    async loadFromDownloadFolder() {
        try {
            // Show loading message
            this.mediaList.textContent = 'Loading media from Download folder...';
            
            // Check if File System Access API is supported
            if (!('showDirectoryPicker' in window)) {
                throw new Error('File System Access API is not supported in this browser');
            }
            
            // Request directory access
            this.directoryHandle = await window.showDirectoryPicker();
            
            // Get all entries in the directory
            const entries = [];
            for await (const entry of this.directoryHandle.values()) {
                entries.push(entry);
            }
            
            // Filter for audio and video files
            const mediaFiles = entries.filter(entry => 
                entry.kind === 'file' && (
                    entry.name.match(/\.(mp3|wav|ogg|m4a|flac|aac)$/i) || // Audio formats
                    entry.name.match(/\.(mp4|webm|ogg|mov|avi|mkv|flv)$/i)    // Video formats
                )
            );
            
            if (mediaFiles.length === 0) {
                this.mediaList.textContent = 'No media files found in the selected folder';
                botReply('No media files found in the selected folder');
                return;
            }
            
            // Process each media file
            const newMediaFiles = [];
            for (const fileHandle of mediaFiles) {
                const file = await fileHandle.getFile();
                const mediaFile = {
                    id: `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    fileHandle: fileHandle,
                    uploadDate: new Date().toLocaleString(),
                    source: 'Download Folder'
                };
                newMediaFiles.push(mediaFile);
            }
            
            // Add to media files array
            this.mediaFiles = [...this.mediaFiles.filter(f => f.source !== 'Download Folder'), ...newMediaFiles];
            
            // Update UI
            this.updateMediaList();
            this.saveMediaFiles();
            botReply(`Loaded ${newMediaFiles.length} media files from Download folder`);
            
        } catch (error) {
            console.error('Error loading from Download folder:', error);
            this.mediaList.textContent = 'Error loading media files. Please try again.';
            botReply(`Error: ${error.message}`);
        }
    }

    /**
     * Upload media file to localStorage
     */
    uploadMedia() {
        const file = this.fileInput.files[0];
        if (!file) {
            botReply('No file selected');
            return;
        }
        
        // Check file size (localStorage limit is ~5MB)
        if (file.size > 5 * 1024 * 1024) {
            botReply('File is too large. Maximum size is 5MB.');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const mediaFile = {
                id: Date.now(),
                name: file.name,
                type: file.type,
                size: file.size,
                data: e.target.result,
                uploadDate: new Date().toLocaleString(),
                source: 'Uploaded'
            };
            
            this.mediaFiles.push(mediaFile);
            this.saveMediaFiles();
            this.updateMediaList();
            this.fileInput.value = '';
            botReply(`Media uploaded: ${file.name}`);
        };
        
        reader.onerror = () => {
            botReply('Error uploading file');
        };
        
        reader.readAsDataURL(file);
    }

    /**
     * Save media files to localStorage
     */
    saveMediaFiles() {
        try {
            // We can't save file handles to localStorage, so we only save metadata
            const filesToSave = this.mediaFiles.map(file => {
                const { fileHandle, ...rest } = file;
                return rest;
            });
            localStorage.setItem(this.storageKey, JSON.stringify(filesToSave));
        } catch (error) {
            console.error('Error saving media files:', error);
            botReply('Error saving media files. Storage may be full.');
        }
    }

    /**
     * Load media files from localStorage
     */
    loadMediaFiles() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                const files = JSON.parse(stored);
                this.mediaFiles = files.map(file => ({
                    ...file,
                    // File handles are lost on refresh, so we need to reload them
                    fileHandle: null
                }));
                this.updateMediaList();
            } else {
                this.mediaList.textContent = 'No media files found. Click "Load from Download Folder" to get started.';
            }
        } catch (error) {
            console.error('Error loading media files:', error);
            this.mediaList.textContent = 'Error loading media files. Please try again.';
        }
    }

    /**
     * Update media list display
     */
    updateMediaList() {
        this.mediaList.innerHTML = '';
        
        if (this.mediaFiles.length === 0) {
            this.mediaList.textContent = 'No media files found. Click "Load from Download Folder" to get started.';
            return;
        }
        
        // Group files by source
        const filesBySource = {};
        this.mediaFiles.forEach(file => {
            if (!filesBySource[file.source]) {
                filesBySource[file.source] = [];
            }
            filesBySource[file.source].push(file);
        });
        
        // Display files grouped by source
        Object.keys(filesBySource).forEach(source => {
            // Create source header
            const sourceHeader = document.createElement('div');
            sourceHeader.style.cssText = `
                font-weight: bold;
                margin-top: 10px;
                margin-bottom: 5px;
                color: #555;
                font-size: 14px;
                border-bottom: 1px solid #eee;
                padding-bottom: 3px;
            `;
            sourceHeader.textContent = source;
            this.mediaList.appendChild(sourceHeader);
            
            // Add files for this source
            filesBySource[source].forEach(file => {
                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 10px;
                    margin-bottom: 5px;
                    background-color: #f9f9f9;
                    border-radius: 5px;
                    cursor: pointer;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    transition: background-color 0.2s;
                `;
                item.addEventListener('mouseenter', () => {
                    item.style.backgroundColor = '#e0e0e0';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.backgroundColor = '#f9f9f9';
                });
                
                const fileInfo = document.createElement('div');
                fileInfo.style.cssText = `
                    flex-grow: 1;
                `;
                const fileName = document.createElement('div');
                fileName.textContent = file.name;
                fileName.style.cssText = `
                    font-weight: bold;
                    margin-bottom: 2px;
                `;
                const fileDetails = document.createElement('div');
                fileDetails.textContent = `${this.formatFileSize(file.size)} • ${file.uploadDate}`;
                fileDetails.style.cssText = `
                    font-size: 12px;
                    color: #666;
                `;
                fileInfo.appendChild(fileName);
                fileInfo.appendChild(fileDetails);
                
                const playIcon = document.createElement('span');
                playIcon.textContent = '▶';
                playIcon.style.cssText = `
                    font-size: 20px;
                    color: #4CAF50;
                    margin-left: 10px;
                `;
                
                item.appendChild(fileInfo);
                item.appendChild(playIcon);
                item.addEventListener('click', () => {
                    this.selectMedia(file);
                });
                
                this.mediaList.appendChild(item);
            });
        });
    }

    /**
     * Select and play media file
     */
    async selectMedia(file) {
        this.currentMedia = file;
        this.currentMediaType = file.type.startsWith('audio/') ? 'audio' : 'video';
        
        // Reset players
        this.audioPlayer.pause();
        this.videoPlayer.pause();
        this.audioPlayer.style.display = 'none';
        this.videoPlayer.style.display = 'none';
        
        try {
            // Set media source
            if (file.data) {
                // For uploaded files
                if (this.currentMediaType === 'audio') {
                    this.audioPlayer.src = file.data;
                    this.audioPlayer.style.display = 'block';
                    this.mediaPlayer = this.audioPlayer;
                } else {
                    this.videoPlayer.src = file.data;
                    this.videoPlayer.style.display = 'block';
                    this.mediaPlayer = this.videoPlayer;
                }
            } else if (file.fileHandle) {
                // For files from Download folder
                const fileObj = await file.fileHandle.getFile();
                const url = URL.createObjectURL(fileObj);
                
                if (this.currentMediaType === 'audio') {
                    this.audioPlayer.src = url;
                    this.audioPlayer.style.display = 'block';
                    this.mediaPlayer = this.audioPlayer;
                } else {
                    this.videoPlayer.src = url;
                    this.videoPlayer.style.display = 'block';
                    this.mediaPlayer = this.videoPlayer;
                }
            } else {
                // File handle is lost (page was refreshed)
                throw new Error('File handle lost. Please reload the Download folder.');
            }
            
            // Update media info
            this.mediaInfo.textContent = `Now Playing: ${file.name} (${file.source})`;
            
            // Load media
            this.mediaPlayer.load();
            
            botReply(`Selected: ${file.name}`);
            
        } catch (error) {
            console.error('Error selecting media:', error);
            this.mediaInfo.textContent = `Error: ${error.message}`;
            botReply(`Error: ${error.message}`);
        }
    }

    /**
     * Play media
     */
    playMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.play();
        this.isPlaying = true;
        botReply('Playing media');
    }

    /**
     * Pause media
     */
    pauseMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.pause();
        this.isPlaying = false;
        botReply('Media paused');
    }

    /**
     * Stop media
     */
    stopMedia() {
        if (!this.mediaPlayer) {
            botReply('No media selected');
            return;
        }
        
        this.mediaPlayer.pause();
        this.mediaPlayer.currentTime = 0;
        this.isPlaying = false;
        this.updateProgressBar();
        botReply('Media stopped');
    }

    /**
     * Seek media
     */
    seekMedia() {
        if (!this.mediaPlayer) return;
        
        const seekTime = (this.progressBar.value / 100) * this.mediaPlayer.duration;
        this.mediaPlayer.currentTime = seekTime;
    }

    /**
     * Change volume
     */
    changeVolume() {
        if (!this.mediaPlayer) return;
        
        const volume = this.volumeSlider.value / 100;
        this.mediaPlayer.volume = volume;
    }

    /**
     * Update progress bar
     */
    updateProgressBar() {
        if (!this.mediaPlayer) return;
        
        const progress = (this.mediaPlayer.currentTime / this.mediaPlayer.duration) * 100;
        this.progressBar.value = progress || 0;
        this.updateTimeDisplay();
    }

    /**
     * Update time display
     */
    updateTimeDisplay() {
        if (!this.mediaPlayer) return;
        
        this.currentTime.textContent = this.formatTime(this.mediaPlayer.currentTime);
        this.duration.textContent = this.formatTime(this.mediaPlayer.duration);
    }

    /**
     * Format time as MM:SS
     */
    formatTime(seconds) {
        if (isNaN(seconds)) return '0:00';
        
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Format file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Handle media ended event
     */
    onMediaEnded() {
        this.isPlaying = false;
        this.progressBar.value = 0;
        this.currentTime.textContent = '0:00';
        botReply('Media finished playing');
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.key === ' ' && this.mediaPlayer) {
            event.preventDefault();
            if (this.isPlaying) {
                this.pauseMedia();
            } else {
                this.playMedia();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Stop any playing media
        if (this.audioPlayer) {
            this.audioPlayer.pause();
        }
        if (this.videoPlayer) {
            this.videoPlayer.pause();
        }
        
        // Revoke any object URLs
        if (this.mediaPlayer && this.mediaPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(this.mediaPlayer.src);
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.fileInput = null;
        this.uploadButton = null;
        this.loadFromFolderButton = null;
        this.mediaList = null;
        this.audioPlayer = null;
        this.videoPlayer = null;
        this.mediaControls = null;
        this.playButton = null;
        this.pauseButton = null;
        this.stopButton = null;
        this.volumeSlider = null;
        this.progressBar = null;
        this.timeDisplay = null;
        this.currentMedia = null;
        this.mediaFiles = [];
        this.directoryHandle = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Media Player closed. Thank you!");
    }
}

// Create a singleton instance
const songsVideosScreenLoader = new SongsVideosScreenLoader();

// Add this to your AI's command handling
if (/media player|music player|video player|play songs|play videos/i.test(userInputRaw)) {
    songsVideosScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    songsVideosScreenLoader.closeGame();
    return;
}

class CaptureScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'CODE CAPTURE',
            instructions: 'Capture, edit, and analyze code from developer tools. Supports syntax highlighting and code analysis.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.codeInput = null;
        this.codeDisplay = null;
        this.languageSelect = null;
        this.captureButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.analyzeButton = null;
        this.outputDiv = null;
        this.currentCode = '';
        this.currentLanguage = 'javascript';
        this.capturedSnippets = [];
        this.storageKey = 'capturedCodeSnippets';
    }

    /**
     * Load the Code Capture Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createCaptureScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.loadCapturedSnippets();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Code Capture UI
     */
    createCaptureScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #1e1e1e;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
            color: #d4d4d4;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Code Capture Tool';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #ffffff;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Capture and analyze code from developer tools (F12)';
        subtitle.style.cssText = `
            margin: 0;
            color: #cccccc;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Instructions section
        const instructionsSection = document.createElement('div');
        instructionsSection.style.cssText = `
            background-color: #2d2d30;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #007acc;
        `;
        instructionsSection.innerHTML = `
            <strong style="color: #ffffff;">How to capture code:</strong><br>
            1. Open developer tools (F12) in your browser<br>
            2. Copy the code you want to capture<br>
            3. Paste it in the input area below<br>
            4. Select the programming language<br>
            5. Click "Capture Code" to format and analyze
        `;
        baseContainer.appendChild(instructionsSection);

        // Language selection
        const languageSection = document.createElement('div');
        languageSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const languageLabel = document.createElement('label');
        languageLabel.textContent = 'Programming Language:';
        languageLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.languageSelect = document.createElement('select');
        this.languageSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            box-sizing: border-box;
        `;
        const languages = [
            { value: 'javascript', text: 'JavaScript' },
            { value: 'html', text: 'HTML' },
            { value: 'css', text: 'CSS' },
            { value: 'python', text: 'Python' },
            { value: 'java', text: 'Java' },
            { value: 'cpp', text: 'C++' },
            { value: 'csharp', text: 'C#' },
            { value: 'php', text: 'PHP' },
            { value: 'ruby', text: 'Ruby' },
            { value: 'go', text: 'Go' },
            { value: 'rust', text: 'Rust' },
            { value: 'typescript', text: 'TypeScript' },
            { value: 'json', text: 'JSON' },
            { value: 'xml', text: 'XML' },
            { value: 'sql', text: 'SQL' },
            { value: 'bash', text: 'Bash' },
            { value: 'markdown', text: 'Markdown' }
        ];
        languages.forEach(lang => {
            const option = document.createElement('option');
            option.value = lang.value;
            option.textContent = lang.text;
            this.languageSelect.appendChild(option);
        });
        this.languageSelect.addEventListener('change', (e) => {
            this.currentLanguage = e.target.value;
        });
        languageSection.appendChild(languageLabel);
        languageSection.appendChild(this.languageSelect);
        baseContainer.appendChild(languageSection);

        // Code input area
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Paste Your Code Here:';
        inputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.codeInput = document.createElement('textarea');
        this.codeInput.style.cssText = `
            width: 100%;
            height: 200px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            resize: vertical;
            box-sizing: border-box;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        `;
        this.codeInput.placeholder = `// Paste your code here
// For example:
function helloWorld() {
    console.log("Hello, World!");
}`;
        this.codeInput.addEventListener('input', () => {
            this.currentCode = this.codeInput.value;
        });
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.codeInput);
        baseContainer.appendChild(inputSection);

        // Action buttons
        const buttonSection = document.createElement('div');
        buttonSection.style.cssText = `
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        `;
        this.captureButton = this.createButton('Capture Code', '#007acc', () => {
            this.captureCode();
        });
        this.clearButton = this.createButton('Clear', '#dc3545', () => {
            this.clearCode();
        });
        this.copyButton = this.createButton('Copy', '#28a745', () => {
            this.copyCode();
        });
        this.analyzeButton = this.createButton('Analyze', '#ffc107', () => {
            this.analyzeCode();
        });
        buttonSection.appendChild(this.captureButton);
        buttonSection.appendChild(this.clearButton);
        buttonSection.appendChild(this.copyButton);
        buttonSection.appendChild(this.analyzeButton);
        baseContainer.appendChild(buttonSection);

        // Code display area
        const displaySection = document.createElement('div');
        displaySection.style.cssText = `
            margin-bottom: 20px;
        `;
        const displayLabel = document.createElement('label');
        displayLabel.textContent = 'Formatted Code:';
        displayLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.codeDisplay = document.createElement('pre');
        this.codeDisplay.style.cssText = `
            width: 100%;
            min-height: 150px;
            max-height: 300px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        `;
        this.codeDisplay.textContent = '// Your formatted code will appear here';
        displaySection.appendChild(displayLabel);
        displaySection.appendChild(this.codeDisplay);
        baseContainer.appendChild(displaySection);

        // Output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Analysis Output:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.outputDiv = document.createElement('div');
        this.outputDiv.style.cssText = `
            width: 100%;
            min-height: 100px;
            max-height: 200px;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 5px;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        `;
        this.outputDiv.textContent = '// Code analysis results will appear here';
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputDiv);
        baseContainer.appendChild(outputSection);

        // Captured snippets section
        const snippetsSection = document.createElement('div');
        snippetsSection.style.cssText = `
            margin-top: auto;
        `;
        const snippetsLabel = document.createElement('label');
        snippetsLabel.textContent = 'Captured Snippets:';
        snippetsLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        `;
        this.snippetsList = document.createElement('div');
        this.snippetsList.style.cssText = `
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #2d2d30;
            padding: 10px;
        `;
        this.snippetsList.textContent = 'No captured snippets yet';
        snippetsSection.appendChild(snippetsLabel);
        snippetsSection.appendChild(this.snippetsList);
        baseContainer.appendChild(snippetsSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Capture and format the code
     */
    captureCode() {
        if (!this.currentCode.trim()) {
            this.outputDiv.textContent = '// Error: No code to capture';
            return;
        }

        // Format the code with syntax highlighting
        const formattedCode = this.formatCode(this.currentCode, this.currentLanguage);
        this.codeDisplay.innerHTML = formattedCode;

        // Save to captured snippets
        const snippet = {
            id: Date.now(),
            code: this.currentCode,
            language: this.currentLanguage,
            timestamp: new Date().toLocaleString(),
            lines: this.currentCode.split('\n').length
        };
        this.capturedSnippets.push(snippet);
        this.saveCapturedSnippets();
        this.updateSnippetsList();

        // Basic analysis
        this.analyzeCode();

        botReply(`Code captured successfully (${snippet.lines} lines of ${this.currentLanguage})`);
    }

    /**
     * Format code with syntax highlighting
     */
    formatCode(code, language) {
        let formatted = code
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');

        // Apply language-specific highlighting
        switch (language) {
            case 'javascript':
            case 'typescript':
                formatted = this.highlightJavaScript(formatted);
                break;
            case 'html':
                formatted = this.highlightHTML(formatted);
                break;
            case 'css':
                formatted = this.highlightCSS(formatted);
                break;
            case 'python':
                formatted = this.highlightPython(formatted);
                break;
            case 'json':
                formatted = this.highlightJSON(formatted);
                break;
            case 'sql':
                formatted = this.highlightSQL(formatted);
                break;
            default:
                // Generic highlighting for other languages
                formatted = this.highlightGeneric(formatted);
        }

        return formatted;
    }

    /**
     * Highlight JavaScript/TypeScript code
     */
    highlightJavaScript(code) {
        // Keywords
        const keywords = /\b(function|var|let|const|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|class|extends|import|export|default|async|await|new|this|super|typeof|instanceof|in|of|delete|void|yield|debugger)\b/g;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /(['"`])((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*|0x[0-9a-fA-F]+)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        // Functions
        const functions = /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g;
        code = code.replace(functions, '<span style="color: #dcdcaa;">$1</span>(');

        return code;
    }

    /**
     * Highlight HTML code
     */
    highlightHTML(code) {
        // Tags
        const tags = /(&lt;\/?[a-zA-Z0-9]+&gt;)/g;
        code = code.replace(tags, '<span style="color: #569cd6;">$&</span>');

        // Attributes
        const attributes = /\b([a-zA-Z-]+)=["'][^"']*["']/g;
        code = code.replace(attributes, '<span style="color: #9cdcfe;">$1</span>=');

        // Strings in attributes
        const attrStrings = /=["']([^"']*)["']/g;
        code = code.replace(attrStrings, '=<span style="color: #ce9178;">"$1"</span>');

        // Comments
        const comments = /(&lt;!--[\s\S]*?--&gt;)/g;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Highlight CSS code
     */
    highlightCSS(code) {
        // Selectors
        const selectors = /([^{]+)\{/g;
        code = code.replace(selectors, '<span style="color: #d7ba7d;">$1</span>{');

        // Properties
        const properties = /\b([a-zA-Z-]+)\s*:/g;
        code = code.replace(properties, '<span style="color: #9cdcfe;">$1</span>:');

        // Values
        const values = /:\s*([^;]+);/g;
        code = code.replace(values, ': <span style="color: #ce9178;">$1</span>;');

        // Numbers in values
        const numbers = /\b(\d+\.?\d*)(px|em|rem|%|vh|vw|pt|pc|in|cm|mm)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$1$2</span>');

        // Colors
        const colors = /#[0-9a-fA-F]{3,6}\b/g;
        code = code.replace(colors, '<span style="color: #ce9178;">$&</span>');

        // Comments
        const comments = /\/\*[\s\S]*?\*\//g;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Highlight Python code
     */
    highlightPython(code) {
        // Keywords
        const keywords = /\b(def|class|if|elif|else|for|while|try|except|finally|with|as|import|from|return|yield|raise|assert|del|pass|break|continue|and|or|not|in|is|lambda|global|nonlocal)\b/g;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /('''|"""|'|"")((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(#.*$)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        // Functions
        const functions = /\bdef\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
        code = code.replace(functions, 'def <span style="color: #dcdcaa;">$1</span>');

        return code;
    }

    /**
     * Highlight JSON code
     */
    highlightJSON(code) {
        // Strings
        const strings = /"([^"]*)":/g;
        code = code.replace(strings, '<span style="color: #9cdcfe;">"$1"</span>:');

        // String values
        const values = /:\s*"([^"]*)"/g;
        code = code.replace(values, ': <span style="color: #ce9178;">"$1"</span>');

        // Numbers
        const numbers = /:\s*(\d+\.?\d*)/g;
        code = code.replace(numbers, ': <span style="color: #b5cea8;">$1</span>');

        // Booleans
        const booleans = /:\s*(true|false|null)/g;
        code = code.replace(booleans, ': <span style="color: #569cd6;">$1</span>');

        return code;
    }

    /**
     * Highlight SQL code
     */
    highlightSQL(code) {
        // Keywords
        const keywords = /\b(SELECT|FROM|WHERE|INSERT|INTO|VALUES|UPDATE|SET|DELETE|CREATE|TABLE|DROP|ALTER|JOIN|INNER|LEFT|RIGHT|FULL|OUTER|ON|GROUP|BY|ORDER|HAVING|LIMIT|OFFSET|UNION|ALL|DISTINCT|AS|AND|OR|NOT|IN|EXISTS|BETWEEN|LIKE|IS|NULL)\b/gi;
        code = code.replace(keywords, '<span style="color: #569cd6;">$&</span>');

        // Strings
        const strings = /'[^']*'/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$&</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments
        const comments = /(--.*$|\/\*[\s\S]*?\*\/)/gm;
        code = code.replace(comments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Generic highlighting for other languages
     */
    highlightGeneric(code) {
        // Strings
        const strings = /(['"`])((?:(?!\1)[^\\]|\\.)*)(\1)/g;
        code = code.replace(strings, '<span style="color: #ce9178;">$1$2$3</span>');

        // Numbers
        const numbers = /\b(\d+\.?\d*)\b/g;
        code = code.replace(numbers, '<span style="color: #b5cea8;">$&</span>');

        // Comments (// style)
        const lineComments = /\/\/.*$/gm;
        code = code.replace(lineComments, '<span style="color: #6a9955;">$&</span>');

        // Comments (/* */ style)
        const blockComments = /\/\*[\s\S]*?\*\//g;
        code = code.replace(blockComments, '<span style="color: #6a9955;">$&</span>');

        return code;
    }

    /**
     * Analyze the captured code
     */
    analyzeCode() {
        if (!this.currentCode.trim()) {
            this.outputDiv.textContent = '// Error: No code to analyze';
            return;
        }

        let analysis = `// Code Analysis Results\n`;
        analysis += `// Language: ${this.currentLanguage.toUpperCase()}\n`;
        analysis += `// Lines: ${this.currentCode.split('\n').length}\n`;
        analysis += `// Characters: ${this.currentCode.length}\n\n`;

        // Basic analysis based on language
        switch (this.currentLanguage) {
            case 'javascript':
            case 'typescript':
                analysis += this.analyzeJavaScript();
                break;
            case 'html':
                analysis += this.analyzeHTML();
                break;
            case 'css':
                analysis += this.analyzeCSS();
                break;
            case 'python':
                analysis += this.analyzePython();
                break;
            case 'json':
                analysis += this.analyzeJSON();
                break;
            case 'sql':
                analysis += this.analyzeSQL();
                break;
            default:
                analysis += '// Basic analysis completed\n';
        }

        this.outputDiv.textContent = analysis;
    }

    /**
     * Analyze JavaScript code
     */
    analyzeJavaScript() {
        let analysis = '// JavaScript Analysis:\n';
        
        // Count functions
        const functionCount = (this.currentCode.match(/\bfunction\b/g) || []).length;
        analysis += `// Functions: ${functionCount}\n`;
        
        // Count variables
        const varCount = (this.currentCode.match(/\b(var|let|const)\b/g) || []).length;
        analysis += `// Variables: ${varCount}\n`;
        
        // Check for async/await
        const hasAsync = /async/.test(this.currentCode);
        analysis += `// Uses async/await: ${hasAsync ? 'Yes' : 'No'}\n`;
        
        // Check for promises
        const hasPromises = /Promise/.test(this.currentCode);
        analysis += `// Uses Promises: ${hasPromises ? 'Yes' : 'No'}\n`;
        
        // Check for arrow functions
        const arrowCount = (this.currentCode.match(/=>/g) || []).length;
        analysis += `// Arrow functions: ${arrowCount}\n`;
        
        return analysis;
    }

    /**
     * Analyze HTML code
     */
    analyzeHTML() {
        let analysis = '// HTML Analysis:\n';
        
        // Count tags
        const tagCount = (this.currentCode.match(/&lt;\/?[a-zA-Z0-9]+&gt;/g) || []).length;
        analysis += `// HTML tags: ${tagCount}\n`;
        
        // Check for common tags
        const hasDiv = /&lt;div/i.test(this.currentCode);
        analysis += `// Contains div elements: ${hasDiv ? 'Yes' : 'No'}\n`;
        
        const hasForm = /&lt;form/i.test(this.currentCode);
        analysis += `// Contains forms: ${hasForm ? 'Yes' : 'No'}\n`;
        
        const hasScript = /&lt;script/i.test(this.currentCode);
        analysis += `// Contains scripts: ${hasScript ? 'Yes' : 'No'}\n`;
        
        const hasStyle = /&lt;style/i.test(this.currentCode);
        analysis += `// Contains styles: ${hasStyle ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze CSS code
     */
    analyzeCSS() {
        let analysis = '// CSS Analysis:\n';
        
        // Count selectors
        const selectorCount = (this.currentCode.match(/[^{]+(?=\{)/g) || []).length;
        analysis += `// CSS selectors: ${selectorCount}\n`;
        
        // Count properties
        const propertyCount = (this.currentCode.match(/[a-zA-Z-]+(?=:)/g) || []).length;
        analysis += `// CSS properties: ${propertyCount}\n`;
        
        // Check for media queries
        const hasMediaQueries = /@media/.test(this.currentCode);
        analysis += `// Contains media queries: ${hasMediaQueries ? 'Yes' : 'No'}\n`;
        
        // Check for animations
        const hasAnimations = /@keyframes|animation/.test(this.currentCode);
        analysis += `// Contains animations: ${hasAnimations ? 'Yes' : 'No'}\n`;
        
        // Check for flexbox
        const hasFlexbox = /display:\s*flex/i.test(this.currentCode);
        analysis += `// Uses flexbox: ${hasFlexbox ? 'Yes' : 'No'}\n`;
        
        // Check for grid
        const hasGrid = /display:\s*grid/i.test(this.currentCode);
        analysis += `// Uses grid: ${hasGrid ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze Python code
     */
    analyzePython() {
        let analysis = '// Python Analysis:\n';
        
        // Count functions
        const functionCount = (this.currentCode.match(/\bdef\b/g) || []).length;
        analysis += `// Functions: ${functionCount}\n`;
        
        // Count classes
        const classCount = (this.currentCode.match(/\bclass\b/g) || []).length;
        analysis += `// Classes: ${classCount}\n`;
        
        // Check for imports
        const importCount = (this.currentCode.match(/\bimport\b/g) || []).length;
        analysis += `// Import statements: ${importCount}\n`;
        
        // Check for loops
        const forCount = (this.currentCode.match(/\bfor\b/g) || []).length;
        const whileCount = (this.currentCode.match(/\bwhile\b/g) || []).length;
        analysis += `// For loops: ${forCount}\n`;
        analysis += `// While loops: ${whileCount}\n`;
        
        // Check for comprehensions
        const hasComprehensions = /\[.*for.*in.*\]/.test(this.currentCode);
        analysis += `// Uses comprehensions: ${hasComprehensions ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Analyze JSON code
     */
    analyzeJSON() {
        let analysis = '// JSON Analysis:\n';
        
        try {
            const parsed = JSON.parse(this.currentCode);
            
            // Check if it's an object or array
            if (Array.isArray(parsed)) {
                analysis += `// Type: Array\n`;
                analysis += `// Elements: ${parsed.length}\n`;
            } else if (typeof parsed === 'object' && parsed !== null) {
                analysis += `// Type: Object\n`;
                analysis += `// Properties: ${Object.keys(parsed).length}\n`;
            }
            
            // Check for nested structures
            const hasNested = JSON.stringify(parsed).includes('{');
            analysis += `// Has nested structures: ${hasNested ? 'Yes' : 'No'}\n`;
            
        } catch (error) {
            analysis += `// Invalid JSON: ${error.message}\n`;
        }
        
        return analysis;
    }

    /**
     * Analyze SQL code
     */
    analyzeSQL() {
        let analysis = '// SQL Analysis:\n';
        
        // Check for SELECT statements
        const hasSelect = /SELECT/i.test(this.currentCode);
        analysis += `// Contains SELECT: ${hasSelect ? 'Yes' : 'No'}\n`;
        
        // Check for JOINs
        const joinCount = (this.currentCode.match(/JOIN/gi) || []).length;
        analysis += `// JOINs: ${joinCount}\n`;
        
        // Check for subqueries
        const hasSubqueries = /\(.*SELECT/i.test(this.currentCode);
        analysis += `// Contains subqueries: ${hasSubqueries ? 'Yes' : 'No'}\n`;
        
        // Check for aggregations
        const hasAggregations = /(COUNT|SUM|AVG|MIN|MAX)/i.test(this.currentCode);
        analysis += `// Uses aggregations: ${hasAggregations ? 'Yes' : 'No'}\n`;
        
        // Check for GROUP BY
        const hasGroupBy = /GROUP BY/i.test(this.currentCode);
        analysis += `// Uses GROUP BY: ${hasGroupBy ? 'Yes' : 'No'}\n`;
        
        return analysis;
    }

    /**
     * Clear the code input and display
     */
    clearCode() {
        this.currentCode = '';
        this.codeInput.value = '';
        this.codeDisplay.textContent = '// Your formatted code will appear here';
        this.outputDiv.textContent = '// Code analysis results will appear here';
        botReply('Code cleared');
    }

    /**
     * Copy the formatted code to clipboard
     */
    copyCode() {
        if (!this.currentCode.trim()) {
            botReply('No code to copy');
            return;
        }

        if (navigator.clipboard) {
            navigator.clipboard.writeText(this.currentCode)
                .then(() => {
                    botReply('Code copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(this.currentCode);
                });
        } else {
            this.fallbackCopyTextToClipboard(this.currentCode);
        }
    }

    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Code copied to clipboard!');
            } else {
                botReply('Unable to copy code');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy code');
        }
        document.body.removeChild(textArea);
    }

    /**
     * Save captured snippets to localStorage
     */
    saveCapturedSnippets() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.capturedSnippets));
        } catch (error) {
            console.error('Error saving captured snippets:', error);
        }
    }

    /**
     * Load captured snippets from localStorage
     */
    loadCapturedSnippets() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                this.capturedSnippets = JSON.parse(stored);
                this.updateSnippetsList();
            }
        } catch (error) {
            console.error('Error loading captured snippets:', error);
        }
    }

    /**
     * Update the snippets list display
     */
    updateSnippetsList() {
        this.snippetsList.innerHTML = '';
        
        if (this.capturedSnippets.length === 0) {
            this.snippetsList.textContent = 'No captured snippets yet';
            return;
        }
        
        this.capturedSnippets.forEach(snippet => {
            const item = document.createElement('div');
            item.style.cssText = `
                padding: 8px;
                margin-bottom: 5px;
                background-color: #1e1e1e;
                border-radius: 5px;
                cursor: pointer;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background-color 0.2s;
            `;
            item.addEventListener('mouseenter', () => {
                item.style.backgroundColor = '#2d2d30';
            });
            item.addEventListener('mouseleave', () => {
                item.style.backgroundColor = '#1e1e1e';
            });
            
            const snippetInfo = document.createElement('div');
            snippetInfo.style.cssText = `
                flex-grow: 1;
            `;
            const snippetTitle = document.createElement('div');
            snippetTitle.textContent = `${snippet.language.toUpperCase()} - ${snippet.lines} lines`;
            snippetTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 2px;
                color: #ffffff;
            `;
            const snippetDetails = document.createElement('div');
            snippetDetails.textContent = snippet.timestamp;
            snippetDetails.style.cssText = `
                font-size: 12px;
                color: #999999;
            `;
            snippetInfo.appendChild(snippetTitle);
            snippetInfo.appendChild(snippetDetails);
            
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load';
            loadButton.style.cssText = `
                padding: 4px 8px;
                background-color: #007acc;
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
                font-size: 12px;
            `;
            loadButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.loadSnippet(snippet);
            });
            
            item.appendChild(snippetInfo);
            item.appendChild(loadButton);
            this.snippetsList.appendChild(item);
        });
    }

    /**
     * Load a captured snippet
     */
    loadSnippet(snippet) {
        this.currentCode = snippet.code;
        this.currentLanguage = snippet.language;
        this.codeInput.value = snippet.code;
        this.languageSelect.value = snippet.language;
        botReply(`Loaded snippet: ${snippet.language.toUpperCase()} - ${snippet.lines} lines`);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        } else if (event.ctrlKey && event.key === 'Enter') {
            event.preventDefault();
            this.captureCode();
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.codeInput = null;
        this.codeDisplay = null;
        this.languageSelect = null;
        this.captureButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.analyzeButton = null;
        this.outputDiv = null;
        this.snippetsList = null;
        this.currentCode = '';
        this.currentLanguage = 'javascript';
        this.capturedSnippets = [];
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Code Capture Tool closed. Thank you!");
    }
}

// Create a singleton instance
const captureScreenLoader = new CaptureScreenLoader();

// Add this to your AI's command handling
if (/code capture|capture code|f12 capture|developer tools/i.test(userInputRaw)) {
    captureScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    captureScreenLoader.closeGame();
    return;
}





class FileConverter {
constructor() {
this.baseScreen = {
name: 'FILE CONVERTER',
instructions: 'Convert images, text, or create Excel/DOCX files. Supports multiple formats.'
};

this.gameContainer = null;
this.isActive = false;
this.isFullscreen = false;
this.fullscreenButton = null;
this.closeButton = null;
this.fileInput = null;
this.textInput = null;
this.convertButton = null;
this.clearButton = null;
this.downloadButton = null;
this.imagePreview = null;
this.outputDiv = null;
this.selectedFiles = [];
this.conversionMode = 'image'; // 'image', 'text', 'excel', 'docx'
this.fileBlob = null;
}

/**
* Load the File Converter
*/
loadBaseScreen() {
if (this.isActive) {
botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
return;
}

this.createGameContainer();
this.createConverterScreen();
this.setupActionButtons();
this.displayGame();

this.isActive = true;
botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
}

/**
* Create the game container
*/
createGameContainer() {
const existingContainer = document.getElementById('screen-container');
if (existingContainer) {
existingContainer.remove();
}

this.gameContainer = document.createElement('div');
this.gameContainer.id = 'screen-container';
this.gameContainer.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 9999;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
`;
}

/**
* Create the Converter UI
*/
createConverterScreen() {
const baseContainer = document.createElement('div');
baseContainer.style.cssText = `
background-color: #f5f5f5;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
padding: 20px;
width: 700px;
max-width: 90vw;
max-height: 80vh;
display: flex;
flex-direction: column;
`;

// Header
const header = document.createElement('div');
header.style.cssText = `
text-align: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid #ddd;
`;

const title = document.createElement('h2');
title.textContent = 'File Converter';
title.style.cssText = `
margin: 0 0 10px 0;
color: #333;
font-size: 24px;
`;

const subtitle = document.createElement('p');
subtitle.textContent = 'Convert files to PDF, Excel, or DOCX format';
subtitle.style.cssText = `
margin: 0;
color: #666;
font-size: 16px;
`;

header.appendChild(title);
header.appendChild(subtitle);
baseContainer.appendChild(header);

// Conversion mode selector
const modeSection = document.createElement('div');
modeSection.style.cssText = `
margin-bottom: 15px;
display: flex;
justify-content: center;
gap: 15px;
flex-wrap: wrap;
`;

// Image mode
const imageModeLabel = this.createModeLabel('Image to PDF', 'image', true);
modeSection.appendChild(imageModeLabel);

// Text mode
const textModeLabel = this.createModeLabel('Text to PDF', 'text', false);
modeSection.appendChild(textModeLabel);

// Excel mode
const excelModeLabel = this.createModeLabel('Create Excel', 'excel', false);
modeSection.appendChild(excelModeLabel);

// DOCX mode
const docxModeLabel = this.createModeLabel('Create DOCX', 'docx', false);
modeSection.appendChild(docxModeLabel);

baseContainer.appendChild(modeSection);

// Image input section (initially visible)
this.imageSection = document.createElement('div');
this.imageSection.id = 'imageSection';

const uploadLabel = document.createElement('label');
uploadLabel.textContent = 'Select Images:';
uploadLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.fileInput = document.createElement('input');
this.fileInput.type = 'file';
this.fileInput.multiple = true;
this.fileInput.accept = 'image/*';
this.fileInput.style.cssText = `
width: 100%;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
margin-bottom: 10px;
`;

this.fileInput.addEventListener('change', (e) => {
this.handleFileSelect(e);
});

this.imageSection.appendChild(uploadLabel);
this.imageSection.appendChild(this.fileInput);
baseContainer.appendChild(this.imageSection);

// Text input section (initially hidden)
this.textSection = document.createElement('div');
this.textSection.id = 'textSection';
this.textSection.style.display = 'none';

const textLabel = document.createElement('label');
textLabel.textContent = 'Enter Text:';
textLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.textInput = document.createElement('textarea');
this.textInput.placeholder = 'Enter text to convert to PDF...';
this.textInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.textSection.appendChild(textLabel);
this.textSection.appendChild(this.textInput);
baseContainer.appendChild(this.textSection);

// Excel input section (initially hidden)
this.excelSection = document.createElement('div');
this.excelSection.id = 'excelSection';
this.excelSection.style.display = 'none';

const excelLabel = document.createElement('label');
excelLabel.textContent = 'Excel Data (CSV format):';
excelLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.excelInput = document.createElement('textarea');
this.excelInput.placeholder = 'Enter data in CSV format:\nName,Age,City\nJohn,25,New York\nJane,30,Los Angeles';
this.excelInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.excelSection.appendChild(excelLabel);
this.excelSection.appendChild(this.excelInput);
baseContainer.appendChild(this.excelSection);

// DOCX input section (initially hidden)
this.docxSection = document.createElement('div');
this.docxSection.id = 'docxSection';
this.docxSection.style.display = 'none';

const docxLabel = document.createElement('label');
docxLabel.textContent = 'Document Content:';
docxLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.docxInput = document.createElement('textarea');
this.docxInput.placeholder = 'Enter document content...';
this.docxInput.style.cssText = `
width: 100%;
height: 120px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.docxSection.appendChild(docxLabel);
this.docxSection.appendChild(this.docxInput);
baseContainer.appendChild(this.docxSection);

// Preview area (for images)
this.imagePreview = document.createElement('div');
this.imagePreview.style.cssText = `
width: 100%;
min-height: 120px;
max-height: 200px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow-y: auto;
margin-bottom: 15px;
display: flex;
flex-wrap: wrap;
gap: 10px;
`;

this.imagePreview.textContent = 'No images selected';
baseContainer.appendChild(this.imagePreview);

// Button grid
const buttonGrid = document.createElement('div');
buttonGrid.style.cssText = `
display: grid;
grid-template-columns: repeat(3, 1fr);
grid-gap: 10px;
margin-bottom: 15px;
`;

// Convert button
this.convertButton = this.createButton('Convert to PDF', '#4CAF50', () => {
this.convertFile();
});

// Clear button
this.clearButton = this.createButton('Clear', '#f44336', () => {
this.clearFields();
});

// Download button (initially disabled)
this.downloadButton = this.createButton('Download File', '#2196F3', () => {
this.downloadFile();
});
this.downloadButton.disabled = true;
this.downloadButton.style.opacity = '0.5';
this.downloadButton.style.cursor = 'not-allowed';

buttonGrid.appendChild(this.convertButton);
buttonGrid.appendChild(this.clearButton);
buttonGrid.appendChild(this.downloadButton);

baseContainer.appendChild(buttonGrid);

// Output section
const outputSection = document.createElement('div');
outputSection.style.cssText = `
margin-bottom: 15px;
`;

const outputLabel = document.createElement('label');
outputLabel.textContent = 'Status:';
outputLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.outputDiv = document.createElement('div');
this.outputDiv.style.cssText = `
width: 100%;
min-height: 80px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
`;

this.outputDiv.textContent = 'Ready to convert files';

outputSection.appendChild(outputLabel);
outputSection.appendChild(this.outputDiv);
baseContainer.appendChild(outputSection);

// Info section
const infoSection = document.createElement('div');
infoSection.style.cssText = `
background-color: #e3f2fd;
border-radius: 5px;
padding: 10px;
font-size: 14px;
color: #1976d2;
border-left: 4px solid #2196F3;
`;

infoSection.innerHTML = `
<strong>Instructions:</strong><br>
            • Select conversion mode: Image, Text, Excel, or DOCX<br>
            • For images: Select one or more images<br>
            • For text: Enter your text in the text area<br>
            • For Excel: Enter data in CSV format<br>
            • For DOCX: Enter document content<br>
            • Click "Convert" to process and "Download" to save
        `;

        baseContainer.appendChild(infoSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Create a mode label with radio button
     */
    createModeLabel(text, value, isChecked) {
        const label = document.createElement('label');
        label.style.cssText = `
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.2s;
        `;

        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'conversionMode';
        radio.value = value;
        radio.checked = isChecked;
        radio.style.marginRight = '5px';

        radio.addEventListener('change', () => {
            this.setConversionMode(value);
        });

        label.appendChild(radio);
        label.appendChild(document.createTextNode(text));

        return label;
    }

    /**
     * Set conversion mode
     */
    setConversionMode(mode) {
        this.conversionMode = mode;

        // Hide all sections
        this.imageSection.style.display = 'none';
        this.textSection.style.display = 'none';
        this.excelSection.style.display = 'none';
        this.docxSection.style.display = 'none';
        this.imagePreview.style.display = 'none';

        // Show appropriate section and update UI
        switch (mode) {
            case 'image':
                this.imageSection.style.display = 'block';
                this.imagePreview.style.display = 'flex';
                this.convertButton.textContent = 'Convert to PDF';
                this.outputDiv.textContent = 'Ready to convert images to PDF';
                break;
            case 'text':
                this.textSection.style.display = 'block';
                this.convertButton.textContent = 'Convert to PDF';
                this.outputDiv.textContent = 'Ready to convert text to PDF';
                break;
            case 'excel':
                this.excelSection.style.display = 'block';
                this.convertButton.textContent = 'Create Excel File';
                this.outputDiv.textContent = 'Ready to create Excel file';
                break;
            case 'docx':
                this.docxSection.style.display = 'block';
                this.convertButton.textContent = 'Create DOCX File';
                this.outputDiv.textContent = 'Ready to create DOCX file';
                break;
        }

        // Reset download button
        this.downloadButton.disabled = true;
        this.downloadButton.style.opacity = '0.5';
        this.downloadButton.style.cursor = 'not-allowed';
        this.fileBlob = null;
    }

    /**
     * Handle file selection
     */
    handleFileSelect(event) {
        this.selectedFiles = Array.from(event.target.files);
        this.updateImagePreview();

        if (this.selectedFiles.length > 0) {
            this.outputDiv.textContent = `${this.selectedFiles.length} image(s) selected. Ready to convert.`;
        } else {
            this.outputDiv.textContent = 'No images selected.';
        }
    }

    /**
     * Update the image preview area
     */
    updateImagePreview() {
        this.imagePreview.innerHTML = '';

        if (this.selectedFiles.length === 0) {
            this.imagePreview.textContent = 'No images selected';
            return;
        }

        this.selectedFiles.forEach((file, index) => {
            const reader = new FileReader();

            reader.onload = (e) => {
                const imgContainer = document.createElement('div');
                imgContainer.style.cssText = `
                    position: relative;
                    width: 100px;
                    height: 100px;
                    border: 1px solid #ddd;
                    border-radius: 5px;
                    overflow: hidden;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                const img = document.createElement('img');
                img.src = e.target.result;
                img.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                `;

                const imgLabel = document.createElement('div');
                imgLabel.textContent = file.name;
                imgLabel.style.cssText = `
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    font-size: 10px;
                    padding: 2px;
                    text-align: center;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;

                imgContainer.appendChild(img);
                imgContainer.appendChild(imgLabel);
                this.imagePreview.appendChild(imgContainer);
            };

            reader.readAsDataURL(file);
        });
    }

    /**
     * Convert file based on selected mode
     */
    convertFile() {
        switch (this.conversionMode) {
            case 'image':
                this.convertImagesToPdf();
                break;
            case 'text':
                this.convertTextToPdf();
                break;
            case 'excel':
                this.convertToExcel();
                break;
            case 'docx':
                this.convertToDocx();
                break;
        }
    }

    /**
     * Convert images to PDF
     */
    convertImagesToPdf() {
        if (this.selectedFiles.length === 0) {
            botReply('Please select at least one image to convert.');
            return;
        }

        this.outputDiv.textContent = 'Converting images to PDF...';

        if (typeof window.jsPDF === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', () => {
                this.processImagesToPdf();
            });
        } else {
            this.processImagesToPdf();
        }
    }

    /**
     * Convert text to PDF
     */
    convertTextToPdf() {
        const text = this.textInput.value.trim();
        if (!text) {
            botReply('Please enter some text to convert.');
            return;
        }

        this.outputDiv.textContent = 'Converting text to PDF...';

        if (typeof window.jsPDF === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', () => {
                this.processTextToPdf(text);
            });
        } else {
            this.processTextToPdf(text);
        }
    }

    /**
     * Convert to Excel
     */
    convertToExcel() {
        const csvData = this.excelInput.value.trim();
        if (!csvData) {
            botReply('Please enter some data to convert to Excel.');
            return;
        }

        this.outputDiv.textContent = 'Creating Excel file...';

        if (typeof window.XLSX === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js', () => {
                this.processToExcel(csvData);
            });
        } else {
            this.processToExcel(csvData);
        }
    }

    /**
     * Convert to DOCX
     */
    convertToDocx() {
        const docContent = this.docxInput.value.trim();
        if (!docContent) {
            botReply('Please enter some content to create a DOCX file.');
            return;
        }

        this.outputDiv.textContent = 'Creating DOCX file...';

        if (typeof window.docx === 'undefined') {
            this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js', () => {
                this.loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js', () => {
                    this.processToDocx(docContent);
                });
            });
        } else {
            this.processToDocx(docContent);
        }
    }

    /**
     * Process images to create PDF
     */
    processImagesToPdf() {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();

        let processedImages = 0;
        const totalImages = this.selectedFiles.length;

        this.selectedFiles.forEach((file, index) => {
            const reader = new FileReader();

            reader.onload = (e) => {
                const imgData = e.target.result;
                const imgProps = pdf.getImageProperties(imgData);
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

                if (index > 0) {
                    pdf.addPage();
                }

                pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);

                processedImages++;
                this.outputDiv.textContent = `Processing image ${processedImages} of ${totalImages}...`;

                if (processedImages === totalImages) {
                    this.fileBlob = pdf.output('blob');
                    this.outputDiv.textContent = `PDF created successfully with ${totalImages} image(s).`;

                    this.downloadButton.disabled = false;
                    this.downloadButton.style.opacity = '1';
                    this.downloadButton.style.cursor = 'pointer';

                    botReply('Images converted to PDF successfully!');
                }
            };

            reader.readAsDataURL(file);
        });
    }

    /**
     * Process text to create PDF
     */
    processTextToPdf(text) {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF();

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const margin = 15;
        const maxWidth = pageWidth - 2 * margin;

        const lines = pdf.splitTextToSize(text, maxWidth);
        pdf.text(lines, margin, margin);

        this.fileBlob = pdf.output('blob');
        this.outputDiv.textContent = 'PDF created successfully from text.';

        this.downloadButton.disabled = false;
        this.downloadButton.style.opacity = '1';
        this.downloadButton.style.cursor = 'pointer';

        botReply('Text converted to PDF successfully!');
    }

    /**
     * Process CSV data to create Excel file
     */
    processToExcel(csvData) {
        // Parse CSV data
        const lines = csvData.split('\n');
        const data = [];

        lines.forEach(line => {
            const values = line.split(',');
            data.push(values);
        });

        // Create workbook
        const workbook = XLSX.utils.book_new();
        const worksheet = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');

        // Generate Excel file
        const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        this.fileBlob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

        this.outputDiv.textContent = 'Excel file created successfully.';

        this.downloadButton.disabled = false;
        this.downloadButton.style.opacity = '1';
        this.downloadButton.style.cursor = 'pointer';

        botReply('Excel file created successfully!');
    }

    /**
     * Process text to create DOCX file
     */
    processToDocx(docContent) {
        // Create document
        const doc = new docx.Document({
            sections: [{
                properties: {},
                children: [
                    new docx.Paragraph({
                        children: [
                            new docx.TextRun(docContent)
                        ],
                    }),
                ],
            }],
        });

        // Generate DOCX file
        docx.Packer.toBlob(doc).then(blob => {
            this.fileBlob = blob;

            this.outputDiv.textContent = 'DOCX file created successfully.';

            this.downloadButton.disabled = false;
            this.downloadButton.style.opacity = '1';
            this.downloadButton.style.cursor = 'pointer';

            botReply('DOCX file created successfully!');
        });
    }

    /**
     * Download the generated file
     */
    downloadFile() {
        if (!this.fileBlob) {
            botReply('No file available for download. Please convert files first.');
            return;
        }

        let fileName = 'converted-file';
        let fileExtension = '.pdf';

        switch (this.conversionMode) {
            case 'image':
                fileName = 'converted-images';
                fileExtension = '.pdf';
                break;
            case 'text':
                fileName = 'converted-text';
                fileExtension = '.pdf';
                break;
            case 'excel':
                fileName = 'converted-data';
                fileExtension = '.xlsx';
                break;
            case 'docx':
                fileName = 'converted-document';
                fileExtension = '.docx';
                break;
        }

        const url = URL.createObjectURL(this.fileBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName + fileExtension;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        botReply('File downloaded successfully!');
    }

    /**
     * Clear all fields and selections
     */
    clearFields() {
        this.fileInput.value = '';
        this.textInput.value = '';
        this.excelInput.value = '';
        this.docxInput.value = '';
        this.selectedFiles = [];
        this.imagePreview.innerHTML = '';
        this.imagePreview.textContent = 'No images selected';
        this.outputDiv.textContent = `Ready to convert ${this.conversionMode}`;
        this.fileBlob = null;

        this.downloadButton.disabled = true;
        this.downloadButton.style.opacity = '0.5';
        this.downloadButton.style.cursor = 'not-allowed';

        botReply('Fields cleared.');
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;

        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });

        button.addEventListener('click', clickHandler);

        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;

        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };

        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };

        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };

        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;

        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };

        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };

        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };

        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);

        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);

        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;

        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;

        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;

        if (this.isFullscreen) {
            this.exitFullscreen();
        }

        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);

        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }

        this.gameContainer = null;
        this.fileInput = null;
        this.textInput = null;
        this.excelInput = null;
        this.docxInput = null;
        this.convertButton = null;
        this.clearButton = null;
        this.downloadButton = null;
        this.imagePreview = null;
        this.outputDiv = null;
        this.selectedFiles = [];
        this.fileBlob = null;
        this.conversionMode = 'image';
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;

        botReply("File Converter closed. Thank you!");
    }
}

// Create a singleton instance
const fileConverter = new FileConverter();

// Add this to your AI's command handling
if (/file converter|pdf convert|convert file|image to pdf|text to pdf|excel|docx|create excel|create docx/i.test(userInputRaw)) {
    fileConverter.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    fileConverter.closeGame();
    return;
}



class AllDocMount {
constructor() {
this.baseScreen = {
name: 'DOCUMENT MANAGER',
instructions: 'Upload, view, edit, download, and copy documents. Supports PDF, DOCX, TXT, and image files.'
};

this.gameContainer = null;
this.isActive = false;
this.isFullscreen = false;
this.fullscreenButton = null;
this.closeButton = null;
this.fileInput = null;
this.viewButton = null;
this.editButton = null;
this.copyButton = null;
this.downloadButton = null;
this.clearButton = null;
this.previewArea = null;
this.editorArea = null;
this.outputDiv = null;
this.currentFile = null;
this.fileContent = null;
this.fileType = null;
this.fileName = null;
this.isEditing = false;
}

/**
* Load the Document Manager
*/
loadBaseScreen() {
if (this.isActive) {
botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
return;
}

this.createGameContainer();
this.createDocManagerScreen();
this.setupActionButtons();
this.displayGame();

this.isActive = true;
botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
}

/**
* Create the game container
*/
createGameContainer() {
const existingContainer = document.getElementById('screen-container');
if (existingContainer) {
existingContainer.remove();
}

this.gameContainer = document.createElement('div');
this.gameContainer.id = 'screen-container';
this.gameContainer.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.8);
z-index: 9999;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
transition: all 0.3s ease;
`;
}

/**
* Create the Document Manager UI
*/
createDocManagerScreen() {
const baseContainer = document.createElement('div');
baseContainer.style.cssText = `
background-color: #f5f5f5;
border-radius: 10px;
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
padding: 20px;
width: 800px;
max-width: 90vw;
max-height: 80vh;
display: flex;
flex-direction: column;
`;

// Header
const header = document.createElement('div');
header.style.cssText = `
text-align: center;
margin-bottom: 20px;
padding-bottom: 15px;
border-bottom: 1px solid #ddd;
`;

const title = document.createElement('h2');
title.textContent = 'Document Manager';
title.style.cssText = `
margin: 0 0 10px 0;
color: #333;
font-size: 24px;
`;

const subtitle = document.createElement('p');
subtitle.textContent = 'Upload, view, edit, download, and copy documents';
subtitle.style.cssText = `
margin: 0;
color: #666;
font-size: 16px;
`;

header.appendChild(title);
header.appendChild(subtitle);
baseContainer.appendChild(header);

// Upload section
const uploadSection = document.createElement('div');
uploadSection.style.cssText = `
margin-bottom: 15px;
`;

const uploadLabel = document.createElement('label');
uploadLabel.textContent = 'Upload Document:';
uploadLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.fileInput = document.createElement('input');
this.fileInput.type = 'file';
this.fileInput.accept = '.pdf,.docx,.txt,.jpg,.jpeg,.png,.gif,.csv,.json,.html,.xml';
this.fileInput.style.cssText = `
width: 100%;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
margin-bottom: 10px;
`;

this.fileInput.addEventListener('change', (e) => {
this.handleFileUpload(e);
});

uploadSection.appendChild(uploadLabel);
uploadSection.appendChild(this.fileInput);
baseContainer.appendChild(uploadSection);

// Button grid
const buttonGrid = document.createElement('div');
buttonGrid.style.cssText = `
display: grid;
grid-template-columns: repeat(5, 1fr);
grid-gap: 10px;
margin-bottom: 15px;
`;

// View button
this.viewButton = this.createButton('View', '#4CAF50', () => {
this.viewDocument();
});
this.viewButton.disabled = true;

// Edit button
this.editButton = this.createButton('Edit', '#2196F3', () => {
this.editDocument();
});
this.editButton.disabled = true;

// Copy button
this.copyButton = this.createButton('Copy', '#FF9800', () => {
this.copyDocument();
});
this.copyButton.disabled = true;

// Download button
this.downloadButton = this.createButton('Download', '#9C27B0', () => {
this.downloadDocument();
});
this.downloadButton.disabled = true;

// Clear button
this.clearButton = this.createButton('Clear', '#f44336', () => {
this.clearDocument();
});

buttonGrid.appendChild(this.viewButton);
buttonGrid.appendChild(this.editButton);
buttonGrid.appendChild(this.copyButton);
buttonGrid.appendChild(this.downloadButton);
buttonGrid.appendChild(this.clearButton);

baseContainer.appendChild(buttonGrid);

// Preview area
this.previewArea = document.createElement('div');
this.previewArea.style.cssText = `
width: 100%;
height: 300px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow: auto;
margin-bottom: 15px;
display: flex;
align-items: center;
justify-content: center;
`;

this.previewArea.textContent = 'No document uploaded';
baseContainer.appendChild(this.previewArea);

// Editor area (initially hidden)
this.editorArea = document.createElement('div');
this.editorArea.style.cssText = `
width: 100%;
height: 300px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
overflow: auto;
margin-bottom: 15px;
display: none;
`;

const editorLabel = document.createElement('label');
editorLabel.textContent = 'Edit Document:';
editorLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.editorTextarea = document.createElement('textarea');
this.editorTextarea.style.cssText = `
width: 100%;
height: 250px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
font-family: 'Courier New', monospace;
resize: vertical;
box-sizing: border-box;
`;

this.editorArea.appendChild(editorLabel);
this.editorArea.appendChild(this.editorTextarea);
baseContainer.appendChild(this.editorArea);

// Output section
const outputSection = document.createElement('div');
outputSection.style.cssText = `
margin-bottom: 15px;
`;

const outputLabel = document.createElement('label');
outputLabel.textContent = 'Status:';
outputLabel.style.cssText = `
display: block;
font-weight: bold;
margin-bottom: 5px;
color: #333;
`;

this.outputDiv = document.createElement('div');
this.outputDiv.style.cssText = `
width: 100%;
min-height: 50px;
padding: 12px;
border: 1px solid #ddd;
border-radius: 5px;
font-size: 14px;
box-sizing: border-box;
background-color: #f9f9f9;
`;

this.outputDiv.textContent = 'Ready to upload a document';

outputSection.appendChild(outputLabel);
outputSection.appendChild(this.outputDiv);
baseContainer.appendChild(outputSection);

// Info section
const infoSection = document.createElement('div');
infoSection.style.cssText = `
background-color: #e3f2fd;
border-radius: 5px;
padding: 10px;
font-size: 14px;
color: #1976d2;
border-left: 4px solid #2196F3;
`;

infoSection.innerHTML = `
<strong>Instructions:</strong><br>
            • Upload a document using the file input<br>
            • View: Display the document in the preview area<br>
            • Edit: Edit text-based documents in the editor<br>
            • Copy: Copy document content to clipboard<br>
            • Download: Save the document to your device<br>
            • Clear: Reset the document manager
        `;

        baseContainer.appendChild(infoSection);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Handle file upload
     */
    handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) {
            this.outputDiv.textContent = 'No file selected';
            return;
        }

        this.currentFile = file;
        this.fileName = file.name;
        this.fileType = file.type;
        this.isEditing = false;

        // Show file info
        this.outputDiv.textContent = `File uploaded: ${this.fileName} (${this.formatFileSize(file.size)})`;

        // Enable buttons
        this.viewButton.disabled = false;
        this.downloadButton.disabled = false;
        this.clearButton.disabled = false;

        // Determine if file can be edited or copied
        const editableTypes = [
            'text/plain',
            'text/csv',
            'application/json',
            'text/html',
            'text/xml',
            'application/xml'
        ];

        if (editableTypes.includes(this.fileType) ||
            this.fileName.endsWith('.txt') ||
            this.fileName.endsWith('.csv') ||
            this.fileName.endsWith('.json') ||
            this.fileName.endsWith('.html') ||
            this.fileName.endsWith('.xml')) {
            this.editButton.disabled = false;
            this.copyButton.disabled = false;
        } else {
            this.editButton.disabled = true;
            this.copyButton.disabled = true;
        }

        // Read file content
        this.readFileContent(file);
    }

    /**
     * Read file content
     */
    readFileContent(file) {
        const reader = new FileReader();

        reader.onload = (e) => {
            this.fileContent = e.target.result;
            this.previewArea.innerHTML = '';

            // Display file based on type
            if (file.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = e.target.result;
                img.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                `;
                this.previewArea.appendChild(img);
            } else if (file.type === 'application/pdf') {
                const iframe = document.createElement('iframe');
                iframe.src = e.target.result;
                iframe.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                `;
                this.previewArea.appendChild(iframe);
            } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                // For DOCX files, we can't display directly, so show a message
                const message = document.createElement('div');
                message.textContent = 'DOCX file uploaded. Use Download to save or Edit if supported.';
                message.style.cssText = `
                    text-align: center;
                    color: #666;
                `;
                this.previewArea.appendChild(message);
            } else {
                // For text files, show a preview
                const pre = document.createElement('pre');
                pre.textContent = e.target.result;
                pre.style.cssText = `
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                `;
                this.previewArea.appendChild(pre);
            }
        };

        reader.onerror = () => {
            this.outputDiv.textContent = 'Error reading file';
        };

        // Read file based on type
        if (file.type.startsWith('image/') || file.type === 'application/pdf') {
            reader.readAsDataURL(file);
        } else {
            reader.readAsText(file);
        }
    }

    /**
     * View document
     */
    viewDocument() {
        if (!this.currentFile) {
            botReply('No document to view');
            return;
        }

        // Show preview area, hide editor
        this.previewArea.style.display = 'flex';
        this.editorArea.style.display = 'none';
        this.isEditing = false;

        botReply(`Viewing document: ${this.fileName}`);
    }

    /**
     * Edit document
     */
    editDocument() {
        if (!this.currentFile) {
            botReply('No document to edit');
            return;
        }

        if (this.editButton.disabled) {
            botReply('This document type cannot be edited');
            return;
        }

        // Show editor area, hide preview
        this.previewArea.style.display = 'none';
        this.editorArea.style.display = 'block';

        // Set editor content
        this.editorTextarea.value = this.fileContent;
        this.isEditing = true;

        botReply(`Editing document: ${this.fileName}`);
    }

    /**
     * Copy document content
     */
    copyDocument() {
        if (!this.currentFile) {
            botReply('No document to copy');
            return;
        }

        if (this.copyButton.disabled) {
            botReply('This document type cannot be copied');
            return;
        }

        // Get content to copy
        let contentToCopy = this.fileContent;
        if (this.isEditing) {
            contentToCopy = this.editorTextarea.value;
        }

        // Copy to clipboard
        if (navigator.clipboard) {
            navigator.clipboard.writeText(contentToCopy)
                .then(() => {
                    botReply('Document content copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(contentToCopy);
                });
        } else {
            this.fallbackCopyTextToClipboard(contentToCopy);
        }
    }

    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;

        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Document content copied to clipboard!');
            } else {
                botReply('Unable to copy document content');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy document content');
        }

        document.body.removeChild(textArea);
    }

    /**
     * Download document
     */
    downloadDocument() {
        if (!this.currentFile) {
            botReply('No document to download');
            return;
        }

        // Create download link
        const url = URL.createObjectURL(this.currentFile);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        botReply(`Document downloaded: ${this.fileName}`);
    }

    /**
     * Clear document
     */
    clearDocument() {
        this.currentFile = null;
        this.fileContent = null;
        this.fileType = null;
        this.fileName = null;
        this.isEditing = false;

        // Reset UI
        this.fileInput.value = '';
        this.previewArea.innerHTML = '';
        this.previewArea.textContent = 'No document uploaded';
        this.previewArea.style.display = 'flex';
        this.editorArea.style.display = 'none';
        this.editorTextarea.value = '';

        // Disable buttons
        this.viewButton.disabled = true;
        this.editButton.disabled = true;
        this.copyButton.disabled = true;
        this.downloadButton.disabled = true;

        this.outputDiv.textContent = 'Document cleared. Ready to upload a new document';

        botReply('Document cleared');
    }

    /**
     * Format file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';

        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;

        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });

        button.addEventListener('click', clickHandler);

        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;

        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };

        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };

        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };

        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;

        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };

        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };

        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };

        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);

        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);

        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;

        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;

        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;

        if (this.isFullscreen) {
            this.exitFullscreen();
        }

        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);

        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }

        this.gameContainer = null;
        this.fileInput = null;
        this.viewButton = null;
        this.editButton = null;
        this.copyButton = null;
        this.downloadButton = null;
        this.clearButton = null;
        this.previewArea = null;
        this.editorArea = null;
        this.outputDiv = null;
        this.currentFile = null;
        this.fileContent = null;
        this.fileType = null;
        this.fileName = null;
        this.isEditing = false;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;

        botReply("Document Manager closed. Thank you!");
    }
}

// Create a singleton instance
const allDocMount = new AllDocMount();

// Add this to your AI's command handling
if (/document manager|doc manager|file manager|upload document|view document|edit document/i.test(userInputRaw)) {
    allDocMount.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    allDocMount.closeGame();
    return;
}

class AdvancedCalendar {
    constructor() {
        this.baseScreen = {
            name: 'ADVANCED CALENDAR',
            instructions: 'Manage your schedule with events, reminders, and recurring tasks. All data is saved locally.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        
        // Calendar state
        this.currentDate = new Date();
        this.currentView = 'month'; // month, week, day, agenda
        this.events = [];
        this.reminders = [];
        this.selectedDate = null;
        this.selectedEvent = null;
        this.selectedReminder = null;
        
        // UI elements
        this.calendarGrid = null;
        this.monthYearDisplay = null;
        this.viewButtons = {};
        this.eventForm = null;
        this.eventsList = null;
        this.reminderForm = null;
        this.remindersList = null;
        this.searchInput = null;
        this.categoryFilter = null;
        this.eventDetailsModal = null;
        this.reminderDetailsModal = null;
        
        // Event categories with colors
        this.categories = [
            { id: 'work', name: 'Work', color: '#4285F4' },
            { id: 'personal', name: 'Personal', color: '#34A853' },
            { id: 'health', name: 'Health', color: '#FBBC05' },
            { id: 'social', name: 'Social', color: '#EA4335' },
            { id: 'other', name: 'Other', color: '#9C27B0' }
        ];
        
        // Load data from localStorage on initialization
        this.loadDataFromStorage();
    }

    /**
     * Load data from localStorage
     */
    loadDataFromStorage() {
        try {
            // Load events
            const eventsData = localStorage.getItem('advancedCalendar_events');
            if (eventsData) {
                const parsedEvents = JSON.parse(eventsData);
                // Convert date strings back to Date objects
                this.events = parsedEvents.map(event => ({
                    ...event,
                    date: new Date(event.date)
                }));
            }
            
            // Load reminders
            const remindersData = localStorage.getItem('advancedCalendar_reminders');
            if (remindersData) {
                const parsedReminders = JSON.parse(remindersData);
                // Convert date strings back to Date objects
                this.reminders = parsedReminders.map(reminder => ({
                    ...reminder,
                    date: new Date(reminder.date)
                }));
            }
        } catch (error) {
            console.error('Error loading data from localStorage:', error);
            // If there's an error, start with empty arrays
            this.events = [];
            this.reminders = [];
        }
    }

    /**
     * Save data to localStorage
     */
    saveDataToStorage() {
        try {
            // Save events
            localStorage.setItem('advancedCalendar_events', JSON.stringify(this.events));
            
            // Save reminders
            localStorage.setItem('advancedCalendar_reminders', JSON.stringify(this.reminders));
        } catch (error) {
            console.error('Error saving data to localStorage:', error);
            botReply('Error saving your data. Your browser may be in private mode or have storage disabled.');
        }
    }

    /**
     * Load the Advanced Calendar
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createCalendarScreen();
        this.setupActionButtons();
        this.renderCalendar();
        this.displayGame();
        this.isActive = true;
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) existingContainer.remove();
        
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }

    /**
     * Create the Advanced Calendar UI
     */
    createCalendarScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 1200px;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Advanced Calendar';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 28px;
        `;
        header.appendChild(title);
        baseContainer.appendChild(header);

        // Top controls
        const topControls = document.createElement('div');
        topControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        `;

        // Navigation buttons
        const navButtons = document.createElement('div');
        navButtons.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        const todayButton = this.createButton('Today', '#4CAF50', () => {
            this.goToToday();
        });
        
        const prevButton = this.createButton('◀', '#2196F3', () => {
            this.navigatePrevious();
        });
        
        const nextButton = this.createButton('▶', '#2196F3', () => {
            this.navigateNext();
        });
        
        navButtons.appendChild(todayButton);
        navButtons.appendChild(prevButton);
        navButtons.appendChild(nextButton);
        topControls.appendChild(navButtons);

        // Month and year display
        this.monthYearDisplay = document.createElement('div');
        this.monthYearDisplay.style.cssText = `
            font-size: 24px;
            font-weight: bold;
            color: #333;
        `;
        topControls.appendChild(this.monthYearDisplay);

        // View buttons
        const viewButtonsContainer = document.createElement('div');
        viewButtonsContainer.style.cssText = `
            display: flex;
            gap: 10px;
        `;
        
        this.viewButtons.month = this.createButton('Month', '#FF9800', () => {
            this.setView('month');
        });
        this.viewButtons.month.classList.add('active');
        
        this.viewButtons.week = this.createButton('Week', '#FF9800', () => {
            this.setView('week');
        });
        
        this.viewButtons.day = this.createButton('Day', '#FF9800', () => {
            this.setView('day');
        });
        
        this.viewButtons.agenda = this.createButton('Agenda', '#FF9800', () => {
            this.setView('agenda');
        });
        
        viewButtonsContainer.appendChild(this.viewButtons.month);
        viewButtonsContainer.appendChild(this.viewButtons.week);
        viewButtonsContainer.appendChild(this.viewButtons.day);
        viewButtonsContainer.appendChild(this.viewButtons.agenda);
        topControls.appendChild(viewButtonsContainer);

        baseContainer.appendChild(topControls);

        // Search and filter
        const searchFilterContainer = document.createElement('div');
        searchFilterContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        `;
        
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search events...';
        this.searchInput.style.cssText = `
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        this.searchInput.addEventListener('input', () => {
            this.filterEvents();
        });
        searchFilterContainer.appendChild(this.searchInput);
        
        this.categoryFilter = document.createElement('select');
        this.categoryFilter.style.cssText = `
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = 'All Categories';
        this.categoryFilter.appendChild(allOption);
        
        this.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            this.categoryFilter.appendChild(option);
        });
        
        this.categoryFilter.addEventListener('change', () => {
            this.filterEvents();
        });
        searchFilterContainer.appendChild(this.categoryFilter);
        
        const addEventButton = this.createButton('Add Event', '#4CAF50', () => {
            this.showEventForm();
        });
        searchFilterContainer.appendChild(addEventButton);
        
        const addReminderButton = this.createButton('Add Reminder', '#9C27B0', () => {
            this.showReminderForm();
        });
        searchFilterContainer.appendChild(addReminderButton);
        
        // Add export/import buttons
        const exportButton = this.createButton('Export', '#607D8B', () => {
            this.exportData();
        });
        searchFilterContainer.appendChild(exportButton);
        
        const importButton = this.createButton('Import', '#607D8B', () => {
            this.importData();
        });
        searchFilterContainer.appendChild(importButton);
        
        baseContainer.appendChild(searchFilterContainer);

        // Main content area
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            display: flex;
            flex-grow: 1;
            gap: 20px;
            overflow: hidden;
        `;

        // Calendar grid
        const calendarContainer = document.createElement('div');
        calendarContainer.style.cssText = `
            flex: 3;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;
        
        this.calendarGrid = document.createElement('div');
        this.calendarGrid.style.cssText = `
            width: 100%;
            overflow: auto;
            flex-grow: 1;
        `;
        calendarContainer.appendChild(this.calendarGrid);
        mainContent.appendChild(calendarContainer);

        // Sidebar
        const sidebar = document.createElement('div');
        sidebar.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: auto;
        `;
        
        // Events list
        const eventsSection = document.createElement('div');
        eventsSection.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        `;
        
        const eventsTitle = document.createElement('h3');
        eventsTitle.textContent = 'Upcoming Events';
        eventsTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        `;
        eventsSection.appendChild(eventsTitle);
        
        this.eventsList = document.createElement('div');
        this.eventsList.style.cssText = `
            max-height: 300px;
            overflow-y: auto;
        `;
        eventsSection.appendChild(this.eventsList);
        sidebar.appendChild(eventsSection);
        
        // Reminders list
        const remindersSection = document.createElement('div');
        remindersSection.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        `;
        
        const remindersTitle = document.createElement('h3');
        remindersTitle.textContent = 'Reminders';
        remindersTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        `;
        remindersSection.appendChild(remindersTitle);
        
        this.remindersList = document.createElement('div');
        this.remindersList.style.cssText = `
            max-height: 300px;
            overflow-y: auto;
        `;
        remindersSection.appendChild(this.remindersList);
        sidebar.appendChild(remindersSection);
        
        // Storage info
        const storageSection = document.createElement('div');
        storageSection.style.cssText = `
            background-color: #e8f5e9;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
            color: #2e7d32;
        `;
        
        const storageTitle = document.createElement('h3');
        storageTitle.textContent = 'Storage Info';
        storageTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 10px;
            color: #2e7d32;
            font-size: 16px;
        `;
        storageSection.appendChild(storageTitle);
        
        const storageInfo = document.createElement('p');
        storageInfo.textContent = 'All your events and reminders are automatically saved in your browser\'s local storage.';
        storageInfo.style.cssText = `
            margin: 0 0 10px 0;
        `;
        storageSection.appendChild(storageInfo);
        
        const clearButton = this.createButton('Clear All Data', '#f44336', () => {
            this.clearAllData();
        });
        clearButton.style.cssText = `
            padding: 8px 12px;
            font-size: 12px;
            margin-top: 10px;
        `;
        storageSection.appendChild(clearButton);
        
        sidebar.appendChild(storageSection);
        
        mainContent.appendChild(sidebar);
        baseContainer.appendChild(mainContent);

        // Event form (initially hidden)
        this.eventForm = this.createEventForm();
        baseContainer.appendChild(this.eventForm);
        
        // Reminder form (initially hidden)
        this.reminderForm = this.createReminderForm();
        baseContainer.appendChild(this.reminderForm);
        
        // Event details modal (initially hidden)
        this.eventDetailsModal = this.createEventDetailsModal();
        baseContainer.appendChild(this.eventDetailsModal);
        
        // Reminder details modal (initially hidden)
        this.reminderDetailsModal = this.createReminderDetailsModal();
        baseContainer.appendChild(this.reminderDetailsModal);

        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Create event form
     */
    createEventForm() {
        const form = document.createElement('div');
        form.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const formTitle = document.createElement('h3');
        formTitle.textContent = 'Add Event';
        formTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        form.appendChild(formTitle);
        
        // Title input
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('label');
        titleLabel.textContent = 'Event Title:';
        titleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        titleContainer.appendChild(titleLabel);
        
        const titleInput = document.createElement('input');
        titleInput.type = 'text';
        titleInput.placeholder = 'Enter event title';
        titleInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        titleContainer.appendChild(titleInput);
        form.appendChild(titleContainer);
        
        // Date and time inputs
        const dateTimeContainer = document.createElement('div');
        dateTimeContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        const dateContainer = document.createElement('div');
        dateContainer.style.cssText = `
            flex: 1;
        `;
        const dateLabel = document.createElement('label');
        dateLabel.textContent = 'Date:';
        dateLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        dateContainer.appendChild(dateLabel);
        
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        dateContainer.appendChild(dateInput);
        dateTimeContainer.appendChild(dateContainer);
        
        const timeContainer = document.createElement('div');
        timeContainer.style.cssText = `
            flex: 1;
        `;
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Time:';
        timeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        timeContainer.appendChild(timeLabel);
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        timeContainer.appendChild(timeInput);
        dateTimeContainer.appendChild(timeContainer);
        form.appendChild(dateTimeContainer);
        
        // Category selection
        const categoryContainer = document.createElement('div');
        categoryContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const categoryLabel = document.createElement('label');
        categoryLabel.textContent = 'Category:';
        categoryLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        categoryContainer.appendChild(categoryLabel);
        
        const categorySelect = document.createElement('select');
        categorySelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        this.categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category.id;
            option.textContent = category.name;
            categorySelect.appendChild(option);
        });
        categoryContainer.appendChild(categorySelect);
        form.appendChild(categoryContainer);
        
        // Recurring options
        const recurringContainer = document.createElement('div');
        recurringContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const recurringLabel = document.createElement('label');
        recurringLabel.textContent = 'Recurring:';
        recurringLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        recurringContainer.appendChild(recurringLabel);
        
        const recurringSelect = document.createElement('select');
        recurringSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const recurringOptions = [
            { value: 'none', text: 'Does not repeat' },
            { value: 'daily', text: 'Daily' },
            { value: 'weekly', text: 'Weekly' },
            { value: 'monthly', text: 'Monthly' },
            { value: 'yearly', text: 'Yearly' }
        ];
        
        recurringOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            recurringSelect.appendChild(opt);
        });
        recurringContainer.appendChild(recurringSelect);
        form.appendChild(recurringContainer);
        
        // Description textarea
        const descContainer = document.createElement('div');
        descContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        const descLabel = document.createElement('label');
        descLabel.textContent = 'Description:';
        descLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        descContainer.appendChild(descLabel);
        
        const descTextarea = document.createElement('textarea');
        descTextarea.placeholder = 'Enter event description (optional)';
        descTextarea.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
            resize: vertical;
            min-height: 80px;
        `;
        descContainer.appendChild(descTextarea);
        form.appendChild(descContainer);
        
        // Form buttons
        const formButtons = document.createElement('div');
        formButtons.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        `;
        
        const saveButton = this.createButton('Save', '#4CAF50', () => {
            this.saveEvent(
                titleInput.value,
                dateInput.value,
                timeInput.value,
                categorySelect.value,
                recurringSelect.value,
                descTextarea.value
            );
            form.style.display = 'none';
        });
        
        const cancelButton = this.createButton('Cancel', '#f44336', () => {
            form.style.display = 'none';
        });
        
        formButtons.appendChild(saveButton);
        formButtons.appendChild(cancelButton);
        form.appendChild(formButtons);
        
        return form;
    }

    /**
     * Create reminder form
     */
    createReminderForm() {
        const form = document.createElement('div');
        form.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const formTitle = document.createElement('h3');
        formTitle.textContent = 'Add Reminder';
        formTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        form.appendChild(formTitle);
        
        // Title input
        const titleContainer = document.createElement('div');
        titleContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('label');
        titleLabel.textContent = 'Reminder Title:';
        titleLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        titleContainer.appendChild(titleLabel);
        
        const titleInput = document.createElement('input');
        titleInput.type = 'text';
        titleInput.placeholder = 'Enter reminder title';
        titleInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        titleContainer.appendChild(titleInput);
        form.appendChild(titleContainer);
        
        // Date and time inputs
        const dateTimeContainer = document.createElement('div');
        dateTimeContainer.style.cssText = `
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        `;
        
        const dateContainer = document.createElement('div');
        dateContainer.style.cssText = `
            flex: 1;
        `;
        const dateLabel = document.createElement('label');
        dateLabel.textContent = 'Date:';
        dateLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        dateContainer.appendChild(dateLabel);
        
        const dateInput = document.createElement('input');
        dateInput.type = 'date';
        dateInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        dateContainer.appendChild(dateInput);
        dateTimeContainer.appendChild(dateContainer);
        
        const timeContainer = document.createElement('div');
        timeContainer.style.cssText = `
            flex: 1;
        `;
        const timeLabel = document.createElement('label');
        timeLabel.textContent = 'Time:';
        timeLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        timeContainer.appendChild(timeLabel);
        
        const timeInput = document.createElement('input');
        timeInput.type = 'time';
        timeInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        timeContainer.appendChild(timeInput);
        dateTimeContainer.appendChild(timeContainer);
        form.appendChild(dateTimeContainer);
        
        // Repeat options
        const repeatContainer = document.createElement('div');
        repeatContainer.style.cssText = `
            margin-bottom: 15px;
        `;
        const repeatLabel = document.createElement('label');
        repeatLabel.textContent = 'Repeat:';
        repeatLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        repeatContainer.appendChild(repeatLabel);
        
        const repeatSelect = document.createElement('select');
        repeatSelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const repeatOptions = [
            { value: 'none', text: 'Does not repeat' },
            { value: 'daily', text: 'Daily' },
            { value: 'weekly', text: 'Weekly' },
            { value: 'monthly', text: 'Monthly' },
            { value: 'yearly', text: 'Yearly' }
        ];
        
        repeatOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            repeatSelect.appendChild(opt);
        });
        repeatContainer.appendChild(repeatSelect);
        form.appendChild(repeatContainer);
        
        // Notification options
        const notifyContainer = document.createElement('div');
        notifyContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        const notifyLabel = document.createElement('label');
        notifyLabel.textContent = 'Notify me:';
        notifyLabel.style.cssText = `
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        `;
        notifyContainer.appendChild(notifyLabel);
        
        const notifySelect = document.createElement('select');
        notifySelect.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-sizing: border-box;
        `;
        
        const notifyOptions = [
            { value: '0', text: 'At time of event' },
            { value: '5', text: '5 minutes before' },
            { value: '15', text: '15 minutes before' },
            { value: '30', text: '30 minutes before' },
            { value: '60', text: '1 hour before' },
            { value: '1440', text: '1 day before' }
        ];
        
        notifyOptions.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option.value;
            opt.textContent = option.text;
            notifySelect.appendChild(opt);
        });
        notifyContainer.appendChild(notifySelect);
        form.appendChild(notifyContainer);
        
        // Form buttons
        const formButtons = document.createElement('div');
        formButtons.style.cssText = `
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        `;
        
        const saveButton = this.createButton('Save', '#9C27B0', () => {
            this.saveReminder(
                titleInput.value,
                dateInput.value,
                timeInput.value,
                repeatSelect.value,
                notifySelect.value
            );
            form.style.display = 'none';
        });
        
        const cancelButton = this.createButton('Cancel', '#f44336', () => {
            form.style.display = 'none';
        });
        
        formButtons.appendChild(saveButton);
        formButtons.appendChild(cancelButton);
        form.appendChild(formButtons);
        
        return form;
    }

    /**
     * Create event details modal
     */
    createEventDetailsModal() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Event Details';
        modalTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        modal.appendChild(modalTitle);
        
        // Event details container
        const detailsContainer = document.createElement('div');
        detailsContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        // Title
        const titleRow = document.createElement('div');
        titleRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('span');
        titleLabel.textContent = 'Title: ';
        titleLabel.style.cssText = `
            font-weight: bold;
        `;
        const titleValue = document.createElement('span');
        titleValue.id = 'event-details-title';
        titleRow.appendChild(titleLabel);
        titleRow.appendChild(titleValue);
        detailsContainer.appendChild(titleRow);
        
        // Date and time
        const dateTimeRow = document.createElement('div');
        dateTimeRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const dateTimeLabel = document.createElement('span');
        dateTimeLabel.textContent = 'Date & Time: ';
        dateTimeLabel.style.cssText = `
            font-weight: bold;
        `;
        const dateTimeValue = document.createElement('span');
        dateTimeValue.id = 'event-details-datetime';
        dateTimeRow.appendChild(dateTimeLabel);
        dateTimeRow.appendChild(dateTimeValue);
        detailsContainer.appendChild(dateTimeRow);
        
        // Category
        const categoryRow = document.createElement('div');
        categoryRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const categoryLabel = document.createElement('span');
        categoryLabel.textContent = 'Category: ';
        categoryLabel.style.cssText = `
            font-weight: bold;
        `;
        const categoryValue = document.createElement('span');
        categoryValue.id = 'event-details-category';
        categoryRow.appendChild(categoryLabel);
        categoryRow.appendChild(categoryValue);
        detailsContainer.appendChild(categoryRow);
        
        // Recurring
        const recurringRow = document.createElement('div');
        recurringRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const recurringLabel = document.createElement('span');
        recurringLabel.textContent = 'Recurring: ';
        recurringLabel.style.cssText = `
            font-weight: bold;
        `;
        const recurringValue = document.createElement('span');
        recurringValue.id = 'event-details-recurring';
        recurringRow.appendChild(recurringLabel);
        recurringRow.appendChild(recurringValue);
        detailsContainer.appendChild(recurringRow);
        
        // Description
        const descriptionRow = document.createElement('div');
        descriptionRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const descriptionLabel = document.createElement('span');
        descriptionLabel.textContent = 'Description: ';
        descriptionLabel.style.cssText = `
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        `;
        const descriptionValue = document.createElement('div');
        descriptionValue.id = 'event-details-description';
        descriptionValue.style.cssText = `
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            min-height: 60px;
        `;
        descriptionRow.appendChild(descriptionLabel);
        descriptionRow.appendChild(descriptionValue);
        detailsContainer.appendChild(descriptionRow);
        
        modal.appendChild(detailsContainer);
        
        // Modal buttons
        const modalButtons = document.createElement('div');
        modalButtons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 10px;
        `;
        
        const deleteButton = this.createButton('Delete', '#f44336', () => {
            if (this.selectedEvent) {
                this.deleteEvent(this.selectedEvent.id);
                modal.style.display = 'none';
            }
        });
        
        const closeButton = this.createButton('Close', '#2196F3', () => {
            modal.style.display = 'none';
        });
        
        modalButtons.appendChild(deleteButton);
        modalButtons.appendChild(closeButton);
        modal.appendChild(modalButtons);
        
        return modal;
    }

    /**
     * Create reminder details modal
     */
    createReminderDetailsModal() {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10000;
            display: none;
        `;
        
        const modalTitle = document.createElement('h3');
        modalTitle.textContent = 'Reminder Details';
        modalTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        `;
        modal.appendChild(modalTitle);
        
        // Reminder details container
        const detailsContainer = document.createElement('div');
        detailsContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        // Title
        const titleRow = document.createElement('div');
        titleRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const titleLabel = document.createElement('span');
        titleLabel.textContent = 'Title: ';
        titleLabel.style.cssText = `
            font-weight: bold;
        `;
        const titleValue = document.createElement('span');
        titleValue.id = 'reminder-details-title';
        titleRow.appendChild(titleLabel);
        titleRow.appendChild(titleValue);
        detailsContainer.appendChild(titleRow);
        
        // Date and time
        const dateTimeRow = document.createElement('div');
        dateTimeRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const dateTimeLabel = document.createElement('span');
        dateTimeLabel.textContent = 'Date & Time: ';
        dateTimeLabel.style.cssText = `
            font-weight: bold;
        `;
        const dateTimeValue = document.createElement('span');
        dateTimeValue.id = 'reminder-details-datetime';
        dateTimeRow.appendChild(dateTimeLabel);
        dateTimeRow.appendChild(dateTimeValue);
        detailsContainer.appendChild(dateTimeRow);
        
        // Repeat
        const repeatRow = document.createElement('div');
        repeatRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const repeatLabel = document.createElement('span');
        repeatLabel.textContent = 'Repeat: ';
        repeatLabel.style.cssText = `
            font-weight: bold;
        `;
        const repeatValue = document.createElement('span');
        repeatValue.id = 'reminder-details-repeat';
        repeatRow.appendChild(repeatLabel);
        repeatRow.appendChild(repeatValue);
        detailsContainer.appendChild(repeatRow);
        
        // Notification
        const notifyRow = document.createElement('div');
        notifyRow.style.cssText = `
            margin-bottom: 15px;
        `;
        const notifyLabel = document.createElement('span');
        notifyLabel.textContent = 'Notify: ';
        notifyLabel.style.cssText = `
            font-weight: bold;
        `;
        const notifyValue = document.createElement('span');
        notifyValue.id = 'reminder-details-notify';
        notifyRow.appendChild(notifyLabel);
        notifyRow.appendChild(notifyValue);
        detailsContainer.appendChild(notifyRow);
        
        modal.appendChild(detailsContainer);
        
        // Modal buttons
        const modalButtons = document.createElement('div');
        modalButtons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 10px;
        `;
        
        const deleteButton = this.createButton('Delete', '#f44336', () => {
            if (this.selectedReminder) {
                this.deleteReminder(this.selectedReminder.id);
                modal.style.display = 'none';
            }
        });
        
        const closeButton = this.createButton('Close', '#2196F3', () => {
            modal.style.display = 'none';
        });
        
        modalButtons.appendChild(deleteButton);
        modalButtons.appendChild(closeButton);
        modal.appendChild(modalButtons);
        
        return modal;
    }

    /**
     * Render calendar based on current view
     */
    renderCalendar() {
        // Update month/year display
        this.updateMonthYearDisplay();
        
        // Clear calendar grid
        this.calendarGrid.innerHTML = '';
        
        // Render based on current view
        switch (this.currentView) {
            case 'month':
                this.renderMonthView();
                break;
            case 'week':
                this.renderWeekView();
                break;
            case 'day':
                this.renderDayView();
                break;
            case 'agenda':
                this.renderAgendaView();
                break;
        }
        
        // Update events and reminders lists
        this.updateEventsList();
        this.updateRemindersList();
    }

    /**
     * Render month view
     */
    renderMonthView() {
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        
        // Create month header with day names
        const monthHeader = document.createElement('div');
        monthHeader.style.cssText = `
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            margin-bottom: 1px;
        `;
        
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        dayNames.forEach(day => {
            const dayHeader = document.createElement('div');
            dayHeader.textContent = day;
            dayHeader.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: center;
                font-weight: bold;
            `;
            monthHeader.appendChild(dayHeader);
        });
        
        this.calendarGrid.appendChild(monthHeader);
        
        // Get first day of month and number of days
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        
        // Create month grid
        const monthGrid = document.createElement('div');
        monthGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add empty cells for days before the first day of the month
        for (let i = 0; i < firstDay; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.style.cssText = `
                background-color: #fff;
                min-height: 100px;
            `;
            monthGrid.appendChild(emptyDay);
        }
        
        // Add cells for each day of the month
        for (let day = 1; day <= daysInMonth; day++) {
            const dayCell = document.createElement('div');
            dayCell.style.cssText = `
                background-color: #fff;
                min-height: 100px;
                padding: 5px;
                position: relative;
                cursor: pointer;
            `;
            
            // Highlight today
            const today = new Date();
            if (year === today.getFullYear() && month === today.getMonth() && day === today.getDate()) {
                dayCell.style.backgroundColor = '#e3f2fd';
            }
            
            // Add day number
            const dayNumber = document.createElement('div');
            dayNumber.textContent = day;
            dayNumber.style.cssText = `
                font-weight: bold;
                margin-bottom: 5px;
            `;
            dayCell.appendChild(dayNumber);
            
            // Add events for this day
            const date = new Date(year, month, day);
            const dayEvents = this.getEventsForDate(date);
            
            const eventsContainer = document.createElement('div');
            eventsContainer.style.cssText = `
                font-size: 12px;
                overflow: hidden;
            `;
            
            dayEvents.slice(0, 3).forEach(event => {
                const eventElement = document.createElement('div');
                eventElement.textContent = event.title;
                eventElement.style.cssText = `
                    background-color: ${event.color};
                    color: white;
                    padding: 2px 5px;
                    margin-bottom: 2px;
                    border-radius: 3px;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                `;
                eventsContainer.appendChild(eventElement);
            });
            
            if (dayEvents.length > 3) {
                const moreElement = document.createElement('div');
                moreElement.textContent = `+${dayEvents.length - 3} more`;
                moreElement.style.cssText = `
                    font-style: italic;
                    color: #666;
                `;
                eventsContainer.appendChild(moreElement);
            }
            
            dayCell.appendChild(eventsContainer);
            
            // Add click event to show event form
            dayCell.addEventListener('click', () => {
                this.selectedDate = new Date(year, month, day);
                this.showEventForm();
            });
            
            monthGrid.appendChild(dayCell);
        }
        
        this.calendarGrid.appendChild(monthGrid);
    }

    /**
     * Render week view
     */
    renderWeekView() {
        const today = new Date();
        const currentDay = this.currentDate.getDay();
        const startDate = new Date(this.currentDate);
        startDate.setDate(this.currentDate.getDate() - currentDay);
        
        // Create week header with day names
        const weekHeader = document.createElement('div');
        weekHeader.style.cssText = `
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            margin-bottom: 1px;
        `;
        
        // Empty cell for time column
        const emptyHeader = document.createElement('div');
        emptyHeader.style.cssText = `
            background-color: #f0f0f0;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        `;
        weekHeader.appendChild(emptyHeader);
        
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        for (let i = 0; i < 7; i++) {
            const date = new Date(startDate);
            date.setDate(startDate.getDate() + i);
            
            const dayHeader = document.createElement('div');
            dayHeader.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: center;
                font-weight: bold;
            `;
            
            // Highlight today
            if (date.toDateString() === today.toDateString()) {
                dayHeader.style.backgroundColor = '#e3f2fd';
            }
            
            dayHeader.innerHTML = `${dayNames[i]}<br>${date.getDate()}`;
            weekHeader.appendChild(dayHeader);
        }
        
        this.calendarGrid.appendChild(weekHeader);
        
        // Create time grid
        const timeGrid = document.createElement('div');
        timeGrid.style.cssText = `
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add time slots
        for (let hour = 0; hour < 24; hour++) {
            // Time label
            const timeLabel = document.createElement('div');
            timeLabel.textContent = `${hour === 0 ? '12' : hour > 12 ? hour - 12 : hour}:00 ${hour < 12 ? 'AM' : 'PM'}`;
            timeLabel.style.cssText = `
                background-color: #f0f0f0;
                padding: 5px;
                text-align: right;
                font-size: 12px;
            `;
            timeGrid.appendChild(timeLabel);
            
            // Add cells for each day
            for (let day = 0; day < 7; day++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + day);
                date.setHours(hour, 0, 0, 0);
                
                const hourCell = document.createElement('div');
                hourCell.style.cssText = `
                    background-color: #fff;
                    min-height: 50px;
                    position: relative;
                    cursor: pointer;
                `;
                
                // Highlight today's hour
                if (date.toDateString() === today.toDateString() && hour === today.getHours()) {
                    hourCell.style.backgroundColor = '#e3f2fd';
                }
                
                // Add events for this hour
                const hourEvents = this.getEventsForDateTime(date);
                
                hourEvents.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.textContent = event.title;
                    eventElement.style.cssText = `
                        background-color: ${event.color};
                        color: white;
                        padding: 2px 5px;
                        margin-bottom: 2px;
                        border-radius: 3px;
                        font-size: 12px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    `;
                    hourCell.appendChild(eventElement);
                });
                
                // Add click event to show event form
                hourCell.addEventListener('click', () => {
                    this.selectedDate = new Date(date);
                    this.showEventForm();
                });
                
                timeGrid.appendChild(hourCell);
            }
        }
        
        this.calendarGrid.appendChild(timeGrid);
    }

    /**
     * Render day view
     */
    renderDayView() {
        const date = new Date(this.currentDate);
        const today = new Date();
        
        // Create day header
        const dayHeader = document.createElement('div');
        dayHeader.style.cssText = `
            display: flex;
            background-color: #f0f0f0;
            padding: 15px;
            margin-bottom: 1px;
            align-items: center;
            justify-content: space-between;
        `;
        
        const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
        const monthName = date.toLocaleDateString('en-US', { month: 'long' });
        const dayNumber = date.getDate();
        const year = date.getFullYear();
        
        const dateDisplay = document.createElement('div');
        dateDisplay.textContent = `${dayName}, ${monthName} ${dayNumber}, ${year}`;
        dateDisplay.style.cssText = `
            font-size: 18px;
            font-weight: bold;
        `;
        
        // Highlight today
        if (date.toDateString() === today.toDateString()) {
            dateDisplay.style.color = '#2196F3';
        }
        
        dayHeader.appendChild(dateDisplay);
        
        const addButton = this.createButton('Add Event', '#4CAF50', () => {
            this.selectedDate = new Date(date);
            this.showEventForm();
        });
        dayHeader.appendChild(addButton);
        
        this.calendarGrid.appendChild(dayHeader);
        
        // Create time grid
        const timeGrid = document.createElement('div');
        timeGrid.style.cssText = `
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 1px;
            background-color: #ddd;
            flex-grow: 1;
        `;
        
        // Add time slots
        for (let hour = 0; hour < 24; hour++) {
            // Time label
            const timeLabel = document.createElement('div');
            timeLabel.textContent = `${hour === 0 ? '12' : hour > 12 ? hour - 12 : hour}:00 ${hour < 12 ? 'AM' : 'PM'}`;
            timeLabel.style.cssText = `
                background-color: #f0f0f0;
                padding: 10px 5px;
                text-align: right;
                font-size: 14px;
            `;
            timeGrid.appendChild(timeLabel);
            
            // Hour cell
            const hourCell = document.createElement('div');
            hourCell.style.cssText = `
                background-color: #fff;
                min-height: 60px;
                position: relative;
                cursor: pointer;
                padding: 5px;
            `;
            
            // Highlight current hour
            if (date.toDateString() === today.toDateString() && hour === today.getHours()) {
                hourCell.style.backgroundColor = '#e3f2fd';
            }
            
            // Add events for this hour
            const hourDate = new Date(date);
            hourDate.setHours(hour, 0, 0, 0);
            const hourEvents = this.getEventsForDateTime(hourDate);
            
            hourEvents.forEach(event => {
                const eventElement = document.createElement('div');
                eventElement.style.cssText = `
                    background-color: ${event.color};
                    color: white;
                    padding: 8px;
                    margin-bottom: 5px;
                    border-radius: 5px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                `;
                
                const eventTitle = document.createElement('div');
                eventTitle.textContent = event.title;
                eventTitle.style.cssText = `
                    font-weight: bold;
                    margin-bottom: 3px;
                `;
                
                const eventTime = document.createElement('div');
                eventTime.textContent = event.time;
                eventTime.style.cssText = `
                    font-size: 12px;
                `;
                
                eventElement.appendChild(eventTitle);
                eventElement.appendChild(eventTime);
                hourCell.appendChild(eventElement);
            });
            
            // Add click event to show event form
            hourCell.addEventListener('click', () => {
                this.selectedDate = new Date(hourDate);
                this.showEventForm();
            });
            
            timeGrid.appendChild(hourCell);
        }
        
        this.calendarGrid.appendChild(timeGrid);
    }

    /**
     * Render agenda view
     */
    renderAgendaView() {
        const agendaContainer = document.createElement('div');
        agendaContainer.style.cssText = `
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            flex-grow: 1;
            overflow: auto;
        `;
        
        const agendaTitle = document.createElement('h3');
        agendaTitle.textContent = 'Agenda';
        agendaTitle.style.cssText = `
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
        `;
        agendaContainer.appendChild(agendaTitle);
        
        // Get events for the next 7 days
        const events = [];
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const dayEvents = this.getEventsForDate(date);
            
            if (dayEvents.length > 0) {
                events.push({
                    date: new Date(date),
                    events: dayEvents
                });
            }
        }
        
        if (events.length === 0) {
            const noEvents = document.createElement('p');
            noEvents.textContent = 'No upcoming events in the next 7 days.';
            noEvents.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            agendaContainer.appendChild(noEvents);
        } else {
            events.forEach(day => {
                const dayContainer = document.createElement('div');
                dayContainer.style.cssText = `
                    margin-bottom: 20px;
                `;
                
                const dayHeader = document.createElement('h4');
                dayHeader.textContent = day.date.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric' 
                });
                dayHeader.style.cssText = `
                    margin-top: 0;
                    margin-bottom: 10px;
                    color: #333;
                    border-bottom: 1px solid #eee;
                    padding-bottom: 5px;
                `;
                dayContainer.appendChild(dayHeader);
                
                day.events.forEach(event => {
                    const eventElement = document.createElement('div');
                    eventElement.style.cssText = `
                        display: flex;
                        align-items: center;
                        padding: 10px;
                        margin-bottom: 8px;
                        border-radius: 5px;
                        background-color: #f9f9f9;
                        border-left: 4px solid ${event.color};
                        cursor: pointer;
                    `;
                    
                    const eventTime = document.createElement('div');
                    eventTime.textContent = event.time;
                    eventTime.style.cssText = `
                        min-width: 70px;
                        font-weight: bold;
                        color: #555;
                    `;
                    
                    const eventDetails = document.createElement('div');
                    eventDetails.style.cssText = `
                        margin-left: 15px;
                    `;
                    
                    const eventTitle = document.createElement('div');
                    eventTitle.textContent = event.title;
                    eventTitle.style.cssText = `
                        font-weight: bold;
                        margin-bottom: 3px;
                    `;
                    
                    const eventCategory = document.createElement('div');
                    eventCategory.textContent = event.categoryName;
                    eventCategory.style.cssText = `
                        font-size: 12px;
                        color: #666;
                    `;
                    
                    eventDetails.appendChild(eventTitle);
                    eventDetails.appendChild(eventCategory);
                    
                    eventElement.appendChild(eventTime);
                    eventElement.appendChild(eventDetails);
                    
                    eventElement.addEventListener('click', () => {
                        this.selectedEvent = event;
                        this.showEventDetails(event);
                    });
                    
                    dayContainer.appendChild(eventElement);
                });
                
                agendaContainer.appendChild(dayContainer);
            });
        }
        
        this.calendarGrid.appendChild(agendaContainer);
    }

    /**
     * Update month/year display
     */
    updateMonthYearDisplay() {
        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        
        const month = monthNames[this.currentDate.getMonth()];
        const year = this.currentDate.getFullYear();
        
        this.monthYearDisplay.textContent = `${month} ${year}`;
    }

    /**
     * Set calendar view
     */
    setView(view) {
        this.currentView = view;
        
        // Update active button
        Object.keys(this.viewButtons).forEach(key => {
            if (key === view) {
                this.viewButtons[key].classList.add('active');
            } else {
                this.viewButtons[key].classList.remove('active');
            }
        });
        
        this.renderCalendar();
    }

    /**
     * Navigate to previous period
     */
    navigatePrevious() {
        switch (this.currentView) {
            case 'month':
                this.currentDate.setMonth(this.currentDate.getMonth() - 1);
                break;
            case 'week':
                this.currentDate.setDate(this.currentDate.getDate() - 7);
                break;
            case 'day':
                this.currentDate.setDate(this.currentDate.getDate() - 1);
                break;
            case 'agenda':
                this.currentDate.setDate(this.currentDate.getDate() - 7);
                break;
        }
        this.renderCalendar();
    }

    /**
     * Navigate to next period
     */
    navigateNext() {
        switch (this.currentView) {
            case 'month':
                this.currentDate.setMonth(this.currentDate.getMonth() + 1);
                break;
            case 'week':
                this.currentDate.setDate(this.currentDate.getDate() + 7);
                break;
            case 'day':
                this.currentDate.setDate(this.currentDate.getDate() + 1);
                break;
            case 'agenda':
                this.currentDate.setDate(this.currentDate.getDate() + 7);
                break;
        }
        this.renderCalendar();
    }

    /**
     * Go to today
     */
    goToToday() {
        this.currentDate = new Date();
        this.renderCalendar();
    }

    /**
     * Show event form
     */
    showEventForm() {
        this.eventForm.style.display = 'block';
        
        // Set default date to selected date or today
        const dateInput = this.eventForm.querySelector('input[type="date"]');
        if (this.selectedDate) {
            dateInput.value = this.formatDateForInput(this.selectedDate);
        } else {
            dateInput.value = this.formatDateForInput(new Date());
        }
    }

    /**
     * Show reminder form
     */
    showReminderForm() {
        this.reminderForm.style.display = 'block';
        
        // Set default date to today
        const dateInput = this.reminderForm.querySelector('input[type="date"]');
        dateInput.value = this.formatDateForInput(new Date());
    }

    /**
     * Show event details modal
     */
    showEventDetails(event) {
        this.selectedEvent = event;
        
        // Populate modal with event details
        document.getElementById('event-details-title').textContent = event.title;
        document.getElementById('event-details-datetime').textContent = 
            `${event.date.toLocaleDateString()} at ${event.time}`;
        document.getElementById('event-details-category').textContent = event.categoryName;
        document.getElementById('event-details-recurring').textContent = 
            event.recurring === 'none' ? 'Does not repeat' : 
            event.recurring.charAt(0).toUpperCase() + event.recurring.slice(1);
        document.getElementById('event-details-description').textContent = 
            event.description || 'No description';
        
        // Show modal
        this.eventDetailsModal.style.display = 'block';
    }

    /**
     * Show reminder details modal
     */
    showReminderDetails(reminder) {
        this.selectedReminder = reminder;
        
        // Populate modal with reminder details
        document.getElementById('reminder-details-title').textContent = reminder.title;
        document.getElementById('reminder-details-datetime').textContent = 
            `${reminder.date.toLocaleDateString()} at ${reminder.time}`;
        document.getElementById('reminder-details-repeat').textContent = 
            reminder.repeat === 'none' ? 'Does not repeat' : 
            reminder.repeat.charAt(0).toUpperCase() + reminder.repeat.slice(1);
        
        // Format notification time
        let notifyText = 'At time of reminder';
        if (reminder.notifyBefore > 0) {
            if (reminder.notifyBefore < 60) {
                notifyText = `${reminder.notifyBefore} minutes before`;
            } else if (reminder.notifyBefore === 60) {
                notifyText = '1 hour before';
            } else if (reminder.notifyBefore === 1440) {
                notifyText = '1 day before';
            }
        }
        document.getElementById('reminder-details-notify').textContent = notifyText;
        
        // Show modal
        this.reminderDetailsModal.style.display = 'block';
    }

    /**
     * Save event
     */
    saveEvent(title, date, time, category, recurring, description) {
        if (!title || !date) {
            botReply('Please fill in the required fields (title and date).');
            return;
        }
        
        const eventDate = new Date(date);
        const event = {
            id: Date.now(),
            title,
            date: eventDate,
            time: time || 'All day',
            category,
            categoryName: this.categories.find(c => c.id === category).name,
            color: this.categories.find(c => c.id === category).color,
            recurring,
            description
        };
        
        this.events.push(event);
        this.saveDataToStorage(); // Save to localStorage
        this.renderCalendar();
        botReply(`Event "${title}" has been added to your calendar and saved.`);
    }

    /**
     * Save reminder
     */
    saveReminder(title, date, time, repeat, notifyBefore) {
        if (!title || !date) {
            botReply('Please fill in the required fields (title and date).');
            return;
        }
        
        const reminderDate = new Date(date);
        const reminder = {
            id: Date.now(),
            title,
            date: reminderDate,
            time: time || 'All day',
            repeat,
            notifyBefore: parseInt(notifyBefore)
        };
        
        this.reminders.push(reminder);
        this.saveDataToStorage(); // Save to localStorage
        this.renderCalendar();
        botReply(`Reminder "${title}" has been added to your calendar and saved.`);
    }

    /**
     * Delete event
     */
    deleteEvent(eventId) {
        if (confirm('Are you sure you want to delete this event?')) {
            this.events = this.events.filter(event => event.id !== eventId);
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('Event has been deleted.');
        }
    }

    /**
     * Delete reminder
     */
    deleteReminder(reminderId) {
        if (confirm('Are you sure you want to delete this reminder?')) {
            this.reminders = this.reminders.filter(reminder => reminder.id !== reminderId);
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('Reminder has been deleted.');
        }
    }

    /**
     * Get events for a specific date
     */
    getEventsForDate(date) {
        const dateStr = date.toDateString();
        return this.events.filter(event => {
            const eventDateStr = event.date.toDateString();
            return eventDateStr === dateStr;
        });
    }

    /**
     * Get events for a specific date and hour
     */
    getEventsForDateTime(dateTime) {
        const dateStr = dateTime.toDateString();
        const hour = dateTime.getHours();
        
        return this.events.filter(event => {
            const eventDateStr = event.date.toDateString();
            if (eventDateStr !== dateStr) return false;
            
            if (event.time === 'All day') return true;
            
            const eventHour = parseInt(event.time.split(':')[0]);
            const eventAmPm = event.time.includes('AM') ? 'AM' : 'PM';
            
            // Convert to 24-hour format for comparison
            let eventHour24 = eventHour;
            if (eventAmPm === 'PM' && eventHour !== 12) {
                eventHour24 += 12;
            } else if (eventAmPm === 'AM' && eventHour === 12) {
                eventHour24 = 0;
            }
            
            return eventHour24 === hour;
        });
    }

    /**
     * Update events list in sidebar
     */
    updateEventsList() {
        this.eventsList.innerHTML = '';
        
        // Get upcoming events (next 7 days)
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const nextWeek = new Date(today);
        nextWeek.setDate(today.getDate() + 7);
        
        const upcomingEvents = this.events.filter(event => {
            return event.date >= today && event.date <= nextWeek;
        });
        
        if (upcomingEvents.length === 0) {
            const noEvents = document.createElement('p');
            noEvents.textContent = 'No upcoming events.';
            noEvents.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            this.eventsList.appendChild(noEvents);
            return;
        }
        
        // Sort events by date and time
        upcomingEvents.sort((a, b) => {
            if (a.date < b.date) return -1;
            if (a.date > b.date) return 1;
            
            if (a.time === 'All day') return -1;
            if (b.time === 'All day') return 1;
            
            return a.time.localeCompare(b.time);
        });
        
        upcomingEvents.forEach(event => {
            const eventElement = document.createElement('div');
            eventElement.style.cssText = `
                padding: 10px;
                margin-bottom: 8px;
                border-radius: 5px;
                background-color: #f9f9f9;
                border-left: 4px solid ${event.color};
                cursor: pointer;
                position: relative;
            `;
            
            const eventTitle = document.createElement('div');
            eventTitle.textContent = event.title;
            eventTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 3px;
            `;
            
            const eventDate = document.createElement('div');
            eventDate.textContent = `${event.date.toLocaleDateString()} at ${event.time}`;
            eventDate.style.cssText = `
                font-size: 12px;
                color: #666;
            `;
            
            eventElement.appendChild(eventTitle);
            eventElement.appendChild(eventDate);
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '✕';
            deleteButton.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: #f44336;
                font-size: 16px;
                cursor: pointer;
                padding: 0;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteEvent(event.id);
            });
            eventElement.appendChild(deleteButton);
            
            eventElement.addEventListener('click', () => {
                this.selectedEvent = event;
                this.showEventDetails(event);
            });
            
            this.eventsList.appendChild(eventElement);
        });
    }

    /**
     * Update reminders list in sidebar
     */
    updateRemindersList() {
        this.remindersList.innerHTML = '';
        
        // Get active reminders
        const today = new Date();
        const activeReminders = this.reminders.filter(reminder => {
            return reminder.date >= today;
        });
        
        if (activeReminders.length === 0) {
            const noReminders = document.createElement('p');
            noReminders.textContent = 'No active reminders.';
            noReminders.style.cssText = `
                color: #666;
                font-style: italic;
            `;
            this.remindersList.appendChild(noReminders);
            return;
        }
        
        // Sort reminders by date and time
        activeReminders.sort((a, b) => {
            if (a.date < b.date) return -1;
            if (a.date > b.date) return 1;
            
            if (a.time === 'All day') return -1;
            if (b.time === 'All day') return 1;
            
            return a.time.localeCompare(b.time);
        });
        
        activeReminders.forEach(reminder => {
            const reminderElement = document.createElement('div');
            reminderElement.style.cssText = `
                padding: 10px;
                margin-bottom: 8px;
                border-radius: 5px;
                background-color: #f9f9f9;
                border-left: 4px solid #9C27B0;
                cursor: pointer;
                position: relative;
            `;
            
            const reminderTitle = document.createElement('div');
            reminderTitle.textContent = reminder.title;
            reminderTitle.style.cssText = `
                font-weight: bold;
                margin-bottom: 3px;
            `;
            
            const reminderDate = document.createElement('div');
            reminderDate.textContent = `${reminder.date.toLocaleDateString()} at ${reminder.time}`;
            reminderDate.style.cssText = `
                font-size: 12px;
                color: #666;
            `;
            
            reminderElement.appendChild(reminderTitle);
            reminderElement.appendChild(reminderDate);
            
            // Add delete button
            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = '✕';
            deleteButton.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: none;
                border: none;
                color: #f44336;
                font-size: 16px;
                cursor: pointer;
                padding: 0;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteReminder(reminder.id);
            });
            reminderElement.appendChild(deleteButton);
            
            reminderElement.addEventListener('click', () => {
                this.selectedReminder = reminder;
                this.showReminderDetails(reminder);
            });
            
            this.remindersList.appendChild(reminderElement);
        });
    }

    /**
     * Filter events based on search and category
     */
    filterEvents() {
        const searchTerm = this.searchInput.value.toLowerCase();
        const selectedCategory = this.categoryFilter.value;
        
        // Implementation for filtering events
        // This would update the calendar view to show only matching events
        botReply(`Filtering events by: "${searchTerm}" and category: ${selectedCategory}`);
    }

    /**
     * Export data to JSON file
     */
    exportData() {
        const data = {
            events: this.events,
            reminders: this.reminders,
            exportDate: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(data, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `calendar-data-${new Date().toISOString().split('T')[0]}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        botReply('Calendar data exported successfully!');
    }

    /**
     * Import data from JSON file
     */
    importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            
            reader.onload = event => {
                try {
                    const data = JSON.parse(event.target.result);
                    
                    if (data.events && Array.isArray(data.events)) {
                        this.events = data.events.map(event => ({
                            ...event,
                            date: new Date(event.date)
                        }));
                    }
                    
                    if (data.reminders && Array.isArray(data.reminders)) {
                        this.reminders = data.reminders.map(reminder => ({
                            ...reminder,
                            date: new Date(reminder.date)
                        }));
                    }
                    
                    this.saveDataToStorage();
                    this.renderCalendar();
                    botReply('Calendar data imported successfully!');
                } catch (error) {
                    console.error('Error importing data:', error);
                    botReply('Error importing data. Please make sure the file is a valid calendar export.');
                }
            };
            
            reader.readAsText(file);
        };
        
        input.click();
    }

    /**
     * Clear all data
     */
    clearAllData() {
        if (confirm('Are you sure you want to clear all calendar data? This action cannot be undone.')) {
            this.events = [];
            this.reminders = [];
            this.saveDataToStorage();
            this.renderCalendar();
            botReply('All calendar data has been cleared.');
        }
    }

    /**
     * Format date for input field
     */
    formatDateForInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 10px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);

        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            // Close any open modals first
            if (this.eventDetailsModal && this.eventDetailsModal.style.display === 'block') {
                this.eventDetailsModal.style.display = 'none';
                return;
            }
            
            if (this.reminderDetailsModal && this.reminderDetailsModal.style.display === 'block') {
                this.reminderDetailsModal.style.display = 'none';
                return;
            }
            
            if (this.eventForm && this.eventForm.style.display === 'block') {
                this.eventForm.style.display = 'none';
                return;
            }
            
            if (this.reminderForm && this.reminderForm.style.display === 'block') {
                this.reminderForm.style.display = 'none';
                return;
            }
            
            // Then handle fullscreen or close
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.calendarGrid = null;
        this.monthYearDisplay = null;
        this.viewButtons = {};
        this.eventForm = null;
        this.eventsList = null;
        this.reminderForm = null;
        this.remindersList = null;
        this.searchInput = null;
        this.categoryFilter = null;
        this.eventDetailsModal = null;
        this.reminderDetailsModal = null;
        this.currentDate = new Date();
        this.currentView = 'month';
        this.selectedDate = null;
        this.selectedEvent = null;
        this.selectedReminder = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Advanced Calendar closed. Your data has been saved locally.");
    }
}

// Create a singleton instance
const advancedCalendar = new AdvancedCalendar();

// Add this to your AI's command handling
if (/calendar|schedule|agenda|planner/i.test(userInputRaw)) {
    advancedCalendar.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    advancedCalendar.closeGame();
    return;
}

class LiveScreenLoaderEditor {
    constructor() {
        this.baseScreen = {
            name: 'LIVE COLLABORATIVE EDITOR',
            instructions: 'Real-time collaborative editing. Admin changes are instantly visible to all users.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.roleToggle = null;
        this.editorArea = null;
        this.previewArea = null;
        this.outputDiv = null;
        this.userList = null;
        this.currentRole = 'user'; // 'user' or 'admin'
        this.documentContent = 'Welcome to the Live Collaborative Editor!\n\nThis is a shared document that can be edited in real-time.\n\nAdmin changes will appear instantly for all users.';
        this.isEditing = false;
        this.isLocked = false;
        this.activeUsers = [];
        this.editHistory = [];
        this.currentVersion = 0;
        this.autoSaveInterval = null;
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.documentRef = null;
        this.usersRef = null;
        this.presenceRef = null;
        this.connectedRef = null;
        this.messagesRef = null;
        this.isFirebaseInitialized = false;
        this.lastEditorId = null;
        this.isLocalChange = false;
        this.messageQueue = [];
        this.isProcessingQueue = false;
    }

    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'user_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Load the Live Editor Screen
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLiveEditorScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.startAutoSave();
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }

    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            firebase.initializeApp(this.firebaseConfig);
            this.db = firebase.database();
            
            // References
            this.documentRef = this.db.ref('collaborativeEditor/document');
            this.usersRef = this.db.ref('collaborativeEditor/users');
            this.presenceRef = this.db.ref('collaborativeEditor/presence');
            this.connectedRef = this.db.ref('.info/connected');
            this.messagesRef = this.db.ref('collaborativeEditor/messages');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.updateConnectionStatus(true);
                    this.registerUser();
                    this.setupFirebaseListeners();
                    this.loadDocumentFromFirebase();
                    this.processMessageQueue();
                } else {
                    this.updateConnectionStatus(false);
                }
            });
            
            this.isFirebaseInitialized = true;
            this.logActivity('Firebase connected successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.logActivity('Firebase connection failed');
            this.updateConnectionStatus(false);
        }
    }

    /**
     * Setup Firebase listeners
     */
    setupFirebaseListeners() {
        // Listen for document changes with high priority
        this.documentRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (data) {
                // Skip if this is a local change
                if (this.isLocalChange && data.lastEditorId === this.userSessionId) {
                    this.isLocalChange = false;
                    return;
                }
                
                // Update document content
                if (data.content !== undefined && data.content !== this.documentContent) {
                    this.documentContent = data.content;
                    this.editorArea.value = this.documentContent;
                    this.previewArea.textContent = this.documentContent;
                    
                    // Only log if it's not our own change
                    if (data.lastEditorId !== this.userSessionId) {
                        this.logActivity(`Document updated by ${data.lastEditorRole || 'another user'}`);
                    }
                }
                
                // Update lock status
                if (data.locked !== undefined && data.locked !== this.isLocked) {
                    this.isLocked = data.locked;
                    this.updateUIForRole();
                    this.logActivity(`Document ${this.isLocked ? 'locked' : 'unlocked'} by admin`);
                }
                
                // Update version
                if (data.version !== undefined && data.version !== this.currentVersion) {
                    this.currentVersion = data.version;
                    this.logActivity(`New version available: ${this.currentVersion}`);
                }
            }
        });
        
        // Listen for user changes
        this.usersRef.on('value', (snapshot) => {
            const users = snapshot.val();
            if (users) {
                this.activeUsers = Object.values(users).filter(user => user.id !== this.userSessionId);
                this.updateActiveUsers();
            }
        });
        
        // Listen for broadcast messages with high priority
        this.messagesRef.on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (message && message.text) {
                // Display message immediately
                this.displayBroadcastMessage(message);
            }
        });
        
        // Setup presence for this user
        this.presenceRef.child(this.userSessionId).onDisconnect().remove();
        this.presenceRef.child(this.userSessionId).set(true);
    }

    /**
     * Display broadcast message immediately
     */
    displayBroadcastMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.style.cssText = `
            background-color: #9C27B0;
            color: white;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-weight: bold;
            animation: fadeIn 0.5s;
        `;
        messageElement.textContent = `📢 ${message.author}: ${message.text}`;
        
        // Insert at the top of the activity log
        this.outputDiv.insertBefore(messageElement, this.outputDiv.firstChild);
        
        // Remove after 5 seconds
        setTimeout(() => {
            if (messageElement.parentNode) {
                messageElement.style.opacity = '0';
                messageElement.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    if (messageElement.parentNode) {
                        messageElement.remove();
                    }
                }, 500);
            }
        }, 5000);
        
        // Also log in activity
        this.logActivity(`Broadcast: "${message.text}" by ${message.author}`);
    }

    /**
     * Process message queue when Firebase is ready
     */
    processMessageQueue() {
        if (this.messageQueue.length > 0) {
            this.messageQueue.forEach(message => {
                this.messagesRef.push(message);
            });
            this.messageQueue = [];
        }
    }

    /**
     * Load document from Firebase
     */
    loadDocumentFromFirebase() {
        this.documentRef.once('value').then((snapshot) => {
            const data = snapshot.val();
            if (data) {
                this.documentContent = data.content || this.documentContent;
                this.isLocked = data.locked || false;
                this.currentVersion = data.version || 0;
                this.editHistory = data.history || [];
                
                // Update UI
                this.editorArea.value = this.documentContent;
                this.previewArea.textContent = this.documentContent;
                this.updateUIForRole();
                
                this.logActivity(`Loaded document version ${this.currentVersion}`);
            } else {
                // Initialize document if it doesn't exist
                this.saveDocumentToFirebase();
            }
        }).catch(error => {
            console.error('Error loading document:', error);
            this.logActivity('Error loading document');
        });
    }

    /**
     * Save document to Firebase
     */
    saveDocumentToFirebase() {
        if (!this.isFirebaseInitialized) return;
        
        const data = {
            content: this.documentContent,
            locked: this.isLocked,
            version: this.currentVersion,
            history: this.editHistory,
            lastUpdated: firebase.database.ServerValue.TIMESTAMP,
            lastEditorId: this.userSessionId,
            lastEditorRole: this.currentRole
        };
        
        this.isLocalChange = true;
        this.documentRef.update(data).catch(error => {
            console.error('Error saving document:', error);
            this.logActivity('Error saving document');
            this.isLocalChange = false;
        });
    }

    /**
     * Register this user in Firebase
     */
    registerUser() {
        if (!this.isFirebaseInitialized) return;
        
        const userData = {
            id: this.userSessionId,
            role: this.currentRole,
            name: this.currentRole === 'admin' ? 'Admin' : 'User',
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            editing: this.isEditing
        };
        
        this.usersRef.child(this.userSessionId).set(userData).catch(error => {
            console.error('Error registering user:', error);
        });
    }

    /**
     * Update user status in Firebase
     */
    updateUserStatus(isEditing) {
        if (!this.isFirebaseInitialized) return;
        
        this.usersRef.child(this.userSessionId).update({
            editing: isEditing,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        }).catch(error => {
            console.error('Error updating user status:', error);
        });
    }

    /**
     * Remove a user from the session (admin only)
     */
    removeUser(userId) {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can remove users.');
            return;
        }
        
        if (confirm('Are you sure you want to remove this user from the session?')) {
            // Remove from users list
            this.usersRef.child(userId).remove().then(() => {
                // Remove from presence
                this.presenceRef.child(userId).remove();
                this.logActivity('User removed from session by admin');
                botReply('User removed from session');
            }).catch(error => {
                console.error('Error removing user:', error);
                this.logActivity('Error removing user');
            });
        }
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow-y: auto;
        `;
    }

    /**
     * Create the Live Editor UI
     */
    createLiveEditorScreen() {
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 900px;
            max-width: 95vw;
            min-height: 80vh;
            display: flex;
            flex-direction: column;
            margin: 20px 0;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        const title = document.createElement('h2');
        title.textContent = 'Live Collaborative Editor';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Real-time collaboration across devices';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);

        // Role toggle and connection status
        const topControls = document.createElement('div');
        topControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 20px;
            flex-wrap: wrap;
        `;

        // Role toggle
        const roleSection = document.createElement('div');
        roleSection.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const roleLabel = document.createElement('label');
        roleLabel.textContent = 'Current Role:';
        roleLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        this.roleToggle = document.createElement('select');
        this.roleToggle.style.cssText = `
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        `;
        const userOption = document.createElement('option');
        userOption.value = 'user';
        userOption.textContent = 'User';
        const adminOption = document.createElement('option');
        adminOption.value = 'admin';
        adminOption.textContent = 'Admin';
        this.roleToggle.appendChild(userOption);
        this.roleToggle.appendChild(adminOption);
        this.roleToggle.addEventListener('change', (e) => {
            this.switchRole(e.target.value);
        });
        roleSection.appendChild(roleLabel);
        roleSection.appendChild(this.roleToggle);

        // Connection status
        const connectionSection = document.createElement('div');
        connectionSection.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        const connectionLabel = document.createElement('label');
        connectionLabel.textContent = 'Connection:';
        connectionLabel.style.cssText = `
            font-weight: bold;
            color: #333;
        `;
        this.connectionStatus = document.createElement('div');
        this.connectionStatus.style.cssText = `
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #f44336;
        `;
        this.connectionTooltip = document.createElement('span');
        this.connectionTooltip.textContent = 'Connecting...';
        this.connectionTooltip.style.cssText = `
            font-size: 14px;
            color: #666;
        `;
        connectionSection.appendChild(connectionLabel);
        connectionSection.appendChild(this.connectionStatus);
        connectionSection.appendChild(this.connectionTooltip);

        topControls.appendChild(roleSection);
        topControls.appendChild(connectionSection);
        baseContainer.appendChild(topControls);

        // Active users section
        const usersSection = document.createElement('div');
        usersSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const usersLabel = document.createElement('label');
        usersLabel.textContent = 'Active Users:';
        usersLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.userList = document.createElement('div');
        this.userList.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 30px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        `;
        this.userList.textContent = 'Loading users...';
        usersSection.appendChild(usersLabel);
        usersSection.appendChild(this.userList);
        baseContainer.appendChild(usersSection);

        // Editor area
        const editorSection = document.createElement('div');
        editorSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const editorLabel = document.createElement('label');
        editorLabel.textContent = 'Live Editor:';
        editorLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.editorArea = document.createElement('textarea');
        this.editorArea.style.cssText = `
            width: 100%;
            height: 150px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
            background-color: #fff;
        `;
        this.editorArea.value = this.documentContent;
        this.editorArea.addEventListener('input', (e) => {
            this.handleTextChange(e.target.value);
        });
        this.editorArea.addEventListener('focus', () => {
            this.startEditing();
        });
        this.editorArea.addEventListener('blur', () => {
            this.stopEditing();
        });
        editorSection.appendChild(editorLabel);
        editorSection.appendChild(this.editorArea);
        baseContainer.appendChild(editorSection);

        // Preview area
        const previewSection = document.createElement('div');
        previewSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const previewLabel = document.createElement('label');
        previewLabel.textContent = 'Live Preview:';
        previewLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.previewArea = document.createElement('div');
        this.previewArea.style.cssText = `
            width: 100%;
            min-height: 100px;
            max-height: 200px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #fff;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
        `;
        this.previewArea.textContent = this.documentContent;
        previewSection.appendChild(previewLabel);
        previewSection.appendChild(this.previewArea);
        baseContainer.appendChild(previewSection);

        // Admin controls
        this.adminControls = document.createElement('div');
        this.adminControls.style.cssText = `
            display: none;
            margin-bottom: 15px;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        `;
        const adminTitle = document.createElement('h3');
        adminTitle.textContent = 'Admin Controls';
        adminTitle.style.cssText = `
            margin: 0 0 15px 0;
            color: #2E7D32;
            font-size: 18px;
        `;
        const adminButtons = document.createElement('div');
        adminButtons.style.cssText = `
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        `;
        const lockButton = this.createButton('Lock Editing', '#FF9800', () => {
            this.toggleLock(true);
        });
        const unlockButton = this.createButton('Unlock Editing', '#4CAF50', () => {
            this.toggleLock(false);
        });
        const saveButton = this.createButton('Save Version', '#2196F3', () => {
            this.saveVersion();
        });
        const clearButton = this.createButton('Clear Document', '#f44336', () => {
            this.clearDocument();
        });
        const broadcastButton = this.createButton('Broadcast Message', '#9C27B0', () => {
            this.broadcastMessage();
        });
        adminButtons.appendChild(lockButton);
        adminButtons.appendChild(unlockButton);
        adminButtons.appendChild(saveButton);
        adminButtons.appendChild(clearButton);
        adminButtons.appendChild(broadcastButton);
        this.adminControls.appendChild(adminTitle);
        this.adminControls.appendChild(adminButtons);
        baseContainer.appendChild(this.adminControls);

        // Output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Activity Log:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        this.outputDiv = document.createElement('div');
        this.outputDiv.style.cssText = `
            width: 100%;
            min-height: 80px;
            max-height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
            background-color: #f9f9f9;
            overflow-y: auto;
        `;
        this.outputDiv.textContent = `Connecting to Firebase...`;
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputDiv);
        baseContainer.appendChild(outputSection);

        // Info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 15px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
            margin-top: auto;
        `;
        infoSection.innerHTML = `
            <strong>Instructions:</strong><br>
            • Switch between User and Admin roles using the dropdown<br>
            • Open this editor on multiple devices to collaborate<br>
            • Admin changes are instantly visible to all users via Firebase<br>
            • Admins can lock/unlock editing and manage permissions<br>
            • Admins can remove users from the session<br>
            • Document auto-saves every 30 seconds to Firebase
        `;
        baseContainer.appendChild(infoSection);
        this.gameContainer.appendChild(baseContainer);
    }

    /**
     * Update active users list with delete option for admin
     */
    updateActiveUsers() {
        this.userList.innerHTML = '';
        
        // Add current user
        const currentUser = document.createElement('span');
        currentUser.textContent = this.currentRole === 'admin' ? '👑 Admin (You)' : '👤 User (You)';
        currentUser.style.cssText = `
            padding: 4px 8px;
            background-color: ${this.currentRole === 'admin' ? '#4CAF50' : '#2196F3'};
            color: white;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        `;
        this.userList.appendChild(currentUser);
        
        // Add other active users
        this.activeUsers.forEach(user => {
            const userContainer = document.createElement('div');
            userContainer.style.cssText = `
                display: flex;
                align-items: center;
                gap: 5px;
            `;
            
            const userElement = document.createElement('span');
            userElement.textContent = user.role === 'admin' ? '👑 Admin' : '👤 User';
            userElement.style.cssText = `
                padding: 4px 8px;
                background-color: ${user.editing ? '#FF9800' : (user.role === 'admin' ? '#81C784' : '#64B5F6')};
                color: white;
                border-radius: 15px;
                font-size: 12px;
            `;
            userElement.title = user.name;
            userContainer.appendChild(userElement);
            
            // Add delete button for admin
            if (this.currentRole === 'admin') {
                const deleteButton = document.createElement('button');
                deleteButton.textContent = '❌';
                deleteButton.style.cssText = `
                    width: 20px;
                    height: 20px;
                    border: none;
                    border-radius: 50%;
                    background-color: #f44336;
                    color: white;
                    font-size: 10px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                deleteButton.title = 'Remove user';
                deleteButton.addEventListener('click', () => {
                    this.removeUser(user.id);
                });
                userContainer.appendChild(deleteButton);
            }
            
            this.userList.appendChild(userContainer);
        });
        
        if (this.activeUsers.length === 0) {
            const noUsers = document.createElement('span');
            noUsers.textContent = 'No other active users';
            noUsers.style.cssText = `
                padding: 4px 8px;
                color: #666;
                font-style: italic;
            `;
            this.userList.appendChild(noUsers);
        }
    }

    /**
     * Update connection status
     */
    updateConnectionStatus(isConnected) {
        if (isConnected) {
            this.connectionStatus.style.backgroundColor = '#4CAF50';
            this.connectionTooltip.textContent = 'Connected to Firebase';
        } else {
            this.connectionStatus.style.backgroundColor = '#f44336';
            this.connectionTooltip.textContent = 'Disconnected';
        }
    }

    /**
     * Handle text changes in the editor
     */
    handleTextChange(newText) {
        // Check if editing is locked and user is not admin
        if (this.isLocked && this.currentRole === 'user') {
            this.logActivity('Editing is locked by admin. Changes discarded.');
            this.editorArea.value = this.documentContent;
            return;
        }
        
        this.documentContent = newText;
        this.previewArea.textContent = newText;
        
        // Save to Firebase to sync with other users
        this.saveDocumentToFirebase();
        
        // Log activity
        this.logActivity(`Document updated by ${this.currentRole}`);
    }

    /**
     * Start editing
     */
    startEditing() {
        if (this.isLocked && this.currentRole === 'user') {
            this.logActivity('Editing is locked by admin.');
            this.editorArea.blur();
            return;
        }
        
        this.isEditing = true;
        this.updateUserStatus(true);
        this.logActivity(`Started editing as ${this.currentRole}`);
    }

    /**
     * Stop editing
     */
    stopEditing() {
        this.isEditing = false;
        this.updateUserStatus(false);
        this.logActivity(`Stopped editing as ${this.currentRole}`);
    }

    /**
     * Switch between user and admin roles
     */
    switchRole(newRole) {
        this.currentRole = newRole;
        this.registerUser(); // Update user role in Firebase
        this.updateUIForRole();
        this.updateActiveUsers(); // Update user list to show/hide delete buttons
        
        // Show/hide admin controls
        if (newRole === 'admin') {
            this.adminControls.style.display = 'block';
            // Scroll to admin controls when switching to admin
            setTimeout(() => {
                this.adminControls.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        } else {
            this.adminControls.style.display = 'none';
        }
        
        this.logActivity(`Switched to ${newRole} role`);
    }

    /**
     * Update UI based on current role
     */
    updateUIForRole() {
        if (this.currentRole === 'admin') {
            this.editorArea.style.backgroundColor = '#fff8e1';
            this.editorArea.style.border = '2px solid #FFC107';
        } else {
            this.editorArea.style.backgroundColor = '#fff';
            this.editorArea.style.border = '1px solid #ddd';
        }
        
        // Disable editor if locked and user
        if (this.isLocked && this.currentRole === 'user') {
            this.editorArea.disabled = true;
            this.logActivity('Document is locked by admin. You cannot edit.');
        } else {
            this.editorArea.disabled = false;
        }
    }

    /**
     * Toggle document lock
     */
    toggleLock(lock) {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can lock/unlock the document.');
            return;
        }
        
        this.isLocked = lock;
        this.updateUIForRole();
        this.saveDocumentToFirebase(); // Sync with other users
        
        if (lock) {
            this.logActivity('Document locked by admin');
            botReply('Document locked for editing');
        } else {
            this.logActivity('Document unlocked by admin');
            botReply('Document unlocked for editing');
        }
    }

    /**
     * Save document version
     */
    saveVersion() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can save versions.');
            return;
        }
        
        this.currentVersion++;
        this.editHistory.push({
            version: this.currentVersion,
            content: this.documentContent,
            timestamp: new Date().toLocaleString(),
            author: this.currentRole
        });
        
        this.saveDocumentToFirebase(); // Sync with other users
        this.logActivity(`Version ${this.currentVersion} saved by ${this.currentRole}`);
        botReply(`Document version ${this.currentVersion} saved`);
    }

    /**
     * Clear document
     */
    clearDocument() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can clear the document.');
            return;
        }
        
        if (confirm('Are you sure you want to clear the document? This cannot be undone.')) {
            this.documentContent = '';
            this.editorArea.value = '';
            this.previewArea.textContent = '';
            this.saveDocumentToFirebase(); // Sync with other users
            this.logActivity('Document cleared by admin');
            botReply('Document cleared');
        }
    }

    /**
     * Broadcast a message to all users
     */
    broadcastMessage() {
        if (this.currentRole !== 'admin') {
            this.logActivity('Only admins can broadcast messages.');
            return;
        }
        
        const message = prompt('Enter message to broadcast to all users:');
        if (message) {
            const messageData = {
                text: message,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                author: this.currentRole
            };
            
            // If Firebase is ready, send immediately
            if (this.isFirebaseInitialized) {
                this.messagesRef.push(messageData);
            } else {
                // Queue the message for when Firebase is ready
                this.messageQueue.push(messageData);
            }
            
            this.logActivity(`Admin broadcast: "${message}"`);
            botReply(`Message broadcast: "${message}"`);
        }
    }

    /**
     * Log activity
     */
    logActivity(message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}\n`;
        this.outputDiv.textContent += logEntry;
        this.outputDiv.scrollTop = this.outputDiv.scrollHeight;
    }

    /**
     * Start auto-save
     */
    startAutoSave() {
        this.autoSaveInterval = setInterval(() => {
            if (this.documentContent.trim() !== '' && this.currentRole === 'admin') {
                this.saveVersion();
            }
        }, 30000); // Auto-save every 30 seconds
    }

    /**
     * Stop auto-save
     */
    stopAutoSave() {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
        }
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 8px 12px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        this.gameContainer.appendChild(floatingButtons);
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove user from Firebase
        if (this.isFirebaseInitialized) {
            this.usersRef.child(this.userSessionId).remove();
            this.presenceRef.child(this.userSessionId).remove();
        }
        
        this.stopAutoSave();
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        this.gameContainer = null;
        this.roleToggle = null;
        this.editorArea = null;
        this.previewArea = null;
        this.outputDiv = null;
        this.userList = null;
        this.adminControls = null;
        this.connectionStatus = null;
        this.connectionTooltip = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Live Collaborative Editor closed. Thank you!");
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}

// Create a singleton instance
const liveScreenLoaderEditor = new LiveScreenLoaderEditor();

// Add this to your AI's command handling
if (/live editor|live text editor|collaborative editor|real-time editor/i.test(userInputRaw)) {
    liveScreenLoaderEditor.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    liveScreenLoaderEditor.closeGame();
    return;
}



class ChatLiveScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'LIVE CHAT APP',
            instructions: 'Real-time chat application with online status and instant messaging.'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.messagesContainer = null;
        this.messageInput = null;
        this.sendButton = null;
        this.userList = null;
        this.statusDiv = null;
        this.currentUsername = '';
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.messagesRef = null;
        this.usersRef = null;
        this.presenceRef = null;
        this.connectedRef = null;
        this.typingRef = null;
        this.isFirebaseInitialized = false;
        this.activeUsers = [];
        this.blockedUsers = new Set();
        this.isAdmin = false;
        this.currentChatPartner = null;
        this.isPrivateChat = false;
        this.displayedMessages = new Set();
        this.messageListeners = {};
        this.typingUsers = new Set();
        this.lastMessageId = null; // Track last message to avoid duplicates
    }

    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'user_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Load the Chat App
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLoginScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }

    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.logActivity('Loading Firebase libraries...');
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }

    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
                this.logActivity('Firebase initialized successfully');
            } else {
                this.logActivity('Using existing Firebase app');
            }
            
            this.db = firebase.database();
            
            // References
            this.messagesRef = this.db.ref('chat/messages');
            this.usersRef = this.db.ref('chat/users');
            this.presenceRef = this.db.ref('chat/presence');
            this.connectedRef = this.db.ref('.info/connected');
            this.typingRef = this.db.ref('chat/typing');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.updateConnectionStatus(true);
                    this.setupFirebaseListeners();
                } else {
                    this.updateConnectionStatus(false);
                }
            });
            
            this.isFirebaseInitialized = true;
        } catch (error) {
            console.error('Firebase initialization error:', error);
            this.logActivity('Firebase connection failed: ' + error.message);
            this.updateConnectionStatus(false);
        }
    }

    /**
     * Setup Firebase listeners (optimized)
     */
    setupFirebaseListeners() {
        // Remove existing listeners
        this.removeFirebaseListeners();
        
        // Single listener for messages with limit
        this.messageListeners.messages = this.messagesRef
            .orderByKey()
            .limitToLast(50)
            .on('child_added', (snapshot) => {
                const message = snapshot.val();
                if (message && snapshot.key !== this.lastMessageId) {
                    this.lastMessageId = snapshot.key;
                    
                    // Check if sender is blocked
                    if (!this.blockedUsers.has(message.senderId)) {
                        // Only display if it's a group message or private message to/from current user
                        if (message.type === 'group' || 
                            (message.receiverId === this.userSessionId) || 
                            (message.senderId === this.userSessionId)) {
                            this.displayMessage(message);
                        }
                    }
                }
            });
        
        // User list listener with throttling
        this.messageListeners.users = this.usersRef.on('value', (snapshot) => {
            const users = snapshot.val();
            if (users) {
                this.activeUsers = Object.values(users).filter(user => user.id !== this.userSessionId);
                this.updateUserList();
            }
        });
        
        // Typing indicator with debouncing
        this.messageListeners.typing = this.typingRef.on('value', (snapshot) => {
            const typingData = snapshot.val();
            if (typingData) {
                this.updateTypingIndicators(typingData);
            }
        });
        
        // Setup presence
        this.presenceRef.child(this.userSessionId).onDisconnect().remove();
        this.presenceRef.child(this.userSessionId).set(true);
    }

    /**
     * Remove Firebase listeners
     */
    removeFirebaseListeners() {
        if (this.messageListeners.messages) {
            this.messagesRef.off('child_added', this.messageListeners.messages);
        }
        if (this.messageListeners.users) {
            this.usersRef.off('value', this.messageListeners.users);
        }
        if (this.messageListeners.typing) {
            this.typingRef.off('value', this.messageListeners.typing);
        }
        this.messageListeners = {};
    }

    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
        `;
    }

    /**
     * Create Login Screen
     */
    createLoginScreen() {
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 30px;
            width: 400px;
            max-width: 90vw;
            text-align: center;
        `;

        const title = document.createElement('h2');
        title.textContent = 'Live Chat App';
        title.style.cssText = `
            margin: 0 0 20px 0;
            color: #128C7E;
            font-size: 28px;
        `;
        loginContainer.appendChild(title);

        const subtitle = document.createElement('p');
        subtitle.textContent = 'Enter your username to start chatting';
        subtitle.style.cssText = `
            margin: 0 0 30px 0;
            color: #666;
            font-size: 16px;
        `;
        loginContainer.appendChild(subtitle);

        const inputContainer = document.createElement('div');
        inputContainer.style.cssText = `
            margin-bottom: 20px;
        `;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter your username';
        input.style.cssText = `
            width: 100%;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
        `;
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleLogin(input.value);
            }
        });
        inputContainer.appendChild(input);
        loginContainer.appendChild(inputContainer);

        // Admin checkbox
        const adminContainer = document.createElement('div');
        adminContainer.style.cssText = `
            margin-bottom: 20px;
            text-align: left;
        `;
        
        const adminLabel = document.createElement('label');
        adminLabel.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        `;
        
        const adminCheckbox = document.createElement('input');
        adminCheckbox.type = 'checkbox';
        adminCheckbox.style.cssText = `
            width: 18px;
            height: 18px;
        `;
        
        const adminText = document.createElement('span');
        adminText.textContent = 'Login as Admin';
        
        adminLabel.appendChild(adminCheckbox);
        adminLabel.appendChild(adminText);
        adminContainer.appendChild(adminLabel);
        loginContainer.appendChild(adminContainer);

        const loginButton = this.createButton('Join Chat', '#128C7E', () => {
            this.isAdmin = adminCheckbox.checked;
            this.handleLogin(input.value);
        });
        loginButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 25px;
            font-size: 16px;
        `;
        loginContainer.appendChild(loginButton);

        // Connection status
        const connectionStatus = document.createElement('div');
        connectionStatus.style.cssText = `
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        `;
        connectionStatus.innerHTML = `
            <span id="connection-indicator" style="display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: #f44336; margin-right: 5px;"></span>
            <span id="connection-text">Connecting to Firebase...</span>
        `;
        loginContainer.appendChild(connectionStatus);

        this.gameContainer.appendChild(loginContainer);
    }

    /**
     * Update connection status
     */
    updateConnectionStatus(isConnected) {
        const indicator = document.getElementById('connection-indicator');
        const text = document.getElementById('connection-text');
        
        if (indicator && text) {
            indicator.style.backgroundColor = isConnected ? '#25D366' : '#f44336';
            text.textContent = isConnected ? 'Connected to Firebase' : 'Connecting to Firebase...';
        }
    }

    /**
     * Log activity
     */
    logActivity(message) {
        console.log(`[Chat App] ${message}`);
    }

    /**
     * Handle Login
     */
    handleLogin(username) {
        if (!username.trim()) {
            this.showNotification('Please enter a username');
            return;
        }

        this.currentUsername = username.trim();
        this.registerUser();
        this.gameContainer.innerHTML = '';
        this.createChatScreen();
    }

    /**
     * Register user
     */
    registerUser() {
        if (!this.isFirebaseInitialized) {
            setTimeout(() => this.registerUser(), 1000);
            return;
        }
        
        const userData = {
            id: this.userSessionId,
            name: this.currentUsername,
            role: this.isAdmin ? 'admin' : 'user',
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            online: true
        };
        
        this.usersRef.child(this.userSessionId).set(userData).then(() => {
            this.logActivity(`User registered: ${this.currentUsername}`);
        }).catch(error => {
            console.error('Error registering user:', error);
        });
    }

    /**
     * Create Chat Screen (optimized sizes)
     */
    createChatScreen() {
        const chatContainer = document.createElement('div');
        chatContainer.style.cssText = `
            background-color: #f0f2f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 95vw;
            height: 90vh;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        `;

        // Header
        const header = document.createElement('div');
        header.style.cssText = `
            background-color: #128C7E;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        `;
        
        const headerLeft = document.createElement('div');
        headerLeft.style.cssText = `
            display: flex;
            align-items: center;
            gap: 15px;
        `;
        
        const appTitle = document.createElement('h2');
        appTitle.textContent = 'Live Chat';
        appTitle.style.cssText = `
            margin: 0;
            font-size: 24px;
        `;
        headerLeft.appendChild(appTitle);
        
        const connectionStatus = document.createElement('div');
        connectionStatus.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        `;
        
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.style.cssText = `
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #f44336;
        `;
        connectionStatus.appendChild(this.statusIndicator);
        
        const statusText = document.createElement('span');
        statusText.textContent = 'Connecting...';
        statusText.id = 'connectionStatus';
        connectionStatus.appendChild(statusText);
        
        headerLeft.appendChild(connectionStatus);
        header.appendChild(headerLeft);
        
        const userInfo = document.createElement('div');
        userInfo.style.cssText = `
            display: flex;
            align-items: center;
            gap: 10px;
        `;
        
        const userAvatar = document.createElement('div');
        userAvatar.style.cssText = `
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: ${this.isAdmin ? '#f44336' : '#25D366'};
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        `;
        userAvatar.textContent = this.currentUsername.charAt(0).toUpperCase();
        userInfo.appendChild(userAvatar);
        
        const userName = document.createElement('span');
        userName.textContent = this.currentUsername;
        userName.style.cssText = `
            font-weight: bold;
            font-size: 16px;
        `;
        userInfo.appendChild(userName);
        
        const roleBadge = document.createElement('span');
        roleBadge.textContent = this.isAdmin ? 'Admin' : 'User';
        roleBadge.style.cssText = `
            background-color: ${this.isAdmin ? '#f44336' : '#25D366'};
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 5px;
        `;
        userInfo.appendChild(roleBadge);
        
        header.appendChild(userInfo);
        chatContainer.appendChild(header);

        // Main Content
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
            flex: 1;
            display: flex;
            overflow: hidden;
        `;
        
        // Sidebar (reduced size)
        const sidebar = document.createElement('div');
        sidebar.style.cssText = `
            width: 200px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        `;
        
        // Users list
        const usersSection = document.createElement('div');
        usersSection.style.cssText = `
            flex: 1;
            overflow-y: auto;
        `;
        
        const usersTitle = document.createElement('div');
        usersTitle.textContent = 'Online Users';
        usersTitle.style.cssText = `
            padding: 10px 15px;
            font-weight: bold;
            color: #666;
            font-size: 14px;
            background-color: #f0f2f5;
        `;
        usersSection.appendChild(usersTitle);
        
        this.userList = document.createElement('div');
        this.userList.id = 'userList';
        this.userList.style.cssText = `
            overflow-y: auto;
        `;
        usersSection.appendChild(this.userList);
        
        sidebar.appendChild(usersSection);
        mainContent.appendChild(sidebar);
        
        // Chat Area
        const chatArea = document.createElement('div');
        chatArea.style.cssText = `
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #efeae2;
        `;
        
        // Messages Container (larger)
        this.messagesContainer = document.createElement('div');
        this.messagesContainer.style.cssText = `
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        
        // Welcome message
        const welcomeMessage = document.createElement('div');
        welcomeMessage.style.cssText = `
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        `;
        welcomeMessage.textContent = 'Welcome to Live Chat! Start a conversation...';
        this.messagesContainer.appendChild(welcomeMessage);
        
        chatArea.appendChild(this.messagesContainer);
        
        // Typing Indicator
        this.typingIndicator = document.createElement('div');
        this.typingIndicator.style.cssText = `
            padding: 10px 20px;
            color: #666;
            font-size: 14px;
            font-style: italic;
            min-height: 20px;
        `;
        chatArea.appendChild(this.typingIndicator);
        
        // Input Area (larger)
        const inputArea = document.createElement('div');
        inputArea.style.cssText = `
            padding: 15px;
            background-color: #f0f2f5;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
            align-items: center;
        `;
        
        this.messageInput = document.createElement('input');
        this.messageInput.type = 'text';
        this.messageInput.placeholder = 'Type a message...';
        this.messageInput.style.cssText = `
            flex: 1;
            padding: 15px 25px;
            border: 1px solid #ddd;
            border-radius: 25px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
        `;
        this.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        this.messageInput.addEventListener('input', () => {
            this.handleTyping();
        });
        inputArea.appendChild(this.messageInput);
        
        this.sendButton = this.createButton('Send', '#128C7E', () => {
            this.sendMessage();
        });
        this.sendButton.style.cssText = `
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
        `;
        inputArea.appendChild(this.sendButton);
        
        chatArea.appendChild(inputArea);
        mainContent.appendChild(chatArea);
        chatContainer.appendChild(mainContent);
        
        this.gameContainer.appendChild(chatContainer);
        
        // Focus on input
        setTimeout(() => {
            this.messageInput.focus();
        }, 100);
        
        this.updateConnectionStatus(this.isFirebaseInitialized);
    }

    /**
     * Update user list (optimized)
     */
    updateUserList() {
        if (!this.userList) return;
        
        // Use document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        if (this.activeUsers.length === 0) {
            const noUsers = document.createElement('div');
            noUsers.textContent = 'No other users online';
            noUsers.style.cssText = `
                padding: 15px;
                color: #666;
                text-align: center;
                font-style: italic;
            `;
            fragment.appendChild(noUsers);
        } else {
            this.activeUsers.forEach(user => {
                const userItem = document.createElement('div');
                userItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    padding: 10px 12px;
                    cursor: pointer;
                    transition: background-color 0.2s;
                `;
                
                userItem.addEventListener('mouseenter', () => {
                    userItem.style.backgroundColor = '#f0f2f5';
                });
                
                userItem.addEventListener('mouseleave', () => {
                    userItem.style.backgroundColor = 'transparent';
                });
                
                userItem.addEventListener('click', () => {
                    this.startPrivateChat(user);
                });
                
                // User avatar (smaller)
                const avatar = document.createElement('div');
                avatar.style.cssText = `
                    width: 32px;
                    height: 32px;
                    border-radius: 50%;
                    background-color: ${user.role === 'admin' ? '#f44336' : '#128C7E'};
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 14px;
                `;
                avatar.textContent = user.name.charAt(0).toUpperCase();
                userItem.appendChild(avatar);
                
                // User name
                const userName = document.createElement('div');
                userName.textContent = user.name;
                userName.style.cssText = `
                    font-weight: bold;
                    color: #333;
                    font-size: 14px;
                `;
                userItem.appendChild(userName);
                
                // Online indicator
                const onlineIndicator = document.createElement('div');
                onlineIndicator.style.cssText = `
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    background-color: #25D366;
                    border: 2px solid white;
                `;
                userItem.appendChild(onlineIndicator);
                
                // Action buttons
                const actionButtons = document.createElement('div');
                actionButtons.style.cssText = `
                    display: flex;
                    gap: 3px;
                    margin-left: auto;
                `;
                
                // Block button
                const blockButton = this.createButton('🚫', '#f44336', () => {
                    this.toggleBlockUser(user);
                });
                blockButton.style.cssText = `
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    padding: 0;
                    font-size: 12px;
                `;
                blockButton.title = this.blockedUsers.has(user.id) ? 'Unblock User' : 'Block User';
                actionButtons.appendChild(blockButton);
                
                // Delete button (admin only)
                if (this.isAdmin) {
                    const deleteButton = this.createButton('❌', '#f44336', () => {
                        this.deleteUser(user);
                    });
                    deleteButton.style.cssText = `
                        width: 24px;
                        height: 24px;
                        border-radius: 50%;
                        padding: 0;
                        font-size: 12px;
                    `;
                    deleteButton.title = 'Delete User';
                    actionButtons.appendChild(deleteButton);
                }
                
                userItem.appendChild(actionButtons);
                fragment.appendChild(userItem);
            });
        }
        
        // Update the list in one operation
        this.userList.innerHTML = '';
        this.userList.appendChild(fragment);
    }

    /**
     * Toggle block user
     */
    toggleBlockUser(user) {
        if (this.blockedUsers.has(user.id)) {
            this.blockedUsers.delete(user.id);
            this.showNotification(`${user.name} unblocked`);
        } else {
            this.blockedUsers.add(user.id);
            this.showNotification(`${user.name} blocked`);
        }
        this.updateUserList();
    }

    /**
     * Delete user (admin only)
     */
    deleteUser(user) {
        if (!this.isAdmin) {
            this.showNotification('Only admins can delete users');
            return;
        }
        
        if (confirm(`Are you sure you want to delete ${user.name}?`)) {
            this.usersRef.child(user.id).remove().then(() => {
                this.presenceRef.child(user.id).remove();
                this.showNotification(`${user.name} has been deleted`);
            }).catch(error => {
                console.error('Error deleting user:', error);
                this.showNotification('Error deleting user');
            });
        }
    }

    /**
     * Start private chat
     */
    startPrivateChat(user) {
        if (this.blockedUsers.has(user.id)) {
            this.showNotification('You have blocked this user');
            return;
        }
        
        this.currentChatPartner = user;
        this.isPrivateChat = true;
        
        const chatHeader = document.querySelector('header h2');
        if (chatHeader) {
            chatHeader.textContent = `Chat with ${user.name}`;
        }
        
        this.messagesContainer.innerHTML = '';
        this.showNotification(`Now chatting privately with ${user.name}`);
    }

    /**
     * Handle typing indicator (optimized)
     */
    handleTyping() {
        if (!this.isFirebaseInitialized) return;
        
        const isTyping = this.messageInput.value.length > 0;
        
        if (isTyping) {
            this.typingRef.child(this.userSessionId).set({
                username: this.currentUsername,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            
            clearTimeout(this.typingTimeout);
            this.typingTimeout = setTimeout(() => {
                this.typingRef.child(this.userSessionId).remove();
            }, 3000);
        } else {
            this.typingRef.child(this.userSessionId).remove();
        }
    }

    /**
     * Update typing indicators
     */
    updateTypingIndicators(typingData) {
        const typingUsers = [];
        const now = Date.now();
        
        Object.keys(typingData).forEach(userId => {
            if (userId !== this.userSessionId) {
                const user = typingData[userId];
                if (now - user.timestamp < 3000) {
                    typingUsers.push(user.username);
                }
            }
        });
        
        this.typingIndicator.textContent = typingUsers.length > 0 ? 
            `${typingUsers.join(', ')} is typing...` : '';
    }

    /**
     * Send message (optimized)
     */
    sendMessage() {
        const messageText = this.messageInput.value.trim();
        if (!messageText) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            text: messageText,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            type: this.isPrivateChat ? 'private' : 'group'
        };
        
        if (this.isPrivateChat && this.currentChatPartner) {
            message.receiverId = this.currentChatPartner.id;
        }
        
        // Use push with key tracking
        const newMessageRef = this.messagesRef.push();
        this.lastMessageId = newMessageRef.key;
        newMessageRef.set(message);
        
        // Clear input
        this.messageInput.value = '';
        this.typingRef.child(this.userSessionId).remove();
        
        // Display immediately for better UX
        this.displayMessage(message);
    }

    /**
     * Display message (optimized)
     */
    displayMessage(message) {
        const isOwnMessage = message.senderId === this.userSessionId;
        
        const messageContainer = document.createElement('div');
        messageContainer.style.cssText = `
            display: flex;
            ${isOwnMessage ? 'justify-content: flex-end' : 'justify-content: flex-start'}
            margin-bottom: 8px;
        `;
        
        const messageBubble = document.createElement('div');
        messageBubble.style.cssText = `
            max-width: 70%;
            padding: 10px 15px;
            border-radius: 18px;
            background-color: ${isOwnMessage ? '#dcf8c6' : '#fff'};
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
        `;
        
        // Sender name
        if (!isOwnMessage && (message.type === 'group' || this.isPrivateChat)) {
            const senderName = document.createElement('div');
            senderName.textContent = message.senderName;
            senderName.style.cssText = `
                font-weight: bold;
                font-size: 12px;
                color: #128C7E;
                margin-bottom: 4px;
            `;
            messageBubble.appendChild(senderName);
        }
        
        // Message text
        const messageText = document.createElement('div');
        messageText.textContent = message.text;
        messageText.style.cssText = `
            word-wrap: break-word;
            font-size: 15px;
        `;
        messageBubble.appendChild(messageText);
        
        // Timestamp
        const timestamp = document.createElement('div');
        timestamp.textContent = this.formatTimestamp(message.timestamp);
        timestamp.style.cssText = `
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            text-align: ${isOwnMessage ? 'right' : 'left'};
        `;
        messageBubble.appendChild(timestamp);
        
        messageContainer.appendChild(messageBubble);
        
        // Remove welcome message if exists
        if (this.messagesContainer.firstChild && this.messagesContainer.firstChild.textContent.includes('Welcome')) {
            this.messagesContainer.innerHTML = '';
        }
        
        this.messagesContainer.appendChild(messageContainer);
        
        // Auto-scroll to bottom
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }

    /**
     * Format timestamp
     */
    formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        return `${hours}:${minutes}`;
    }

    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            z-index: 10000;
            animation: slideDown 0.3s ease;
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 20px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 16px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }

    /**
     * Set up action buttons
     */
    setupActionButtons() {
        const existingButtons = document.querySelector('.floating-buttons');
        if (existingButtons) {
            existingButtons.remove();
        }
        
        const floatingButtons = document.createElement('div');
        floatingButtons.className = 'floating-buttons';
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10001;
        `;

        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);

        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        
        if (this.gameContainer) {
            this.gameContainer.appendChild(floatingButtons);
        } else {
            document.body.appendChild(floatingButtons);
        }
    }

    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }

    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }

    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }

    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }

    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }

    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        if (this.isFirebaseInitialized) {
            this.usersRef.child(this.userSessionId).remove();
            this.presenceRef.child(this.userSessionId).remove();
            this.typingRef.child(this.userSessionId).remove();
        }
        
        this.removeFirebaseListeners();
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        const floatingButtons = document.querySelector('.floating-buttons');
        if (floatingButtons) {
            floatingButtons.remove();
        }
        
        this.gameContainer = null;
        this.messagesContainer = null;
        this.messageInput = null;
        this.sendButton = null;
        this.userList = null;
        this.statusDiv = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Live Chat App closed. Thank you!");
    }

    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}

// Create a singleton instance
const chatLiveScreenLoader = new ChatLiveScreenLoader();

// Add this to your AI's command handling
if (/chat app|live chat|whatsapp|messenger|chat room/i.test(userInputRaw)) {
    chatLiveScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    chatLiveScreenLoader.closeGame();
    return;
}

class TicTacToeGame {
    constructor() {
        this.baseScreen = {
            name: 'TIC TAC TOE',
            instructions: 'Real-time two-player game. Play with anyone online!'
        };
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.currentUsername = '';
        this.userSessionId = this.generateSessionId();
        this.firebaseConfig = {
            apiKey: "AIzaSyANmru4_kH0eDNgDFURF5aZTaiPgaQ4avU",
            projectId: "vipteammod-movies",
            appId: "1:1024721077525:android:c25e4ab10ec8e4166ad51c",
            databaseURL: "https://vipteammod-movies-default-rtdb.firebaseio.com"
        };
        this.db = null;
        this.gameRef = null;
        this.playersRef = null;
        this.connectedRef = null;
        this.messagesRef = null;
        this.isFirebaseInitialized = false;
        this.currentGame = null;
        this.gameListener = null;
        this.playersListener = null;
        this.messagesListener = null;
        this.board = Array(9).fill('');
        this.currentPlayer = 'X';
        this.gameActive = false;
        this.playerSymbol = null;
        this.opponentSymbol = null;
        this.playerNumber = null;
        this.availableGames = [];
        this.gameScreenCreated = false;
        this.player1Online = true;
        this.player2Online = true;
        this.emojis = ['😀', '😂', '😍', '🤔', '😎', '👍', '👎', '🔥', '💯', '🎉'];
        this.messageInput = null;
        this.emojiPanel = null;
        this.messagesContainer = null;
        this.connectionChecked = false;
        this.messageConnectionChecked = false;
        this.emojiConnectionChecked = false;
        
        // Neon color scheme
        this.colors = {
            primary: '#00f2fe',      // Cyan - for primary elements
            secondary: '#ff00cc',    // Pink - for secondary elements
            accent: '#fffc00',       // Yellow - for accents
            dark: '#0a0a27',         // Dark blue - for backgrounds
            light: '#ffffff',        // White - for text
            playerX: '#00f2fe',      // Cyan for X
            playerO: '#ff00cc',      // Pink for O
            success: '#4ade80',      // Green for success
            warning: '#fbbf24',      // Yellow for warnings
            error: '#9ca3af'        // Gray for errors
        };
    }
    /**
     * Generate a unique session ID for this user
     */
    generateSessionId() {
        return 'player_' + Math.random().toString(36).substr(2, 9);
    }
    /**
     * Load the Tic Tac Toe Game
     */
    loadBaseScreen() {
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        this.createGameContainer();
        this.createLoginScreen();
        this.setupActionButtons();
        this.displayGame();
        this.isActive = true;
        this.initializeFirebase();
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }
    /**
     * Initialize Firebase
     */
    initializeFirebase() {
        if (typeof firebase === 'undefined') {
            this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js', () => {
                this.loadScript('https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js', () => {
                    this.setupFirebase();
                });
            });
        } else {
            this.setupFirebase();
        }
    }
    /**
     * Setup Firebase
     */
    setupFirebase() {
        try {
            if (firebase.apps.length === 0) {
                firebase.initializeApp(this.firebaseConfig);
            }
            
            this.db = firebase.database();
            
            // References
            this.gameRef = this.db.ref('tictactoe/games');
            this.playersRef = this.db.ref('tictactoe/players');
            this.messagesRef = this.db.ref('tictactoe/messages');
            this.connectedRef = this.db.ref('.info/connected');
            
            // Setup connection monitoring
            this.connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    this.setupFirebaseListeners();
                    this.loadAvailableGames();
                }
            });
            
            this.isFirebaseInitialized = true;
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
    }
    /**
     * Setup Firebase listeners
     */
    setupFirebaseListeners() {
        // Listen for available games
        this.playersRef = this.db.ref('tictactoe/players');
        this.playersListener = this.playersRef.on('value', (snapshot) => {
            const players = snapshot.val();
            if (players) {
                this.updateAvailableGames(players);
                this.checkPlayerOnlineStatus(players);
                
                // One-time connection check for all players
                if (!this.connectionChecked && this.currentGame) {
                    this.checkAllConnections(players);
                    this.connectionChecked = true;
                }
            }
        });
    }
    
    /**
     * Check all connections in the game
     */
    checkAllConnections(players) {
        if (!this.currentGame) return;
        
        // Check if both players are connected
        const player1Connected = !!players[this.currentGame.player1];
        const player2Connected = !!players[this.currentGame.player2];
        
        if (player1Connected && player2Connected) {
            this.showNotification('Both players are connected! Game ready to play.');
        } else if (!player1Connected && this.currentGame.player1) {
            this.showNotification('Player 1 has disconnected.');
        } else if (!player2Connected && this.currentGame.player2) {
            this.showNotification('Player 2 has disconnected.');
        }
        
        // Check message connection
        if (!this.messageConnectionChecked) {
            this.checkMessageConnection();
            this.messageConnectionChecked = true;
        }
        
        // Check emoji connection
        if (!this.emojiConnectionChecked) {
            this.checkEmojiConnection();
            this.emojiConnectionChecked = true;
        }
    }
    
    /**
     * Check message connection
     */
    checkMessageConnection() {
        if (!this.currentGame) return;
        
        // Create a test message
        const testMessage = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: "Connection test",
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isTest: true
        };
        
        this.messagesRef.child(this.currentGame.id).push(testMessage)
            .then(() => {
                this.showNotification('Message connection established successfully!');
                // Remove the test message
                this.messagesRef.child(this.currentGame.id).once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const message = childSnapshot.val();
                        if (message.isTest) {
                            this.messagesRef.child(this.currentGame.id).child(childSnapshot.key).remove();
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Message connection error:', error);
                this.showNotification('Message connection failed. Please try again.');
            });
    }
    
    /**
     * Check emoji connection
     */
    checkEmojiConnection() {
        if (!this.currentGame) return;
        
        // Create a test emoji
        const testEmoji = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: "🔗",
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            isTest: true
        };
        
        this.messagesRef.child(this.currentGame.id).push(testEmoji)
            .then(() => {
                this.showNotification('Emoji connection established successfully!');
                // Remove the test emoji
                this.messagesRef.child(this.currentGame.id).once('value', (snapshot) => {
                    snapshot.forEach((childSnapshot) => {
                        const message = childSnapshot.val();
                        if (message.isTest) {
                            this.messagesRef.child(this.currentGame.id).child(childSnapshot.key).remove();
                        }
                    });
                });
            })
            .catch(error => {
                console.error('Emoji connection error:', error);
                this.showNotification('Emoji connection failed. Please try again.');
            });
    }
    
    /**
     * Check player online status
     */
    checkPlayerOnlineStatus(players) {
        if (!this.currentGame || !this.gameScreenCreated) return;
        
        // Check if player 1 is online
        this.player1Online = !!(players[this.currentGame.player1]);
        
        // Check if player 2 is online
        this.player2Online = !!(players[this.currentGame.player2]);
        
        // Update the game screen with online status
        this.updatePlayerOnlineStatus();
    }
    
    /**
     * Update player online status in UI
     */
    updatePlayerOnlineStatus() {
        if (!this.gameContainer || !this.currentGame) return;
        
        const player1Info = this.gameContainer.querySelector('.player1-info');
        const player2Info = this.gameContainer.querySelector('.player2-info');
        
        if (player1Info) {
            const statusIndicator = player1Info.querySelector('.status-indicator') || 
                                   document.createElement('span');
            statusIndicator.className = 'status-indicator';
            statusIndicator.style.cssText = `
                display: inline-block;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-left: 5px;
                background-color: ${this.player1Online ? this.colors.success : this.colors.error};
                box-shadow: 0 0 8px ${this.player1Online ? this.colors.success : this.colors.error};
            `;
            
            if (!player1Info.contains(statusIndicator)) {
                player1Info.appendChild(statusIndicator);
            }
        }
        
        if (player2Info) {
            const statusIndicator = player2Info.querySelector('.status-indicator') || 
                                   document.createElement('span');
            statusIndicator.className = 'status-indicator';
            statusIndicator.style.cssText = `
                display: inline-block;
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-left: 5px;
                background-color: ${this.player2Online ? this.colors.success : this.colors.error};
                box-shadow: 0 0 8px ${this.player2Online ? this.colors.success : this.colors.error};
            `;
            
            if (!player2Info.contains(statusIndicator)) {
                player2Info.appendChild(statusIndicator);
            }
        }
        
        // Show notification if opponent is offline
        if ((this.playerNumber === 1 && !this.player2Online) || 
            (this.playerNumber === 2 && !this.player1Online)) {
            this.showNotification('Your opponent is offline');
        }
    }
    /**
     * Create the game container
     */
    createGameContainer() {
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, ${this.colors.dark}, #1a1a3e, ${this.colors.dark});
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        `;
        
        // Add CSS animation for background gradient
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes gradientBG {
                0% { background-position: 0% 50%; }
                50% { background-position: 100% 50%; }
                100% { background-position: 0% 50%; }
            }
            
            .neon-glow {
                box-shadow: 0 0 10px ${this.colors.primary}, 0 0 20px ${this.colors.primary}, 0 0 30px ${this.colors.primary};
                transition: all 0.3s ease;
            }
            
            .neon-glow:hover {
                box-shadow: 0 0 15px ${this.colors.primary}, 0 0 25px ${this.colors.primary}, 0 0 35px ${this.colors.primary};
            }
            
            .neon-glow-pink {
                box-shadow: 0 0 10px ${this.colors.secondary}, 0 0 20px ${this.colors.secondary}, 0 0 30px ${this.colors.secondary};
                transition: all 0.3s ease;
            }
            
            .neon-glow-pink:hover {
                box-shadow: 0 0 15px ${this.colors.secondary}, 0 0 25px ${this.colors.secondary}, 0 0 35px ${this.colors.secondary};
            }
            
            .neon-glow-yellow {
                box-shadow: 0 0 10px ${this.colors.accent}, 0 0 20px ${this.colors.accent}, 0 0 30px ${this.colors.accent};
                transition: all 0.3s ease;
            }
            
            .neon-glow-yellow:hover {
                box-shadow: 0 0 15px ${this.colors.accent}, 0 0 25px ${this.colors.accent}, 0 0 35px ${this.colors.accent};
            }
            
            .game-cell {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(5px);
                border: 2px solid rgba(255, 255, 255, 0.1);
                border-radius: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 48px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }
            
            .game-cell::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
                opacity: 0;
                transition: opacity 0.3s ease;
            }
            
            .game-cell:hover::before {
                opacity: 1;
            }
            
            .game-cell:hover {
                background: rgba(255, 255, 255, 0.1);
                transform: scale(1.05);
            }
            
            .game-cell.x-player {
                color: ${this.colors.playerX};
                text-shadow: 0 0 10px ${this.colors.playerX}, 0 0 20px ${this.colors.playerX};
            }
            
            .game-cell.o-player {
                color: ${this.colors.playerO};
                text-shadow: 0 0 10px ${this.colors.playerO}, 0 0 20px ${this.colors.playerO};
            }
            
            .message-bubble {
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                border-radius: 20px;
                padding: 10px 15px;
                margin: 5px 0;
                max-width: 80%;
                word-wrap: break-word;
                animation: fadeIn 0.3s ease;
                position: relative;
            }
            
            .message-bubble.player-message {
                background: rgba(0, 242, 254, 0.2);
                border: 1px solid rgba(0, 242, 254, 0.5);
                align-self: flex-end;
                border-bottom-right-radius: 5px;
            }
            
            .message-bubble.opponent-message {
                background: rgba(255, 0, 204, 0.2);
                border: 1px solid rgba(255, 0, 204, 0.5);
                align-self: flex-start;
                border-bottom-left-radius: 5px;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .emoji-btn {
                background: none;
                border: none;
                font-size: 20px;
                cursor: pointer;
                padding: 5px;
                border-radius: 50%;
                transition: all 0.2s ease;
            }
            
            .emoji-btn:hover {
                background: rgba(255, 255, 255, 0.2);
                transform: scale(1.2);
            }
            
            .neon-text {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.primary}, 0 0 10px ${this.colors.primary};
            }
            
            .neon-text-pink {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.secondary}, 0 0 10px ${this.colors.secondary};
            }
            
            .neon-text-yellow {
                color: ${this.colors.light};
                text-shadow: 0 0 5px ${this.colors.accent}, 0 0 10px ${this.colors.accent};
            }
        `;
        document.head.appendChild(style);
    }
    /**
     * Create Login Screen
     */
    createLoginScreen() {
        const loginContainer = document.createElement('div');
        loginContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 40px;
            width: 400px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        loginContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Tic Tac Toe';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 36px;
            letter-spacing: 2px;
        `;
        loginContainer.appendChild(title);
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Enter your name to play';
        subtitle.style.cssText = `
            margin: 0 0 30px 0;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
        `;
        loginContainer.appendChild(subtitle);
        const inputContainer = document.createElement('div');
        inputContainer.style.cssText = `
            margin-bottom: 25px;
        `;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = 'Enter your name';
        input.style.cssText = `
            width: 100%;
            padding: 15px 20px;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            box-sizing: border-box;
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            color: ${this.colors.light};
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        // Add placeholder styling
        input.addEventListener('focus', () => {
            input.style.boxShadow = `0 0 15px ${this.colors.primary}`;
            input.style.borderColor = this.colors.primary;
        });
        
        input.addEventListener('blur', () => {
            input.style.boxShadow = 'none';
            input.style.borderColor = 'transparent';
        });
        
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.handleLogin(input.value);
            }
        });
        inputContainer.appendChild(input);
        loginContainer.appendChild(inputContainer);
        const loginButton = this.createButton('Play Game', this.colors.primary, () => {
            this.handleLogin(input.value);
        });
        loginButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 1px;
            background: linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary});
        `;
        loginContainer.appendChild(loginButton);
        this.gameContainer.appendChild(loginContainer);
    }
    /**
     * Handle Login
     */
    handleLogin(username) {
        if (!username.trim()) {
            this.showNotification('Please enter your name');
            return;
        }
        this.currentUsername = username.trim();
        this.gameContainer.innerHTML = '';
        this.createGameLobby();
    }
    /**
     * Create Game Lobby
     */
    createGameLobby() {
        const lobbyContainer = document.createElement('div');
        lobbyContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 30px;
            width: 600px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        lobbyContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Game Lobby';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 32px;
            letter-spacing: 2px;
        `;
        lobbyContainer.appendChild(title);
        const userInfo = document.createElement('div');
        userInfo.style.cssText = `
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            color: ${this.colors.light};
            font-size: 18px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        userInfo.textContent = `Welcome, ${this.currentUsername}!`;
        lobbyContainer.appendChild(userInfo);
        // Game options
        const optionsContainer = document.createElement('div');
        optionsContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 25px;
        `;
        const newGameButton = this.createButton('Create New Game', this.colors.primary, () => {
            this.createNewGame();
        });
        newGameButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary});
        `;
        optionsContainer.appendChild(newGameButton);
        const joinGameButton = this.createButton('Join Random Game', this.colors.secondary, () => {
            this.joinRandomGame();
        });
        joinGameButton.style.cssText = `
            width: 100%;
            padding: 15px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, ${this.colors.secondary}, ${this.colors.primary});
        `;
        optionsContainer.appendChild(joinGameButton);
        lobbyContainer.appendChild(optionsContainer);
        // Available games list
        const gamesSection = document.createElement('div');
        gamesSection.style.cssText = `
            margin-top: 20px;
        `;
        
        const gamesTitle = document.createElement('h3');
        gamesTitle.textContent = 'Available Games';
        gamesTitle.className = 'neon-text';
        gamesTitle.style.cssText = `
            margin: 0 0 15px 0;
            font-size: 22px;
            letter-spacing: 1px;
        `;
        gamesSection.appendChild(gamesTitle);
        this.gamesList = document.createElement('div');
        this.gamesList.style.cssText = `
            max-height: 250px;
            overflow-y: auto;
            text-align: left;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        this.gamesList.textContent = 'Loading available games...';
        gamesSection.appendChild(this.gamesList);
        lobbyContainer.appendChild(gamesSection);
        this.gameContainer.appendChild(lobbyContainer);
    }
    /**
     * Load available games
     */
    loadAvailableGames() {
        // First get all games from the games reference
        this.gameRef.once('value').then((snapshot) => {
            const games = snapshot.val();
            if (games) {
                // Then get all players to check who is online
                this.playersRef.once('value').then((playersSnapshot) => {
                    const players = playersSnapshot.val();
                    this.updateAvailableGamesWithGames(games, players);
                });
            } else {
                this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            }
        });
    }
    
    /**
     * Update available games list with games data
     */
    updateAvailableGamesWithGames(games, players) {
        if (!this.gamesList) return;
        
        this.gamesList.innerHTML = '';
        
        // Convert games object to array
        const gamesArray = Object.entries(games).map(([gameId, game]) => ({
            id: gameId,
            ...game
        }));
        
        if (gamesArray.length === 0) {
            this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            return;
        }
        
        gamesArray.forEach(game => {
            const gameItem = document.createElement('div');
            gameItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;
            
            gameItem.addEventListener('mouseenter', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                gameItem.style.boxShadow = `0 0 10px ${this.colors.primary}`;
            });
            
            gameItem.addEventListener('mouseleave', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                gameItem.style.boxShadow = 'none';
            });
            
            // Get player info
            const player1Name = game.player1Name || 'Player 1';
            const player2Name = game.player2Name || (game.status === 'waiting' ? 'Waiting for opponent' : 'Player 2');
            
            const gameInfo = document.createElement('div');
            gameInfo.innerHTML = `
                <div style="font-weight: bold; color: ${this.colors.light}; font-size: 16px;">
                    ${player1Name} ${player.player2Name ? 'vs' : 'vs'} ${player2Name}
                </div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">
                    ${game.status === 'waiting' ? 'Waiting for opponent' : 'Game in progress'}
                </div>
            `;
            gameItem.appendChild(gameInfo);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '8px';
            
            // Show Join button only for waiting games
            if (game.status === 'waiting') {
                const joinButton = this.createButton('Join', this.colors.success, () => {
                    this.joinGame(game.id);
                });
                joinButton.style.cssText = `
                    padding: 6px 12px;
                    font-size: 14px;
                    border-radius: 20px;
                `;
                buttonContainer.appendChild(joinButton);
            }
            
            // Add delete button for all games
            const deleteButton = this.createButton('Delete', this.colors.error, () => {
                this.deleteGame(game.id);
            });
            deleteButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(deleteButton);
            
            gameItem.appendChild(buttonContainer);
            this.gamesList.appendChild(gameItem);
        });
    }
    
    /**
     * Update available games list (fallback method for players data)
     */
    updateAvailableGames(players) {
        if (!this.gamesList) return;
        const waitingPlayers = Object.values(players).filter(p => p.status === 'waiting');
        
        if (waitingPlayers.length === 0) {
            this.gamesList.innerHTML = '<div style="color: rgba(255,255,255,0.7); text-align: center; padding: 15px;">No available games. Create a new game!</div>';
            return;
        }
        this.gamesList.innerHTML = '';
        
        waitingPlayers.forEach(player => {
            const gameItem = document.createElement('div');
            gameItem.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                cursor: pointer;
                transition: all 0.3s ease;
                border: 1px solid rgba(255, 255, 255, 0.1);
            `;
            
            gameItem.addEventListener('mouseenter', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                gameItem.style.boxShadow = `0 0 10px ${this.colors.primary}`;
            });
            
            gameItem.addEventListener('mouseleave', () => {
                gameItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                gameItem.style.boxShadow = 'none';
            });
            
            const playerInfo = document.createElement('div');
            playerInfo.innerHTML = `
                <div style="font-weight: bold; color: ${this.colors.light}; font-size: 16px;">${player.name}</div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">Waiting for opponent</div>
            `;
            gameItem.appendChild(playerInfo);
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '8px';
            
            const joinButton = this.createButton('Join', this.colors.success, () => {
                this.joinGame(player.gameId);
            });
            joinButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(joinButton);
            
            // Add delete button for all games
            const deleteButton = this.createButton('Delete', this.colors.error, () => {
                this.deleteGame(player.gameId);
            });
            deleteButton.style.cssText = `
                padding: 6px 12px;
                font-size: 14px;
                border-radius: 20px;
            `;
            buttonContainer.appendChild(deleteButton);
            
            gameItem.appendChild(buttonContainer);
            this.gamesList.appendChild(gameItem);
        });
    }
    
    /**
     * Delete a game
     */
    deleteGame(gameId) {
        if (confirm('Are you sure you want to delete this game? This action cannot be undone.')) {
            // Remove game from Firebase
            this.gameRef.child(gameId).remove()
                .then(() => {
                    // Remove all players associated with this game
                    this.playersRef.once('value').then((snapshot) => {
                        const players = snapshot.val();
                        if (players) {
                            Object.entries(players).forEach(([playerId, player]) => {
                                if (player.gameId === gameId) {
                                    this.playersRef.child(playerId).remove();
                                }
                            });
                        }
                    })
                    .then(() => {
                        this.showNotification('Game deleted successfully');
                        // Refresh the games list
                        this.loadAvailableGames();
                    })
                    .catch(error => {
                        console.error('Error removing players:', error);
                        this.showNotification('Error deleting game');
                    });
                })
                .catch(error => {
                    console.error('Error deleting game:', error);
                    this.showNotification('Error deleting game');
                });
        }
    }
    /**
     * Create new game
     */
    createNewGame() {
        const gameId = 'game_' + Date.now();
        
        // Create player entry
        const playerData = {
            id: this.userSessionId,
            name: this.currentUsername,
            gameId: gameId,
            status: 'waiting',
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.playersRef.child(this.userSessionId).set(playerData).then(() => {
            this.currentGame = {
                id: gameId,
                board: Array(9).fill(''),
                currentPlayer: 'X',
                status: 'waiting',
                player1: this.userSessionId,
                player1Name: this.currentUsername,
                player2: null,
                player2Name: null,
                winner: null,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };
            
            this.gameRef.child(gameId).set(this.currentGame).then(() => {
                this.setupGameListener(gameId);
                this.showNotification('Game created! Waiting for opponent...');
            });
        });
    }
    /**
     * Join random game
     */
    joinRandomGame() {
        this.playersRef.once('value').then((snapshot) => {
            const players = snapshot.val();
            if (players) {
                const waitingPlayers = Object.values(players).filter(p => p.status === 'waiting');
                if (waitingPlayers.length > 0) {
                    const randomPlayer = waitingPlayers[Math.floor(Math.random() * waitingPlayers.length)];
                    this.joinGame(randomPlayer.gameId);
                } else {
                    this.showNotification('No available games. Create a new game!');
                }
            }
        });
    }
    /**
     * Join specific game
     */
    joinGame(gameId) {
        // Get game data
        this.gameRef.child(gameId).once('value').then((snapshot) => {
            const game = snapshot.val();
            if (game && game.status === 'waiting') {
                // Update game with player 2
                const updates = {
                    status: 'playing',
                    player2: this.userSessionId,
                    player2Name: this.currentUsername
                };
                
                this.gameRef.child(gameId).update(updates).then(() => {
                    // Update player status
                    this.playersRef.child(this.userSessionId).set({
                        id: this.userSessionId,
                        name: this.currentUsername,
                        gameId: gameId,
                        status: 'playing',
                        timestamp: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    // Set up game listener
                    this.setupGameListener(gameId);
                    
                    // Set local game state
                    this.currentGame = { ...game, ...updates };
                    this.playerSymbol = 'O';
                    this.opponentSymbol = 'X';
                    this.playerNumber = 2;
                    this.gameActive = true;
                    this.gameScreenCreated = false;
                    
                    // Create game screen
                    this.createGameScreen();
                });
            } else {
                this.showNotification('Game is no longer available');
            }
        });
    }
    /**
     * Setup game listener
     */
    setupGameListener(gameId) {
        // Remove existing listener if any
        if (this.gameListener) {
            this.gameRef.child(gameId).off('value', this.gameListener);
        }
        
        this.gameListener = this.gameRef.child(gameId).on('value', (snapshot) => {
            const game = snapshot.val();
            if (game) {
                this.currentGame = game;
                
                // Check if game is ready to play (both players connected)
                if (game.status === 'playing' && game.player1 && game.player2) {
                    this.gameActive = true;
                    
                    // Set player symbols if not already set
                    if (!this.playerSymbol) {
                        if (game.player1 === this.userSessionId) {
                            this.playerSymbol = 'X';
                            this.opponentSymbol = 'O';
                            this.playerNumber = 1;
                        } else if (game.player2 === this.userSessionId) {
                            this.playerSymbol = 'O';
                            this.opponentSymbol = 'X';
                            this.playerNumber = 2;
                        }
                    }
                    
                    // Create game screen if not already created
                    if (!this.gameScreenCreated) {
                        this.gameScreenCreated = true;
                        this.createGameScreen();
                    } else {
                        // Always update the game screen when data changes
                        this.updateGameScreen();
                    }
                }
                
                // Check for draw condition and update both players
                if (game.status === 'finished' && game.winner === 'draw') {
                    this.updateGameScreen();
                }
            }
        });
        
        // Setup messages listener
        this.setupMessagesListener(gameId);
    }
    
    /**
     * Setup messages listener
     */
    setupMessagesListener(gameId) {
        // Remove existing listener if any
        if (this.messagesListener) {
            this.messagesRef.child(gameId).off('child_added', this.messagesListener);
        }
        
        this.messagesListener = this.messagesRef.child(gameId).limitToLast(20).on('child_added', (snapshot) => {
            const message = snapshot.val();
            if (this.messagesContainer) {
                this.displayMessage(message);
            }
        });
    }
    
    /**
     * Display a message in the messages container
     */
    displayMessage(message) {
        if (!this.messagesContainer) return;
        
        // Skip test messages
        if (message.isTest) return;
        
        const messageElement = document.createElement('div');
        messageElement.className = 'message-bubble';
        
        // Style based on who sent the message
        if (message.senderId === this.userSessionId) {
            messageElement.classList.add('player-message');
        } else {
            messageElement.classList.add('opponent-message');
        }
        
        // Add sender name for opponent messages
        if (message.senderId !== this.userSessionId) {
            const senderName = document.createElement('div');
            senderName.textContent = message.senderName;
            senderName.style.cssText = `
                font-weight: bold;
                margin-bottom: 5px;
                color: ${this.colors.light};
                font-size: 14px;
            `;
            messageElement.appendChild(senderName);
        }
        
        // Add message content
        const content = document.createElement('div');
        content.textContent = message.content;
        content.style.cssText = `
            color: ${this.colors.light};
            font-size: 16px;
        `;
        messageElement.appendChild(content);
        
        // Add timestamp
        const timestamp = document.createElement('div');
        timestamp.textContent = new Date(message.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        timestamp.style.cssText = `
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 5px;
            text-align: right;
        `;
        messageElement.appendChild(timestamp);
        
        this.messagesContainer.appendChild(messageElement);
        
        // Scroll to bottom
        this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        
        // Add animation effect
        messageElement.style.animation = 'fadeIn 0.3s ease';
        
        // Add glow effect for emojis
        if (this.emojis.includes(message.content)) {
            content.style.fontSize = '24px';
            content.style.textAlign = 'center';
            
            if (message.senderId === this.userSessionId) {
                content.style.textShadow = `0 0 10px ${this.colors.primary}, 0 0 20px ${this.colors.primary}`;
            } else {
                content.style.textShadow = `0 0 10px ${this.colors.secondary}, 0 0 20px ${this.colors.secondary}`;
            }
        }
    }
    
    /**
     * Send a message
     */
    sendMessage() {
        if (!this.messageInput || !this.currentGame) return;
        
        const content = this.messageInput.value.trim();
        if (!content) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: content,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.messagesRef.child(this.currentGame.id).push(message)
            .then(() => {
                this.messageInput.value = '';
            })
            .catch(error => {
                console.error('Error sending message:', error);
                this.showNotification('Error sending message');
            });
    }
    
    /**
     * Send an emoji
     */
    sendEmoji(emoji) {
        if (!this.currentGame) return;
        
        const message = {
            senderId: this.userSessionId,
            senderName: this.currentUsername,
            content: emoji,
            timestamp: firebase.database.ServerValue.TIMESTAMP
        };
        
        this.messagesRef.child(this.currentGame.id).push(message)
            .catch(error => {
                console.error('Error sending emoji:', error);
                this.showNotification('Error sending emoji');
            });
    }
    
    /**
     * Create emoji panel
     */
    createEmojiPanel() {
        this.emojiPanel = document.createElement('div');
        this.emojiPanel.style.cssText = `
            position: absolute;
            bottom: 60px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        `;
        
        this.emojis.forEach(emoji => {
            const emojiButton = document.createElement('button');
            emojiButton.className = 'emoji-btn';
            emojiButton.textContent = emoji;
            emojiButton.addEventListener('click', () => {
                this.sendEmoji(emoji);
                this.toggleEmojiPanel();
            });
            this.emojiPanel.appendChild(emojiButton);
        });
        
        // Initially hide the panel
        this.emojiPanel.style.display = 'none';
        
        return this.emojiPanel;
    }
    
    /**
     * Toggle emoji panel visibility
     */
    toggleEmojiPanel() {
        if (!this.emojiPanel) return;
        
        if (this.emojiPanel.style.display === 'none') {
            this.emojiPanel.style.display = 'grid';
        } else {
            this.emojiPanel.style.display = 'none';
        }
    }
    /**
     * Create Game Screen
     */
    createGameScreen() {
        if (!this.currentGame) return;
        
        // Clear the game container
        this.gameContainer.innerHTML = '';
        
        const gameContainer = document.createElement('div');
        gameContainer.className = 'game-board';
        gameContainer.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            padding: 30px;
            width: 550px;
            max-width: 90vw;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        `;
        
        // Add neon border effect
        const neonBorder = document.createElement('div');
        neonBorder.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 20px;
            border: 2px solid transparent;
            background: linear-gradient(${this.colors.dark}, ${this.colors.dark}) padding-box, 
                        linear-gradient(45deg, ${this.colors.primary}, ${this.colors.secondary}) border-box;
            z-index: -1;
        `;
        gameContainer.appendChild(neonBorder);
        
        const title = document.createElement('h2');
        title.textContent = 'Tic Tac Toe';
        title.className = 'neon-text';
        title.style.cssText = `
            margin: 0 0 20px 0;
            font-size: 36px;
            letter-spacing: 2px;
        `;
        gameContainer.appendChild(title);
        // Game info
        const gameInfo = document.createElement('div');
        gameInfo.style.cssText = `
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        const player1Info = document.createElement('div');
        player1Info.className = 'player1-info';
        player1Info.innerHTML = `
            <div style="font-weight: bold; color: ${this.colors.playerX}; font-size: 18px;">Player 1 (X)</div>
            <div style="color: ${this.colors.light}; font-size: 16px;">${this.currentGame.player1Name || 'Player 1'}</div>
        `;
        gameInfo.appendChild(player1Info);
        
        const vsText = document.createElement('div');
        vsText.textContent = 'VS';
        vsText.className = 'neon-text-yellow';
        vsText.style.cssText = `
            font-weight: bold;
            display: flex;
            align-items: center;
            font-size: 20px;
        `;
        gameInfo.appendChild(vsText);
        
        const player2Info = document.createElement('div');
        player2Info.className = 'player2-info';
        player2Info.innerHTML = `
            <div style="font-weight: bold; color: ${this.colors.playerO}; font-size: 18px;">Player 2 (O)</div>
            <div style="color: ${this.colors.light}; font-size: 16px;">${this.currentGame.player2Name || 'Waiting...'}</div>
        `;
        gameInfo.appendChild(player2Info);
        
        gameContainer.appendChild(gameInfo);
        
        // Game board
        this.boardContainer = document.createElement('div');
        this.boardContainer.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 20px auto;
            width: 300px;
            height: 300px;
        `;
        
        for (let i = 0; i < 9; i++) {
            const cell = document.createElement('div');
            cell.className = 'game-cell';
            cell.dataset.index = i;
            
            // Set initial cell content if needed
            if (this.currentGame.board[i]) {
                cell.textContent = this.currentGame.board[i];
                if (this.currentGame.board[i] === 'X') {
                    cell.classList.add('x-player');
                } else {
                    cell.classList.add('o-player');
                }
            }
            
            cell.addEventListener('click', () => {
                this.makeMove(i);
            });
            
            this.boardContainer.appendChild(cell);
        }
        
        gameContainer.appendChild(this.boardContainer);
        
        // Game status
        this.gameStatus = document.createElement('div');
        this.gameStatus.className = 'neon-text-yellow';
        this.gameStatus.style.cssText = `
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            min-height: 30px;
        `;
        gameContainer.appendChild(this.gameStatus);
        
        // Messages container
        const messagesSection = document.createElement('div');
        messagesSection.style.cssText = `
            margin-top: 20px;
            display: flex;
            flex-direction: column;
        `;
        
        const messagesTitle = document.createElement('h3');
        messagesTitle.textContent = 'Chat';
        messagesTitle.className = 'neon-text';
        messagesTitle.style.cssText = `
            margin: 0 0 10px 0;
            font-size: 18px;
            text-align: left;
        `;
        messagesSection.appendChild(messagesTitle);
        
        this.messagesContainer = document.createElement('div');
        this.messagesContainer.style.cssText = `
            height: 120px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        messagesSection.appendChild(this.messagesContainer);
        
        // Message input container
        const messageInputContainer = document.createElement('div');
        messageInputContainer.style.cssText = `
            position: relative;
            display: flex;
            align-items: center;
        `;
        
        this.messageInput = document.createElement('input');
        this.messageInput.type = 'text';
        this.messageInput.placeholder = 'Type a message...';
        this.messageInput.style.cssText = `
            flex: 1;
            padding: 10px 40px 10px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: ${this.colors.light};
            font-size: 14px;
            outline: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
        `;
        
        this.messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.sendMessage();
            }
        });
        
        messageInputContainer.appendChild(this.messageInput);
        
        // Emoji button
        const emojiButton = document.createElement('button');
        emojiButton.innerHTML = '😊';
        emojiButton.className = 'emoji-btn';
        emojiButton.style.cssText = `
            position: absolute;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        `;
        emojiButton.addEventListener('click', () => {
            this.toggleEmojiPanel();
        });
        messageInputContainer.appendChild(emojiButton);
        
        messagesSection.appendChild(messageInputContainer);
        gameContainer.appendChild(messagesSection);
        
        // Control buttons
        const controlsContainer = document.createElement('div');
        controlsContainer.style.cssText = `
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        `;
        
        const newGameButton = this.createButton('New Game', this.colors.success, () => {
            this.newGame();
        });
        newGameButton.style.cssText = `
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
        `;
        controlsContainer.appendChild(newGameButton);
        
        const lobbyButton = this.createButton('Back to Lobby', this.colors.primary, () => {
            this.backToLobby();
        });
        lobbyButton.style.cssText = `
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
        `;
        controlsContainer.appendChild(lobbyButton);
        
        gameContainer.appendChild(controlsContainer);
        
        this.gameContainer.appendChild(gameContainer);
        
        // Add emoji panel
        this.gameContainer.appendChild(this.createEmojiPanel());
        
        // Update the game screen with current data
        this.updateGameScreen();
        
        // Set up a presence listener for the opponent
        this.setupOpponentPresenceListener();
    }
    
    /**
     * Setup opponent presence listener
     */
    setupOpponentPresenceListener() {
        if (!this.currentGame) return;
        
        // Get opponent ID
        const opponentId = this.playerNumber === 1 ? 
                          this.currentGame.player2 : 
                          this.currentGame.player1;
        
        if (opponentId) {
            // Listen for opponent's presence
            this.playersRef.child(opponentId).on('value', (snapshot) => {
                const isOnline = !!snapshot.val();
                
                if (this.playerNumber === 1) {
                    this.player2Online = isOnline;
                } else {
                    this.player1Online = isOnline;
                }
                
                this.updatePlayerOnlineStatus();
            });
        }
    }
    /**
     * Update game screen
     */
    updateGameScreen() {
        if (!this.currentGame || !this.boardContainer || !this.gameStatus) return;
        
        // Update board
        const cells = this.boardContainer.children;
        
        for (let i = 0; i < 9; i++) {
            if (cells[i]) {
                // Update cell content
                cells[i].textContent = this.currentGame.board[i] || '';
                
                // Update cell color based on content
                if (this.currentGame.board[i]) {
                    if (this.currentGame.board[i] === 'X') {
                        cells[i].classList.add('x-player');
                        cells[i].classList.remove('o-player');
                    } else {
                        cells[i].classList.add('o-player');
                        cells[i].classList.remove('x-player');
                    }
                    cells[i].style.cursor = 'default';
                } else {
                    cells[i].classList.remove('x-player', 'o-player');
                    cells[i].style.cursor = 'pointer';
                }
            }
        }
        
        // Update status
        if (this.currentGame.winner) {
            if (this.currentGame.winner === 'draw') {
                this.gameStatus.textContent = "It's a draw!";
                this.gameStatus.style.color = this.colors.warning;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
            } else {
                const winnerName = this.currentGame.winner === 'X' ? 
                    this.currentGame.player1Name : this.currentGame.player2Name;
                this.gameStatus.textContent = `${winnerName} wins!`;
                this.gameStatus.style.color = this.colors.success;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.success}`;
            }
            this.gameActive = false;
        } else if (this.currentGame.status === 'playing') {
            if (this.currentGame.currentPlayer === this.playerSymbol) {
                this.gameStatus.textContent = 'Your turn';
                this.gameStatus.style.color = this.colors.success;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.success}`;
            } else {
                this.gameStatus.textContent = 'Opponent\'s turn';
                this.gameStatus.style.color = this.colors.warning;
                this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
            }
        } else {
            this.gameStatus.textContent = 'Waiting for opponent...';
            this.gameStatus.style.color = this.colors.warning;
            this.gameStatus.style.textShadow = `0 0 10px ${this.colors.warning}`;
        }
        
        // Update player online status
        this.updatePlayerOnlineStatus();
    }
    /**
     * Make a move
     */
    makeMove(index) {
        // Check if it's the player's turn
        if (!this.currentGame || 
            !this.gameActive || 
            this.currentGame.board[index] !== '' || 
            this.currentGame.currentPlayer !== this.playerSymbol ||
            this.currentGame.status !== 'playing') {
            return;
        }
        
        // Create a copy of the board
        const updatedBoard = [...this.currentGame.board];
        updatedBoard[index] = this.playerSymbol;
        
        // Check for winner
        const winner = this.checkWinner(updatedBoard);
        const nextPlayer = this.playerSymbol === 'X' ? 'O' : 'X';
        
        // Prepare updates
        const updates = {
            board: updatedBoard,
            currentPlayer: nextPlayer
        };
        
        if (winner) {
            updates.winner = winner;
            updates.status = 'finished';
        }
        
        // Update Firebase
        this.gameRef.child(this.currentGame.id).update(updates)
            .then(() => {
                // Move successfully made
                console.log('Move made successfully');
            })
            .catch(error => {
                console.error('Error making move:', error);
                this.showNotification('Error making move. Please try again.');
            });
    }
    /**
     * Check for winner
     */
    checkWinner(board) {
        const winPatterns = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6] // Diagonals
        ];
        
        for (const pattern of winPatterns) {
            const [a, b, c] = pattern;
            if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                return board[a];
            }
        }
        
        // Check for draw - if all cells are filled and no winner
        if (board.every(cell => cell !== '')) {
            return 'draw';
        }
        
        return null;
    }
    /**
     * Start new game
     */
    newGame() {
        if (this.currentGame) {
            const newBoard = Array(9).fill('');
            const updates = {
                board: newBoard,
                currentPlayer: 'X',
                winner: null,
                status: 'playing'
            };
            
            this.gameRef.child(this.currentGame.id).update(updates);
            this.gameActive = true;
        }
    }
    /**
     * Back to lobby
     */
    backToLobby() {
        // Remove from current game
        if (this.currentGame) {
            this.playersRef.child(this.userSessionId).remove();
            
            if (this.gameListener) {
                this.gameRef.child(this.currentGame.id).off('value', this.gameListener);
            }
            
            if (this.messagesListener) {
                this.messagesRef.child(this.currentGame.id).off('child_added', this.messagesListener);
            }
            
            // If game is waiting for player, delete it
            if (this.currentGame.status === 'waiting') {
                this.gameRef.child(this.currentGame.id).remove();
            }
        }
        
        this.currentGame = null;
        this.gameActive = false;
        this.gameScreenCreated = false;
        this.playerSymbol = null;
        this.opponentSymbol = null;
        this.playerNumber = null;
        this.connectionChecked = false;
        this.messageConnectionChecked = false;
        this.emojiConnectionChecked = false;
        this.gameContainer.innerHTML = '';
        this.createGameLobby();
    }
    /**
     * Show notification
     */
    showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            color: ${this.colors.light};
            padding: 15px 25px;
            border-radius: 30px;
            z-index: 10000;
            animation: slideDown 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.3s ease';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 20px;
            background: linear-gradient(135deg, ${color}, ${color}dd);
            color: ${this.colors.light};
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-size: 16px;
            letter-spacing: 1px;
        `;
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-3px)';
            button.style.boxShadow = '0 7px 20px rgba(0, 0, 0, 0.3)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)';
        });
        button.addEventListener('click', clickHandler);
        return button;
    }
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10001;
        `;
        // Fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = '⛶';
        this.fullscreenButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, ${this.colors.primary}, ${this.colors.primary}cc);
            color: ${this.colors.light};
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = this.colors.primary;
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = `${this.colors.primary}cc`;
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        floatingButtons.appendChild(this.fullscreenButton);
        // Close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(145deg, ${this.colors.error}, ${this.colors.error}cc);
            color: ${this.colors.light};
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = this.colors.error;
            this.closeButton.style.transform = 'scale(1.1)';
        };
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = `${this.colors.error}cc`;
            this.closeButton.style.transform = 'scale(1)';
        };
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        floatingButtons.appendChild(this.closeButton);
        
        if (this.gameContainer) {
            this.gameContainer.appendChild(floatingButtons);
        }
    }
    /**
     * Display the game
     */
    displayGame() {
        document.body.appendChild(this.gameContainer);
        document.addEventListener('keydown', this.handleKeyPress);
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement ||
                              document.webkitFullscreenElement ||
                              document.msFullscreenElement);
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            this.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            this.msExitFullscreen();
        }
    }
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Clean up Firebase
        if (this.isFirebaseInitialized) {
            if (this.currentGame) {
                this.playersRef.child(this.userSessionId).remove();
                
                if (this.gameListener) {
                    this.gameRef.child(this.currentGame.id).off('value', this.gameListener);
                }
                
                if (this.messagesListener) {
                    this.messagesRef.child(this.currentGame.id).off('child_added', this.messagesListener);
                }
                
                // If game is waiting for player, delete it
                if (this.currentGame.status === 'waiting') {
                    this.gameRef.child(this.currentGame.id).remove();
                }
            }
            
            if (this.playersListener) {
                this.playersRef.off('value', this.playersListener);
            }
        }
        
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        const floatingButtons = document.querySelector('.floating-buttons');
        if (floatingButtons) {
            floatingButtons.remove();
        }
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        botReply("Tic Tac Toe closed. Thank you for playing!");
    }
    /**
     * Load external script
     */
    loadScript(src, callback) {
        const script = document.createElement('script');
        script.src = src;
        script.onload = callback;
        document.head.appendChild(script);
    }
}
// Create a singleton instance
const ticTacToeGame = new TicTacToeGame();
// Add this to your AI's command handling
if (/tic tac toe|tictactoe|game|two player game/i.test(userInputRaw)) {
    ticTacToeGame.loadBaseScreen();
    return;
}
// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    ticTacToeGame.closeGame();
    return;
}





class BaseScreenLoader {
    constructor() {
        this.baseScreen = {
            name: 'BASE ENCODER/DECODER',
            instructions: 'Encode or decode text using Base64 or Base32. Supports copy and clear functions.'
        };
        
        this.gameContainer = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        this.inputTextarea = null;
        this.outputTextarea = null;
        this.base64EncodeButton = null;
        this.base64DecodeButton = null;
        this.base32EncodeButton = null;
        this.base32DecodeButton = null;
        this.clearButton = null;
        this.copyButton = null;
        
        // Base32 alphabet (RFC 4648)
        this.base32Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
    }
    
    /**
     * Load the Base Screen
     */
    loadBaseScreen() {
        // Check if already active
        if (this.isActive) {
            botReply(`The ${this.baseScreen.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Create container
        this.createGameContainer();
        
        // Create base screen
        this.createBaseScreen();
        
        // Set up action buttons
        this.setupActionButtons();
        
        // Display the base screen
        this.displayGame();
        
        this.isActive = true;
        botReply(`${this.baseScreen.name} loaded! ${this.baseScreen.instructions}`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the Base Screen UI
     */
    createBaseScreen() {
        // Create base container
        const baseContainer = document.createElement('div');
        baseContainer.style.cssText = `
            background-color: #f5f5f5;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            width: 700px;
            max-width: 90vw;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        `;
        
        // Create header
        const header = document.createElement('div');
        header.style.cssText = `
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #ddd;
        `;
        
        const title = document.createElement('h2');
        title.textContent = 'Base64 & Base32 Encoder/Decoder';
        title.style.cssText = `
            margin: 0 0 10px 0;
            color: #333;
            font-size: 24px;
        `;
        
        const subtitle = document.createElement('p');
        subtitle.textContent = 'Encode or decode text using Base64 or Base32 algorithms';
        subtitle.style.cssText = `
            margin: 0;
            color: #666;
            font-size: 16px;
        `;
        
        header.appendChild(title);
        header.appendChild(subtitle);
        baseContainer.appendChild(header);
        
        // Create input section
        const inputSection = document.createElement('div');
        inputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const inputLabel = document.createElement('label');
        inputLabel.textContent = 'Input Text:';
        inputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        
        this.inputTextarea = document.createElement('textarea');
        this.inputTextarea.placeholder = 'Enter text to encode or decode...';
        this.inputTextarea.style.cssText = `
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
        `;
        
        inputSection.appendChild(inputLabel);
        inputSection.appendChild(this.inputTextarea);
        baseContainer.appendChild(inputSection);
        
        // Create button grid
        const buttonGrid = document.createElement('div');
        buttonGrid.style.cssText = `
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            margin-bottom: 15px;
        `;
        
        // Base64 Encode button
        this.base64EncodeButton = this.createButton('Base64 Encode', '#4CAF50', () => {
            this.base64Encode();
        });
        
        // Base64 Decode button
        this.base64DecodeButton = this.createButton('Base64 Decode', '#2196F3', () => {
            this.base64Decode();
        });
        
        // Base32 Encode button
        this.base32EncodeButton = this.createButton('Base32 Encode', '#FF9800', () => {
            this.base32Encode();
        });
        
        // Base32 Decode button
        this.base32DecodeButton = this.createButton('Base32 Decode', '#9C27B0', () => {
            this.base32Decode();
        });
        
        // Clear button
        this.clearButton = this.createButton('Clear', '#f44336', () => {
            this.clearFields();
        });
        
        // Copy button
        this.copyButton = this.createButton('Copy Output', '#607D8B', () => {
            this.copyOutput();
        });
        
        buttonGrid.appendChild(this.base64EncodeButton);
        buttonGrid.appendChild(this.base64DecodeButton);
        buttonGrid.appendChild(this.base32EncodeButton);
        buttonGrid.appendChild(this.base32DecodeButton);
        buttonGrid.appendChild(this.clearButton);
        buttonGrid.appendChild(this.copyButton);
        
        baseContainer.appendChild(buttonGrid);
        
        // Create output section
        const outputSection = document.createElement('div');
        outputSection.style.cssText = `
            margin-bottom: 15px;
        `;
        
        const outputLabel = document.createElement('label');
        outputLabel.textContent = 'Output Text:';
        outputLabel.style.cssText = `
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        `;
        
        this.outputTextarea = document.createElement('textarea');
        this.outputTextarea.placeholder = 'Result will appear here...';
        this.outputTextarea.readOnly = true;
        this.outputTextarea.style.cssText = `
            width: 100%;
            height: 120px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            box-sizing: border-box;
            background-color: #f9f9f9;
        `;
        
        outputSection.appendChild(outputLabel);
        outputSection.appendChild(this.outputTextarea);
        baseContainer.appendChild(outputSection);
        
        // Create info section
        const infoSection = document.createElement('div');
        infoSection.style.cssText = `
            background-color: #e3f2fd;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
            color: #1976d2;
            border-left: 4px solid #2196F3;
        `;
        
        infoSection.innerHTML = `
            <strong>Tips:</strong><br>
            • Base64 is commonly used for encoding binary data in text format<br>
            • Base32 uses a 32-character set and is case-insensitive<br>
            • Use Copy Output to quickly copy the result to clipboard<br>
            • Clear button resets both input and output fields
        `;
        
        baseContainer.appendChild(infoSection);
        
        this.gameContainer.appendChild(baseContainer);
    }
    
    /**
     * Create a styled button
     */
    createButton(text, color, clickHandler) {
        const button = document.createElement('button');
        button.textContent = text;
        button.style.cssText = `
            padding: 12px 15px;
            background-color: ${color};
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        `;
        
        // Add hover effect
        button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });
        
        button.addEventListener('mouseleave', () => {
            button.style.transform = '';
            button.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.2)';
        });
        
        // Add click handler
        button.addEventListener('click', clickHandler);
        
        return button;
    }
    
    /**
     * Base64 Encode
     */
    base64Encode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some text to encode.');
            return;
        }
        
        try {
            const encoded = btoa(unescape(encodeURIComponent(input)));
            this.outputTextarea.value = encoded;
            botReply('Text encoded to Base64 successfully!');
        } catch (error) {
            console.error('Base64 encode error:', error);
            botReply('Error encoding to Base64. Please check your input.');
        }
    }
    
    /**
     * Base64 Decode
     */
    base64Decode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some Base64 text to decode.');
            return;
        }
        
        try {
            const decoded = decodeURIComponent(escape(atob(input)));
            this.outputTextarea.value = decoded;
            botReply('Base64 text decoded successfully!');
        } catch (error) {
            console.error('Base64 decode error:', error);
            botReply('Error decoding Base64. Please check your input.');
        }
    }
    
    /**
     * Base32 Encode
     */
    base32Encode() {
        const input = this.inputTextarea.value;
        if (!input) {
            botReply('Please enter some text to encode.');
            return;
        }
        
        try {
            const encoded = this.encodeBase32(input);
            this.outputTextarea.value = encoded;
            botReply('Text encoded to Base32 successfully!');
        } catch (error) {
            console.error('Base32 encode error:', error);
            botReply('Error encoding to Base32. Please check your input.');
        }
    }
    
    /**
     * Base32 Decode
     */
    base32Decode() {
        const input = this.inputTextarea.value.trim().toUpperCase();
        if (!input) {
            botReply('Please enter some Base32 text to decode.');
            return;
        }
        
        try {
            const decoded = this.decodeBase32(input);
            this.outputTextarea.value = decoded;
            botReply('Base32 text decoded successfully!');
        } catch (error) {
            console.error('Base32 decode error:', error);
            botReply('Error decoding Base32. Please check your input.');
        }
    }
    
    /**
     * Encode string to Base32
     */
    encodeBase32(str) {
        // Convert string to Uint8Array
        const encoder = new TextEncoder();
        const data = encoder.encode(str);
        
        let result = '';
        let buffer = 0;
        let bitsLeft = 0;
        
        for (let i = 0; i < data.length; i++) {
            buffer = (buffer << 8) | data[i];
            bitsLeft += 8;
            
            while (bitsLeft >= 5) {
                const index = (buffer >>> (bitsLeft - 5)) & 0x1F;
                result += this.base32Alphabet[index];
                bitsLeft -= 5;
            }
        }
        
        // Handle remaining bits
        if (bitsLeft > 0) {
            const index = (buffer << (5 - bitsLeft)) & 0x1F;
            result += this.base32Alphabet[index];
        }
        
        // Add padding if needed
        const padding = (8 - (result.length % 8)) % 8;
        if (padding > 0) {
            result += '='.repeat(padding);
        }
        
        return result;
    }
    
    /**
     * Decode Base32 string
     */
    decodeBase32(str) {
        // Remove padding and convert to uppercase
        str = str.replace(/=/g, '').toUpperCase();
        
        let buffer = 0;
        let bitsLeft = 0;
        const result = [];
        
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            const index = this.base32Alphabet.indexOf(char);
            
            if (index === -1) {
                throw new Error('Invalid Base32 character: ' + char);
            }
            
            buffer = (buffer << 5) | index;
            bitsLeft += 5;
            
            if (bitsLeft >= 8) {
                result.push((buffer >>> (bitsLeft - 8)) & 0xFF);
                bitsLeft -= 8;
            }
        }
        
        // Convert Uint8Array to string
        const decoder = new TextDecoder();
        return decoder.decode(new Uint8Array(result));
    }
    
    /**
     * Clear input and output fields
     */
    clearFields() {
        this.inputTextarea.value = '';
        this.outputTextarea.value = '';
        botReply('Fields cleared.');
    }
    
    /**
     * Copy output to clipboard
     */
    copyOutput() {
        const output = this.outputTextarea.value;
        if (!output) {
            botReply('No output to copy.');
            return;
        }
        
        // Use modern Clipboard API if available
        if (navigator.clipboard) {
            navigator.clipboard.writeText(output)
                .then(() => {
                    botReply('Output copied to clipboard!');
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    this.fallbackCopyTextToClipboard(output);
                });
        } else {
            // Fallback for older browsers
            this.fallbackCopyTextToClipboard(output);
        }
    }
    
    /**
     * Fallback method to copy text to clipboard
     */
    fallbackCopyTextToClipboard(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";

        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
            const successful = document.execCommand('copy');
            if (successful) {
                botReply('Output copied to clipboard!');
            } else {
                botReply('Unable to copy output');
            }
        } catch (err) {
            console.error('Fallback: Oops, unable to copy', err);
            botReply('Unable to copy output');
        }

        document.body.removeChild(textArea);
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
            border-radius: 4px;
            box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        this.fullscreenButton.onclick = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
            border-radius: 4px;
            box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     */
    handleKeyPress = (event) => {
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) {
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) {
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.inputTextarea = null;
        this.outputTextarea = null;
        this.base64EncodeButton = null;
        this.base64DecodeButton = null;
        this.base32EncodeButton = null;
        this.base32DecodeButton = null;
        this.clearButton = null;
        this.copyButton = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.closeButton = null;
        
        botReply("Base Encoder/Decoder closed. Thank you!");
    }
}

// Create a singleton instance
const baseScreenLoader = new BaseScreenLoader();

// Add this to your AI's command handling
if (/base|base64|base32|encode|decode|Decrypt|Encrypt/i.test(userInputRaw)) {
    baseScreenLoader.loadBaseScreen();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    baseScreenLoader.closeGame();
    return;
}


class ScreenLoader {
    constructor() {
        this.games = {
            Movie: {
                url: 'https://vipteammod897.github.io/VIPTEAMMOD-AI/AIMovie.html',
              //  name: 'VIPTEAMMOD AI MOVIES',
               // instructions: 'Browse and watch your favorite movies.'
            },
            Games: {
                url: 'https://vipteammod.site/VipTeamModServer.html',
             //   name: 'PLAY ONLINE GAMES',
               // instructions: 'Play a variety of online games in your browser.'
            }
        };
        
        this.gameContainer = null;
        this.gameIframe = null;
        this.currentGame = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.fullscreenButtonClickHandler = null;
        this.closeButton = null;
    }
    
    /**
     * Load a specific game
     * @param {string} gameKey - The key of the game to load
     */
    loadGame(gameKey) {
        // Check if a game is already active
        if (this.isActive) {
            botReply(`The ${this.currentGame.name} is already running! Type 'close screen' to exit first.`);
            return;
        }
        
        // Check if the game exists
        if (!this.games[gameKey]) {
            botReply(`Screen not found. Available screens: ${Object.keys(this.games).map(key => this.games[key].name).join(', ')}`);
            return;
        }
        
        // Set the current game
        this.currentGame = this.games[gameKey];
        
        // Create game container
        this.createGameContainer();
        
        // Create iframe for the game
        this.createGameIframe();
        
        // Set up action buttons
        this.setupActionButtons();

        
        // Display the game
        this.displayGame();
        
        this.isActive = true;
        
       // botReply(`${this.currentGame.name} loaded! ${this.currentGame.instructions}`);
    }
    
    /**
     * List all available games
     */
    listGames() {
        const gameList = Object.keys(this.games).map(key => this.games[key].name).join(', ');
        botReply(`Available screens: ${gameList}. Type 'play [screen name]' to start.`);
    }
    
    /**
     * Create the game container
     */
    createGameContainer() {
        // Remove existing container if any
        const existingContainer = document.getElementById('screen-container');
        if (existingContainer) {
            existingContainer.remove();
        }
        
        // Create new container
        this.gameContainer = document.createElement('div');
        this.gameContainer.id = 'screen-container';
        this.gameContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        `;
    }
    
    /**
     * Create the game iframe
     */
    createGameIframe() {
        this.gameIframe = document.createElement('iframe');
        this.gameIframe.src = this.currentGame.url;
        this.gameIframe.style.cssText = `
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            max-height: 800px;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        `;
        
        // Handle iframe load event
        this.gameIframe.onload = () => {
            // Game has loaded, focus on it for controls
            this.gameIframe.focus();
        };
        
        // Handle iframe error event
        this.gameIframe.onerror = () => {
            botReply(`Error loading the ${this.currentGame.name}. Please try again later.`);
            this.closeGame();
        };
    }
    
    /**
     * Set up action buttons (fullscreen and close)
     */
    setupActionButtons() {
        // Create floating action buttons container
        const floatingButtons = document.createElement('div');
        floatingButtons.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10000;
        `;
        
        // Create fullscreen button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        this.fullscreenButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #0084ff, #0084ff);
    border-radius: 4px;
    box-shadow: 0 0 10px #0084ff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.fullscreenButton.onmouseover = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 1)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
        };
        
        this.fullscreenButton.onmouseout = () => {
            this.fullscreenButton.style.backgroundColor = 'rgba(33, 150, 243, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1)';
        };
        
        // Use a named function for the click handler
        this.fullscreenButtonClickHandler = (e) => {
            e.stopPropagation();
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.enterFullscreen();
            }
        };
        
        // Remove any existing event listener before adding a new one
        this.fullscreenButton.removeEventListener('click', this.fullscreenButtonClickHandler);
        this.fullscreenButton.addEventListener('click', this.fullscreenButtonClickHandler);
        
        floatingButtons.appendChild(this.fullscreenButton);
        
        // Create close button
        this.closeButton = document.createElement('button');
        this.closeButton.innerHTML = '❌';
        this.closeButton.style.cssText = `
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(145deg, #fff, #fff);
    border-radius: 4px;
    box-shadow: 0 0 10px #fff;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
           
            transition: all 0.2s ease;
        `;
        
        // Add hover effect
        this.closeButton.onmouseover = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 1)';
            this.closeButton.style.transform = 'scale(1.1)';
        };
        
        this.closeButton.onmouseout = () => {
            this.closeButton.style.backgroundColor = 'rgba(244, 67, 54, 0.8)';
            this.closeButton.style.transform = 'scale(1)';
        };
        
        this.closeButton.onclick = (e) => {
            e.stopPropagation();
            this.closeGame();
        };
        
        floatingButtons.appendChild(this.closeButton);
        
        // Add floating buttons to container
        this.gameContainer.appendChild(floatingButtons);
    }
    
    /**
     * Display the game
     */
    displayGame() {
        // Add iframe to container
        this.gameContainer.appendChild(this.gameIframe);
        
        // Add container to document body
        document.body.appendChild(this.gameContainer);
        
        // Set up keyboard event listener for closing the game
        document.addEventListener('keydown', this.handleKeyPress);
        
        // Set up fullscreen change event listener
        document.addEventListener('fullscreenchange', this.handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.addEventListener('msfullscreenchange', this.handleFullscreenChange);
    }
    
    /**
     * Handle keyboard events
     * @param {KeyboardEvent} event - The keyboard event
     */
    handleKeyPress = (event) => {
        // Check if escape key was pressed
        if (event.key === 'Escape') {
            if (this.isFullscreen) {
                this.exitFullscreen();
            } else {
                this.closeGame();
            }
        }
    }
    
    /**
     * Handle fullscreen change events
     */
    handleFullscreenChange = () => {
        // Check if we're actually in fullscreen mode
        this.isFullscreen = !!(document.fullscreenElement || 
                              document.webkitFullscreenElement || 
                              document.msFullscreenElement);
        
        // Update fullscreen button
        if (this.fullscreenButton) {
            this.fullscreenButton.innerHTML = this.isFullscreen ? '⛶' : '⛶';
        }
        
        // Adjust iframe size based on fullscreen state
        if (this.isFullscreen) {
            this.gameIframe.style.width = '98%';
            this.gameIframe.style.height = '95vh';
        } else {
            this.gameIframe.style.width = '90%';
            this.gameIframe.style.height = '85vh';
        }
    }
    
    /**
     * Enter fullscreen mode
     */
    enterFullscreen() {
        if (!this.gameContainer) return;
        
        if (this.gameContainer.requestFullscreen) {
            this.gameContainer.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable fullscreen: ${err.message}`);
            });
        } else if (this.gameContainer.webkitRequestFullscreen) { /* Safari */
            this.gameContainer.webkitRequestFullscreen();
        } else if (this.gameContainer.msRequestFullscreen) { /* IE11 */
            this.gameContainer.msRequestFullscreen();
        }
    }
    
    /**
     * Exit fullscreen mode
     */
    exitFullscreen() {
        if (!this.isFullscreen) return;
        
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) { /* Safari */
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) { /* IE11 */
            document.msExitFullscreen();
        }
    }
    
    /**
     * Close the game
     */
    closeGame() {
        if (!this.isActive) return;
        
        // Exit fullscreen if in fullscreen mode
        if (this.isFullscreen) {
            this.exitFullscreen();
        }
        
        // Remove event listeners
        document.removeEventListener('keydown', this.handleKeyPress);
        document.removeEventListener('fullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.handleFullscreenChange);
        document.removeEventListener('msfullscreenchange', this.handleFullscreenChange);
        
        // Remove fullscreen button event listener
        if (this.fullscreenButton && this.fullscreenButtonClickHandler) {
            this.fullscreenButton.removeEventListener('click', this.fullscreenButtonClickHandler);
        }
        
        // Remove game container
        if (this.gameContainer && this.gameContainer.parentNode) {
            this.gameContainer.parentNode.removeChild(this.gameContainer);
        }
        
        // Reset variables
        this.gameContainer = null;
        this.gameIframe = null;
        this.currentGame = null;
        this.isActive = false;
        this.isFullscreen = false;
        this.fullscreenButton = null;
        this.fullscreenButtonClickHandler = null;
        this.closeButton = null;
        
        botReply("Screen closed. Thank you!");
    }
}

// Create a singleton instance
const screenloader = new ScreenLoader();

// Add this to your AI's command handling
if (/Movies|play Movie/i.test(userInputRaw)) {
    screenloader.loadGame('Movie');
    return;
}

// Add command for Games
if (/Games|play Games/i.test(userInputRaw)) {
    screenloader.loadGame('Games');
    return;
}

// Add command to list all screens
if (/list screens|available screens/i.test(userInputRaw)) {
    screenloader.listGames();
    return;
}

// Add command to close the screen
if (/close screen|exit screen/i.test(userInputRaw)) {
    screenloader.closeGame();
    return;
}







if (/unlock image to text/i.test(userInputRaw)) {
    // Add a small delay before opening the file picker
    setTimeout(() => {
        document.getElementById('hiddenFileInput').click();
    }, 1500); // 1500 milliseconds = 1.5 seconds delay
    return;
}

// Create Hidden File Input (if not already created elsewhere in your code)
let hiddenFileInput = document.getElementById('hiddenFileInput');
if (!hiddenFileInput) {
    hiddenFileInput = document.createElement("input");
    hiddenFileInput.type = "file";
    hiddenFileInput.accept = "image/*";
    hiddenFileInput.id = "hiddenFileInput";
    hiddenFileInput.style.display = "none"; // hide the input field
    document.body.appendChild(hiddenFileInput);
    
    // Function to handle file selection
    hiddenFileInput.addEventListener('change', handleFileSelect, false);
}

// Function to handle file selection and OCR processing
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    botReply("Reading the image file...");
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            // After image is loaded, you can preprocess and call an OCR function
            processImageToText(img);
        };
        img.onerror = function() {
            botReply("Error loading the image. Please try another image.");
        };
        img.src = e.target.result; // Load the image
    };
    reader.onerror = function() {
        botReply("Error reading the file. Please try again.");
    };
    reader.readAsDataURL(file); // Read the image file as a data URL
}

// Improved OCR function using Tesseract.js with preprocessing
function processImageToText(img) {
    botReply("Processing image... Please wait.");
    
    try {
        // Preprocess the image (resize, grayscale, binarization, etc.)
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set a maximum size for better performance
        const MAX_WIDTH = 2000;
        const MAX_HEIGHT = 2000;
        let width = img.width;
        let height = img.height;
        
        if (width > height) {
            if (width > MAX_WIDTH) {
                height *= MAX_WIDTH / width;
                width = MAX_WIDTH;
            }
        } else {
            if (height > MAX_HEIGHT) {
                width *= MAX_HEIGHT / height;
                height = MAX_HEIGHT;
            }
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        // Preprocessing: Convert to grayscale
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
            data[i] = data[i + 1] = data[i + 2] = avg; // Set R, G, B to grayscale value
        }
        ctx.putImageData(imgData, 0, 0);
        
        // Additional preprocessing: Apply threshold for better OCR results
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const newData = imageData.data;
        for (let i = 0; i < newData.length; i += 4) {
            // Simple threshold: if pixel is darker than middle gray, make it black, otherwise white
            const value = newData[i] > 128 ? 255 : 0;
            newData[i] = newData[i + 1] = newData[i + 2] = value;
        }
        ctx.putImageData(imageData, 0, 0);
        
        // Use Tesseract.js to extract text from the processed image
        Tesseract.recognize(
            canvas,
            'eng', // Add more language support if needed
            {
                logger: (m) => {
                    if (m.status === 'recognizing text') {
                        const progress = Math.round(m.progress * 100);
                        botReply(`Processing image... ${progress}% complete`);
                    }
                },
            }
        ).then(({ data: { text } }) => {
            if (text.trim() === "") {
                botReply("No text was extracted from the image. Please try again with a clearer image.");
            } else {
                // Preserve some line breaks for better formatting
                const processedText = text.trim().replace(/\n{3,}/g, '\n\n');
                botReply(`Extracted Text:\n\n${processedText}`);
            }
        }).catch(error => {
            botReply("Error extracting text from the image. Please try again later.");
            console.error("OCR Error:", error);
        });
    } catch (error) {
        botReply("Error processing the image. Please try again.");
        console.error("Processing Error:", error);
    }
}



}

function botReply(message) {
    const chatBox = document.getElementById("chat-box");
    const botMessageContainer = document.createElement("div");
    botMessageContainer.classList.add("bot-container");

    // Create the copy button
    const copyButton = document.createElement("button");
    copyButton.classList.add("copy-btn");
    copyButton.innerText = "Copy";

    // Copy the message to clipboard when clicked
    copyButton.addEventListener("click", () => {
        navigator.clipboard.writeText(message).then(() => {
            // Change button text to "Copied"
            copyButton.innerText = "Copied";

            // Reset the button text after 2 seconds
            setTimeout(() => {
                copyButton.innerText = "Copy";
            }, 2000);
        }).catch(err => {
            console.error("Error copying text: ", err);
        });
    });

    // Create the share button (same style as copy button)
    const shareButton = document.createElement("button");
    shareButton.classList.add("copy-btn"); // Same class as copy button
    shareButton.innerText = "Share";

    // Share the message when clicked
    shareButton.addEventListener("click", () => {
        // Use the Web Share API to share the message (if supported)
        if (navigator.share) {
            navigator.share({
                title: "AI Bot Message",
                text: message,
                url: window.location.href
            }).then(() => {
                console.log("Message shared successfully!");
            }).catch(err => {
                console.error("Error sharing message: ", err);
            });
        } else {
            // If the Web Share API is not supported, alert the user
            alert("Sharing is not supported on this device/browser.");
        }
    });

    // Create the bot message
    const botMessage = document.createElement("div");
    botMessage.classList.add("bot-message");
    botMessage.innerHTML = `<strong style="color: white; background: linear-gradient(145deg, #d30, #d35); padding: 4px 8px; box-shadow: 0 0 5px #d35;border-radius: 6px; display: inline-block;">AI Bot:</strong> ${message}`;

    // Create a div for the buttons and apply flexbox for alignment
    const buttonContainer = document.createElement("div");
    buttonContainer.classList.add("button-container");

    // Append buttons to the container
    buttonContainer.appendChild(copyButton);
    buttonContainer.appendChild(shareButton);

    // Append the button container and the message to the bot message container
    botMessageContainer.appendChild(buttonContainer);
    botMessageContainer.appendChild(botMessage);

    // Append the container to chatBox
    chatBox.appendChild(botMessageContainer);
    chatBox.appendChild(document.createElement("br"));

    // Save plain text message for history
    chatHistory.push(`[${new Date().toLocaleTimeString()}] AI Bot: ${botMessage.textContent}`);

    // Scroll to bottom
    chatBox.scrollTop = chatBox.scrollHeight;
}
        botReply(` Welcome To VIPTEAMMOD AI 3.0`);

// Function to download chat history as a .txt file

function downloadChatHistory() {
    if (chatHistory.length > 0) {
        chatHistory.push(`\nChat End: ${new Date().toLocaleString()}`);
    }
    const blob = new Blob([chatHistory.join("\n")], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "chat_history.txt";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

const downloadBtn = document.createElement("button");
downloadBtn.textContent = "Download Chat History";
downloadBtn.id = "downloadBtn"; // Assign the ID for styling
downloadBtn.onclick = downloadChatHistory;


    // Event listeners
    document.getElementById('user-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });
// Append the button inside the chat container
document.querySelector(".chat-container").appendChild(downloadBtn);


  </script>
  <script>
    // Disable right-click
document.addEventListener("contextmenu", function (e) {
    e.preventDefault();
});

// Disable keyboard shortcuts for DevTools
document.addEventListener("keydown", function (e) {
    if (e.ctrlKey && (e.key === "u" || e.key === "U" || e.key === "s" || e.key === "S" || e.key === "i" || e.key === "I" || e.key === "j" || e.key === "J" || e.key === "c" || e.key === "C")) {
        e.preventDefault();
    }
});

// Disable F12, Ctrl+Shift+I, Ctrl+Shift+J
document.onkeydown = function (e) {
    if (e.keyCode == 123) { return false; } // F12
    if (e.ctrlKey && e.shiftKey && (e.keyCode == 73 || e.keyCode == 74)) { return false; } // Ctrl+Shift+I/J
};
  
  </script>
<script>
    const blockScreen = document.getElementById('blockScreen');

    function detectDevTools() {
      const widthDiff = window.outerWidth - window.innerWidth;
      const heightDiff = window.outerHeight - window.innerHeight;
      const threshold = 120;

      // True if dimensions indicate DevTools or if debugger gets trapped
      let devtoolsOpen = widthDiff > threshold || heightDiff > threshold;

      // Mobile-specific trap
      const trap = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (trap) {
        const start = new Date();
        debugger;
        const end = new Date();
        if (end - start > 100) devtoolsOpen = true;
      }

      if (devtoolsOpen) {
       window.location.href = "https://c.tenor.com/x4V9PRp9R-0AAAAC/tenor.gif"; // Replace with your redirect URL

      } else {
        blockScreen.style.display = 'none';
        document.body.style.pointerEvents = 'auto';
      }
    }

    setInterval(detectDevTools, 600);

    // Block right-click
    document.addEventListener('contextmenu', e => e.preventDefault());

    // Block common dev hotkeys
    document.addEventListener('keydown', function (event) {
      if (
        event.key === 'F12' ||
        (event.ctrlKey && event.shiftKey && ['I', 'J', 'C'].includes(event.key.toUpperCase())) ||
        (event.ctrlKey && event.key.toLowerCase() === 'u')
      ) {
        event.preventDefault();
      }
    });
  </script>
    <script>
        // Function to adjust the container based on screen size
        function adjustScreenSize() {
            const container = document.getElementById('main-container');
            const windowWidth = window.innerWidth;
            
            // For desktop screens
            if (windowWidth > 1200) {
                container.style.width = '97%';
                container.style.margin = '0 auto';
            } 
            // For tablet screens
            else if (windowWidth > 768) {
                container.style.width = '97%';
                container.style.margin = '0 auto';
            } 
            // For mobile screens
            else {
                container.style.width = '97%';
                container.style.margin = '0';
            }
        }
        
        // Call the function when the page loads
        window.addEventListener('load', adjustScreenSize);
        
        // Call the function when the window is resized
        window.addEventListener('resize', adjustScreenSize);
    </script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>

</body>

</html>